#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_Teleporter

#include "Basic.hpp"

#include "B_Teleporter_classes.hpp"
#include "B_Teleporter_parameters.hpp"


#pragma pack(push, 0x4)
namespace SDK
{

// Function B_Teleporter.B_Teleporter_C.ExecuteUbergraph_B_Teleporter
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::ExecuteUbergraph_B_Teleporter(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "ExecuteUbergraph_B_Teleporter");

	Params::B_Teleporter_C_ExecuteUbergraph_B_Teleporter Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.ClientActorsTeleported
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TeleportedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::ClientActorsTeleported(class AActor* TeleportedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "ClientActorsTeleported");

	Params::B_Teleporter_C_ClientActorsTeleported Parms{};

	Parms.TeleportedActor = TeleportedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.OnDeathPlayEffects
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTagContainer&     DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm)
// const struct FVector&                   Momentum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class AFortPawn*                        InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayEffectContextHandle&EffectContext                                          (Parm)

void AB_Teleporter_C::OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnDeathPlayEffects");

	Params::B_Teleporter_C_OnDeathPlayEffects Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.OnWorldReady
// (Event, Public, BlueprintEvent)

void AB_Teleporter_C::OnWorldReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnWorldReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnRechargingChanged
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRechargingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRechargingChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.UpdateArrowDirection
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::UpdateArrowDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "UpdateArrowDirection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.DirectionalRayDeactivate
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::DirectionalRayDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "DirectionalRayDeactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.DirectionalRayActivate
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::DirectionalRayActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "DirectionalRayActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnActiveChanged
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnActiveChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnActiveChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.ReceiveDestroyed
// (Event, Public, BlueprintEvent)

void AB_Teleporter_C::ReceiveDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "ReceiveDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnDeathServer
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTagContainer&     DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm)
// const struct FVector&                   Momentum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayEffectContextHandle&EffectContext                                          (Parm)

void AB_Teleporter_C::OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnDeathServer");

	Params::B_Teleporter_C_OnDeathServer Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.OnComponentBeginOverlap_Event_0
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void AB_Teleporter_C::OnComponentBeginOverlap_Event_0(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnComponentBeginOverlap_Event_0");

	Params::B_Teleporter_C_OnComponentBeginOverlap_Event_0 Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.BlueprintOnInteract
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::BlueprintOnInteract(const class AFortPawn* InteractingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "BlueprintOnInteract");

	Params::B_Teleporter_C_BlueprintOnInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.PostProcessTL__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::PostProcessTL__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "PostProcessTL__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.PostProcessTL__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::PostProcessTL__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "PostProcessTL__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.ScaleLoadingRings__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::ScaleLoadingRings__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "ScaleLoadingRings__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.ScaleLoadingRings__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::ScaleLoadingRings__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "ScaleLoadingRings__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.RotateArrowTimeline__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::RotateArrowTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "RotateArrowTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.RotateArrowTimeline__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::RotateArrowTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "RotateArrowTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.LightrayFade__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::LightrayFade__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "LightrayFade__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.LightrayFade__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::LightrayFade__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "LightrayFade__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.GlowMaterialTransitionOut__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::GlowMaterialTransitionOut__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "GlowMaterialTransitionOut__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.GlowMaterialTransitionOut__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::GlowMaterialTransitionOut__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "GlowMaterialTransitionOut__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.GlowMaterialTransitionIn__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::GlowMaterialTransitionIn__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "GlowMaterialTransitionIn__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.GlowMaterialTransitionIn__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::GlowMaterialTransitionIn__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "GlowMaterialTransitionIn__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.RingSpeedUp__UpdateFunc
// (BlueprintEvent)

void AB_Teleporter_C::RingSpeedUp__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "RingSpeedUp__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.RingSpeedUp__FinishedFunc
// (BlueprintEvent)

void AB_Teleporter_C::RingSpeedUp__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "RingSpeedUp__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.SetTargetTeleporter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_Teleporter_C*                  NewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::SetTargetTeleporter(class AB_Teleporter_C* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "SetTargetTeleporter");

	Params::B_Teleporter_C_SetTargetTeleporter Parms{};

	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.TeleportToTarget
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToTeleport                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::TeleportToTarget(class AActor* ActorToTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "TeleportToTarget");

	Params::B_Teleporter_C_TeleportToTarget Parms{};

	Parms.ActorToTeleport = ActorToTeleport;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.IsValidActorToTeleport
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToTeleport                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   ValidActor                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::IsValidActorToTeleport(class AActor* ActorToTeleport, bool* ValidActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "IsValidActorToTeleport");

	Params::B_Teleporter_C_IsValidActorToTeleport Parms{};

	Parms.ActorToTeleport = ActorToTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (ValidActor != nullptr)
		*ValidActor = Parms.ValidActor;
}


// Function B_Teleporter.B_Teleporter_C.UpdateTeleportersActive
// (Private, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::UpdateTeleportersActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "UpdateTeleportersActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.IsExclusivelyActive
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsActive                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::IsExclusivelyActive(bool* IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "IsExclusivelyActive");

	Params::B_Teleporter_C_IsExclusivelyActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsActive != nullptr)
		*IsActive = Parms.IsActive;
}


// Function B_Teleporter.B_Teleporter_C.OnRep_bTeleporterActive
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRep_bTeleporterActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRep_bTeleporterActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.RechargeComplete
// (Private, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::RechargeComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "RechargeComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.TriggerRecharge
// (Private, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::TriggerRecharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "TriggerRecharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnRep_TeleportCount
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRep_TeleportCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRep_TeleportCount");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.UpdateTargetTeleporterLocation
// (Public, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::UpdateTargetTeleporterLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "UpdateTargetTeleporterLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnRep_bBeingCarried
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRep_bBeingCarried()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRep_bBeingCarried");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.UpdateGlowVisuals
// (Public, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::UpdateGlowVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "UpdateGlowVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.SetShowGlow
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::SetShowGlow(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "SetShowGlow");

	Params::B_Teleporter_C_SetShowGlow Parms{};

	Parms.Show = Show;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.InitializeTeleporter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewMaxRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   NewRechargeDecay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TeleporterArrowColor_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::InitializeTeleporter(float NewMaxRange, float NewRechargeDecay, const struct FLinearColor& TeleporterArrowColor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "InitializeTeleporter");

	Params::B_Teleporter_C_InitializeTeleporter Parms{};

	Parms.NewMaxRange = NewMaxRange;
	Parms.NewRechargeDecay = NewRechargeDecay;
	Parms.TeleporterArrowColor_0 = std::move(TeleporterArrowColor_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.OnRep_bRecharging
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRep_bRecharging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRep_bRecharging");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.OnRep_TeleporterArrowColor
// (BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::OnRep_TeleporterArrowColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "OnRep_TeleporterArrowColor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.TriggerRechargeInternal
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_Teleporter_C::TriggerRechargeInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "TriggerRechargeInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_Teleporter.B_Teleporter_C.InternalSetActive
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_Teleporter_C::InternalSetActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "InternalSetActive");

	Params::B_Teleporter_C_InternalSetActive Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_Teleporter.B_Teleporter_C.BlueprintCanInteract
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_Teleporter_C::BlueprintCanInteract(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "BlueprintCanInteract");

	Params::B_Teleporter_C_BlueprintCanInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_Teleporter.B_Teleporter_C.BlueprintGetInteractionString
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AB_Teleporter_C::BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "BlueprintGetInteractionString");

	Params::B_Teleporter_C_BlueprintGetInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_Teleporter.B_Teleporter_C.IsAcceptablePositionForPlacement
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
// const struct FRotator&                  InRotation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
// class AFortDecoTool*                    DecoTool                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIsCDO                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText*                            OutFailureReason                                       (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_Teleporter_C::IsAcceptablePositionForPlacement(const struct FVector& InLocation, const struct FRotator& InRotation, class AFortDecoTool* DecoTool, bool bIsCDO, class FText* OutFailureReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_Teleporter_C", "IsAcceptablePositionForPlacement");

	Params::B_Teleporter_C_IsAcceptablePositionForPlacement Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);
	Parms.DecoTool = DecoTool;
	Parms.bIsCDO = bIsCDO;

	UObject::ProcessEvent(Func, &Parms);

	if (OutFailureReason != nullptr)
		*OutFailureReason = std::move(Parms.OutFailureReason);

	return Parms.ReturnValue;
}

}

#pragma pack(pop)
