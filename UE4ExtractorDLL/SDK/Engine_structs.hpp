#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Engine

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"


#pragma pack(push, 0x4)
namespace SDK
{

// Enum Engine.EEndPlayReason
// NumValues: 0x0006
enum class EEndPlayReason : uint8
{
	Destroyed                                = 0,
	LevelTransition                          = 1,
	EndPlayInEditor                          = 2,
	RemovedFromWorld                         = 3,
	Quit                                     = 4,
	EEndPlayReason_MAX                       = 5,
};

// Enum Engine.ENavPathEvent
// NumValues: 0x0008
enum class ENavPathEvent : uint8
{
	Cleared                                  = 0,
	NewPath                                  = 1,
	UpdatedDueToGoalMoved                    = 2,
	UpdatedDueToNavigationChanged            = 3,
	Invalidated                              = 4,
	RePathFailed                             = 5,
	Custom                                   = 6,
	ENavPathEvent_MAX                        = 7,
};

// Enum Engine.ETickingGroup
// NumValues: 0x0009
enum class ETickingGroup : uint8
{
	TG_PrePhysics                            = 0,
	TG_StartPhysics                          = 1,
	TG_DuringPhysics                         = 2,
	TG_EndPhysics                            = 3,
	TG_PostPhysics                           = 4,
	TG_PostUpdateWork                        = 5,
	TG_LastDemotable                         = 6,
	TG_NewlySpawned                          = 7,
	TG_MAX                                   = 8,
};

// Enum Engine.EComponentCreationMethod
// NumValues: 0x0005
enum class EComponentCreationMethod : uint8
{
	Native                                   = 0,
	SimpleConstructionScript                 = 1,
	UserConstructionScript                   = 2,
	Instance                                 = 3,
	EComponentCreationMethod_MAX             = 4,
};

// Enum Engine.EPlaneConstraintAxisSetting
// NumValues: 0x0006
enum class EPlaneConstraintAxisSetting : uint8
{
	Custom                                   = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	UseGlobalPhysicsSetting                  = 4,
	EPlaneConstraintAxisSetting_MAX          = 5,
};

// Enum Engine.EInterpToBehaviourType
// NumValues: 0x0005
enum class EInterpToBehaviourType : uint8
{
	OneShot                                  = 0,
	OneShot_Reverse                          = 1,
	Loop_Reset                               = 2,
	PingPong                                 = 3,
	EInterpToBehaviourType_MAX               = 4,
};

// Enum Engine.EPlatformInterfaceDataType
// NumValues: 0x0007
enum class EPlatformInterfaceDataType : uint8
{
	PIDT_None                                = 0,
	PIDT_Int                                 = 1,
	PIDT_Float                               = 2,
	PIDT_String                              = 3,
	PIDT_Object                              = 4,
	PIDT_Custom                              = 5,
	PIDT_MAX                                 = 6,
};

// Enum Engine.EMovementMode
// NumValues: 0x0008
enum class EMovementMode : uint8
{
	MOVE_None                                = 0,
	MOVE_Walking                             = 1,
	MOVE_NavWalking                          = 2,
	MOVE_Falling                             = 3,
	MOVE_Swimming                            = 4,
	MOVE_Flying                              = 5,
	MOVE_Custom                              = 6,
	MOVE_MAX                                 = 7,
};

// Enum Engine.EOverlapFilterOption
// NumValues: 0x0004
enum class EOverlapFilterOption : uint8
{
	OverlapFilter_All                        = 0,
	OverlapFilter_DynamicOnly                = 1,
	OverlapFilter_StaticOnly                 = 2,
	OverlapFilter_MAX                        = 3,
};

// Enum Engine.EObjectTypeQuery
// NumValues: 0x0022
enum class EObjectTypeQuery : uint8
{
	ObjectTypeQuery1                         = 0,
	ObjectTypeQuery2                         = 1,
	ObjectTypeQuery3                         = 2,
	ObjectTypeQuery4                         = 3,
	ObjectTypeQuery5                         = 4,
	ObjectTypeQuery6                         = 5,
	ObjectTypeQuery7                         = 6,
	ObjectTypeQuery8                         = 7,
	ObjectTypeQuery9                         = 8,
	ObjectTypeQuery10                        = 9,
	ObjectTypeQuery11                        = 10,
	ObjectTypeQuery12                        = 11,
	ObjectTypeQuery13                        = 12,
	ObjectTypeQuery14                        = 13,
	ObjectTypeQuery15                        = 14,
	ObjectTypeQuery16                        = 15,
	ObjectTypeQuery17                        = 16,
	ObjectTypeQuery18                        = 17,
	ObjectTypeQuery19                        = 18,
	ObjectTypeQuery20                        = 19,
	ObjectTypeQuery21                        = 20,
	ObjectTypeQuery22                        = 21,
	ObjectTypeQuery23                        = 22,
	ObjectTypeQuery24                        = 23,
	ObjectTypeQuery25                        = 24,
	ObjectTypeQuery26                        = 25,
	ObjectTypeQuery27                        = 26,
	ObjectTypeQuery28                        = 27,
	ObjectTypeQuery29                        = 28,
	ObjectTypeQuery30                        = 29,
	ObjectTypeQuery31                        = 30,
	ObjectTypeQuery32                        = 31,
	ObjectTypeQuery_MAX                      = 32,
	EObjectTypeQuery_MAX                     = 33,
};

// Enum Engine.EDrawDebugTrace
// NumValues: 0x0005
enum class EDrawDebugTrace : uint8
{
	None                                     = 0,
	ForOneFrame                              = 1,
	ForDuration                              = 2,
	Persistent                               = 3,
	EDrawDebugTrace_MAX                      = 4,
};

// Enum Engine.ETraceTypeQuery
// NumValues: 0x0022
enum class ETraceTypeQuery : uint8
{
	TraceTypeQuery1                          = 0,
	TraceTypeQuery2                          = 1,
	TraceTypeQuery3                          = 2,
	TraceTypeQuery4                          = 3,
	TraceTypeQuery5                          = 4,
	TraceTypeQuery6                          = 5,
	TraceTypeQuery7                          = 6,
	TraceTypeQuery8                          = 7,
	TraceTypeQuery9                          = 8,
	TraceTypeQuery10                         = 9,
	TraceTypeQuery11                         = 10,
	TraceTypeQuery12                         = 11,
	TraceTypeQuery13                         = 12,
	TraceTypeQuery14                         = 13,
	TraceTypeQuery15                         = 14,
	TraceTypeQuery16                         = 15,
	TraceTypeQuery17                         = 16,
	TraceTypeQuery18                         = 17,
	TraceTypeQuery19                         = 18,
	TraceTypeQuery20                         = 19,
	TraceTypeQuery21                         = 20,
	TraceTypeQuery22                         = 21,
	TraceTypeQuery23                         = 22,
	TraceTypeQuery24                         = 23,
	TraceTypeQuery25                         = 24,
	TraceTypeQuery26                         = 25,
	TraceTypeQuery27                         = 26,
	TraceTypeQuery28                         = 27,
	TraceTypeQuery29                         = 28,
	TraceTypeQuery30                         = 29,
	TraceTypeQuery31                         = 30,
	TraceTypeQuery32                         = 31,
	TraceTypeQuery_MAX                       = 32,
	ETraceTypeQuery_MAX                      = 33,
};

// Enum Engine.ECollisionChannel
// NumValues: 0x0022
enum class ECollisionChannel : uint8
{
	ECC_WorldStatic                          = 0,
	ECC_WorldDynamic                         = 1,
	ECC_Pawn                                 = 2,
	ECC_Visibility                           = 3,
	ECC_Camera                               = 4,
	ECC_PhysicsBody                          = 5,
	ECC_Vehicle                              = 6,
	ECC_Destructible                         = 7,
	ECC_EngineTraceChannel1                  = 8,
	ECC_EngineTraceChannel2                  = 9,
	ECC_EngineTraceChannel3                  = 10,
	ECC_EngineTraceChannel4                  = 11,
	ECC_EngineTraceChannel5                  = 12,
	ECC_EngineTraceChannel6                  = 13,
	ECC_GameTraceChannel1                    = 14,
	ECC_GameTraceChannel2                    = 15,
	ECC_GameTraceChannel3                    = 16,
	ECC_GameTraceChannel4                    = 17,
	ECC_GameTraceChannel5                    = 18,
	ECC_GameTraceChannel6                    = 19,
	ECC_GameTraceChannel7                    = 20,
	ECC_GameTraceChannel8                    = 21,
	ECC_GameTraceChannel9                    = 22,
	ECC_GameTraceChannel10                   = 23,
	ECC_GameTraceChannel11                   = 24,
	ECC_GameTraceChannel12                   = 25,
	ECC_GameTraceChannel13                   = 26,
	ECC_GameTraceChannel14                   = 27,
	ECC_GameTraceChannel15                   = 28,
	ECC_GameTraceChannel16                   = 29,
	ECC_GameTraceChannel17                   = 30,
	ECC_GameTraceChannel18                   = 31,
	ECC_OverlapAll_Deprecated                = 32,
	ECC_MAX                                  = 33,
};

// Enum Engine.EMoveComponentAction
// NumValues: 0x0004
enum class EMoveComponentAction : uint8
{
	Move                                     = 0,
	Stop                                     = 1,
	Return                                   = 2,
	EMoveComponentAction_MAX                 = 3,
};

// Enum Engine.EQuitPreference
// NumValues: 0x0003
enum class EQuitPreference : uint8
{
	Quit                                     = 0,
	Background                               = 1,
	EQuitPreference_MAX                      = 2,
};

// Enum Engine.EViewModeIndex
// NumValues: 0x0016
enum class EViewModeIndex : uint8
{
	VMI_BrushWireframe                       = 0,
	VMI_Wireframe                            = 1,
	VMI_Unlit                                = 2,
	VMI_Lit                                  = 3,
	VMI_Lit_DetailLighting                   = 4,
	VMI_LightingOnly                         = 5,
	VMI_LightComplexity                      = 6,
	VMI_ShaderComplexity                     = 8,
	VMI_LightmapDensity                      = 9,
	VMI_LitLightmapDensity                   = 10,
	VMI_ReflectionOverride                   = 11,
	VMI_VisualizeBuffer                      = 12,
	VMI_StationaryLightOverlap               = 14,
	VMI_CollisionPawn                        = 15,
	VMI_CollisionVisibility                  = 16,
	VMI_VertexDensities                      = 17,
	VMI_LODColoration                        = 18,
	VMI_QuadComplexity                       = 19,
	VMI_WantedMipsAccuracy                   = 20,
	VMI_TexelFactorAccuracy                  = 21,
	VMI_Max                                  = 22,
	VMI_Unknown                              = 255,
};

// Enum Engine.EDemoPlayFailure
// NumValues: 0x0005
enum class EDemoPlayFailure : uint8
{
	Generic                                  = 0,
	DemoNotFound                             = 1,
	Corrupt                                  = 2,
	InvalidVersion                           = 3,
	EDemoPlayFailure_MAX                     = 4,
};

// Enum Engine.ETravelType
// NumValues: 0x0004
enum class ETravelType : uint8
{
	TRAVEL_Absolute                          = 0,
	TRAVEL_Partial                           = 1,
	TRAVEL_Relative                          = 2,
	TRAVEL_MAX                               = 3,
};

// Enum Engine.ETravelFailure
// NumValues: 0x000D
enum class ETravelFailure : uint8
{
	NoLevel                                  = 0,
	LoadMapFailure                           = 1,
	InvalidURL                               = 2,
	PackageMissing                           = 3,
	PackageVersion                           = 4,
	NoDownload                               = 5,
	TravelFailure                            = 6,
	CheatCommands                            = 7,
	PendingNetGameCreateFailure              = 8,
	CloudSaveFailure                         = 9,
	ServerTravelFailure                      = 10,
	ClientTravelFailure                      = 11,
	ETravelFailure_MAX                       = 12,
};

// Enum Engine.ENetworkLagState
// NumValues: 0x0003
enum class ENetworkLagState : uint8
{
	NotLagging                               = 0,
	Lagging                                  = 1,
	ENetworkLagState_MAX                     = 2,
};

// Enum Engine.ENetworkFailure
// NumValues: 0x000A
enum class ENetworkFailure : uint8
{
	NetDriverAlreadyExists                   = 0,
	NetDriverCreateFailure                   = 1,
	NetDriverListenFailure                   = 2,
	ConnectionLost                           = 3,
	ConnectionTimeout                        = 4,
	FailureReceived                          = 5,
	OutdatedClient                           = 6,
	OutdatedServer                           = 7,
	PendingConnectionFailure                 = 8,
	ENetworkFailure_MAX                      = 9,
};

// Enum Engine.EInputEvent
// NumValues: 0x0006
enum class EInputEvent : uint8
{
	IE_Pressed                               = 0,
	IE_Released                              = 1,
	IE_Repeat                                = 2,
	IE_DoubleClick                           = 3,
	IE_Axis                                  = 4,
	IE_MAX                                   = 5,
};

// Enum Engine.ESpawnActorCollisionHandlingMethod
// NumValues: 0x0006
enum class ESpawnActorCollisionHandlingMethod : uint8
{
	Undefined                                = 0,
	AlwaysSpawn                              = 1,
	AdjustIfPossibleButAlwaysSpawn           = 2,
	AdjustIfPossibleButDontSpawnIfColliding  = 3,
	DontSpawnIfColliding                     = 4,
	ESpawnActorCollisionHandlingMethod_MAX   = 5,
};

// Enum Engine.EAngularConstraintMotion
// NumValues: 0x0004
enum class EAngularConstraintMotion : uint8
{
	ACM_Free                                 = 0,
	ACM_Limited                              = 1,
	ACM_Locked                               = 2,
	ACM_MAX                                  = 3,
};

// Enum Engine.EComponentSocketType
// NumValues: 0x0004
enum class EComponentSocketType : uint8
{
	Invalid                                  = 0,
	Bone                                     = 1,
	Socket                                   = 2,
	EComponentSocketType_MAX                 = 3,
};

// Enum Engine.EComponentMobility
// NumValues: 0x0004
enum class EComponentMobility : uint8
{
	Static                                   = 0,
	Stationary                               = 1,
	Movable                                  = 2,
	EComponentMobility_MAX                   = 3,
};

// Enum Engine.EPhysicalSurface
// NumValues: 0x0041
enum class EPhysicalSurface : uint8
{
	SurfaceType_Default                      = 0,
	SurfaceType1                             = 1,
	SurfaceType2                             = 2,
	SurfaceType3                             = 3,
	SurfaceType4                             = 4,
	SurfaceType5                             = 5,
	SurfaceType6                             = 6,
	SurfaceType7                             = 7,
	SurfaceType8                             = 8,
	SurfaceType9                             = 9,
	SurfaceType10                            = 10,
	SurfaceType11                            = 11,
	SurfaceType12                            = 12,
	SurfaceType13                            = 13,
	SurfaceType14                            = 14,
	SurfaceType15                            = 15,
	SurfaceType16                            = 16,
	SurfaceType17                            = 17,
	SurfaceType18                            = 18,
	SurfaceType19                            = 19,
	SurfaceType20                            = 20,
	SurfaceType21                            = 21,
	SurfaceType22                            = 22,
	SurfaceType23                            = 23,
	SurfaceType24                            = 24,
	SurfaceType25                            = 25,
	SurfaceType26                            = 26,
	SurfaceType27                            = 27,
	SurfaceType28                            = 28,
	SurfaceType29                            = 29,
	SurfaceType30                            = 30,
	SurfaceType31                            = 31,
	SurfaceType32                            = 32,
	SurfaceType33                            = 33,
	SurfaceType34                            = 34,
	SurfaceType35                            = 35,
	SurfaceType36                            = 36,
	SurfaceType37                            = 37,
	SurfaceType38                            = 38,
	SurfaceType39                            = 39,
	SurfaceType40                            = 40,
	SurfaceType41                            = 41,
	SurfaceType42                            = 42,
	SurfaceType43                            = 43,
	SurfaceType44                            = 44,
	SurfaceType45                            = 45,
	SurfaceType46                            = 46,
	SurfaceType47                            = 47,
	SurfaceType48                            = 48,
	SurfaceType49                            = 49,
	SurfaceType50                            = 50,
	SurfaceType51                            = 51,
	SurfaceType52                            = 52,
	SurfaceType53                            = 53,
	SurfaceType54                            = 54,
	SurfaceType55                            = 55,
	SurfaceType56                            = 56,
	SurfaceType57                            = 57,
	SurfaceType58                            = 58,
	SurfaceType59                            = 59,
	SurfaceType60                            = 60,
	SurfaceType61                            = 61,
	SurfaceType62                            = 62,
	SurfaceType_Max                          = 63,
	EPhysicalSurface_MAX                     = 64,
};

// Enum Engine.EWalkableSlopeBehavior
// NumValues: 0x0005
enum class EWalkableSlopeBehavior : uint8
{
	WalkableSlope_Default                    = 0,
	WalkableSlope_Increase                   = 1,
	WalkableSlope_Decrease                   = 2,
	WalkableSlope_Unwalkable                 = 3,
	WalkableSlope_Max                        = 4,
};

// Enum Engine.ERotatorQuantization
// NumValues: 0x0003
enum class ERotatorQuantization : uint8
{
	ByteComponents                           = 0,
	ShortComponents                          = 1,
	ERotatorQuantization_MAX                 = 2,
};

// Enum Engine.EVectorQuantization
// NumValues: 0x0004
enum class EVectorQuantization : uint8
{
	RoundWholeNumber                         = 0,
	RoundOneDecimal                          = 1,
	RoundTwoDecimals                         = 2,
	EVectorQuantization_MAX                  = 3,
};

// Enum Engine.EAutoPossessAI
// NumValues: 0x0005
enum class EAutoPossessAI : uint8
{
	Disabled                                 = 0,
	PlacedInWorld                            = 1,
	Spawned                                  = 2,
	PlacedInWorldOrSpawned                   = 3,
	EAutoPossessAI_MAX                       = 4,
};

// Enum Engine.EAutoReceiveInput
// NumValues: 0x000A
enum class EAutoReceiveInput : uint8
{
	Disabled                                 = 0,
	Player0                                  = 1,
	Player1                                  = 2,
	Player2                                  = 3,
	Player3                                  = 4,
	Player4                                  = 5,
	Player5                                  = 6,
	Player6                                  = 7,
	Player7                                  = 8,
	EAutoReceiveInput_MAX                    = 9,
};

// Enum Engine.ENetDormancy
// NumValues: 0x0007
enum class ENetDormancy : uint8
{
	DORM_Never                               = 0,
	DORM_Awake                               = 1,
	DORM_DormantAll                          = 2,
	DORM_DormantPartial                      = 3,
	DORM_Initial                             = 4,
	DORN_MAX                                 = 5,
	ENetDormancy_MAX                         = 6,
};

// Enum Engine.ENetRole
// NumValues: 0x0005
enum class ENetRole : uint8
{
	ROLE_None                                = 0,
	ROLE_SimulatedProxy                      = 1,
	ROLE_AutonomousProxy                     = 2,
	ROLE_Authority                           = 3,
	ROLE_MAX                                 = 4,
};

// Enum Engine.ETextureSizingType
// NumValues: 0x0005
enum class ETextureSizingType : uint8
{
	TextureSizingType_UseSingleTextureSize   = 0,
	TextureSizingType_UseAutomaticBiasedSizes = 1,
	TextureSizingType_UseManualOverrideTextureSize = 2,
	TextureSizingType_UseSimplygonAutomaticSizing = 3,
	TextureSizingType_MAX                    = 4,
};

// Enum Engine.EMeshFeatureImportance
// NumValues: 0x0007
enum class EMeshFeatureImportance : uint8
{
	Off                                      = 0,
	Lowest                                   = 1,
	Low                                      = 2,
	Normal                                   = 3,
	High                                     = 4,
	Highest                                  = 5,
	EMeshFeatureImportance_MAX               = 6,
};

// Enum Engine.EUpdateRateShiftBucket
// NumValues: 0x0008
enum class EUpdateRateShiftBucket : uint8
{
	ShiftBucket0                             = 0,
	ShiftBucket1                             = 1,
	ShiftBucket2                             = 2,
	ShiftBucket3                             = 3,
	ShiftBucket4                             = 4,
	ShiftBucket5                             = 5,
	ShiftBucketMax                           = 6,
	EUpdateRateShiftBucket_MAX               = 7,
};

// Enum Engine.EShadowMapFlags
// NumValues: 0x0003
enum class EShadowMapFlags : uint8
{
	SMF_None                                 = 0,
	SMF_Streamed                             = 1,
	SMF_MAX                                  = 2,
};

// Enum Engine.ELightMapPaddingType
// NumValues: 0x0004
enum class ELightMapPaddingType : uint8
{
	LMPT_NormalPadding                       = 0,
	LMPT_PrePadding                          = 1,
	LMPT_NoPadding                           = 2,
	LMPT_MAX                                 = 3,
};

// Enum Engine.ECollisionEnabled
// NumValues: 0x0005
enum class ECollisionEnabled : uint8
{
	NoCollision                              = 0,
	QueryOnly                                = 1,
	PhysicsOnly                              = 2,
	QueryAndPhysics                          = 3,
	ECollisionEnabled_MAX                    = 4,
};

// Enum Engine.ETimelineSigType
// NumValues: 0x0006
enum class ETimelineSigType : uint8
{
	ETS_EventSignature                       = 0,
	ETS_FloatSignature                       = 1,
	ETS_VectorSignature                      = 2,
	ETS_LinearColorSignature                 = 3,
	ETS_InvalidSignature                     = 4,
	ETS_MAX                                  = 5,
};

// Enum Engine.ESleepFamily
// NumValues: 0x0004
enum class ESleepFamily : uint8
{
	Normal                                   = 0,
	Sensitive                                = 1,
	Custom                                   = 2,
	ESleepFamily_MAX                         = 3,
};

// Enum Engine.ERadialImpulseFalloff
// NumValues: 0x0003
enum class ERadialImpulseFalloff : uint8
{
	RIF_Constant                             = 0,
	RIF_Linear                               = 1,
	RIF_MAX                                  = 2,
};

// Enum Engine.EInputConsumeOptions
// NumValues: 0x0004
enum class EInputConsumeOptions : uint8
{
	ICO_ConsumeAll                           = 0,
	ICO_ConsumeBoundKeys                     = 1,
	ICO_ConsumeNone                          = 2,
	ICO_MAX                                  = 3,
};

// Enum Engine.EFilterInterpolationType
// NumValues: 0x0004
enum class EFilterInterpolationType : uint8
{
	BSIT_Average                             = 0,
	BSIT_Linear                              = 1,
	BSIT_Cubic                               = 2,
	BSIT_MAX                                 = 3,
};

// Enum Engine.ECollisionResponse
// NumValues: 0x0004
enum class ECollisionResponse : uint8
{
	ECR_Ignore                               = 0,
	ECR_Overlap                              = 1,
	ECR_Block                                = 2,
	ECR_MAX                                  = 3,
};

// Enum Engine.EPhysicsSceneType
// NumValues: 0x0004
enum class EPhysicsSceneType : uint8
{
	PST_Sync                                 = 0,
	PST_Cloth                                = 1,
	PST_Async                                = 2,
	PST_MAX                                  = 3,
};

// Enum Engine.ENetworkSmoothingMode
// NumValues: 0x0004
enum class ENetworkSmoothingMode : uint8
{
	Disabled                                 = 0,
	Linear                                   = 1,
	Exponential                              = 2,
	ENetworkSmoothingMode_MAX                = 3,
};

// Enum Engine.ETriangleSortAxis
// NumValues: 0x0004
enum class ETriangleSortAxis : uint8
{
	TSA_X_Axis                               = 0,
	TSA_Y_Axis                               = 1,
	TSA_Z_Axis                               = 2,
	TSA_MAX                                  = 3,
};

// Enum Engine.ETriangleSortOption
// NumValues: 0x0007
enum class ETriangleSortOption : uint8
{
	TRISORT_None                             = 0,
	TRISORT_CenterRadialDistance             = 1,
	TRISORT_Random                           = 2,
	TRISORT_MergeContiguous                  = 3,
	TRISORT_Custom                           = 4,
	TRISORT_CustomLeftRight                  = 5,
	TRISORT_MAX                              = 6,
};

// Enum Engine.ELightingBuildQuality
// NumValues: 0x0005
enum class ELightingBuildQuality : uint8
{
	Quality_Preview                          = 0,
	Quality_Medium                           = 1,
	Quality_High                             = 2,
	Quality_Production                       = 3,
	Quality_MAX                              = 4,
};

// Enum Engine.EMaterialSamplerType
// NumValues: 0x0009
enum class EMaterialSamplerType : uint8
{
	SAMPLERTYPE_Color                        = 0,
	SAMPLERTYPE_Grayscale                    = 1,
	SAMPLERTYPE_Alpha                        = 2,
	SAMPLERTYPE_Normal                       = 3,
	SAMPLERTYPE_Masks                        = 4,
	SAMPLERTYPE_DistanceFieldFont            = 5,
	SAMPLERTYPE_LinearColor                  = 6,
	SAMPLERTYPE_LinearGrayscale              = 7,
	SAMPLERTYPE_MAX                          = 8,
};

// Enum Engine.EMaterialTessellationMode
// NumValues: 0x0004
enum class EMaterialTessellationMode : uint8
{
	MTM_NoTessellation                       = 0,
	MTM_FlatTessellation                     = 1,
	MTM_PNTriangles                          = 2,
	MTM_MAX                                  = 3,
};

// Enum Engine.EMaterialShadingModel
// NumValues: 0x000B
enum class EMaterialShadingModel : uint8
{
	MSM_Unlit                                = 0,
	MSM_DefaultLit                           = 1,
	MSM_Subsurface                           = 2,
	MSM_PreintegratedSkin                    = 3,
	MSM_ClearCoat                            = 4,
	MSM_SubsurfaceProfile                    = 5,
	MSM_TwoSidedFoliage                      = 6,
	MSM_Hair                                 = 7,
	MSM_Cloth                                = 8,
	MSM_Eye                                  = 9,
	MSM_MAX                                  = 10,
};

// Enum Engine.EParticleCollisionMode
// NumValues: 0x0003
enum class EParticleCollisionMode : uint8
{
	SceneDepth                               = 0,
	DistanceField                            = 1,
	EParticleCollisionMode_MAX               = 2,
};

// Enum Engine.ETrailWidthMode
// NumValues: 0x0004
enum class ETrailWidthMode : uint8
{
	ETrailWidthMode_FromCentre               = 0,
	ETrailWidthMode_FromFirst                = 1,
	ETrailWidthMode_FromSecond               = 2,
	ETrailWidthMode_MAX                      = 3,
};

// Enum Engine.ETranslucentSortPolicy
// NumValues: 0x0004
enum class ETranslucentSortPolicy : uint8
{
	SortByDistance                           = 0,
	SortByProjectedZ                         = 1,
	SortAlongAxis                            = 2,
	ETranslucentSortPolicy_MAX               = 3,
};

// Enum Engine.ETranslucencyLightingMode
// NumValues: 0x0007
enum class ETranslucencyLightingMode : uint8
{
	TLM_VolumetricNonDirectional             = 0,
	TLM_VolumetricDirectional                = 1,
	TLM_VolumetricPerVertexNonDirectional    = 2,
	TLM_VolumetricPerVertexDirectional       = 3,
	TLM_Surface                              = 4,
	TLM_SurfacePerPixelLighting              = 5,
	TLM_MAX                                  = 6,
};

// Enum Engine.ESamplerSourceMode
// NumValues: 0x0004
enum class ESamplerSourceMode : uint8
{
	SSM_FromTextureAsset                     = 0,
	SSM_Wrap_WorldGroupSettings              = 1,
	SSM_Clamp_WorldGroupSettings             = 2,
	SSM_MAX                                  = 3,
};

// Enum Engine.EBlendMode
// NumValues: 0x0006
enum class EBlendMode : uint8
{
	BLEND_Opaque                             = 0,
	BLEND_Masked                             = 1,
	BLEND_Translucent                        = 2,
	BLEND_Additive                           = 3,
	BLEND_Modulate                           = 4,
	BLEND_MAX                                = 5,
};

// Enum Engine.EIndirectLightingCacheQuality
// NumValues: 0x0004
enum class EIndirectLightingCacheQuality : uint8
{
	ILCQ_Off                                 = 0,
	ILCQ_Point                               = 1,
	ILCQ_Volume                              = 2,
	ILCQ_MAX                                 = 3,
};

// Enum Engine.ESceneDepthPriorityGroup
// NumValues: 0x0003
enum class ESceneDepthPriorityGroup : uint8
{
	SDPG_World                               = 0,
	SDPG_Foreground                          = 1,
	SDPG_MAX                                 = 2,
};

// Enum Engine.EAttachLocation
// NumValues: 0x0005
enum class EAttachLocation : uint8
{
	KeepRelativeOffset                       = 0,
	KeepWorldPosition                        = 1,
	SnapToTarget                             = 2,
	SnapToTargetIncludingScale               = 3,
	EAttachLocation_MAX                      = 4,
};

// Enum Engine.EActorMetricsType
// NumValues: 0x0004
enum class EActorMetricsType : uint8
{
	METRICS_VERTS                            = 0,
	METRICS_TRIS                             = 1,
	METRICS_SECTIONS                         = 2,
	METRICS_MAX                              = 3,
};

// Enum Engine.EAspectRatioAxisConstraint
// NumValues: 0x0004
enum class EAspectRatioAxisConstraint : uint8
{
	AspectRatio_MaintainYFOV                 = 0,
	AspectRatio_MaintainXFOV                 = 1,
	AspectRatio_MajorAxisFOV                 = 2,
	AspectRatio_MAX                          = 3,
};

// Enum Engine.ENodeEnabledState
// NumValues: 0x0004
enum class ENodeEnabledState : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	DevelopmentOnly                          = 2,
	ENodeEnabledState_MAX                    = 3,
};

// Enum Engine.ENodeAdvancedPins
// NumValues: 0x0004
enum class ENodeAdvancedPins : uint8
{
	NoPins                                   = 0,
	Shown                                    = 1,
	Hidden                                   = 2,
	ENodeAdvancedPins_MAX                    = 3,
};

// Enum Engine.ENodeTitleType
// NumValues: 0x0006
enum class ENodeTitleType : uint8
{
	FullTitle                                = 0,
	ListView                                 = 1,
	EditableTitle                            = 2,
	MenuTitle                                = 3,
	MAX_TitleTypes                           = 4,
	ENodeTitleType_MAX                       = 5,
};

// Enum Engine.EEdGraphPinDirection
// NumValues: 0x0003
enum class EEdGraphPinDirection : uint8
{
	EGPD_Input                               = 0,
	EGPD_Output                              = 1,
	EGPD_MAX                                 = 2,
};

// Enum Engine.EBlueprintPinStyleType
// NumValues: 0x0003
enum class EBlueprintPinStyleType : uint8
{
	BPST_Original                            = 0,
	BPST_VariantA                            = 1,
	BPST_MAX                                 = 2,
};

// Enum Engine.EBlueprintCompileMode
// NumValues: 0x0004
enum class EBlueprintCompileMode : uint8
{
	Default                                  = 0,
	Development                              = 1,
	FinalRelease                             = 2,
	EBlueprintCompileMode_MAX                = 3,
};

// Enum Engine.EBlueprintType
// NumValues: 0x0007
enum class EBlueprintType : uint8
{
	BPTYPE_Normal                            = 0,
	BPTYPE_Const                             = 1,
	BPTYPE_MacroLibrary                      = 2,
	BPTYPE_Interface                         = 3,
	BPTYPE_LevelScript                       = 4,
	BPTYPE_FunctionLibrary                   = 5,
	BPTYPE_MAX                               = 6,
};

// Enum Engine.EBlueprintStatus
// NumValues: 0x0007
enum class EBlueprintStatus : uint8
{
	BS_Unknown                               = 0,
	BS_Dirty                                 = 1,
	BS_Error                                 = 2,
	BS_UpToDate                              = 3,
	BS_BeingCreated                          = 4,
	BS_UpToDateWithWarnings                  = 5,
	BS_MAX                                   = 6,
};

// Enum Engine.ERelativeTransformSpace
// NumValues: 0x0004
enum class ERelativeTransformSpace : uint8
{
	RTS_World                                = 0,
	RTS_Actor                                = 1,
	RTS_Component                            = 2,
	RTS_MAX                                  = 3,
};

// Enum Engine.EDetailMode
// NumValues: 0x0004
enum class EDetailMode : uint8
{
	DM_Low                                   = 0,
	DM_Medium                                = 1,
	DM_High                                  = 2,
	DM_MAX                                   = 3,
};

// Enum Engine.EBrushType
// NumValues: 0x0004
enum class EBrushType : uint8
{
	Brush_Default                            = 0,
	Brush_Add                                = 1,
	Brush_Subtract                           = 2,
	Brush_MAX                                = 3,
};

// Enum Engine.ECsgOper
// NumValues: 0x0007
enum class ECsgOper : uint8
{
	CSG_Active                               = 0,
	CSG_Add                                  = 1,
	CSG_Subtract                             = 2,
	CSG_Intersect                            = 3,
	CSG_Deintersect                          = 4,
	CSG_None                                 = 5,
	CSG_MAX                                  = 6,
};

// Enum Engine.ReverbPreset
// NumValues: 0x0018
enum class EReverbPreset : uint8
{
	REVERB_Default                           = 0,
	REVERB_Bathroom                          = 1,
	REVERB_StoneRoom                         = 2,
	REVERB_Auditorium                        = 3,
	REVERB_ConcertHall                       = 4,
	REVERB_Cave                              = 5,
	REVERB_Hallway                           = 6,
	REVERB_StoneCorridor                     = 7,
	REVERB_Alley                             = 8,
	REVERB_Forest                            = 9,
	REVERB_City                              = 10,
	REVERB_Mountains                         = 11,
	REVERB_Quarry                            = 12,
	REVERB_Plain                             = 13,
	REVERB_ParkingLot                        = 14,
	REVERB_SewerPipe                         = 15,
	REVERB_Underwater                        = 16,
	REVERB_SmallRoom                         = 17,
	REVERB_MediumRoom                        = 18,
	REVERB_LargeRoom                         = 19,
	REVERB_MediumHall                        = 20,
	REVERB_LargeHall                         = 21,
	REVERB_Plate                             = 22,
	REVERB_MAX                               = 23,
};

// Enum Engine.EStreamingVolumeUsage
// NumValues: 0x0006
enum class EStreamingVolumeUsage : uint8
{
	SVB_Loading                              = 0,
	SVB_LoadingAndVisibility                 = 1,
	SVB_VisibilityBlockingOnLoad             = 2,
	SVB_BlockingOnLoad                       = 3,
	SVB_LoadingNotVisible                    = 4,
	SVB_MAX                                  = 5,
};

// Enum Engine.ENavigationQueryResult
// NumValues: 0x0005
enum class ENavigationQueryResult : uint8
{
	Invalid                                  = 0,
	Error                                    = 1,
	Fail                                     = 2,
	Success                                  = 3,
	ENavigationQueryResult_MAX               = 4,
};

// Enum Engine.ENavDataGatheringModeConfig
// NumValues: 0x0004
enum class ENavDataGatheringModeConfig : uint8
{
	Invalid                                  = 0,
	Instant                                  = 1,
	Lazy                                     = 2,
	ENavDataGatheringModeConfig_MAX          = 3,
};

// Enum Engine.ENavDataGatheringMode
// NumValues: 0x0004
enum class ENavDataGatheringMode : uint8
{
	Default                                  = 0,
	Instant                                  = 1,
	Lazy                                     = 2,
	ENavDataGatheringMode_MAX                = 3,
};

// Enum Engine.ENavigationOptionFlag
// NumValues: 0x0005
enum class ENavigationOptionFlag : uint8
{
	Default                                  = 0,
	Enable                                   = 1,
	Disable                                  = 2,
	MAX                                      = 3,
	ENavigationOptionFlag_MAX                = 4,
};

// Enum Engine.EBlendableLocation
// NumValues: 0x0005
enum class EBlendableLocation : uint8
{
	BL_AfterTonemapping                      = 0,
	BL_BeforeTonemapping                     = 1,
	BL_BeforeTranslucency                    = 2,
	BL_ReplacingTonemapper                   = 3,
	BL_MAX                                   = 4,
};

// Enum Engine.EAutoExposureMethod
// NumValues: 0x0003
enum class EAutoExposureMethod : uint8
{
	AEM_Histogram                            = 0,
	AEM_Basic                                = 1,
	AEM_MAX                                  = 2,
};

// Enum Engine.EAntiAliasingMethod
// NumValues: 0x0004
enum class EAntiAliasingMethod : uint8
{
	AAM_None                                 = 0,
	AAM_FXAA                                 = 1,
	AAM_TemporalAA                           = 2,
	AAM_MAX                                  = 3,
};

// Enum Engine.EDepthOfFieldMethod
// NumValues: 0x0004
enum class EDepthOfFieldMethod : uint8
{
	DOFM_BokehDOF                            = 0,
	DOFM_Gaussian                            = 1,
	DOFM_CircleDOF                           = 2,
	DOFM_MAX                                 = 3,
};

// Enum Engine.ECameraAnimPlaySpace
// NumValues: 0x0004
enum class ECameraAnimPlaySpace : uint8
{
	CameraLocal                              = 0,
	World                                    = 1,
	UserDefined                              = 2,
	ECameraAnimPlaySpace_MAX                 = 3,
};

// Enum Engine.ECameraProjectionMode
// NumValues: 0x0003
enum class ECameraProjectionMode : uint8
{
	Perspective                              = 0,
	Orthographic                             = 1,
	ECameraProjectionMode_MAX                = 2,
};

// Enum Engine.EInitialOscillatorOffset
// NumValues: 0x0003
enum class EInitialOscillatorOffset : uint8
{
	EOO_OffsetRandom                         = 0,
	EOO_OffsetZero                           = 1,
	EOO_MAX                                  = 2,
};

// Enum Engine.EViewTargetBlendFunction
// NumValues: 0x0006
enum class EViewTargetBlendFunction : uint8
{
	VTBlend_Linear                           = 0,
	VTBlend_Cubic                            = 1,
	VTBlend_EaseIn                           = 2,
	VTBlend_EaseOut                          = 3,
	VTBlend_EaseInOut                        = 4,
	VTBlend_MAX                              = 5,
};

// Enum Engine.EControllerAnalogStick
// NumValues: 0x0003
enum class EControllerAnalogStick : uint8
{
	CAS_LeftStick                            = 0,
	CAS_RightStick                           = 1,
	CAS_MAX                                  = 2,
};

// Enum Engine.ERichCurveExtrapolation
// NumValues: 0x0007
enum class ERichCurveExtrapolation : uint8
{
	RCCE_Cycle                               = 0,
	RCCE_CycleWithOffset                     = 1,
	RCCE_Oscillate                           = 2,
	RCCE_Linear                              = 3,
	RCCE_Constant                            = 4,
	RCCE_None                                = 5,
	RCCE_MAX                                 = 6,
};

// Enum Engine.ERichCurveTangentWeightMode
// NumValues: 0x0005
enum class ERichCurveTangentWeightMode : uint8
{
	RCTWM_WeightedNone                       = 0,
	RCTWM_WeightedArrive                     = 1,
	RCTWM_WeightedLeave                      = 2,
	RCTWM_WeightedBoth                       = 3,
	RCTWM_MAX                                = 4,
};

// Enum Engine.ERichCurveTangentMode
// NumValues: 0x0005
enum class ERichCurveTangentMode : uint8
{
	RCTM_Auto                                = 0,
	RCTM_User                                = 1,
	RCTM_Break                               = 2,
	RCTM_None                                = 3,
	RCTM_MAX                                 = 4,
};

// Enum Engine.ERichCurveInterpMode
// NumValues: 0x0005
enum class ERichCurveInterpMode : uint8
{
	RCIM_Linear                              = 0,
	RCIM_Constant                            = 1,
	RCIM_Cubic                               = 2,
	RCIM_None                                = 3,
	RCIM_MAX                                 = 4,
};

// Enum Engine.EDynamicForceFeedbackAction
// NumValues: 0x0004
enum class EDynamicForceFeedbackAction : uint8
{
	Start                                    = 0,
	Update                                   = 1,
	Stop                                     = 2,
	EDynamicForceFeedbackAction_MAX          = 3,
};

// Enum Engine.EStandbyType
// NumValues: 0x0004
enum class EStandbyType : uint8
{
	STDBY_Rx                                 = 0,
	STDBY_Tx                                 = 1,
	STDBY_BadPing                            = 2,
	STDBY_MAX                                = 3,
};

// Enum Engine.EVisibilityAggressiveness
// NumValues: 0x0004
enum class EVisibilityAggressiveness : uint8
{
	VIS_LeastAggressive                      = 0,
	VIS_ModeratelyAggressive                 = 1,
	VIS_MostAggressive                       = 2,
	VIS_Max                                  = 3,
};

// Enum Engine.ERuntimeGenerationType
// NumValues: 0x0005
enum class ERuntimeGenerationType : uint8
{
	Static                                   = 0,
	DynamicModifiersOnly                     = 1,
	Dynamic                                  = 2,
	LegacyGeneration                         = 3,
	ERuntimeGenerationType_MAX               = 4,
};

// Enum Engine.ERecastPartitioning
// NumValues: 0x0004
enum class ERecastPartitioning : uint8
{
	Monotone                                 = 0,
	Watershed                                = 1,
	ChunkyMonotone                           = 2,
	ERecastPartitioning_MAX                  = 3,
};

// Enum Engine.ENavCostDisplay
// NumValues: 0x0004
enum class ENavCostDisplay : uint8
{
	TotalCost                                = 0,
	HeuristicOnly                            = 1,
	RealCostOnly                             = 2,
	ENavCostDisplay_MAX                      = 3,
};

// Enum Engine.ENavLinkDirection
// NumValues: 0x0004
enum class ENavLinkDirection : uint8
{
	BothWays                                 = 0,
	LeftToRight                              = 1,
	RightToLeft                              = 2,
	ENavLinkDirection_MAX                    = 3,
};

// Enum Engine.EBoneTranslationRetargetingMode
// NumValues: 0x0005
enum class EBoneTranslationRetargetingMode : uint8
{
	Animation                                = 0,
	Skeleton                                 = 1,
	AnimationScaled                          = 2,
	AnimationRelative                        = 3,
	EBoneTranslationRetargetingMode_MAX      = 4,
};

// Enum Engine.SkeletalMeshOptimizationType
// NumValues: 0x0003
enum class ESkeletalMeshOptimizationType : uint8
{
	SMOT_NumOfTriangles                      = 0,
	SMOT_MaxDeviation                        = 1,
	SMOT_MAX                                 = 2,
};

// Enum Engine.SkeletalMeshOptimizationImportance
// NumValues: 0x0007
enum class ESkeletalMeshOptimizationImportance : uint8
{
	SMOI_Off                                 = 0,
	SMOI_Lowest                              = 1,
	SMOI_Low                                 = 2,
	SMOI_Normal                              = 3,
	SMOI_High                                = 4,
	SMOI_Highest                             = 5,
	SMOI_MAX                                 = 6,
};

// Enum Engine.EAnimGroupRole
// NumValues: 0x0005
enum class EAnimGroupRole : uint8
{
	CanBeLeader                              = 0,
	AlwaysFollower                           = 1,
	AlwaysLeader                             = 2,
	TransitionLeader                         = 3,
	EAnimGroupRole_MAX                       = 4,
};

// Enum Engine.ERootMotionMode
// NumValues: 0x0005
enum class ERootMotionMode : uint8
{
	NoRootMotionExtraction                   = 0,
	IgnoreRootMotion                         = 1,
	RootMotionFromEverything                 = 2,
	RootMotionFromMontagesOnly               = 3,
	ERootMotionMode_MAX                      = 4,
};

// Enum Engine.ERootMotionRootLock
// NumValues: 0x0004
enum class ERootMotionRootLock : uint8
{
	RefPose                                  = 0,
	AnimFirstFrame                           = 1,
	Zero                                     = 2,
	ERootMotionRootLock_MAX                  = 3,
};

// Enum Engine.ERootMotionSourceSettingsFlags
// NumValues: 0x0002
enum class ERootMotionSourceSettingsFlags : uint8
{
	UseSensitiveLiftoffCheck                 = 1,
	ERootMotionSourceSettingsFlags_MAX       = 2,
};

// Enum Engine.ERootMotionSourceStatusFlags
// NumValues: 0x0004
enum class ERootMotionSourceStatusFlags : uint8
{
	Prepared                                 = 1,
	Finished                                 = 2,
	MarkedForRemoval                         = 4,
	ERootMotionSourceStatusFlags_MAX         = 5,
};

// Enum Engine.ERootMotionAccumulateMode
// NumValues: 0x0003
enum class ERootMotionAccumulateMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	ERootMotionAccumulateMode_MAX            = 2,
};

// Enum Engine.EDOFMode
// NumValues: 0x0008
enum class EDOFMode : uint8
{
	Default                                  = 0,
	SixDOF                                   = 1,
	YZPlane                                  = 2,
	XZPlane                                  = 3,
	XYPlane                                  = 4,
	CustomPlane                              = 5,
	None                                     = 6,
	EDOFMode_MAX                             = 7,
};

// Enum Engine.EHasCustomNavigableGeometry
// NumValues: 0x0005
enum class EHasCustomNavigableGeometry : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	EvenIfNotCollidable                      = 2,
	DontExport                               = 3,
	EHasCustomNavigableGeometry_MAX          = 4,
};

// Enum Engine.ECanBeCharacterBase
// NumValues: 0x0004
enum class ECanBeCharacterBase : uint8
{
	ECB_No                                   = 0,
	ECB_Yes                                  = 1,
	ECB_Owner                                = 2,
	ECB_MAX                                  = 3,
};

// Enum Engine.EBoneSpaces
// NumValues: 0x0003
enum class EBoneSpaces : uint8
{
	WorldSpace                               = 0,
	ComponentSpace                           = 1,
	EBoneSpaces_MAX                          = 2,
};

// Enum Engine.EMeshComponentUpdateFlag
// NumValues: 0x0004
enum class EMeshComponentUpdateFlag : uint8
{
	AlwaysTickPoseAndRefreshBones            = 0,
	AlwaysTickPose                           = 1,
	OnlyTickPoseWhenRendered                 = 2,
	EMeshComponentUpdateFlag_MAX             = 3,
};

// Enum Engine.EPhysBodyOp
// NumValues: 0x0004
enum class EPhysBodyOp : uint8
{
	PBO_None                                 = 0,
	PBO_Term                                 = 1,
	PBO_Disable                              = 2,
	PBO_MAX                                  = 3,
};

// Enum Engine.EBoneVisibilityStatus
// NumValues: 0x0004
enum class EBoneVisibilityStatus : uint8
{
	BVS_HiddenByParent                       = 0,
	BVS_Visible                              = 1,
	BVS_ExplicitlyHidden                     = 2,
	BVS_MAX                                  = 3,
};

// Enum Engine.EAngularDriveMode
// NumValues: 0x0003
enum class EAngularDriveMode : uint8
{
	SLERP                                    = 0,
	TwistAndSwing                            = 1,
	EAngularDriveMode_MAX                    = 2,
};

// Enum Engine.EConstraintFrame
// NumValues: 0x0003
enum class EConstraintFrame : uint8
{
	Frame1                                   = 0,
	Frame2                                   = 1,
	EConstraintFrame_MAX                     = 2,
};

// Enum Engine.ELinearConstraintMotion
// NumValues: 0x0004
enum class ELinearConstraintMotion : uint8
{
	LCM_Free                                 = 0,
	LCM_Limited                              = 1,
	LCM_Locked                               = 2,
	LCM_MAX                                  = 3,
};

// Enum Engine.EAnimLinkMethod
// NumValues: 0x0004
enum class EAnimLinkMethod : uint8
{
	Absolute                                 = 0,
	Relative                                 = 1,
	Proportional                             = 2,
	EAnimLinkMethod_MAX                      = 3,
};

// Enum Engine.ECurveBlendOption
// NumValues: 0x0004
enum class ECurveBlendOption : uint8
{
	MaxWeight                                = 0,
	NormalizeByWeight                        = 1,
	BlendByWeight                            = 2,
	ECurveBlendOption_MAX                    = 3,
};

// Enum Engine.EAdditiveAnimationType
// NumValues: 0x0004
enum class EAdditiveAnimationType : uint8
{
	AAT_None                                 = 0,
	AAT_LocalSpaceBase                       = 1,
	AAT_RotationOffsetMeshSpace              = 2,
	AAT_MAX                                  = 3,
};

// Enum Engine.ENotifyFilterType
// NumValues: 0x0003
enum class ENotifyFilterType : uint8
{
	NoFiltering                              = 0,
	LOD                                      = 1,
	ENotifyFilterType_MAX                    = 2,
};

// Enum Engine.EMontageNotifyTickType
// NumValues: 0x0003
enum class EMontageNotifyTickType : uint8
{
	Queued                                   = 0,
	BranchingPoint                           = 1,
	EMontageNotifyTickType_MAX               = 2,
};

// Enum Engine.EAnimationMode
// NumValues: 0x0003
enum class EAnimationMode : uint8
{
	AnimationBlueprint                       = 0,
	AnimationSingleNode                      = 1,
	EAnimationMode_MAX                       = 2,
};

// Enum Engine.EKinematicBonesUpdateToPhysics
// NumValues: 0x0003
enum class EKinematicBonesUpdateToPhysics : uint8
{
	SkipSimulatingBones                      = 0,
	SkipAllBones                             = 1,
	EKinematicBonesUpdateToPhysics_MAX       = 2,
};

// Enum Engine.ESplineCoordinateSpace
// NumValues: 0x0003
enum class ESplineCoordinateSpace : uint8
{
	Local                                    = 0,
	World                                    = 1,
	ESplineCoordinateSpace_MAX               = 2,
};

// Enum Engine.ESplinePointType
// NumValues: 0x0006
enum class ESplinePointType : uint8
{
	Linear                                   = 0,
	Curve                                    = 1,
	Constant                                 = 2,
	CurveClamped                             = 3,
	CurveCustomTangent                       = 4,
	ESplinePointType_MAX                     = 5,
};

// Enum Engine.FNavigationSystemRunMode
// NumValues: 0x0006
enum class EFNavigationSystemRunMode : uint8
{
	InvalidMode                              = 0,
	GameMode                                 = 1,
	EditorMode                               = 2,
	SimulationMode                           = 3,
	PIEMode                                  = 4,
	FNavigationSystemRunMode_MAX             = 5,
};

// Enum Engine.EVehicleDifferential4W
// NumValues: 0x0007
enum class EVehicleDifferential4W : uint8
{
	LimitedSlip_4W                           = 0,
	LimitedSlip_FrontDrive                   = 1,
	LimitedSlip_RearDrive                    = 2,
	Open_4W                                  = 3,
	Open_FrontDrive                          = 4,
	Open_RearDrive                           = 5,
	EVehicleDifferential4W_MAX               = 6,
};

// Enum Engine.ESoundSpatializationAlgorithm
// NumValues: 0x0003
enum class ESoundSpatializationAlgorithm : uint8
{
	SPATIALIZATION_Default                   = 0,
	SPATIALIZATION_HRTF                      = 1,
	SPATIALIZATION_MAX                       = 2,
};

// Enum Engine.EAttenuationShape
// NumValues: 0x0005
enum class EAttenuationShape : uint8
{
	Sphere                                   = 0,
	Capsule                                  = 1,
	Box                                      = 2,
	Cone                                     = 3,
	EAttenuationShape_MAX                    = 4,
};

// Enum Engine.ESoundDistanceCalc
// NumValues: 0x0005
enum class ESoundDistanceCalc : uint8
{
	SOUNDDISTANCE_Normal                     = 0,
	SOUNDDISTANCE_InfiniteXYPlane            = 1,
	SOUNDDISTANCE_InfiniteXZPlane            = 2,
	SOUNDDISTANCE_InfiniteYZPlane            = 3,
	SOUNDDISTANCE_MAX                        = 4,
};

// Enum Engine.ESoundDistanceModel
// NumValues: 0x0007
enum class ESoundDistanceModel : uint8
{
	ATTENUATION_Linear                       = 0,
	ATTENUATION_Logarithmic                  = 1,
	ATTENUATION_Inverse                      = 2,
	ATTENUATION_LogReverse                   = 3,
	ATTENUATION_NaturalSound                 = 4,
	ATTENUATION_Custom                       = 5,
	ATTENUATION_MAX                          = 6,
};

// Enum Engine.ESkyLightSourceType
// NumValues: 0x0003
enum class ESkyLightSourceType : uint8
{
	SLS_CapturedScene                        = 0,
	SLS_SpecifiedCubemap                     = 1,
	SLS_MAX                                  = 2,
};

// Enum Engine.ESplineMeshAxis
// NumValues: 0x0004
enum class ESplineMeshAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	ESplineMeshAxis_MAX                      = 3,
};

// Enum Engine.EMaterialUsage
// NumValues: 0x000B
enum class EMaterialUsage : uint8
{
	MATUSAGE_SkeletalMesh                    = 0,
	MATUSAGE_ParticleSprites                 = 1,
	MATUSAGE_BeamTrails                      = 2,
	MATUSAGE_MeshParticles                   = 3,
	MATUSAGE_StaticLighting                  = 4,
	MATUSAGE_MorphTargets                    = 5,
	MATUSAGE_SplineMesh                      = 6,
	MATUSAGE_Landscape                       = 7,
	MATUSAGE_InstancedStaticMeshes           = 8,
	MATUSAGE_Clothing                        = 9,
	MATUSAGE_MAX                             = 10,
};

// Enum Engine.EParticleSystemOcclusionBoundsMethod
// NumValues: 0x0004
enum class EParticleSystemOcclusionBoundsMethod : uint8
{
	EPSOBM_None                              = 0,
	EPSOBM_ParticleBounds                    = 1,
	EPSOBM_CustomBounds                      = 2,
	EPSOBM_MAX                               = 3,
};

// Enum Engine.ParticleSystemLODMethod
// NumValues: 0x0004
enum class EParticleSystemLODMethod : uint8
{
	PARTICLESYSTEMLODMETHOD_Automatic        = 0,
	PARTICLESYSTEMLODMETHOD_DirectSet        = 1,
	PARTICLESYSTEMLODMETHOD_ActivateAutomatic = 2,
	PARTICLESYSTEMLODMETHOD_MAX              = 3,
};

// Enum Engine.EParticleSystemUpdateMode
// NumValues: 0x0003
enum class EParticleSystemUpdateMode : uint8
{
	EPSUM_RealTime                           = 0,
	EPSUM_FixedTime                          = 1,
	EPSUM_MAX                                = 2,
};

// Enum Engine.EParticleEventType
// NumValues: 0x0007
enum class EParticleEventType : uint8
{
	EPET_Any                                 = 0,
	EPET_Spawn                               = 1,
	EPET_Death                               = 2,
	EPET_Collision                           = 3,
	EPET_Burst                               = 4,
	EPET_Blueprint                           = 5,
	EPET_MAX                                 = 6,
};

// Enum Engine.ParticleReplayState
// NumValues: 0x0004
enum class EParticleReplayState : uint8
{
	PRS_Disabled                             = 0,
	PRS_Capturing                            = 1,
	PRS_Replaying                            = 2,
	PRS_MAX                                  = 3,
};

// Enum Engine.EParticleSysParamType
// NumValues: 0x0009
enum class EParticleSysParamType : uint8
{
	PSPT_None                                = 0,
	PSPT_Scalar                              = 1,
	PSPT_ScalarRand                          = 2,
	PSPT_Vector                              = 3,
	PSPT_VectorRand                          = 4,
	PSPT_Color                               = 5,
	PSPT_Actor                               = 6,
	PSPT_Material                            = 7,
	PSPT_MAX                                 = 8,
};

// Enum Engine.EVerticalTextAligment
// NumValues: 0x0005
enum class EVerticalTextAligment : uint8
{
	EVRTA_TextTop                            = 0,
	EVRTA_TextCenter                         = 1,
	EVRTA_TextBottom                         = 2,
	EVRTA_QuadTop                            = 3,
	EVRTA_MAX                                = 4,
};

// Enum Engine.EHorizTextAligment
// NumValues: 0x0004
enum class EHorizTextAligment : uint8
{
	EHTA_Left                                = 0,
	EHTA_Center                              = 1,
	EHTA_Right                               = 2,
	EHTA_MAX                                 = 3,
};

// Enum Engine.ESceneCaptureSource
// NumValues: 0x0003
enum class ESceneCaptureSource : uint8
{
	SCS_SceneColorHDR                        = 0,
	SCS_FinalColorLDR                        = 1,
	SCS_MAX                                  = 2,
};

// Enum Engine.ETimelineDirection
// NumValues: 0x0003
enum class ETimelineDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	ETimelineDirection_MAX                   = 2,
};

// Enum Engine.ETimelineLengthMode
// NumValues: 0x0003
enum class ETimelineLengthMode : uint8
{
	TL_TimelineLength                        = 0,
	TL_LastKeyFrame                          = 1,
	TL_MAX                                   = 2,
};

// Enum Engine.ETypeAdvanceAnim
// NumValues: 0x0004
enum class ETypeAdvanceAnim : uint8
{
	ETAA_Default                             = 0,
	ETAA_Finished                            = 1,
	ETAA_Looped                              = 2,
	ETAA_MAX                                 = 3,
};

// Enum Engine.EAlphaBlendOption
// NumValues: 0x0010
enum class EAlphaBlendOption : uint8
{
	Linear                                   = 0,
	Cubic                                    = 1,
	HermiteCubic                             = 2,
	Sinusoidal                               = 3,
	QuadraticInOut                           = 4,
	CubicInOut                               = 5,
	QuarticInOut                             = 6,
	QuinticInOut                             = 7,
	CircularIn                               = 8,
	CircularOut                              = 9,
	CircularInOut                            = 10,
	ExpIn                                    = 11,
	ExpOut                                   = 12,
	ExpInOut                                 = 13,
	Custom                                   = 14,
	EAlphaBlendOption_MAX                    = 15,
};

// Enum Engine.ETransitionLogicType
// NumValues: 0x0003
enum class ETransitionLogicType : uint8
{
	TLT_StandardBlend                        = 0,
	TLT_Custom                               = 1,
	TLT_MAX                                  = 2,
};

// Enum Engine.ETransitionBlendMode
// NumValues: 0x0003
enum class ETransitionBlendMode : uint8
{
	TBM_Linear                               = 0,
	TBM_Cubic                                = 1,
	TBM_MAX                                  = 2,
};

// Enum Engine.EBoneRotationSource
// NumValues: 0x0004
enum class EBoneRotationSource : uint8
{
	BRS_KeepComponentSpaceRotation           = 0,
	BRS_KeepLocalSpaceRotation               = 1,
	BRS_CopyFromTarget                       = 2,
	BRS_MAX                                  = 3,
};

// Enum Engine.EBoneControlSpace
// NumValues: 0x0005
enum class EBoneControlSpace : uint8
{
	BCS_WorldSpace                           = 0,
	BCS_ComponentSpace                       = 1,
	BCS_ParentBoneSpace                      = 2,
	BCS_BoneSpace                            = 3,
	BCS_MAX                                  = 4,
};

// Enum Engine.EAnimNotifyEventType
// NumValues: 0x0003
enum class EAnimNotifyEventType : uint8
{
	Begin                                    = 0,
	End                                      = 1,
	EAnimNotifyEventType_MAX                 = 2,
};

// Enum Engine.EAdditiveBasePoseType
// NumValues: 0x0005
enum class EAdditiveBasePoseType : uint8
{
	ABPT_None                                = 0,
	ABPT_RefPose                             = 1,
	ABPT_AnimScaled                          = 2,
	ABPT_AnimFrame                           = 3,
	ABPT_MAX                                 = 4,
};

// Enum Engine.AnimationKeyFormat
// NumValues: 0x0004
enum class EAnimationKeyFormat : uint8
{
	AKF_ConstantKeyLerp                      = 0,
	AKF_VariableKeyLerp                      = 1,
	AKF_PerTrackCompression                  = 2,
	AKF_MAX                                  = 3,
};

// Enum Engine.AnimationCompressionFormat
// NumValues: 0x0008
enum class EAnimationCompressionFormat : uint8
{
	ACF_None                                 = 0,
	ACF_Float96NoW                           = 1,
	ACF_Fixed48NoW                           = 2,
	ACF_IntervalFixed32NoW                   = 3,
	ACF_Fixed32NoW                           = 4,
	ACF_Float32NoW                           = 5,
	ACF_Identity                             = 6,
	ACF_MAX                                  = 7,
};

// Enum Engine.ENotifyTriggerMode
// NumValues: 0x0004
enum class ENotifyTriggerMode : uint8
{
	AllAnimations                            = 0,
	HighestWeightedAnimation                 = 1,
	None                                     = 2,
	ENotifyTriggerMode_MAX                   = 3,
};

// Enum Engine.EBlendSpaceAxis
// NumValues: 0x0004
enum class EBlendSpaceAxis : uint8
{
	BSA_None                                 = 0,
	BSA_X                                    = 1,
	BSA_Y                                    = 2,
	BSA_Max                                  = 3,
};

// Enum Engine.EEvaluateCurveTableResult
// NumValues: 0x0003
enum class EEvaluateCurveTableResult : uint8
{
	RowFound                                 = 0,
	RowNotFound                              = 1,
	EEvaluateCurveTableResult_MAX            = 2,
};

// Enum Engine.EGrammaticalNumber
// NumValues: 0x0003
enum class EGrammaticalNumber : uint8
{
	Singular                                 = 0,
	Plural                                   = 1,
	EGrammaticalNumber_MAX                   = 2,
};

// Enum Engine.EGrammaticalGender
// NumValues: 0x0005
enum class EGrammaticalGender : uint8
{
	Neuter                                   = 0,
	Masculine                                = 1,
	Feminine                                 = 2,
	Mixed                                    = 3,
	EGrammaticalGender_MAX                   = 4,
};

// Enum Engine.ESuggestProjVelocityTraceOption
// NumValues: 0x0004
enum class ESuggestProjVelocityTraceOption : uint8
{
	DoNotTrace                               = 0,
	TraceFullPath                            = 1,
	OnlyTraceWhileAsceding                   = 2,
	ESuggestProjVelocityTraceOption_MAX      = 3,
};

// Enum Engine.EOrientPositionSelector
// NumValues: 0x0004
enum class EOrientPositionSelector : uint8
{
	Orientation                              = 0,
	Position                                 = 1,
	OrientationAndPosition                   = 2,
	EOrientPositionSelector_MAX              = 3,
};

// Enum Engine.EEasingFunc
// NumValues: 0x000F
enum class EEasingFunc : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	SinusoidalIn                             = 2,
	SinusoidalOut                            = 3,
	SinusoidalInOut                          = 4,
	EaseIn                                   = 5,
	EaseOut                                  = 6,
	EaseInOut                                = 7,
	ExpoIn                                   = 8,
	ExpoOut                                  = 9,
	ExpoInOut                                = 10,
	CircularIn                               = 11,
	CircularOut                              = 12,
	CircularInOut                            = 13,
	EEasingFunc_MAX                          = 14,
};

// Enum Engine.ERoundingMode
// NumValues: 0x0008
enum class ERoundingMode : uint8
{
	HalfToEven                               = 0,
	HalfFromZero                             = 1,
	HalfToZero                               = 2,
	FromZero                                 = 3,
	ToZero                                   = 4,
	ToNegativeInfinity                       = 5,
	ToPositiveInfinity                       = 6,
	ERoundingMode_MAX                        = 7,
};

// Enum Engine.EVertexPaintAxis
// NumValues: 0x0004
enum class EVertexPaintAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	EVertexPaintAxis_MAX                     = 3,
};

// Enum Engine.EBodyCollisionResponse
// NumValues: 0x0003
enum class EBodyCollisionResponse : uint8
{
	BodyCollision_Enabled                    = 0,
	BodyCollision_Disabled                   = 1,
	BodyCollision_MAX                        = 2,
};

// Enum Engine.EPhysicsType
// NumValues: 0x0004
enum class EPhysicsType : uint8
{
	PhysType_Default                         = 0,
	PhysType_Kinematic                       = 1,
	PhysType_Simulated                       = 2,
	PhysType_MAX                             = 3,
};

// Enum Engine.ECollisionTraceFlag
// NumValues: 0x0004
enum class ECollisionTraceFlag : uint8
{
	CTF_UseDefault                           = 0,
	CTF_UseSimpleAsComplex                   = 1,
	CTF_UseComplexAsSimple                   = 2,
	CTF_MAX                                  = 3,
};

// Enum Engine.EConsoleType
// NumValues: 0x0003
enum class EConsoleType : uint8
{
	CONSOLE_Any                              = 0,
	CONSOLE_Mobile                           = 1,
	CONSOLE_MAX                              = 2,
};

// Enum Engine.ETransitionType
// NumValues: 0x0008
enum class ETransitionType : uint8
{
	TT_None                                  = 0,
	TT_Paused                                = 1,
	TT_Loading                               = 2,
	TT_Saving                                = 3,
	TT_Connecting                            = 4,
	TT_Precaching                            = 5,
	TT_WaitingToConnect                      = 6,
	TT_MAX                                   = 7,
};

// Enum Engine.EFullyLoadPackageType
// NumValues: 0x0006
enum class EFullyLoadPackageType : uint8
{
	FULLYLOAD_Map                            = 0,
	FULLYLOAD_Game_PreLoadClass              = 1,
	FULLYLOAD_Game_PostLoadClass             = 2,
	FULLYLOAD_Always                         = 3,
	FULLYLOAD_Mutator                        = 4,
	FULLYLOAD_MAX                            = 5,
};

// Enum Engine.EUIScalingRule
// NumValues: 0x0006
enum class EUIScalingRule : uint8
{
	ShortestSide                             = 0,
	LongestSide                              = 1,
	Horizontal                               = 2,
	Vertical                                 = 3,
	Custom                                   = 4,
	EUIScalingRule_MAX                       = 5,
};

// Enum Engine.ERenderFocusRule
// NumValues: 0x0005
enum class ERenderFocusRule : uint8
{
	Always                                   = 0,
	NonPointer                               = 1,
	NavigationOnly                           = 2,
	Never                                    = 3,
	ERenderFocusRule_MAX                     = 4,
};

// Enum Engine.EFrictionCombineMode
// NumValues: 0x0005
enum class EFrictionCombineMode : uint8
{
	Average                                  = 0,
	Min                                      = 1,
	Multiply                                 = 2,
	Max                                      = 3,
	EFrictionCombineMode_MAX                 = 4,
};

// Enum Engine.ESettingsLockedAxis
// NumValues: 0x0006
enum class ESettingsLockedAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	Invalid                                  = 4,
	ESettingsLockedAxis_MAX                  = 5,
};

// Enum Engine.ESettingsDOF
// NumValues: 0x0005
enum class ESettingsDOF : uint8
{
	Full3D                                   = 0,
	YZPlane                                  = 1,
	XZPlane                                  = 2,
	XYPlane                                  = 3,
	ESettingsDOF_MAX                         = 4,
};

// Enum Engine.EAntiAliasingMethodUI
// NumValues: 0x0004
enum class EAntiAliasingMethodUI : uint8
{
	AAM_None                                 = 0,
	AAM_FXAA                                 = 1,
	AAM_TemporalAA                           = 2,
	AAM_MAX                                  = 3,
};

// Enum Engine.EEarlyZPass
// NumValues: 0x0005
enum class EEarlyZPass : uint8
{
	None                                     = 0,
	OpaqueOnly                               = 1,
	OpaqueAndMasked                          = 2,
	Auto                                     = 3,
	EEarlyZPass_MAX                          = 4,
};

// Enum Engine.ECustomDepthStencil
// NumValues: 0x0005
enum class ECustomDepthStencil : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EnabledOnDemand                          = 2,
	EnabledWithStencil                       = 3,
	ECustomDepthStencil_MAX                  = 4,
};

// Enum Engine.ECompositingSampleCount
// NumValues: 0x0005
enum class ECompositingSampleCount : uint8
{
	One                                      = 1,
	Two                                      = 2,
	Four                                     = 4,
	Eight                                    = 8,
	ECompositingSampleCount_MAX              = 9,
};

// Enum Engine.EClearSceneOptions
// NumValues: 0x0004
enum class EClearSceneOptions : uint8
{
	NoClear                                  = 0,
	HardwareClear                            = 1,
	QuadAtMaxZ                               = 2,
	EClearSceneOptions_MAX                   = 3,
};

// Enum Engine.ETextureSamplerFilter
// NumValues: 0x0006
enum class ETextureSamplerFilter : uint8
{
	Point                                    = 0,
	Bilinear                                 = 1,
	Trilinear                                = 2,
	AnisotropicPoint                         = 3,
	AnisotropicLinear                        = 4,
	ETextureSamplerFilter_MAX                = 5,
};

// Enum Engine.ETexturePowerOfTwoSetting
// NumValues: 0x0004
enum class ETexturePowerOfTwoSetting : uint8
{
	None                                     = 0,
	PadToPowerOfTwo                          = 1,
	PadToSquarePowerOfTwo                    = 2,
	ETexturePowerOfTwoSetting_MAX            = 3,
};

// Enum Engine.TextureMipGenSettings
// NumValues: 0x0015
enum class ETextureMipGenSettings : uint8
{
	TMGS_FromTextureGroup                    = 0,
	TMGS_SimpleAverage                       = 1,
	TMGS_Sharpen0                            = 2,
	TMGS_Sharpen1                            = 3,
	TMGS_Sharpen2                            = 4,
	TMGS_Sharpen3                            = 5,
	TMGS_Sharpen4                            = 6,
	TMGS_Sharpen5                            = 7,
	TMGS_Sharpen6                            = 8,
	TMGS_Sharpen7                            = 9,
	TMGS_Sharpen8                            = 10,
	TMGS_Sharpen9                            = 11,
	TMGS_Sharpen10                           = 12,
	TMGS_NoMipmaps                           = 13,
	TMGS_LeaveExistingMips                   = 14,
	TMGS_Blur1                               = 15,
	TMGS_Blur2                               = 16,
	TMGS_Blur3                               = 17,
	TMGS_Blur4                               = 18,
	TMGS_Blur5                               = 19,
	TMGS_MAX                                 = 20,
};

// Enum Engine.TextureGroup
// NumValues: 0x001E
enum class ETextureGroup : uint8
{
	TEXTUREGROUP_World                       = 0,
	TEXTUREGROUP_WorldNormalMap              = 1,
	TEXTUREGROUP_WorldSpecular               = 2,
	TEXTUREGROUP_Character                   = 3,
	TEXTUREGROUP_CharacterNormalMap          = 4,
	TEXTUREGROUP_CharacterSpecular           = 5,
	TEXTUREGROUP_Weapon                      = 6,
	TEXTUREGROUP_WeaponNormalMap             = 7,
	TEXTUREGROUP_WeaponSpecular              = 8,
	TEXTUREGROUP_Vehicle                     = 9,
	TEXTUREGROUP_VehicleNormalMap            = 10,
	TEXTUREGROUP_VehicleSpecular             = 11,
	TEXTUREGROUP_Cinematic                   = 12,
	TEXTUREGROUP_Effects                     = 13,
	TEXTUREGROUP_EffectsNotFiltered          = 14,
	TEXTUREGROUP_Skybox                      = 15,
	TEXTUREGROUP_UI                          = 16,
	TEXTUREGROUP_Lightmap                    = 17,
	TEXTUREGROUP_RenderTarget                = 18,
	TEXTUREGROUP_MobileFlattened             = 19,
	TEXTUREGROUP_ProcBuilding_Face           = 20,
	TEXTUREGROUP_ProcBuilding_LightMap       = 21,
	TEXTUREGROUP_Shadowmap                   = 22,
	TEXTUREGROUP_ColorLookupTable            = 23,
	TEXTUREGROUP_Terrain_Heightmap           = 24,
	TEXTUREGROUP_Terrain_Weightmap           = 25,
	TEXTUREGROUP_Bokeh                       = 26,
	TEXTUREGROUP_IESLightProfile             = 27,
	TEXTUREGROUP_Pixels2D                    = 28,
	TEXTUREGROUP_MAX                         = 29,
};

// Enum Engine.DistributionParamMode
// NumValues: 0x0004
enum class EDistributionParamMode : uint8
{
	DPM_Normal                               = 0,
	DPM_Abs                                  = 1,
	DPM_Direct                               = 2,
	DPM_MAX                                  = 3,
};

// Enum Engine.EDistributionVectorMirrorFlags
// NumValues: 0x0004
enum class EDistributionVectorMirrorFlags : uint8
{
	EDVMF_Same                               = 0,
	EDVMF_Different                          = 1,
	EDVMF_Mirror                             = 2,
	EDVMF_MAX                                = 3,
};

// Enum Engine.EDistributionVectorLockFlags
// NumValues: 0x0006
enum class EDistributionVectorLockFlags : uint8
{
	EDVLF_None                               = 0,
	EDVLF_XY                                 = 1,
	EDVLF_XZ                                 = 2,
	EDVLF_YZ                                 = 3,
	EDVLF_XYZ                                = 4,
	EDVLF_MAX                                = 5,
};

// Enum Engine.ECanCreateConnectionResponse
// NumValues: 0x0007
enum class ECanCreateConnectionResponse : uint8
{
	CONNECT_RESPONSE_MAKE                    = 0,
	CONNECT_RESPONSE_DISALLOW                = 1,
	CONNECT_RESPONSE_BREAK_OTHERS_A          = 2,
	CONNECT_RESPONSE_BREAK_OTHERS_B          = 3,
	CONNECT_RESPONSE_BREAK_OTHERS_AB         = 4,
	CONNECT_RESPONSE_MAKE_WITH_CONVERSION_NODE = 5,
	CONNECT_RESPONSE_MAX                     = 6,
};

// Enum Engine.EGraphType
// NumValues: 0x0006
enum class EGraphType : uint8
{
	GT_Function                              = 0,
	GT_Ubergraph                             = 1,
	GT_Macro                                 = 2,
	GT_Animation                             = 3,
	GT_StateMachine                          = 4,
	GT_MAX                                   = 5,
};

// Enum Engine.EFontImportCharacterSet
// NumValues: 0x0004
enum class EFontImportCharacterSet : uint8
{
	FontICS_Default                          = 0,
	FontICS_Ansi                             = 1,
	FontICS_Symbol                           = 2,
	FontICS_MAX                              = 3,
};

// Enum Engine.EFontCacheType
// NumValues: 0x0003
enum class EFontCacheType : uint8
{
	Offline                                  = 0,
	Runtime                                  = 1,
	EFontCacheType_MAX                       = 2,
};

// Enum Engine.EGameplayDebuggerShapeElement
// NumValues: 0x000A
enum class EGameplayDebuggerShapeElement : uint8
{
	Invalid                                  = 0,
	SinglePoint                              = 1,
	Segment                                  = 2,
	Box                                      = 3,
	Cone                                     = 4,
	Cylinder                                 = 5,
	Capsule                                  = 6,
	Polygon                                  = 7,
	String                                   = 8,
	EGameplayDebuggerShapeElement_MAX        = 9,
};

// Enum Engine.EWindowMode
// NumValues: 0x0005
enum class EWindowMode : uint8
{
	Fullscreen                               = 0,
	WindowedFullscreen                       = 1,
	Windowed                                 = 2,
	WindowedMirror                           = 3,
	EWindowMode_MAX                          = 4,
};

// Enum Engine.ETrackActiveCondition
// NumValues: 0x0004
enum class ETrackActiveCondition : uint8
{
	ETAC_Always                              = 0,
	ETAC_GoreEnabled                         = 1,
	ETAC_GoreDisabled                        = 2,
	ETAC_MAX                                 = 3,
};

// Enum Engine.EInterpTrackMoveRotMode
// NumValues: 0x0004
enum class EInterpTrackMoveRotMode : uint8
{
	IMR_Keyframed                            = 0,
	IMR_LookAtGroup                          = 1,
	IMR_Ignore                               = 2,
	IMR_MAX                                  = 3,
};

// Enum Engine.EInterpMoveAxis
// NumValues: 0x0007
enum class EInterpMoveAxis : uint8
{
	AXIS_TranslationX                        = 0,
	AXIS_TranslationY                        = 1,
	AXIS_TranslationZ                        = 2,
	AXIS_RotationX                           = 3,
	AXIS_RotationY                           = 4,
	AXIS_RotationZ                           = 5,
	AXIS_MAX                                 = 6,
};

// Enum Engine.ETrackToggleAction
// NumValues: 0x0005
enum class ETrackToggleAction : uint8
{
	ETTA_Off                                 = 0,
	ETTA_On                                  = 1,
	ETTA_Toggle                              = 2,
	ETTA_Trigger                             = 3,
	ETTA_MAX                                 = 4,
};

// Enum Engine.EVisibilityTrackCondition
// NumValues: 0x0004
enum class EVisibilityTrackCondition : uint8
{
	EVTC_Always                              = 0,
	EVTC_GoreEnabled                         = 1,
	EVTC_GoreDisabled                        = 2,
	EVTC_MAX                                 = 3,
};

// Enum Engine.EVisibilityTrackAction
// NumValues: 0x0004
enum class EVisibilityTrackAction : uint8
{
	EVTA_Hide                                = 0,
	EVTA_Show                                = 1,
	EVTA_Toggle                              = 2,
	EVTA_MAX                                 = 3,
};

// Enum Engine.EClampMode
// NumValues: 0x0004
enum class EClampMode : uint8
{
	CMODE_Clamp                              = 0,
	CMODE_ClampMin                           = 1,
	CMODE_ClampMax                           = 2,
	CMODE_MAX                                = 3,
};

// Enum Engine.ECustomMaterialOutputType
// NumValues: 0x0005
enum class ECustomMaterialOutputType : uint8
{
	CMOT_Float1                              = 0,
	CMOT_Float2                              = 1,
	CMOT_Float3                              = 2,
	CMOT_Float4                              = 3,
	CMOT_MAX                                 = 4,
};

// Enum Engine.EDepthOfFieldFunctionValue
// NumValues: 0x0005
enum class EDepthOfFieldFunctionValue : uint8
{
	TDOF_NearAndFarMask                      = 0,
	TDOF_NearMask                            = 1,
	TDOF_FarMask                             = 2,
	TDOF_CircleOfConfusionRadius             = 3,
	TDOF_MAX                                 = 4,
};

// Enum Engine.EFunctionInputType
// NumValues: 0x0009
enum class EFunctionInputType : uint8
{
	FunctionInput_Scalar                     = 0,
	FunctionInput_Vector2                    = 1,
	FunctionInput_Vector3                    = 2,
	FunctionInput_Vector4                    = 3,
	FunctionInput_Texture2D                  = 4,
	FunctionInput_TextureCube                = 5,
	FunctionInput_StaticBool                 = 6,
	FunctionInput_MaterialAttributes         = 7,
	FunctionInput_MAX                        = 8,
};

// Enum Engine.ENoiseFunction
// NumValues: 0x0005
enum class ENoiseFunction : uint8
{
	NOISEFUNCTION_Simplex                    = 0,
	NOISEFUNCTION_Perlin                     = 1,
	NOISEFUNCTION_Gradient                   = 2,
	NOISEFUNCTION_FastGradient               = 3,
	NOISEFUNCTION_MAX                        = 4,
};

// Enum Engine.EMaterialSceneAttributeInputMode
// NumValues: 0x0003
enum class EMaterialSceneAttributeInputMode : uint8
{
	Coordinates                              = 0,
	OffsetFraction                           = 1,
	EMaterialSceneAttributeInputMode_MAX     = 2,
};

// Enum Engine.ESceneTextureId
// NumValues: 0x001C
enum class ESceneTextureId : uint8
{
	PPI_SceneColor                           = 0,
	PPI_SceneDepth                           = 1,
	PPI_DiffuseColor                         = 2,
	PPI_SpecularColor                        = 3,
	PPI_SubsurfaceColor                      = 4,
	PPI_BaseColor                            = 5,
	PPI_Specular                             = 6,
	PPI_Metallic                             = 7,
	PPI_WorldNormal                          = 8,
	PPI_SeparateTranslucency                 = 9,
	PPI_Opacity                              = 10,
	PPI_Roughness                            = 11,
	PPI_MaterialAO                           = 12,
	PPI_CustomDepth                          = 13,
	PPI_PostProcessInput0                    = 14,
	PPI_PostProcessInput1                    = 15,
	PPI_PostProcessInput2                    = 16,
	PPI_PostProcessInput3                    = 17,
	PPI_PostProcessInput4                    = 18,
	PPI_PostProcessInput5                    = 19,
	PPI_PostProcessInput6                    = 20,
	PPI_DecalMask                            = 21,
	PPI_ShadingModel                         = 22,
	PPI_AmbientOcclusion                     = 23,
	PPI_CustomStencil                        = 24,
	PPI_StoredBaseColor                      = 25,
	PPI_StoredSpecular                       = 26,
	PPI_MAX                                  = 27,
};

// Enum Engine.ESpeedTreeLODType
// NumValues: 0x0003
enum class ESpeedTreeLODType : uint8
{
	STLOD_Pop                                = 0,
	STLOD_Smooth                             = 1,
	STLOD_MAX                                = 2,
};

// Enum Engine.ESpeedTreeWindType
// NumValues: 0x0008
enum class ESpeedTreeWindType : uint8
{
	STW_None                                 = 0,
	STW_Fastest                              = 1,
	STW_Fast                                 = 2,
	STW_Better                               = 3,
	STW_Best                                 = 4,
	STW_Palm                                 = 5,
	STW_BestPlus                             = 6,
	STW_MAX                                  = 7,
};

// Enum Engine.ESpeedTreeGeometryType
// NumValues: 0x0006
enum class ESpeedTreeGeometryType : uint8
{
	STG_Branch                               = 0,
	STG_Frond                                = 1,
	STG_Leaf                                 = 2,
	STG_FacingLeaf                           = 3,
	STG_Billboard                            = 4,
	STG_MAX                                  = 5,
};

// Enum Engine.ETextureMipValueMode
// NumValues: 0x0005
enum class ETextureMipValueMode : uint8
{
	TMVM_None                                = 0,
	TMVM_MipLevel                            = 1,
	TMVM_MipBias                             = 2,
	TMVM_Derivative                          = 3,
	TMVM_MAX                                 = 4,
};

// Enum Engine.ETextureColorChannel
// NumValues: 0x0005
enum class ETextureColorChannel : uint8
{
	TCC_Red                                  = 0,
	TCC_Green                                = 1,
	TCC_Blue                                 = 2,
	TCC_Alpha                                = 3,
	TCC_MAX                                  = 4,
};

// Enum Engine.EMaterialExposedTextureProperty
// NumValues: 0x0003
enum class EMaterialExposedTextureProperty : uint8
{
	TMTM_TextureSize                         = 0,
	TMTM_TexelSize                           = 1,
	TMTM_MAX                                 = 2,
};

// Enum Engine.EMaterialVectorCoordTransform
// NumValues: 0x0006
enum class EMaterialVectorCoordTransform : uint8
{
	TRANSFORM_Tangent                        = 0,
	TRANSFORM_Local                          = 1,
	TRANSFORM_World                          = 2,
	TRANSFORM_View                           = 3,
	TRANSFORM_Camera                         = 4,
	TRANSFORM_MAX                            = 5,
};

// Enum Engine.EMaterialVectorCoordTransformSource
// NumValues: 0x0006
enum class EMaterialVectorCoordTransformSource : uint8
{
	TRANSFORMSOURCE_Tangent                  = 0,
	TRANSFORMSOURCE_Local                    = 1,
	TRANSFORMSOURCE_World                    = 2,
	TRANSFORMSOURCE_View                     = 3,
	TRANSFORMSOURCE_Camera                   = 4,
	TRANSFORMSOURCE_MAX                      = 5,
};

// Enum Engine.EMaterialPositionTransformSource
// NumValues: 0x0006
enum class EMaterialPositionTransformSource : uint8
{
	TRANSFORMPOSSOURCE_Local                 = 0,
	TRANSFORMPOSSOURCE_World                 = 1,
	TRANSFORMPOSSOURCE_TranslatedWorld       = 2,
	TRANSFORMPOSSOURCE_View                  = 3,
	TRANSFORMPOSSOURCE_Camera                = 4,
	TRANSFORMPOSSOURCE_MAX                   = 5,
};

// Enum Engine.EMaterialExposedViewProperty
// NumValues: 0x0007
enum class EMaterialExposedViewProperty : uint8
{
	MEVP_BufferSize                          = 0,
	MEVP_FieldOfView                         = 1,
	MEVP_TanHalfFieldOfView                  = 2,
	MEVP_ViewSize                            = 3,
	MEVP_WorldSpaceViewPosition              = 4,
	MEVP_WorldSpaceCameraPosition            = 5,
	MEVP_MAX                                 = 6,
};

// Enum Engine.EWorldPositionIncludedOffsets
// NumValues: 0x0005
enum class EWorldPositionIncludedOffsets : uint8
{
	WPT_Default                              = 0,
	WPT_ExcludeAllShaderOffsets              = 1,
	WPT_CameraRelative                       = 2,
	WPT_CameraRelativeNoOffsets              = 3,
	WPT_MAX                                  = 4,
};

// Enum Engine.EMaterialDecalResponse
// NumValues: 0x0009
enum class EMaterialDecalResponse : uint8
{
	MDR_None                                 = 0,
	MDR_ColorNormalRoughness                 = 1,
	MDR_Color                                = 2,
	MDR_ColorNormal                          = 3,
	MDR_ColorRoughness                       = 4,
	MDR_Normal                               = 5,
	MDR_NormalRoughness                      = 6,
	MDR_Roughness                            = 7,
	MDR_MAX                                  = 8,
};

// Enum Engine.EMaterialDomain
// NumValues: 0x0006
enum class EMaterialDomain : uint8
{
	MD_Surface                               = 0,
	MD_DeferredDecal                         = 1,
	MD_LightFunction                         = 2,
	MD_PostProcess                           = 3,
	MD_UI                                    = 4,
	MD_MAX                                   = 5,
};

// Enum Engine.EDecalBlendMode
// NumValues: 0x000D
enum class EDecalBlendMode : uint8
{
	DBM_Translucent                          = 0,
	DBM_Stain                                = 1,
	DBM_Normal                               = 2,
	DBM_Emissive                             = 3,
	DBM_DBuffer_ColorNormalRoughness         = 4,
	DBM_DBuffer_Color                        = 5,
	DBM_DBuffer_ColorNormal                  = 6,
	DBM_DBuffer_ColorRoughness               = 7,
	DBM_DBuffer_Normal                       = 8,
	DBM_DBuffer_NormalRoughness              = 9,
	DBM_DBuffer_Roughness                    = 10,
	DBM_Volumetric_DistanceFunction          = 11,
	DBM_MAX                                  = 12,
};

// Enum Engine.EEmitterRenderMode
// NumValues: 0x0006
enum class EEmitterRenderMode : uint8
{
	ERM_Normal                               = 0,
	ERM_Point                                = 1,
	ERM_Cross                                = 2,
	ERM_LightsOnly                           = 3,
	ERM_None                                 = 4,
	ERM_MAX                                  = 5,
};

// Enum Engine.EParticleSubUVInterpMethod
// NumValues: 0x0006
enum class EParticleSubUVInterpMethod : uint8
{
	PSUVIM_None                              = 0,
	PSUVIM_Linear                            = 1,
	PSUVIM_Linear_Blend                      = 2,
	PSUVIM_Random                            = 3,
	PSUVIM_Random_Blend                      = 4,
	PSUVIM_MAX                               = 5,
};

// Enum Engine.EParticleBurstMethod
// NumValues: 0x0003
enum class EParticleBurstMethod : uint8
{
	EPBM_Instant                             = 0,
	EPBM_Interpolated                        = 1,
	EPBM_MAX                                 = 2,
};

// Enum Engine.EParticleScreenAlignment
// NumValues: 0x0007
enum class EParticleScreenAlignment : uint8
{
	PSA_FacingCameraPosition                 = 0,
	PSA_Square                               = 1,
	PSA_Rectangle                            = 2,
	PSA_Velocity                             = 3,
	PSA_AwayFromCenter                       = 4,
	PSA_TypeSpecific                         = 5,
	PSA_MAX                                  = 6,
};

// Enum Engine.EParticleSourceSelectionMethod
// NumValues: 0x0003
enum class EParticleSourceSelectionMethod : uint8
{
	EPSSM_Random                             = 0,
	EPSSM_Sequential                         = 1,
	EPSSM_MAX                                = 2,
};

// Enum Engine.EModuleType
// NumValues: 0x0009
enum class EModuleType : uint8
{
	EPMT_General                             = 0,
	EPMT_TypeData                            = 1,
	EPMT_Beam                                = 2,
	EPMT_Trail                               = 3,
	EPMT_Spawn                               = 4,
	EPMT_Required                            = 5,
	EPMT_Event                               = 6,
	EPMT_Light                               = 7,
	EPMT_MAX                                 = 8,
};

// Enum Engine.EParticleAxisLock
// NumValues: 0x000B
enum class EParticleAxisLock : uint8
{
	EPAL_NONE                                = 0,
	EPAL_X                                   = 1,
	EPAL_Y                                   = 2,
	EPAL_Z                                   = 3,
	EPAL_NEGATIVE_X                          = 4,
	EPAL_NEGATIVE_Y                          = 5,
	EPAL_NEGATIVE_Z                          = 6,
	EPAL_ROTATE_X                            = 7,
	EPAL_ROTATE_Y                            = 8,
	EPAL_ROTATE_Z                            = 9,
	EPAL_MAX                                 = 10,
};

// Enum Engine.EAttractorParticleSelectionMethod
// NumValues: 0x0003
enum class EAttractorParticleSelectionMethod : uint8
{
	EAPSM_Random                             = 0,
	EAPSM_Sequential                         = 1,
	EAPSM_MAX                                = 2,
};

// Enum Engine.Beam2SourceTargetTangentMethod
// NumValues: 0x0005
enum class EBeam2SourceTargetTangentMethod : uint8
{
	PEB2STTM_Direct                          = 0,
	PEB2STTM_UserSet                         = 1,
	PEB2STTM_Distribution                    = 2,
	PEB2STTM_Emitter                         = 3,
	PEB2STTM_MAX                             = 4,
};

// Enum Engine.Beam2SourceTargetMethod
// NumValues: 0x0006
enum class EBeam2SourceTargetMethod : uint8
{
	PEB2STM_Default                          = 0,
	PEB2STM_UserSet                          = 1,
	PEB2STM_Emitter                          = 2,
	PEB2STM_Particle                         = 3,
	PEB2STM_Actor                            = 4,
	PEB2STM_MAX                              = 5,
};

// Enum Engine.BeamModifierType
// NumValues: 0x0003
enum class EBeamModifierType : uint8
{
	PEB2MT_Source                            = 0,
	PEB2MT_Target                            = 1,
	PEB2MT_MAX                               = 2,
};

// Enum Engine.EParticleCameraOffsetUpdateMethod
// NumValues: 0x0004
enum class EParticleCameraOffsetUpdateMethod : uint8
{
	EPCOUM_DirectSet                         = 0,
	EPCOUM_Additive                          = 1,
	EPCOUM_Scalar                            = 2,
	EPCOUM_MAX                               = 3,
};

// Enum Engine.EParticleCollisionComplete
// NumValues: 0x0007
enum class EParticleCollisionComplete : uint8
{
	EPCC_Kill                                = 0,
	EPCC_Freeze                              = 1,
	EPCC_HaltCollisions                      = 2,
	EPCC_FreezeTranslation                   = 3,
	EPCC_FreezeRotation                      = 4,
	EPCC_FreezeMovement                      = 5,
	EPCC_MAX                                 = 6,
};

// Enum Engine.EParticleCollisionResponse
// NumValues: 0x0004
enum class EParticleCollisionResponse : uint8
{
	Bounce                                   = 0,
	Stop                                     = 1,
	Kill                                     = 2,
	EParticleCollisionResponse_MAX           = 3,
};

// Enum Engine.ELocationBoneSocketSelectionMethod
// NumValues: 0x0003
enum class ELocationBoneSocketSelectionMethod : uint8
{
	BONESOCKETSEL_Sequential                 = 0,
	BONESOCKETSEL_Random                     = 1,
	BONESOCKETSEL_MAX                        = 2,
};

// Enum Engine.ELocationBoneSocketSource
// NumValues: 0x0003
enum class ELocationBoneSocketSource : uint8
{
	BONESOCKETSOURCE_Bones                   = 0,
	BONESOCKETSOURCE_Sockets                 = 1,
	BONESOCKETSOURCE_MAX                     = 2,
};

// Enum Engine.ELocationEmitterSelectionMethod
// NumValues: 0x0003
enum class ELocationEmitterSelectionMethod : uint8
{
	ELESM_Random                             = 0,
	ELESM_Sequential                         = 1,
	ELESM_MAX                                = 2,
};

// Enum Engine.CylinderHeightAxis
// NumValues: 0x0004
enum class ECylinderHeightAxis : uint8
{
	PMLPC_HEIGHTAXIS_X                       = 0,
	PMLPC_HEIGHTAXIS_Y                       = 1,
	PMLPC_HEIGHTAXIS_Z                       = 2,
	PMLPC_HEIGHTAXIS_MAX                     = 3,
};

// Enum Engine.ELocationSkelVertSurfaceSource
// NumValues: 0x0003
enum class ELocationSkelVertSurfaceSource : uint8
{
	VERTSURFACESOURCE_Vert                   = 0,
	VERTSURFACESOURCE_Surface                = 1,
	VERTSURFACESOURCE_MAX                    = 2,
};

// Enum Engine.EOrbitChainMode
// NumValues: 0x0004
enum class EOrbitChainMode : uint8
{
	EOChainMode_Add                          = 0,
	EOChainMode_Scale                        = 1,
	EOChainMode_Link                         = 2,
	EOChainMode_MAX                          = 3,
};

// Enum Engine.EEmitterDynamicParameterValue
// NumValues: 0x0006
enum class EEmitterDynamicParameterValue : uint8
{
	EDPV_UserSet                             = 0,
	EDPV_VelocityX                           = 1,
	EDPV_VelocityY                           = 2,
	EDPV_VelocityZ                           = 3,
	EDPV_VelocityMag                         = 4,
	EDPV_MAX                                 = 5,
};

// Enum Engine.EEmitterNormalsMode
// NumValues: 0x0004
enum class EEmitterNormalsMode : uint8
{
	ENM_CameraFacing                         = 0,
	ENM_Spherical                            = 1,
	ENM_Cylindrical                          = 2,
	ENM_MAX                                  = 3,
};

// Enum Engine.EParticleSortMode
// NumValues: 0x0006
enum class EParticleSortMode : uint8
{
	PSORTMODE_None                           = 0,
	PSORTMODE_ViewProjDepth                  = 1,
	PSORTMODE_DistanceToView                 = 2,
	PSORTMODE_Age_OldestFirst                = 3,
	PSORTMODE_Age_NewestFirst                = 4,
	PSORTMODE_MAX                            = 5,
};

// Enum Engine.EParticleUVFlipMode
// NumValues: 0x0009
enum class EParticleUVFlipMode : uint8
{
	None                                     = 0,
	FlipUV                                   = 1,
	FlipUOnly                                = 2,
	FlipVOnly                                = 3,
	RandomFlipUV                             = 4,
	RandomFlipUOnly                          = 5,
	RandomFlipVOnly                          = 6,
	RandomFlipUVIndependent                  = 7,
	EParticleUVFlipMode_MAX                  = 8,
};

// Enum Engine.ESubUVBoundingVertexCount
// NumValues: 0x0003
enum class ESubUVBoundingVertexCount : uint8
{
	BVC_FourVertices                         = 0,
	BVC_EightVertices                        = 1,
	BVC_MAX                                  = 2,
};

// Enum Engine.ETrail2SourceMethod
// NumValues: 0x0004
enum class ETrail2SourceMethod : uint8
{
	PET2SRCM_Default                         = 0,
	PET2SRCM_Particle                        = 1,
	PET2SRCM_Actor                           = 2,
	PET2SRCM_MAX                             = 3,
};

// Enum Engine.EBeamTaperMethod
// NumValues: 0x0004
enum class EBeamTaperMethod : uint8
{
	PEBTM_None                               = 0,
	PEBTM_Full                               = 1,
	PEBTM_Partial                            = 2,
	PEBTM_MAX                                = 3,
};

// Enum Engine.EBeam2Method
// NumValues: 0x0004
enum class EBeam2Method : uint8
{
	PEB2M_Distance                           = 0,
	PEB2M_Target                             = 1,
	PEB2M_Branch                             = 2,
	PEB2M_MAX                                = 3,
};

// Enum Engine.EMeshCameraFacingOptions
// NumValues: 0x000E
enum class EMeshCameraFacingOptions : uint8
{
	XAxisFacing_NoUp                         = 0,
	XAxisFacing_ZUp                          = 1,
	XAxisFacing_NegativeZUp                  = 2,
	XAxisFacing_YUp                          = 3,
	XAxisFacing_NegativeYUp                  = 4,
	LockedAxis_ZAxisFacing                   = 5,
	LockedAxis_NegativeZAxisFacing           = 6,
	LockedAxis_YAxisFacing                   = 7,
	LockedAxis_NegativeYAxisFacing           = 8,
	VelocityAligned_ZAxisFacing              = 9,
	VelocityAligned_NegativeZAxisFacing      = 10,
	VelocityAligned_YAxisFacing              = 11,
	VelocityAligned_NegativeYAxisFacing      = 12,
	EMeshCameraFacingOptions_MAX             = 13,
};

// Enum Engine.EMeshCameraFacingUpAxis
// NumValues: 0x0006
enum class EMeshCameraFacingUpAxis : uint8
{
	CameraFacing_NoneUP                      = 0,
	CameraFacing_ZUp                         = 1,
	CameraFacing_NegativeZUp                 = 2,
	CameraFacing_YUp                         = 3,
	CameraFacing_NegativeYUp                 = 4,
	CameraFacing_MAX                         = 5,
};

// Enum Engine.EMeshScreenAlignment
// NumValues: 0x0004
enum class EMeshScreenAlignment : uint8
{
	PSMA_MeshFaceCameraWithRoll              = 0,
	PSMA_MeshFaceCameraWithSpin              = 1,
	PSMA_MeshFaceCameraWithLockedAxis        = 2,
	PSMA_MAX                                 = 3,
};

// Enum Engine.ETrailsRenderAxisOption
// NumValues: 0x0004
enum class ETrailsRenderAxisOption : uint8
{
	Trails_CameraUp                          = 0,
	Trails_SourceUp                          = 1,
	Trails_WorldUp                           = 2,
	Trails_MAX                               = 3,
};

// Enum Engine.ECloudStorageDelegate
// NumValues: 0x0008
enum class ECloudStorageDelegate : uint8
{
	CSD_KeyValueReadComplete                 = 0,
	CSD_KeyValueWriteComplete                = 1,
	CSD_ValueChanged                         = 2,
	CSD_DocumentQueryComplete                = 3,
	CSD_DocumentReadComplete                 = 4,
	CSD_DocumentWriteComplete                = 5,
	CSD_DocumentConflictDetected             = 6,
	CSD_MAX                                  = 7,
};

// Enum Engine.EAdManagerDelegate
// NumValues: 0x0003
enum class EAdManagerDelegate : uint8
{
	AMD_ClickedBanner                        = 0,
	AMD_UserClosedAd                         = 1,
	AMD_MAX                                  = 2,
};

// Enum Engine.EMicroTransactionResult
// NumValues: 0x0005
enum class EMicroTransactionResult : uint8
{
	MTR_Succeeded                            = 0,
	MTR_Failed                               = 1,
	MTR_Canceled                             = 2,
	MTR_RestoredFromServer                   = 3,
	MTR_MAX                                  = 4,
};

// Enum Engine.EMicroTransactionDelegate
// NumValues: 0x0003
enum class EMicroTransactionDelegate : uint8
{
	MTD_PurchaseQueryComplete                = 0,
	MTD_PurchaseComplete                     = 1,
	MTD_MAX                                  = 2,
};

// Enum Engine.ETwitterIntegrationDelegate
// NumValues: 0x0004
enum class ETwitterIntegrationDelegate : uint8
{
	TID_AuthorizeComplete                    = 0,
	TID_TweetUIComplete                      = 1,
	TID_RequestComplete                      = 2,
	TID_MAX                                  = 3,
};

// Enum Engine.ETwitterRequestMethod
// NumValues: 0x0004
enum class ETwitterRequestMethod : uint8
{
	TRM_Get                                  = 0,
	TRM_Post                                 = 1,
	TRM_Delete                               = 2,
	TRM_MAX                                  = 3,
};

// Enum Engine.EReporterLineStyle
// NumValues: 0x0003
enum class EReporterLineStyle : uint8
{
	Line                                     = 0,
	Dash                                     = 1,
	EReporterLineStyle_MAX                   = 2,
};

// Enum Engine.ELegendPosition
// NumValues: 0x0003
enum class ELegendPosition : uint8
{
	Outside                                  = 0,
	Inside                                   = 1,
	ELegendPosition_MAX                      = 2,
};

// Enum Engine.EGraphDataStyle
// NumValues: 0x0003
enum class EGraphDataStyle : uint8
{
	Lines                                    = 0,
	Filled                                   = 1,
	EGraphDataStyle_MAX                      = 2,
};

// Enum Engine.EGraphAxisStyle
// NumValues: 0x0004
enum class EGraphAxisStyle : uint8
{
	Lines                                    = 0,
	Notches                                  = 1,
	Grid                                     = 2,
	EGraphAxisStyle_MAX                      = 3,
};

// Enum Engine.EConstraintTransform
// NumValues: 0x0003
enum class EConstraintTransform : uint8
{
	Absolute                                 = 0,
	Relative                                 = 1,
	EConstraintTransform_MAX                 = 2,
};

// Enum Engine.EControlConstraint
// NumValues: 0x0004
enum class EControlConstraint : uint8
{
	Orientation                              = 0,
	Translation                              = 1,
	Max                                      = 2,
	EControlConstraint_MAX                   = 3,
};

// Enum Engine.EImpactDamageOverride
// NumValues: 0x0004
enum class EImpactDamageOverride : uint8
{
	IDO_None                                 = 0,
	IDO_On                                   = 1,
	IDO_Off                                  = 2,
	IDO_MAX                                  = 3,
};

// Enum Engine.EMaxConcurrentResolutionRule
// NumValues: 0x0007
enum class EMaxConcurrentResolutionRule : uint8
{
	PreventNew                               = 0,
	StopOldest                               = 1,
	StopFarthestThenPreventNew               = 2,
	StopFarthestThenOldest                   = 3,
	StopLowestPriority                       = 4,
	StopQuietest                             = 5,
	EMaxConcurrentResolutionRule_MAX         = 6,
};

// Enum Engine.ESoundGroup
// NumValues: 0x001A
enum class ESoundGroup : uint8
{
	SOUNDGROUP_Default                       = 0,
	SOUNDGROUP_Effects                       = 1,
	SOUNDGROUP_UI                            = 2,
	SOUNDGROUP_Music                         = 3,
	SOUNDGROUP_Voice                         = 4,
	SOUNDGROUP_GameSoundGroup1               = 5,
	SOUNDGROUP_GameSoundGroup2               = 6,
	SOUNDGROUP_GameSoundGroup3               = 7,
	SOUNDGROUP_GameSoundGroup4               = 8,
	SOUNDGROUP_GameSoundGroup5               = 9,
	SOUNDGROUP_GameSoundGroup6               = 10,
	SOUNDGROUP_GameSoundGroup7               = 11,
	SOUNDGROUP_GameSoundGroup8               = 12,
	SOUNDGROUP_GameSoundGroup9               = 13,
	SOUNDGROUP_GameSoundGroup10              = 14,
	SOUNDGROUP_GameSoundGroup11              = 15,
	SOUNDGROUP_GameSoundGroup12              = 16,
	SOUNDGROUP_GameSoundGroup13              = 17,
	SOUNDGROUP_GameSoundGroup14              = 18,
	SOUNDGROUP_GameSoundGroup15              = 19,
	SOUNDGROUP_GameSoundGroup16              = 20,
	SOUNDGROUP_GameSoundGroup17              = 21,
	SOUNDGROUP_GameSoundGroup18              = 22,
	SOUNDGROUP_GameSoundGroup19              = 23,
	SOUNDGROUP_GameSoundGroup20              = 24,
	SOUNDGROUP_MAX                           = 25,
};

// Enum Engine.EDecompressionType
// NumValues: 0x0009
enum class EDecompressionType : uint8
{
	DTYPE_Setup                              = 0,
	DTYPE_Invalid                            = 1,
	DTYPE_Preview                            = 2,
	DTYPE_Native                             = 3,
	DTYPE_RealTime                           = 4,
	DTYPE_Procedural                         = 5,
	DTYPE_Xenon                              = 6,
	DTYPE_Streaming                          = 7,
	DTYPE_MAX                                = 8,
};

// Enum Engine.EAudioOutputTarget
// NumValues: 0x0004
enum class EAudioOutputTarget : uint8
{
	Speaker                                  = 0,
	Controller                               = 1,
	ControllerFallbackToSpeaker              = 2,
	EAudioOutputTarget_MAX                   = 3,
};

// Enum Engine.ModulationParamMode
// NumValues: 0x0004
enum class EModulationParamMode : uint8
{
	MPM_Normal                               = 0,
	MPM_Abs                                  = 1,
	MPM_Direct                               = 2,
	MPM_MAX                                  = 3,
};

// Enum Engine.EOptimizationType
// NumValues: 0x0003
enum class EOptimizationType : uint8
{
	OT_NumOfTriangles                        = 0,
	OT_MaxDeviation                          = 1,
	OT_MAX                                   = 2,
};

// Enum Engine.EImportanceLevel
// NumValues: 0x0008
enum class EImportanceLevel : uint8
{
	IL_Off                                   = 0,
	IL_Lowest                                = 1,
	IL_Low                                   = 2,
	IL_Normal                                = 3,
	IL_High                                  = 4,
	IL_Highest                               = 5,
	TEMP_BROKEN2                             = 6,
	EImportanceLevel_MAX                     = 7,
};

// Enum Engine.ENormalMode
// NumValues: 0x0006
enum class ENormalMode : uint8
{
	NM_PreserveSmoothingGroups               = 0,
	NM_RecalculateNormals                    = 1,
	NM_RecalculateNormalsSmooth              = 2,
	NM_RecalculateNormalsHard                = 3,
	TEMP_BROKEN                              = 4,
	ENormalMode_MAX                          = 5,
};

// Enum Engine.ETextureSourceFormat
// NumValues: 0x0009
enum class ETextureSourceFormat : uint8
{
	TSF_Invalid                              = 0,
	TSF_G8                                   = 1,
	TSF_BGRA8                                = 2,
	TSF_BGRE8                                = 3,
	TSF_RGBA16                               = 4,
	TSF_RGBA16F                              = 5,
	TSF_RGBA8                                = 6,
	TSF_RGBE8                                = 7,
	TSF_MAX                                  = 8,
};

// Enum Engine.ETextureSourceArtType
// NumValues: 0x0004
enum class ETextureSourceArtType : uint8
{
	TSAT_Uncompressed                        = 0,
	TSAT_PNGCompressed                       = 1,
	TSAT_DDSFile                             = 2,
	TSAT_MAX                                 = 3,
};

// Enum Engine.ETextureMipCount
// NumValues: 0x0004
enum class ETextureMipCount : uint8
{
	TMC_ResidentMips                         = 0,
	TMC_AllMips                              = 1,
	TMC_AllMipsBiased                        = 2,
	TMC_MAX                                  = 3,
};

// Enum Engine.ECompositeTextureMode
// NumValues: 0x0006
enum class ECompositeTextureMode : uint8
{
	CTM_Disabled                             = 0,
	CTM_NormalRoughnessToRed                 = 1,
	CTM_NormalRoughnessToGreen               = 2,
	CTM_NormalRoughnessToBlue                = 3,
	CTM_NormalRoughnessToAlpha               = 4,
	CTM_MAX                                  = 5,
};

// Enum Engine.TextureAddress
// NumValues: 0x0004
enum class ETextureAddress : uint8
{
	TA_Wrap                                  = 0,
	TA_Clamp                                 = 1,
	TA_Mirror                                = 2,
	TA_MAX                                   = 3,
};

// Enum Engine.TextureFilter
// NumValues: 0x0005
enum class ETextureFilter : uint8
{
	TF_Nearest                               = 0,
	TF_Bilinear                              = 1,
	TF_Trilinear                             = 2,
	TF_Default                               = 3,
	TF_MAX                                   = 4,
};

// Enum Engine.TextureCompressionSettings
// NumValues: 0x000D
enum class ETextureCompressionSettings : uint8
{
	TC_Default                               = 0,
	TC_Normalmap                             = 1,
	TC_Masks                                 = 2,
	TC_Grayscale                             = 3,
	TC_Displacementmap                       = 4,
	TC_VectorDisplacementmap                 = 5,
	TC_HDR                                   = 6,
	TC_EditorIcon                            = 7,
	TC_Alpha                                 = 8,
	TC_DistanceFieldFont                     = 9,
	TC_HDR_Compressed                        = 10,
	TC_BC7                                   = 11,
	TC_MAX                                   = 12,
};

// Enum Engine.EUserDefinedStructureStatus
// NumValues: 0x0005
enum class EUserDefinedStructureStatus : uint8
{
	UDSS_UpToDate                            = 0,
	UDSS_Dirty                               = 1,
	UDSS_Error                               = 2,
	UDSS_Duplicate                           = 3,
	UDSS_MAX                                 = 4,
};

// Enum Engine.EVectorFieldConstructionOp
// NumValues: 0x0003
enum class EVectorFieldConstructionOp : uint8
{
	VFCO_Extrude                             = 0,
	VFCO_Revolve                             = 1,
	VFCO_MAX                                 = 2,
};

// Enum Engine.EPostCopyOperation
// NumValues: 0x0003
enum class EPostCopyOperation : uint8
{
	None                                     = 0,
	LogicalNegateBool                        = 1,
	EPostCopyOperation_MAX                   = 2,
};

// Enum Engine.EPinHidingMode
// NumValues: 0x0005
enum class EPinHidingMode : uint8
{
	NeverAsPin                               = 0,
	PinHiddenByDefault                       = 1,
	PinShownByDefault                        = 2,
	AlwaysAsPin                              = 3,
	EPinHidingMode_MAX                       = 4,
};

// Enum Engine.EEvaluatorMode
// NumValues: 0x0004
enum class EEvaluatorMode : uint8
{
	EM_Standard                              = 0,
	EM_Freeze                                = 1,
	EM_DelayedFreeze                         = 2,
	EM_MAX                                   = 3,
};

// Enum Engine.EEvaluatorDataSource
// NumValues: 0x0003
enum class EEvaluatorDataSource : uint8
{
	EDS_SourcePose                           = 0,
	EDS_DestinationPose                      = 1,
	EDS_MAX                                  = 2,
};

// Enum Engine.ECameraAlphaBlendMode
// NumValues: 0x0003
enum class ECameraAlphaBlendMode : uint8
{
	CABM_Linear                              = 0,
	CABM_Cubic                               = 1,
	CABM_MAX                                 = 2,
};

// Enum Engine.AnimPhysCollisionType
// NumValues: 0x0005
enum class EAnimPhysCollisionType : uint8
{
	CoM                                      = 0,
	CustomSphere                             = 1,
	InnerSphere                              = 2,
	OuterSphere                              = 3,
	AnimPhysCollisionType_MAX                = 4,
};

// Enum Engine.AnimPhysTwistAxis
// NumValues: 0x0004
enum class EAnimPhysTwistAxis : uint8
{
	AxisX                                    = 0,
	AxisY                                    = 1,
	AxisZ                                    = 2,
	AnimPhysTwistAxis_MAX                    = 3,
};

// ScriptStruct Engine.RootMotionMovementParams
// 0x0040 (0x0040 - 0x0000)
struct FRootMotionMovementParams final
{
public:
	bool                                          bHasRootMotion;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RootMotionTransform;                               // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionMovementParams) == 0x000010, "Wrong alignment on FRootMotionMovementParams");
static_assert(sizeof(FRootMotionMovementParams) == 0x000040, "Wrong size on FRootMotionMovementParams");
static_assert(offsetof(FRootMotionMovementParams, bHasRootMotion) == 0x000000, "Member 'FRootMotionMovementParams::bHasRootMotion' has a wrong offset!");
static_assert(offsetof(FRootMotionMovementParams, BlendWeight) == 0x000004, "Member 'FRootMotionMovementParams::BlendWeight' has a wrong offset!");
static_assert(offsetof(FRootMotionMovementParams, RootMotionTransform) == 0x000010, "Member 'FRootMotionMovementParams::RootMotionTransform' has a wrong offset!");

// ScriptStruct Engine.BPVariableMetaDataEntry
// 0x0014 (0x0014 - 0x0000)
struct FBPVariableMetaDataEntry final
{
public:
	class FName                                   DataKey;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataValue;                                         // 0x0008(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBPVariableMetaDataEntry) == 0x000004, "Wrong alignment on FBPVariableMetaDataEntry");
static_assert(sizeof(FBPVariableMetaDataEntry) == 0x000014, "Wrong size on FBPVariableMetaDataEntry");
static_assert(offsetof(FBPVariableMetaDataEntry, DataKey) == 0x000000, "Member 'FBPVariableMetaDataEntry::DataKey' has a wrong offset!");
static_assert(offsetof(FBPVariableMetaDataEntry, DataValue) == 0x000008, "Member 'FBPVariableMetaDataEntry::DataValue' has a wrong offset!");

// ScriptStruct Engine.SimpleMemberReference
// 0x001C (0x001C - 0x0000)
struct FSimpleMemberReference final
{
public:
	class UObject*                                MemberParent;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemberName;                                        // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MemberGuid;                                        // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleMemberReference) == 0x000004, "Wrong alignment on FSimpleMemberReference");
static_assert(sizeof(FSimpleMemberReference) == 0x00001C, "Wrong size on FSimpleMemberReference");
static_assert(offsetof(FSimpleMemberReference, MemberParent) == 0x000000, "Member 'FSimpleMemberReference::MemberParent' has a wrong offset!");
static_assert(offsetof(FSimpleMemberReference, MemberName) == 0x000004, "Member 'FSimpleMemberReference::MemberName' has a wrong offset!");
static_assert(offsetof(FSimpleMemberReference, MemberGuid) == 0x00000C, "Member 'FSimpleMemberReference::MemberGuid' has a wrong offset!");

// ScriptStruct Engine.EdGraphPinType
// 0x0040 (0x0040 - 0x0000)
struct FEdGraphPinType final
{
public:
	class FString                                 PinCategory;                                       // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PinSubCategory;                                    // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 PinSubCategoryObject;                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSimpleMemberReference                 PinSubCategoryMemberReference;                     // 0x0020(0x001C)(NativeAccessSpecifierPublic)
	bool                                          bIsArray;                                          // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsReference;                                      // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsConst;                                          // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsWeakPointer;                                    // 0x003F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEdGraphPinType) == 0x000004, "Wrong alignment on FEdGraphPinType");
static_assert(sizeof(FEdGraphPinType) == 0x000040, "Wrong size on FEdGraphPinType");
static_assert(offsetof(FEdGraphPinType, PinCategory) == 0x000000, "Member 'FEdGraphPinType::PinCategory' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, PinSubCategory) == 0x00000C, "Member 'FEdGraphPinType::PinSubCategory' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, PinSubCategoryObject) == 0x000018, "Member 'FEdGraphPinType::PinSubCategoryObject' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, PinSubCategoryMemberReference) == 0x000020, "Member 'FEdGraphPinType::PinSubCategoryMemberReference' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, bIsArray) == 0x00003C, "Member 'FEdGraphPinType::bIsArray' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, bIsReference) == 0x00003D, "Member 'FEdGraphPinType::bIsReference' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, bIsConst) == 0x00003E, "Member 'FEdGraphPinType::bIsConst' has a wrong offset!");
static_assert(offsetof(FEdGraphPinType, bIsWeakPointer) == 0x00003F, "Member 'FEdGraphPinType::bIsWeakPointer' has a wrong offset!");

// ScriptStruct Engine.BPVariableDescription
// 0x0098 (0x0098 - 0x0000)
struct FBPVariableDescription final
{
public:
	class FName                                   VarName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  VarGuid;                                           // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEdGraphPinType                        VarType;                                           // 0x0018(0x0040)(Edit, NativeAccessSpecifierPublic)
	class FString                                 FriendlyName;                                      // 0x0058(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0064(0x000C)(Edit, NativeAccessSpecifierPublic)
	uint64                                        PropertyFlags;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RepNotifyFunc;                                     // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBPVariableMetaDataEntry>       MetaDataArray;                                     // 0x0080(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x008C(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBPVariableDescription) == 0x000004, "Wrong alignment on FBPVariableDescription");
static_assert(sizeof(FBPVariableDescription) == 0x000098, "Wrong size on FBPVariableDescription");
static_assert(offsetof(FBPVariableDescription, VarName) == 0x000000, "Member 'FBPVariableDescription::VarName' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, VarGuid) == 0x000008, "Member 'FBPVariableDescription::VarGuid' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, VarType) == 0x000018, "Member 'FBPVariableDescription::VarType' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, FriendlyName) == 0x000058, "Member 'FBPVariableDescription::FriendlyName' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, Category) == 0x000064, "Member 'FBPVariableDescription::Category' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, PropertyFlags) == 0x000070, "Member 'FBPVariableDescription::PropertyFlags' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, RepNotifyFunc) == 0x000078, "Member 'FBPVariableDescription::RepNotifyFunc' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, MetaDataArray) == 0x000080, "Member 'FBPVariableDescription::MetaDataArray' has a wrong offset!");
static_assert(offsetof(FBPVariableDescription, DefaultValue) == 0x00008C, "Member 'FBPVariableDescription::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.MeshBuildSettings
// 0x0030 (0x0030 - 0x0000)
struct FMeshBuildSettings final
{
public:
	bool                                          bUseMikkTSpace;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRecomputeNormals;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRecomputeTangents;                                // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRemoveDegenerates;                                // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBuildAdjacencyBuffer;                             // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBuildReversedIndexBuffer;                         // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFullPrecisionUVs;                              // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateLightmapUVs;                              // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MinLightmapResolution;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SrcLightmapIndex;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstLightmapIndex;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildScale;                                        // 0x0014(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BuildScale3D;                                      // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DistanceFieldResolutionScale;                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateDistanceFieldAsIfTwoSided;                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DistanceFieldReplacementMesh;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshBuildSettings) == 0x000004, "Wrong alignment on FMeshBuildSettings");
static_assert(sizeof(FMeshBuildSettings) == 0x000030, "Wrong size on FMeshBuildSettings");
static_assert(offsetof(FMeshBuildSettings, bUseMikkTSpace) == 0x000000, "Member 'FMeshBuildSettings::bUseMikkTSpace' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bRecomputeNormals) == 0x000001, "Member 'FMeshBuildSettings::bRecomputeNormals' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bRecomputeTangents) == 0x000002, "Member 'FMeshBuildSettings::bRecomputeTangents' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bRemoveDegenerates) == 0x000003, "Member 'FMeshBuildSettings::bRemoveDegenerates' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bBuildAdjacencyBuffer) == 0x000004, "Member 'FMeshBuildSettings::bBuildAdjacencyBuffer' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bBuildReversedIndexBuffer) == 0x000005, "Member 'FMeshBuildSettings::bBuildReversedIndexBuffer' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bUseFullPrecisionUVs) == 0x000006, "Member 'FMeshBuildSettings::bUseFullPrecisionUVs' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bGenerateLightmapUVs) == 0x000007, "Member 'FMeshBuildSettings::bGenerateLightmapUVs' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, MinLightmapResolution) == 0x000008, "Member 'FMeshBuildSettings::MinLightmapResolution' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, SrcLightmapIndex) == 0x00000C, "Member 'FMeshBuildSettings::SrcLightmapIndex' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, DstLightmapIndex) == 0x000010, "Member 'FMeshBuildSettings::DstLightmapIndex' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, BuildScale) == 0x000014, "Member 'FMeshBuildSettings::BuildScale' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, BuildScale3D) == 0x000018, "Member 'FMeshBuildSettings::BuildScale3D' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, DistanceFieldResolutionScale) == 0x000024, "Member 'FMeshBuildSettings::DistanceFieldResolutionScale' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, bGenerateDistanceFieldAsIfTwoSided) == 0x000028, "Member 'FMeshBuildSettings::bGenerateDistanceFieldAsIfTwoSided' has a wrong offset!");
static_assert(offsetof(FMeshBuildSettings, DistanceFieldReplacementMesh) == 0x00002C, "Member 'FMeshBuildSettings::DistanceFieldReplacementMesh' has a wrong offset!");

// ScriptStruct Engine.TickFunction
// 0x0034 (0x0034 - 0x0000)
struct FTickFunction
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ETickingGroup                                 TickGroup;                                         // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETickingGroup                                 EndTickGroup;                                      // 0x0005(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTickEvenWhenPaused : 1;                           // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bCanEverTick : 1;                                  // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bStartWithTickEnabled : 1;                         // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAllowTickOnDedicatedServer : 1;                   // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x23];                                       // 0x0009(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTickFunction) == 0x000004, "Wrong alignment on FTickFunction");
static_assert(sizeof(FTickFunction) == 0x000034, "Wrong size on FTickFunction");
static_assert(offsetof(FTickFunction, TickGroup) == 0x000004, "Member 'FTickFunction::TickGroup' has a wrong offset!");
static_assert(offsetof(FTickFunction, EndTickGroup) == 0x000005, "Member 'FTickFunction::EndTickGroup' has a wrong offset!");
static_assert(offsetof(FTickFunction, TickInterval) == 0x00002C, "Member 'FTickFunction::TickInterval' has a wrong offset!");

// ScriptStruct Engine.ActorComponentTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FActorComponentTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorComponentTickFunction) == 0x000004, "Wrong alignment on FActorComponentTickFunction");
static_assert(sizeof(FActorComponentTickFunction) == 0x000038, "Wrong size on FActorComponentTickFunction");

// ScriptStruct Engine.ExpressionInput
// 0x002C (0x002C - 0x0000)
struct FExpressionInput
{
public:
	class UMaterialExpression*                    Expression;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputName;                                         // 0x0008(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GCC64_Padding;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExpressionInput) == 0x000004, "Wrong alignment on FExpressionInput");
static_assert(sizeof(FExpressionInput) == 0x00002C, "Wrong size on FExpressionInput");
static_assert(offsetof(FExpressionInput, Expression) == 0x000000, "Member 'FExpressionInput::Expression' has a wrong offset!");
static_assert(offsetof(FExpressionInput, OutputIndex) == 0x000004, "Member 'FExpressionInput::OutputIndex' has a wrong offset!");
static_assert(offsetof(FExpressionInput, InputName) == 0x000008, "Member 'FExpressionInput::InputName' has a wrong offset!");
static_assert(offsetof(FExpressionInput, Mask) == 0x000014, "Member 'FExpressionInput::Mask' has a wrong offset!");
static_assert(offsetof(FExpressionInput, MaskR) == 0x000018, "Member 'FExpressionInput::MaskR' has a wrong offset!");
static_assert(offsetof(FExpressionInput, MaskG) == 0x00001C, "Member 'FExpressionInput::MaskG' has a wrong offset!");
static_assert(offsetof(FExpressionInput, MaskB) == 0x000020, "Member 'FExpressionInput::MaskB' has a wrong offset!");
static_assert(offsetof(FExpressionInput, MaskA) == 0x000024, "Member 'FExpressionInput::MaskA' has a wrong offset!");
static_assert(offsetof(FExpressionInput, GCC64_Padding) == 0x000028, "Member 'FExpressionInput::GCC64_Padding' has a wrong offset!");

// ScriptStruct Engine.MaterialAttributesInput
// 0x0000 (0x002C - 0x002C)
struct FMaterialAttributesInput final : public FExpressionInput
{
};
static_assert(alignof(FMaterialAttributesInput) == 0x000004, "Wrong alignment on FMaterialAttributesInput");
static_assert(sizeof(FMaterialAttributesInput) == 0x00002C, "Wrong size on FMaterialAttributesInput");

// ScriptStruct Engine.FastArraySerializer
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x04) FFastArraySerializer
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFastArraySerializer) == 0x000004, "Wrong alignment on FFastArraySerializer");
static_assert(sizeof(FFastArraySerializer) == 0x000080, "Wrong size on FFastArraySerializer");

// ScriptStruct Engine.AnimBlueprintDebugData
// 0x0001 (0x0001 - 0x0000)
struct FAnimBlueprintDebugData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimBlueprintDebugData) == 0x000001, "Wrong alignment on FAnimBlueprintDebugData");
static_assert(sizeof(FAnimBlueprintDebugData) == 0x000001, "Wrong size on FAnimBlueprintDebugData");

// ScriptStruct Engine.ResponseChannel
// 0x000C (0x000C - 0x0000)
struct FResponseChannel final
{
public:
	class FName                                   Channel;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Response;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResponseChannel) == 0x000004, "Wrong alignment on FResponseChannel");
static_assert(sizeof(FResponseChannel) == 0x00000C, "Wrong size on FResponseChannel");
static_assert(offsetof(FResponseChannel, Channel) == 0x000000, "Member 'FResponseChannel::Channel' has a wrong offset!");
static_assert(offsetof(FResponseChannel, Response) == 0x000008, "Member 'FResponseChannel::Response' has a wrong offset!");

// ScriptStruct Engine.FastArraySerializerItem
// 0x000C (0x000C - 0x0000)
struct FFastArraySerializerItem
{
public:
	int32                                         ReplicationID;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplicationKey;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MostRecentArrayReplicationKey;                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFastArraySerializerItem) == 0x000004, "Wrong alignment on FFastArraySerializerItem");
static_assert(sizeof(FFastArraySerializerItem) == 0x00000C, "Wrong size on FFastArraySerializerItem");
static_assert(offsetof(FFastArraySerializerItem, ReplicationID) == 0x000000, "Member 'FFastArraySerializerItem::ReplicationID' has a wrong offset!");
static_assert(offsetof(FFastArraySerializerItem, ReplicationKey) == 0x000004, "Member 'FFastArraySerializerItem::ReplicationKey' has a wrong offset!");
static_assert(offsetof(FFastArraySerializerItem, MostRecentArrayReplicationKey) == 0x000008, "Member 'FFastArraySerializerItem::MostRecentArrayReplicationKey' has a wrong offset!");

// ScriptStruct Engine.DistributionLookupTable
// 0x001C (0x001C - 0x0000)
struct FDistributionLookupTable final
{
public:
	uint8                                         Op;                                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EntryCount;                                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EntryStride;                                       // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubEntryStride;                                    // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScale;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBias;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         LockFlag;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistributionLookupTable) == 0x000004, "Wrong alignment on FDistributionLookupTable");
static_assert(sizeof(FDistributionLookupTable) == 0x00001C, "Wrong size on FDistributionLookupTable");
static_assert(offsetof(FDistributionLookupTable, Op) == 0x000000, "Member 'FDistributionLookupTable::Op' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, EntryCount) == 0x000001, "Member 'FDistributionLookupTable::EntryCount' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, EntryStride) == 0x000002, "Member 'FDistributionLookupTable::EntryStride' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, SubEntryStride) == 0x000003, "Member 'FDistributionLookupTable::SubEntryStride' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, TimeScale) == 0x000004, "Member 'FDistributionLookupTable::TimeScale' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, TimeBias) == 0x000008, "Member 'FDistributionLookupTable::TimeBias' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, Values) == 0x00000C, "Member 'FDistributionLookupTable::Values' has a wrong offset!");
static_assert(offsetof(FDistributionLookupTable, LockFlag) == 0x000018, "Member 'FDistributionLookupTable::LockFlag' has a wrong offset!");

// ScriptStruct Engine.FloatDistribution
// 0x001C (0x001C - 0x0000)
struct FFloatDistribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatDistribution) == 0x000004, "Wrong alignment on FFloatDistribution");
static_assert(sizeof(FFloatDistribution) == 0x00001C, "Wrong size on FFloatDistribution");
static_assert(offsetof(FFloatDistribution, Table) == 0x000000, "Member 'FFloatDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.UniqueNetIdRepl
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FUniqueNetIdRepl final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueNetIdRepl) == 0x000004, "Wrong alignment on FUniqueNetIdRepl");
static_assert(sizeof(FUniqueNetIdRepl) == 0x000008, "Wrong size on FUniqueNetIdRepl");

// ScriptStruct Engine.BoneReference
// 0x000C (0x000C - 0x0000)
struct FBoneReference final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneReference) == 0x000004, "Wrong alignment on FBoneReference");
static_assert(sizeof(FBoneReference) == 0x00000C, "Wrong size on FBoneReference");
static_assert(offsetof(FBoneReference, BoneName) == 0x000000, "Member 'FBoneReference::BoneName' has a wrong offset!");

// ScriptStruct Engine.CircleElement2D
// 0x000C (0x000C - 0x0000)
struct FCircleElement2D final
{
public:
	struct FVector2D                              Center;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCircleElement2D) == 0x000004, "Wrong alignment on FCircleElement2D");
static_assert(sizeof(FCircleElement2D) == 0x00000C, "Wrong size on FCircleElement2D");
static_assert(offsetof(FCircleElement2D, Center) == 0x000000, "Member 'FCircleElement2D::Center' has a wrong offset!");
static_assert(offsetof(FCircleElement2D, Radius) == 0x000008, "Member 'FCircleElement2D::Radius' has a wrong offset!");

// ScriptStruct Engine.FormatArgumentData
// 0x0018 (0x0018 - 0x0000)
struct FFormatArgumentData final
{
public:
	class FString                                 ArgumentName;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ArgumentValue;                                     // 0x000C(0x000C)(Edit, BlueprintVisible, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFormatArgumentData) == 0x000004, "Wrong alignment on FFormatArgumentData");
static_assert(sizeof(FFormatArgumentData) == 0x000018, "Wrong size on FFormatArgumentData");
static_assert(offsetof(FFormatArgumentData, ArgumentName) == 0x000000, "Member 'FFormatArgumentData::ArgumentName' has a wrong offset!");
static_assert(offsetof(FFormatArgumentData, ArgumentValue) == 0x00000C, "Member 'FFormatArgumentData::ArgumentValue' has a wrong offset!");

// ScriptStruct Engine.RawDistribution
// 0x001C (0x001C - 0x0000)
struct FRawDistribution
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRawDistribution) == 0x000004, "Wrong alignment on FRawDistribution");
static_assert(sizeof(FRawDistribution) == 0x00001C, "Wrong size on FRawDistribution");
static_assert(offsetof(FRawDistribution, Table) == 0x000000, "Member 'FRawDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.PassiveSoundMixModifier
// 0x000C (0x000C - 0x0000)
struct FPassiveSoundMixModifier final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVolumeThreshold;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVolumeThreshold;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveSoundMixModifier) == 0x000004, "Wrong alignment on FPassiveSoundMixModifier");
static_assert(sizeof(FPassiveSoundMixModifier) == 0x00000C, "Wrong size on FPassiveSoundMixModifier");
static_assert(offsetof(FPassiveSoundMixModifier, SoundMix) == 0x000000, "Member 'FPassiveSoundMixModifier::SoundMix' has a wrong offset!");
static_assert(offsetof(FPassiveSoundMixModifier, MinVolumeThreshold) == 0x000004, "Member 'FPassiveSoundMixModifier::MinVolumeThreshold' has a wrong offset!");
static_assert(offsetof(FPassiveSoundMixModifier, MaxVolumeThreshold) == 0x000008, "Member 'FPassiveSoundMixModifier::MaxVolumeThreshold' has a wrong offset!");

// ScriptStruct Engine.StartPhysicsTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FStartPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartPhysicsTickFunction) == 0x000004, "Wrong alignment on FStartPhysicsTickFunction");
static_assert(sizeof(FStartPhysicsTickFunction) == 0x000038, "Wrong size on FStartPhysicsTickFunction");

// ScriptStruct Engine.VectorDistribution
// 0x001C (0x001C - 0x0000)
struct FVectorDistribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorDistribution) == 0x000004, "Wrong alignment on FVectorDistribution");
static_assert(sizeof(FVectorDistribution) == 0x00001C, "Wrong size on FVectorDistribution");
static_assert(offsetof(FVectorDistribution, Table) == 0x000000, "Member 'FVectorDistribution::Table' has a wrong offset!");

// ScriptStruct Engine.LightmassMaterialInterfaceSettings
// 0x0014 (0x0014 - 0x0000)
struct FLightmassMaterialInterfaceSettings final
{
public:
	uint8                                         bCastShadowAsMasked : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmissiveBoost;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExportResolutionScale;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideCastShadowAsMasked : 1;                   // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideEmissiveBoost : 1;                        // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideDiffuseBoost : 1;                         // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideExportResolutionScale : 1;                // 0x0010(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightmassMaterialInterfaceSettings) == 0x000004, "Wrong alignment on FLightmassMaterialInterfaceSettings");
static_assert(sizeof(FLightmassMaterialInterfaceSettings) == 0x000014, "Wrong size on FLightmassMaterialInterfaceSettings");
static_assert(offsetof(FLightmassMaterialInterfaceSettings, EmissiveBoost) == 0x000004, "Member 'FLightmassMaterialInterfaceSettings::EmissiveBoost' has a wrong offset!");
static_assert(offsetof(FLightmassMaterialInterfaceSettings, DiffuseBoost) == 0x000008, "Member 'FLightmassMaterialInterfaceSettings::DiffuseBoost' has a wrong offset!");
static_assert(offsetof(FLightmassMaterialInterfaceSettings, ExportResolutionScale) == 0x00000C, "Member 'FLightmassMaterialInterfaceSettings::ExportResolutionScale' has a wrong offset!");

// ScriptStruct Engine.BlendSampleData
// 0x002C (0x002C - 0x0000)
struct FBlendSampleData final
{
public:
	int32                                         SampleDataIndex;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalWeight;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTime;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x1C];                                      // 0x0010(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendSampleData) == 0x000004, "Wrong alignment on FBlendSampleData");
static_assert(sizeof(FBlendSampleData) == 0x00002C, "Wrong size on FBlendSampleData");
static_assert(offsetof(FBlendSampleData, SampleDataIndex) == 0x000000, "Member 'FBlendSampleData::SampleDataIndex' has a wrong offset!");
static_assert(offsetof(FBlendSampleData, TotalWeight) == 0x000004, "Member 'FBlendSampleData::TotalWeight' has a wrong offset!");
static_assert(offsetof(FBlendSampleData, Time) == 0x000008, "Member 'FBlendSampleData::Time' has a wrong offset!");
static_assert(offsetof(FBlendSampleData, PreviousTime) == 0x00000C, "Member 'FBlendSampleData::PreviousTime' has a wrong offset!");

// ScriptStruct Engine.Vector4Distribution
// 0x001C (0x001C - 0x0000)
struct FVector4Distribution final
{
public:
	struct FDistributionLookupTable               Table;                                             // 0x0000(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector4Distribution) == 0x000004, "Wrong alignment on FVector4Distribution");
static_assert(sizeof(FVector4Distribution) == 0x00001C, "Wrong size on FVector4Distribution");
static_assert(offsetof(FVector4Distribution, Table) == 0x000000, "Member 'FVector4Distribution::Table' has a wrong offset!");

// ScriptStruct Engine.TextureParameterValue
// 0x001C (0x001C - 0x0000)
struct FTextureParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ParameterValue;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureParameterValue) == 0x000004, "Wrong alignment on FTextureParameterValue");
static_assert(sizeof(FTextureParameterValue) == 0x00001C, "Wrong size on FTextureParameterValue");
static_assert(offsetof(FTextureParameterValue, ParameterName) == 0x000000, "Member 'FTextureParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FTextureParameterValue, ParameterValue) == 0x000008, "Member 'FTextureParameterValue::ParameterValue' has a wrong offset!");
static_assert(offsetof(FTextureParameterValue, ExpressionGUID) == 0x00000C, "Member 'FTextureParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.SupportedAreaData
// 0x0014 (0x0014 - 0x0000)
struct FSupportedAreaData final
{
public:
	class FString                                 AreaClassName;                                     // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaID;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AreaClass;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedAreaData) == 0x000004, "Wrong alignment on FSupportedAreaData");
static_assert(sizeof(FSupportedAreaData) == 0x000014, "Wrong size on FSupportedAreaData");
static_assert(offsetof(FSupportedAreaData, AreaClassName) == 0x000000, "Member 'FSupportedAreaData::AreaClassName' has a wrong offset!");
static_assert(offsetof(FSupportedAreaData, AreaID) == 0x00000C, "Member 'FSupportedAreaData::AreaID' has a wrong offset!");
static_assert(offsetof(FSupportedAreaData, AreaClass) == 0x000010, "Member 'FSupportedAreaData::AreaClass' has a wrong offset!");

// ScriptStruct Engine.SubtitleCue
// 0x0010 (0x0010 - 0x0000)
struct FSubtitleCue final
{
public:
	class FText                                   TEXT;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubtitleCue) == 0x000004, "Wrong alignment on FSubtitleCue");
static_assert(sizeof(FSubtitleCue) == 0x000010, "Wrong size on FSubtitleCue");
static_assert(offsetof(FSubtitleCue, TEXT) == 0x000000, "Member 'FSubtitleCue::TEXT' has a wrong offset!");
static_assert(offsetof(FSubtitleCue, Time) == 0x00000C, "Member 'FSubtitleCue::Time' has a wrong offset!");

// ScriptStruct Engine.ModulatorContinuousParams
// 0x0020 (0x0020 - 0x0000)
struct FModulatorContinuousParams final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinInput;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInput;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOutput;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOutput;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModulationParamMode                          ParamMode;                                         // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FModulatorContinuousParams) == 0x000004, "Wrong alignment on FModulatorContinuousParams");
static_assert(sizeof(FModulatorContinuousParams) == 0x000020, "Wrong size on FModulatorContinuousParams");
static_assert(offsetof(FModulatorContinuousParams, ParameterName) == 0x000000, "Member 'FModulatorContinuousParams::ParameterName' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, Default) == 0x000008, "Member 'FModulatorContinuousParams::Default' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, MinInput) == 0x00000C, "Member 'FModulatorContinuousParams::MinInput' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, MaxInput) == 0x000010, "Member 'FModulatorContinuousParams::MaxInput' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, MinOutput) == 0x000014, "Member 'FModulatorContinuousParams::MinOutput' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, MaxOutput) == 0x000018, "Member 'FModulatorContinuousParams::MaxOutput' has a wrong offset!");
static_assert(offsetof(FModulatorContinuousParams, ParamMode) == 0x00001C, "Member 'FModulatorContinuousParams::ParamMode' has a wrong offset!");

// ScriptStruct Engine.CollectionParameterBase
// 0x0018 (0x0018 - 0x0000)
struct FCollectionParameterBase
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ID;                                                // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionParameterBase) == 0x000004, "Wrong alignment on FCollectionParameterBase");
static_assert(sizeof(FCollectionParameterBase) == 0x000018, "Wrong size on FCollectionParameterBase");
static_assert(offsetof(FCollectionParameterBase, ParameterName) == 0x000000, "Member 'FCollectionParameterBase::ParameterName' has a wrong offset!");
static_assert(offsetof(FCollectionParameterBase, ID) == 0x000008, "Member 'FCollectionParameterBase::ID' has a wrong offset!");

// ScriptStruct Engine.ExpressionOutput
// 0x0020 (0x0020 - 0x0000)
struct FExpressionOutput final
{
public:
	class FString                                 OutputName;                                        // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExpressionOutput) == 0x000004, "Wrong alignment on FExpressionOutput");
static_assert(sizeof(FExpressionOutput) == 0x000020, "Wrong size on FExpressionOutput");
static_assert(offsetof(FExpressionOutput, OutputName) == 0x000000, "Member 'FExpressionOutput::OutputName' has a wrong offset!");
static_assert(offsetof(FExpressionOutput, Mask) == 0x00000C, "Member 'FExpressionOutput::Mask' has a wrong offset!");
static_assert(offsetof(FExpressionOutput, MaskR) == 0x000010, "Member 'FExpressionOutput::MaskR' has a wrong offset!");
static_assert(offsetof(FExpressionOutput, MaskG) == 0x000014, "Member 'FExpressionOutput::MaskG' has a wrong offset!");
static_assert(offsetof(FExpressionOutput, MaskB) == 0x000018, "Member 'FExpressionOutput::MaskB' has a wrong offset!");
static_assert(offsetof(FExpressionOutput, MaskA) == 0x00001C, "Member 'FExpressionOutput::MaskA' has a wrong offset!");

// ScriptStruct Engine.ActiveForceFeedbackEffect
// 0x0014 (0x0014 - 0x0000)
struct FActiveForceFeedbackEffect final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x10];                                       // 0x0004(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveForceFeedbackEffect) == 0x000004, "Wrong alignment on FActiveForceFeedbackEffect");
static_assert(sizeof(FActiveForceFeedbackEffect) == 0x000014, "Wrong size on FActiveForceFeedbackEffect");
static_assert(offsetof(FActiveForceFeedbackEffect, ForceFeedbackEffect) == 0x000000, "Member 'FActiveForceFeedbackEffect::ForceFeedbackEffect' has a wrong offset!");

// ScriptStruct Engine.MaterialInput
// 0x002C (0x002C - 0x0000)
struct FMaterialInput
{
public:
	class UMaterialExpression*                    Expression;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InputName;                                         // 0x0008(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskR;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskG;                                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskB;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskA;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GCC64_Padding;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialInput) == 0x000004, "Wrong alignment on FMaterialInput");
static_assert(sizeof(FMaterialInput) == 0x00002C, "Wrong size on FMaterialInput");
static_assert(offsetof(FMaterialInput, Expression) == 0x000000, "Member 'FMaterialInput::Expression' has a wrong offset!");
static_assert(offsetof(FMaterialInput, OutputIndex) == 0x000004, "Member 'FMaterialInput::OutputIndex' has a wrong offset!");
static_assert(offsetof(FMaterialInput, InputName) == 0x000008, "Member 'FMaterialInput::InputName' has a wrong offset!");
static_assert(offsetof(FMaterialInput, Mask) == 0x000014, "Member 'FMaterialInput::Mask' has a wrong offset!");
static_assert(offsetof(FMaterialInput, MaskR) == 0x000018, "Member 'FMaterialInput::MaskR' has a wrong offset!");
static_assert(offsetof(FMaterialInput, MaskG) == 0x00001C, "Member 'FMaterialInput::MaskG' has a wrong offset!");
static_assert(offsetof(FMaterialInput, MaskB) == 0x000020, "Member 'FMaterialInput::MaskB' has a wrong offset!");
static_assert(offsetof(FMaterialInput, MaskA) == 0x000024, "Member 'FMaterialInput::MaskA' has a wrong offset!");
static_assert(offsetof(FMaterialInput, GCC64_Padding) == 0x000028, "Member 'FMaterialInput::GCC64_Padding' has a wrong offset!");

// ScriptStruct Engine.DirectoryPath
// 0x000C (0x000C - 0x0000)
struct FDirectoryPath final
{
public:
	class FString                                 Path;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectoryPath) == 0x000004, "Wrong alignment on FDirectoryPath");
static_assert(sizeof(FDirectoryPath) == 0x00000C, "Wrong size on FDirectoryPath");
static_assert(offsetof(FDirectoryPath, Path) == 0x000000, "Member 'FDirectoryPath::Path' has a wrong offset!");

// ScriptStruct Engine.DestructibleSpecialHierarchyDepths
// 0x0014 (0x0014 - 0x0000)
struct FDestructibleSpecialHierarchyDepths final
{
public:
	int32                                         SupportDepth;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumFractureDepth;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebris;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebrisDepth;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EssentialDepth;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleSpecialHierarchyDepths) == 0x000004, "Wrong alignment on FDestructibleSpecialHierarchyDepths");
static_assert(sizeof(FDestructibleSpecialHierarchyDepths) == 0x000014, "Wrong size on FDestructibleSpecialHierarchyDepths");
static_assert(offsetof(FDestructibleSpecialHierarchyDepths, SupportDepth) == 0x000000, "Member 'FDestructibleSpecialHierarchyDepths::SupportDepth' has a wrong offset!");
static_assert(offsetof(FDestructibleSpecialHierarchyDepths, MinimumFractureDepth) == 0x000004, "Member 'FDestructibleSpecialHierarchyDepths::MinimumFractureDepth' has a wrong offset!");
static_assert(offsetof(FDestructibleSpecialHierarchyDepths, bEnableDebris) == 0x000008, "Member 'FDestructibleSpecialHierarchyDepths::bEnableDebris' has a wrong offset!");
static_assert(offsetof(FDestructibleSpecialHierarchyDepths, DebrisDepth) == 0x00000C, "Member 'FDestructibleSpecialHierarchyDepths::DebrisDepth' has a wrong offset!");
static_assert(offsetof(FDestructibleSpecialHierarchyDepths, EssentialDepth) == 0x000010, "Member 'FDestructibleSpecialHierarchyDepths::EssentialDepth' has a wrong offset!");

// ScriptStruct Engine.ColorMaterialInput
// 0x0008 (0x0034 - 0x002C)
struct FColorMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Constant;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorMaterialInput) == 0x000004, "Wrong alignment on FColorMaterialInput");
static_assert(sizeof(FColorMaterialInput) == 0x000034, "Wrong size on FColorMaterialInput");
static_assert(offsetof(FColorMaterialInput, Constant) == 0x000030, "Member 'FColorMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.DestructibleDepthParameters
// 0x0001 (0x0001 - 0x0000)
struct FDestructibleDepthParameters final
{
public:
	EImpactDamageOverride                         ImpactDamageOverride;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleDepthParameters) == 0x000001, "Wrong alignment on FDestructibleDepthParameters");
static_assert(sizeof(FDestructibleDepthParameters) == 0x000001, "Wrong size on FDestructibleDepthParameters");
static_assert(offsetof(FDestructibleDepthParameters, ImpactDamageOverride) == 0x000000, "Member 'FDestructibleDepthParameters::ImpactDamageOverride' has a wrong offset!");

// ScriptStruct Engine.DebugDisplayProperty
// 0x0014 (0x0014 - 0x0000)
struct FDebugDisplayProperty final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    WithinClass;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugDisplayProperty) == 0x000004, "Wrong alignment on FDebugDisplayProperty");
static_assert(sizeof(FDebugDisplayProperty) == 0x000014, "Wrong size on FDebugDisplayProperty");
static_assert(offsetof(FDebugDisplayProperty, Obj) == 0x000000, "Member 'FDebugDisplayProperty::Obj' has a wrong offset!");
static_assert(offsetof(FDebugDisplayProperty, WithinClass) == 0x000004, "Member 'FDebugDisplayProperty::WithinClass' has a wrong offset!");

// ScriptStruct Engine.RichCurveKey
// 0x001C (0x001C - 0x0000)
struct FRichCurveKey final
{
public:
	ERichCurveInterpMode                          InterpMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentMode                         TangentMode;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveTangentWeightMode                   TangentWeightMode;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangent;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangentWeight;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangent;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangentWeight;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichCurveKey) == 0x000004, "Wrong alignment on FRichCurveKey");
static_assert(sizeof(FRichCurveKey) == 0x00001C, "Wrong size on FRichCurveKey");
static_assert(offsetof(FRichCurveKey, InterpMode) == 0x000000, "Member 'FRichCurveKey::InterpMode' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, TangentMode) == 0x000001, "Member 'FRichCurveKey::TangentMode' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, TangentWeightMode) == 0x000002, "Member 'FRichCurveKey::TangentWeightMode' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, Time) == 0x000004, "Member 'FRichCurveKey::Time' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, Value) == 0x000008, "Member 'FRichCurveKey::Value' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, ArriveTangent) == 0x00000C, "Member 'FRichCurveKey::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, ArriveTangentWeight) == 0x000010, "Member 'FRichCurveKey::ArriveTangentWeight' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, LeaveTangent) == 0x000014, "Member 'FRichCurveKey::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FRichCurveKey, LeaveTangentWeight) == 0x000018, "Member 'FRichCurveKey::LeaveTangentWeight' has a wrong offset!");

// ScriptStruct Engine.KeyHandleMap
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FKeyHandleMap final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyHandleMap) == 0x000004, "Wrong alignment on FKeyHandleMap");
static_assert(sizeof(FKeyHandleMap) == 0x00003C, "Wrong size on FKeyHandleMap");

// ScriptStruct Engine.IndexedCurve
// 0x0040 (0x0040 - 0x0000)
struct FIndexedCurve
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKeyHandleMap                          KeyHandlesToIndices;                               // 0x0004(0x003C)(Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FIndexedCurve) == 0x000004, "Wrong alignment on FIndexedCurve");
static_assert(sizeof(FIndexedCurve) == 0x000040, "Wrong size on FIndexedCurve");
static_assert(offsetof(FIndexedCurve, KeyHandlesToIndices) == 0x000004, "Member 'FIndexedCurve::KeyHandlesToIndices' has a wrong offset!");

// ScriptStruct Engine.RichCurve
// 0x0014 (0x0054 - 0x0040)
struct FRichCurve final : public FIndexedCurve
{
public:
	ERichCurveExtrapolation                       PreInfinityExtrap;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveExtrapolation                       PostInfinityExtrap;                                // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRichCurveKey>                  Keys;                                              // 0x0044(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichCurve) == 0x000004, "Wrong alignment on FRichCurve");
static_assert(sizeof(FRichCurve) == 0x000054, "Wrong size on FRichCurve");
static_assert(offsetof(FRichCurve, PreInfinityExtrap) == 0x000040, "Member 'FRichCurve::PreInfinityExtrap' has a wrong offset!");
static_assert(offsetof(FRichCurve, PostInfinityExtrap) == 0x000041, "Member 'FRichCurve::PostInfinityExtrap' has a wrong offset!");
static_assert(offsetof(FRichCurve, Keys) == 0x000044, "Member 'FRichCurve::Keys' has a wrong offset!");
static_assert(offsetof(FRichCurve, DefaultValue) == 0x000050, "Member 'FRichCurve::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.RuntimeFloatCurve
// 0x0058 (0x0058 - 0x0000)
struct FRuntimeFloatCurve final
{
public:
	struct FRichCurve                             EditorCurveData;                                   // 0x0000(0x0054)(NativeAccessSpecifierPublic)
	class UCurveFloat*                            ExternalCurve;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeFloatCurve) == 0x000004, "Wrong alignment on FRuntimeFloatCurve");
static_assert(sizeof(FRuntimeFloatCurve) == 0x000058, "Wrong size on FRuntimeFloatCurve");
static_assert(offsetof(FRuntimeFloatCurve, EditorCurveData) == 0x000000, "Member 'FRuntimeFloatCurve::EditorCurveData' has a wrong offset!");
static_assert(offsetof(FRuntimeFloatCurve, ExternalCurve) == 0x000054, "Member 'FRuntimeFloatCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Engine.SoundClassAdjuster
// 0x0014 (0x0014 - 0x0000)
struct FSoundClassAdjuster final
{
public:
	class USoundClass*                            SoundClassObject;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeAdjuster;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchAdjuster;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyToChildren : 1;                              // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VoiceCenterChannelVolumeAdjuster;                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundClassAdjuster) == 0x000004, "Wrong alignment on FSoundClassAdjuster");
static_assert(sizeof(FSoundClassAdjuster) == 0x000014, "Wrong size on FSoundClassAdjuster");
static_assert(offsetof(FSoundClassAdjuster, SoundClassObject) == 0x000000, "Member 'FSoundClassAdjuster::SoundClassObject' has a wrong offset!");
static_assert(offsetof(FSoundClassAdjuster, VolumeAdjuster) == 0x000004, "Member 'FSoundClassAdjuster::VolumeAdjuster' has a wrong offset!");
static_assert(offsetof(FSoundClassAdjuster, PitchAdjuster) == 0x000008, "Member 'FSoundClassAdjuster::PitchAdjuster' has a wrong offset!");
static_assert(offsetof(FSoundClassAdjuster, VoiceCenterChannelVolumeAdjuster) == 0x000010, "Member 'FSoundClassAdjuster::VoiceCenterChannelVolumeAdjuster' has a wrong offset!");

// ScriptStruct Engine.ClothPhysicsProperties
// 0x0050 (0x0050 - 0x0000)
struct FClothPhysicsProperties final
{
public:
	float                                         VerticalResistance;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalResistance;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BendResistance;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShearResistance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetherStiffness;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetherLimit;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StiffnessFrequency;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassScale;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaBlend;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionThickness;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionSquashScale;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelfCollisionStiffness;                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolverFrequency;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberCompression;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberExpansion;                                    // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiberResistance;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClothPhysicsProperties) == 0x000004, "Wrong alignment on FClothPhysicsProperties");
static_assert(sizeof(FClothPhysicsProperties) == 0x000050, "Wrong size on FClothPhysicsProperties");
static_assert(offsetof(FClothPhysicsProperties, VerticalResistance) == 0x000000, "Member 'FClothPhysicsProperties::VerticalResistance' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, HorizontalResistance) == 0x000004, "Member 'FClothPhysicsProperties::HorizontalResistance' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, BendResistance) == 0x000008, "Member 'FClothPhysicsProperties::BendResistance' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, ShearResistance) == 0x00000C, "Member 'FClothPhysicsProperties::ShearResistance' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, Friction) == 0x000010, "Member 'FClothPhysicsProperties::Friction' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, Damping) == 0x000014, "Member 'FClothPhysicsProperties::Damping' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, TetherStiffness) == 0x000018, "Member 'FClothPhysicsProperties::TetherStiffness' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, TetherLimit) == 0x00001C, "Member 'FClothPhysicsProperties::TetherLimit' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, Drag) == 0x000020, "Member 'FClothPhysicsProperties::Drag' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, StiffnessFrequency) == 0x000024, "Member 'FClothPhysicsProperties::StiffnessFrequency' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, GravityScale) == 0x000028, "Member 'FClothPhysicsProperties::GravityScale' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, MassScale) == 0x00002C, "Member 'FClothPhysicsProperties::MassScale' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, InertiaBlend) == 0x000030, "Member 'FClothPhysicsProperties::InertiaBlend' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, SelfCollisionThickness) == 0x000034, "Member 'FClothPhysicsProperties::SelfCollisionThickness' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, SelfCollisionSquashScale) == 0x000038, "Member 'FClothPhysicsProperties::SelfCollisionSquashScale' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, SelfCollisionStiffness) == 0x00003C, "Member 'FClothPhysicsProperties::SelfCollisionStiffness' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, SolverFrequency) == 0x000040, "Member 'FClothPhysicsProperties::SolverFrequency' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, FiberCompression) == 0x000044, "Member 'FClothPhysicsProperties::FiberCompression' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, FiberExpansion) == 0x000048, "Member 'FClothPhysicsProperties::FiberExpansion' has a wrong offset!");
static_assert(offsetof(FClothPhysicsProperties, FiberResistance) == 0x00004C, "Member 'FClothPhysicsProperties::FiberResistance' has a wrong offset!");

// ScriptStruct Engine.ScalarMaterialInput
// 0x0008 (0x0034 - 0x002C)
struct FScalarMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Constant;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScalarMaterialInput) == 0x000004, "Wrong alignment on FScalarMaterialInput");
static_assert(sizeof(FScalarMaterialInput) == 0x000034, "Wrong size on FScalarMaterialInput");
static_assert(offsetof(FScalarMaterialInput, Constant) == 0x000030, "Member 'FScalarMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.VectorMaterialInput
// 0x0010 (0x003C - 0x002C)
struct FVectorMaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Constant;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorMaterialInput) == 0x000004, "Wrong alignment on FVectorMaterialInput");
static_assert(sizeof(FVectorMaterialInput) == 0x00003C, "Wrong size on FVectorMaterialInput");
static_assert(offsetof(FVectorMaterialInput, Constant) == 0x000030, "Member 'FVectorMaterialInput::Constant' has a wrong offset!");

// ScriptStruct Engine.OrbitOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FOrbitOptions final
{
public:
	uint8                                         bProcessDuringSpawn : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bProcessDuringUpdate : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseEmitterTime : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOrbitOptions) == 0x000004, "Wrong alignment on FOrbitOptions");
static_assert(sizeof(FOrbitOptions) == 0x000004, "Wrong size on FOrbitOptions");

// ScriptStruct Engine.RawDistributionVector
// 0x000C (0x0028 - 0x001C)
struct FRawDistributionVector final : public FRawDistribution
{
public:
	float                                         MinValue;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxValue;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDistributionVector*                    Distribution;                                      // 0x0024(0x0004)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRawDistributionVector) == 0x000004, "Wrong alignment on FRawDistributionVector");
static_assert(sizeof(FRawDistributionVector) == 0x000028, "Wrong size on FRawDistributionVector");
static_assert(offsetof(FRawDistributionVector, MinValue) == 0x00001C, "Member 'FRawDistributionVector::MinValue' has a wrong offset!");
static_assert(offsetof(FRawDistributionVector, MaxValue) == 0x000020, "Member 'FRawDistributionVector::MaxValue' has a wrong offset!");
static_assert(offsetof(FRawDistributionVector, Distribution) == 0x000024, "Member 'FRawDistributionVector::Distribution' has a wrong offset!");

// ScriptStruct Engine.BoxElement2D
// 0x0014 (0x0014 - 0x0000)
struct FBoxElement2D final
{
public:
	struct FVector2D                              Center;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxElement2D) == 0x000004, "Wrong alignment on FBoxElement2D");
static_assert(sizeof(FBoxElement2D) == 0x000014, "Wrong size on FBoxElement2D");
static_assert(offsetof(FBoxElement2D, Center) == 0x000000, "Member 'FBoxElement2D::Center' has a wrong offset!");
static_assert(offsetof(FBoxElement2D, Width) == 0x000008, "Member 'FBoxElement2D::Width' has a wrong offset!");
static_assert(offsetof(FBoxElement2D, Height) == 0x00000C, "Member 'FBoxElement2D::Height' has a wrong offset!");
static_assert(offsetof(FBoxElement2D, Angle) == 0x000010, "Member 'FBoxElement2D::Angle' has a wrong offset!");

// ScriptStruct Engine.Vector2MaterialInput
// 0x000C (0x0038 - 0x002C)
struct FVector2MaterialInput final : public FMaterialInput
{
public:
	uint8                                         UseConstant : 1;                                   // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstantX;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantY;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector2MaterialInput) == 0x000004, "Wrong alignment on FVector2MaterialInput");
static_assert(sizeof(FVector2MaterialInput) == 0x000038, "Wrong size on FVector2MaterialInput");
static_assert(offsetof(FVector2MaterialInput, ConstantX) == 0x000030, "Member 'FVector2MaterialInput::ConstantX' has a wrong offset!");
static_assert(offsetof(FVector2MaterialInput, ConstantY) == 0x000034, "Member 'FVector2MaterialInput::ConstantY' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantize
// 0x0000 (0x000C - 0x000C)
struct FVector_NetQuantize final : public FVector
{
};
static_assert(alignof(FVector_NetQuantize) == 0x000004, "Wrong alignment on FVector_NetQuantize");
static_assert(sizeof(FVector_NetQuantize) == 0x00000C, "Wrong size on FVector_NetQuantize");

// ScriptStruct Engine.PoseLinkBase
// 0x000C (0x000C - 0x0000)
struct FPoseLinkBase
{
public:
	int32                                         LinkID;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPoseLinkBase) == 0x000004, "Wrong alignment on FPoseLinkBase");
static_assert(sizeof(FPoseLinkBase) == 0x00000C, "Wrong size on FPoseLinkBase");
static_assert(offsetof(FPoseLinkBase, LinkID) == 0x000000, "Member 'FPoseLinkBase::LinkID' has a wrong offset!");

// ScriptStruct Engine.PoseLink
// 0x0000 (0x000C - 0x000C)
struct FPoseLink final : public FPoseLinkBase
{
};
static_assert(alignof(FPoseLink) == 0x000004, "Wrong alignment on FPoseLink");
static_assert(sizeof(FPoseLink) == 0x00000C, "Wrong size on FPoseLink");

// ScriptStruct Engine.InputScaleBias
// 0x0008 (0x0008 - 0x0000)
struct FInputScaleBias final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputScaleBias) == 0x000004, "Wrong alignment on FInputScaleBias");
static_assert(sizeof(FInputScaleBias) == 0x000008, "Wrong size on FInputScaleBias");
static_assert(offsetof(FInputScaleBias, Scale) == 0x000000, "Member 'FInputScaleBias::Scale' has a wrong offset!");
static_assert(offsetof(FInputScaleBias, Bias) == 0x000004, "Member 'FInputScaleBias::Bias' has a wrong offset!");

// ScriptStruct Engine.ExposedValueCopyRecord
// 0x0030 (0x0030 - 0x0000)
struct FExposedValueCopyRecord final
{
public:
	class UProperty*                              SourceProperty;                                    // 0x0000(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourcePropertyName;                                // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSubPropertyName;                             // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceArrayIndex;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProperty*                              DestProperty;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DestArrayIndex;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPostCopyOperation                            PostCopyOperation;                                 // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0xB];                                       // 0x0025(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExposedValueCopyRecord) == 0x000004, "Wrong alignment on FExposedValueCopyRecord");
static_assert(sizeof(FExposedValueCopyRecord) == 0x000030, "Wrong size on FExposedValueCopyRecord");
static_assert(offsetof(FExposedValueCopyRecord, SourceProperty) == 0x000000, "Member 'FExposedValueCopyRecord::SourceProperty' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, SourcePropertyName) == 0x000004, "Member 'FExposedValueCopyRecord::SourcePropertyName' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, SourceSubPropertyName) == 0x00000C, "Member 'FExposedValueCopyRecord::SourceSubPropertyName' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, SourceArrayIndex) == 0x000014, "Member 'FExposedValueCopyRecord::SourceArrayIndex' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, DestProperty) == 0x000018, "Member 'FExposedValueCopyRecord::DestProperty' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, DestArrayIndex) == 0x00001C, "Member 'FExposedValueCopyRecord::DestArrayIndex' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, Size) == 0x000020, "Member 'FExposedValueCopyRecord::Size' has a wrong offset!");
static_assert(offsetof(FExposedValueCopyRecord, PostCopyOperation) == 0x000024, "Member 'FExposedValueCopyRecord::PostCopyOperation' has a wrong offset!");

// ScriptStruct Engine.ExposedValueHandler
// 0x001C (0x001C - 0x0000)
struct FExposedValueHandler final
{
public:
	class FName                                   BoundFunction;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FExposedValueCopyRecord>        CopyRecords;                                       // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x8];                                       // 0x0014(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExposedValueHandler) == 0x000004, "Wrong alignment on FExposedValueHandler");
static_assert(sizeof(FExposedValueHandler) == 0x00001C, "Wrong size on FExposedValueHandler");
static_assert(offsetof(FExposedValueHandler, BoundFunction) == 0x000000, "Member 'FExposedValueHandler::BoundFunction' has a wrong offset!");
static_assert(offsetof(FExposedValueHandler, CopyRecords) == 0x000008, "Member 'FExposedValueHandler::CopyRecords' has a wrong offset!");

// ScriptStruct Engine.AnimNode_Base
// 0x0020 (0x0020 - 0x0000)
struct FAnimNode_Base
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExposedValueHandler                   EvaluateGraphExposedInputs;                        // 0x0004(0x001C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_Base) == 0x000004, "Wrong alignment on FAnimNode_Base");
static_assert(sizeof(FAnimNode_Base) == 0x000020, "Wrong size on FAnimNode_Base");
static_assert(offsetof(FAnimNode_Base, EvaluateGraphExposedInputs) == 0x000004, "Member 'FAnimNode_Base::EvaluateGraphExposedInputs' has a wrong offset!");

// ScriptStruct Engine.AnimNode_ApplyMeshSpaceAdditive
// 0x0028 (0x0048 - 0x0020)
struct FAnimNode_ApplyMeshSpaceAdditive final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0020(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPoseLink                              Additive;                                          // 0x002C(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x003C(0x0008)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_ApplyMeshSpaceAdditive) == 0x000004, "Wrong alignment on FAnimNode_ApplyMeshSpaceAdditive");
static_assert(sizeof(FAnimNode_ApplyMeshSpaceAdditive) == 0x000048, "Wrong size on FAnimNode_ApplyMeshSpaceAdditive");
static_assert(offsetof(FAnimNode_ApplyMeshSpaceAdditive, Base) == 0x000020, "Member 'FAnimNode_ApplyMeshSpaceAdditive::Base' has a wrong offset!");
static_assert(offsetof(FAnimNode_ApplyMeshSpaceAdditive, Additive) == 0x00002C, "Member 'FAnimNode_ApplyMeshSpaceAdditive::Additive' has a wrong offset!");
static_assert(offsetof(FAnimNode_ApplyMeshSpaceAdditive, Alpha) == 0x000038, "Member 'FAnimNode_ApplyMeshSpaceAdditive::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_ApplyMeshSpaceAdditive, AlphaScaleBias) == 0x00003C, "Member 'FAnimNode_ApplyMeshSpaceAdditive::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FAnimNode_ApplyMeshSpaceAdditive, LODThreshold) == 0x000044, "Member 'FAnimNode_ApplyMeshSpaceAdditive::LODThreshold' has a wrong offset!");

// ScriptStruct Engine.TableRowBase
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FTableRowBase
{
};
#pragma pack(pop)
static_assert(alignof(FTableRowBase) == 0x000001, "Wrong alignment on FTableRowBase");
static_assert(sizeof(FTableRowBase) == 0x000001, "Wrong size on FTableRowBase");

// ScriptStruct Engine.DestructibleDebrisParameters
// 0x002C (0x002C - 0x0000)
struct FDestructibleDebrisParameters final
{
public:
	float                                         DebrisLifetimeMin;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLifetimeMax;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisMaxSeparationMin;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisMaxSeparationMax;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ValidBounds;                                       // 0x0010(0x001C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleDebrisParameters) == 0x000004, "Wrong alignment on FDestructibleDebrisParameters");
static_assert(sizeof(FDestructibleDebrisParameters) == 0x00002C, "Wrong size on FDestructibleDebrisParameters");
static_assert(offsetof(FDestructibleDebrisParameters, DebrisLifetimeMin) == 0x000000, "Member 'FDestructibleDebrisParameters::DebrisLifetimeMin' has a wrong offset!");
static_assert(offsetof(FDestructibleDebrisParameters, DebrisLifetimeMax) == 0x000004, "Member 'FDestructibleDebrisParameters::DebrisLifetimeMax' has a wrong offset!");
static_assert(offsetof(FDestructibleDebrisParameters, DebrisMaxSeparationMin) == 0x000008, "Member 'FDestructibleDebrisParameters::DebrisMaxSeparationMin' has a wrong offset!");
static_assert(offsetof(FDestructibleDebrisParameters, DebrisMaxSeparationMax) == 0x00000C, "Member 'FDestructibleDebrisParameters::DebrisMaxSeparationMax' has a wrong offset!");
static_assert(offsetof(FDestructibleDebrisParameters, ValidBounds) == 0x000010, "Member 'FDestructibleDebrisParameters::ValidBounds' has a wrong offset!");

// ScriptStruct Engine.CollisionResponseTemplate
// 0x0050 (0x0050 - 0x0000)
struct FCollisionResponseTemplate final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectTypeName;                                    // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResponseChannel>               CustomResponses;                                   // 0x0014(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 HelpMessage;                                       // 0x0020(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanModify;                                        // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x23];                                      // 0x002D(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollisionResponseTemplate) == 0x000004, "Wrong alignment on FCollisionResponseTemplate");
static_assert(sizeof(FCollisionResponseTemplate) == 0x000050, "Wrong size on FCollisionResponseTemplate");
static_assert(offsetof(FCollisionResponseTemplate, Name) == 0x000000, "Member 'FCollisionResponseTemplate::Name' has a wrong offset!");
static_assert(offsetof(FCollisionResponseTemplate, CollisionEnabled) == 0x000008, "Member 'FCollisionResponseTemplate::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(FCollisionResponseTemplate, ObjectTypeName) == 0x00000C, "Member 'FCollisionResponseTemplate::ObjectTypeName' has a wrong offset!");
static_assert(offsetof(FCollisionResponseTemplate, CustomResponses) == 0x000014, "Member 'FCollisionResponseTemplate::CustomResponses' has a wrong offset!");
static_assert(offsetof(FCollisionResponseTemplate, HelpMessage) == 0x000020, "Member 'FCollisionResponseTemplate::HelpMessage' has a wrong offset!");
static_assert(offsetof(FCollisionResponseTemplate, bCanModify) == 0x00002C, "Member 'FCollisionResponseTemplate::bCanModify' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantizeNormal
// 0x0000 (0x000C - 0x000C)
struct FVector_NetQuantizeNormal final : public FVector
{
};
static_assert(alignof(FVector_NetQuantizeNormal) == 0x000004, "Wrong alignment on FVector_NetQuantizeNormal");
static_assert(sizeof(FVector_NetQuantizeNormal) == 0x00000C, "Wrong size on FVector_NetQuantizeNormal");

// ScriptStruct Engine.HitResult
// 0x0080 (0x0080 - 0x0000)
struct FHitResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bStartPenetrating : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x000C(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0018(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0024(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ImpactNormal;                                      // 0x0030(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceStart;                                        // 0x003C(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    TraceEnd;                                          // 0x0048(0x000C)(NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       PhysMaterial;                                      // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0064(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x006C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0074(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceIndex;                                         // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitResult) == 0x000004, "Wrong alignment on FHitResult");
static_assert(sizeof(FHitResult) == 0x000080, "Wrong size on FHitResult");
static_assert(offsetof(FHitResult, Time) == 0x000004, "Member 'FHitResult::Time' has a wrong offset!");
static_assert(offsetof(FHitResult, Distance) == 0x000008, "Member 'FHitResult::Distance' has a wrong offset!");
static_assert(offsetof(FHitResult, Location) == 0x00000C, "Member 'FHitResult::Location' has a wrong offset!");
static_assert(offsetof(FHitResult, ImpactPoint) == 0x000018, "Member 'FHitResult::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FHitResult, Normal) == 0x000024, "Member 'FHitResult::Normal' has a wrong offset!");
static_assert(offsetof(FHitResult, ImpactNormal) == 0x000030, "Member 'FHitResult::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FHitResult, TraceStart) == 0x00003C, "Member 'FHitResult::TraceStart' has a wrong offset!");
static_assert(offsetof(FHitResult, TraceEnd) == 0x000048, "Member 'FHitResult::TraceEnd' has a wrong offset!");
static_assert(offsetof(FHitResult, PenetrationDepth) == 0x000054, "Member 'FHitResult::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(FHitResult, Item) == 0x000058, "Member 'FHitResult::Item' has a wrong offset!");
static_assert(offsetof(FHitResult, PhysMaterial) == 0x00005C, "Member 'FHitResult::PhysMaterial' has a wrong offset!");
static_assert(offsetof(FHitResult, Actor) == 0x000064, "Member 'FHitResult::Actor' has a wrong offset!");
static_assert(offsetof(FHitResult, Component) == 0x00006C, "Member 'FHitResult::Component' has a wrong offset!");
static_assert(offsetof(FHitResult, BoneName) == 0x000074, "Member 'FHitResult::BoneName' has a wrong offset!");
static_assert(offsetof(FHitResult, FaceIndex) == 0x00007C, "Member 'FHitResult::FaceIndex' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceSettings
// 0x0001 (0x0001 - 0x0000)
struct FRootMotionSourceSettings final
{
public:
	uint8                                         Flags;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionSourceSettings) == 0x000001, "Wrong alignment on FRootMotionSourceSettings");
static_assert(sizeof(FRootMotionSourceSettings) == 0x000001, "Wrong size on FRootMotionSourceSettings");
static_assert(offsetof(FRootMotionSourceSettings, Flags) == 0x000000, "Member 'FRootMotionSourceSettings::Flags' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceStatus
// 0x0001 (0x0001 - 0x0000)
struct FRootMotionSourceStatus final
{
public:
	uint8                                         Flags;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionSourceStatus) == 0x000001, "Wrong alignment on FRootMotionSourceStatus");
static_assert(sizeof(FRootMotionSourceStatus) == 0x000001, "Wrong size on FRootMotionSourceStatus");
static_assert(offsetof(FRootMotionSourceStatus, Flags) == 0x000000, "Member 'FRootMotionSourceStatus::Flags' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource
// 0x0080 (0x0080 - 0x0000)
struct FRootMotionSource
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Priority;                                          // 0x0010(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        LocalID;                                           // 0x0012(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionAccumulateMode                     AccumulateMode;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InstanceName;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousTime;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRootMotionSourceStatus                Status;                                            // 0x0030(0x0001)(NativeAccessSpecifierPublic)
	struct FRootMotionSourceSettings              Settings;                                          // 0x0031(0x0001)(NativeAccessSpecifierPublic)
	bool                                          bInLocalSpace;                                     // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bImpartsVelocityOnRemoval;                         // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionMovementParams              RootMotionParams;                                  // 0x0040(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionSource) == 0x000010, "Wrong alignment on FRootMotionSource");
static_assert(sizeof(FRootMotionSource) == 0x000080, "Wrong size on FRootMotionSource");
static_assert(offsetof(FRootMotionSource, Priority) == 0x000010, "Member 'FRootMotionSource::Priority' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, LocalID) == 0x000012, "Member 'FRootMotionSource::LocalID' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, AccumulateMode) == 0x000014, "Member 'FRootMotionSource::AccumulateMode' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, InstanceName) == 0x000018, "Member 'FRootMotionSource::InstanceName' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, StartTime) == 0x000020, "Member 'FRootMotionSource::StartTime' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, CurrentTime) == 0x000024, "Member 'FRootMotionSource::CurrentTime' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, PreviousTime) == 0x000028, "Member 'FRootMotionSource::PreviousTime' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, Duration) == 0x00002C, "Member 'FRootMotionSource::Duration' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, Status) == 0x000030, "Member 'FRootMotionSource::Status' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, Settings) == 0x000031, "Member 'FRootMotionSource::Settings' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, bInLocalSpace) == 0x000032, "Member 'FRootMotionSource::bInLocalSpace' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, bImpartsVelocityOnRemoval) == 0x000033, "Member 'FRootMotionSource::bImpartsVelocityOnRemoval' has a wrong offset!");
static_assert(offsetof(FRootMotionSource, RootMotionParams) == 0x000040, "Member 'FRootMotionSource::RootMotionParams' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_JumpForce
// 0x0030 (0x00B0 - 0x0080)
struct FRootMotionSource_JumpForce final : public FRootMotionSource
{
public:
	struct FRotator                               Rotation;                                          // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTimeout;                                   // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_JumpForce) == 0x000010, "Wrong alignment on FRootMotionSource_JumpForce");
static_assert(sizeof(FRootMotionSource_JumpForce) == 0x0000B0, "Wrong size on FRootMotionSource_JumpForce");
static_assert(offsetof(FRootMotionSource_JumpForce, Rotation) == 0x000080, "Member 'FRootMotionSource_JumpForce::Rotation' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_JumpForce, Distance) == 0x00008C, "Member 'FRootMotionSource_JumpForce::Distance' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_JumpForce, Height) == 0x000090, "Member 'FRootMotionSource_JumpForce::Height' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_JumpForce, bDisableTimeout) == 0x000094, "Member 'FRootMotionSource_JumpForce::bDisableTimeout' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_JumpForce, PathOffsetCurve) == 0x000098, "Member 'FRootMotionSource_JumpForce::PathOffsetCurve' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_JumpForce, TimeMappingCurve) == 0x00009C, "Member 'FRootMotionSource_JumpForce::TimeMappingCurve' has a wrong offset!");

// ScriptStruct Engine.URL
// 0x0050 (0x0050 - 0x0000)
struct FURL final
{
public:
	class FString                                 Protocol;                                          // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Host;                                              // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Map;                                               // 0x001C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RedirectURL;                                       // 0x0028(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Op;                                                // 0x0034(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Portal;                                            // 0x0040(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Valid;                                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FURL) == 0x000004, "Wrong alignment on FURL");
static_assert(sizeof(FURL) == 0x000050, "Wrong size on FURL");
static_assert(offsetof(FURL, Protocol) == 0x000000, "Member 'FURL::Protocol' has a wrong offset!");
static_assert(offsetof(FURL, Host) == 0x00000C, "Member 'FURL::Host' has a wrong offset!");
static_assert(offsetof(FURL, Port) == 0x000018, "Member 'FURL::Port' has a wrong offset!");
static_assert(offsetof(FURL, Map) == 0x00001C, "Member 'FURL::Map' has a wrong offset!");
static_assert(offsetof(FURL, RedirectURL) == 0x000028, "Member 'FURL::RedirectURL' has a wrong offset!");
static_assert(offsetof(FURL, Op) == 0x000034, "Member 'FURL::Op' has a wrong offset!");
static_assert(offsetof(FURL, Portal) == 0x000040, "Member 'FURL::Portal' has a wrong offset!");
static_assert(offsetof(FURL, Valid) == 0x00004C, "Member 'FURL::Valid' has a wrong offset!");

// ScriptStruct Engine.CanvasUVTri
// 0x0060 (0x0060 - 0x0000)
struct FCanvasUVTri final
{
public:
	struct FVector2D                              V0_Pos;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              V0_UV;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           V0_Color;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_Pos;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_UV;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           V1_Color;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_Pos;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_UV;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           V2_Color;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCanvasUVTri) == 0x000004, "Wrong alignment on FCanvasUVTri");
static_assert(sizeof(FCanvasUVTri) == 0x000060, "Wrong size on FCanvasUVTri");
static_assert(offsetof(FCanvasUVTri, V0_Pos) == 0x000000, "Member 'FCanvasUVTri::V0_Pos' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V0_UV) == 0x000008, "Member 'FCanvasUVTri::V0_UV' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V0_Color) == 0x000010, "Member 'FCanvasUVTri::V0_Color' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V1_Pos) == 0x000020, "Member 'FCanvasUVTri::V1_Pos' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V1_UV) == 0x000028, "Member 'FCanvasUVTri::V1_UV' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V1_Color) == 0x000030, "Member 'FCanvasUVTri::V1_Color' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V2_Pos) == 0x000040, "Member 'FCanvasUVTri::V2_Pos' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V2_UV) == 0x000048, "Member 'FCanvasUVTri::V2_UV' has a wrong offset!");
static_assert(offsetof(FCanvasUVTri, V2_Color) == 0x000050, "Member 'FCanvasUVTri::V2_Color' has a wrong offset!");

// ScriptStruct Engine.GenericStruct
// 0x0004 (0x0004 - 0x0000)
struct FGenericStruct final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenericStruct) == 0x000004, "Wrong alignment on FGenericStruct");
static_assert(sizeof(FGenericStruct) == 0x000004, "Wrong size on FGenericStruct");
static_assert(offsetof(FGenericStruct, Data) == 0x000000, "Member 'FGenericStruct::Data' has a wrong offset!");

// ScriptStruct Engine.NavigationFilterArea
// 0x0010 (0x0010 - 0x0000)
struct FNavigationFilterArea final
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelCostOverride;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnteringCostOverride;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsExcluded : 1;                                   // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideTravelCost : 1;                           // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideEnteringCost : 1;                         // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationFilterArea) == 0x000004, "Wrong alignment on FNavigationFilterArea");
static_assert(sizeof(FNavigationFilterArea) == 0x000010, "Wrong size on FNavigationFilterArea");
static_assert(offsetof(FNavigationFilterArea, AreaClass) == 0x000000, "Member 'FNavigationFilterArea::AreaClass' has a wrong offset!");
static_assert(offsetof(FNavigationFilterArea, TravelCostOverride) == 0x000004, "Member 'FNavigationFilterArea::TravelCostOverride' has a wrong offset!");
static_assert(offsetof(FNavigationFilterArea, EnteringCostOverride) == 0x000008, "Member 'FNavigationFilterArea::EnteringCostOverride' has a wrong offset!");

// ScriptStruct Engine.MaterialProxySettings
// 0x0064 (0x0064 - 0x0000)
struct FMaterialProxySettings final
{
public:
	struct FIntPoint                              TextureSize;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ETextureSizingType                            TextureSizingType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GutterSpace;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalMap;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMetallicMap;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MetallicConstant;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoughnessMap;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoughnessConstant;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecularMap;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpecularConstant;                                  // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmissiveMap;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOpacityMap;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              DiffuseTextureSize;                                // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              NormalTextureSize;                                 // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              MetallicTextureSize;                               // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              RoughnessTextureSize;                              // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              SpecularTextureSize;                               // 0x004C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              EmissiveTextureSize;                               // 0x0054(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FIntPoint                              OpacityTextureSize;                                // 0x005C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialProxySettings) == 0x000004, "Wrong alignment on FMaterialProxySettings");
static_assert(sizeof(FMaterialProxySettings) == 0x000064, "Wrong size on FMaterialProxySettings");
static_assert(offsetof(FMaterialProxySettings, TextureSize) == 0x000000, "Member 'FMaterialProxySettings::TextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, TextureSizingType) == 0x000008, "Member 'FMaterialProxySettings::TextureSizingType' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, GutterSpace) == 0x00000C, "Member 'FMaterialProxySettings::GutterSpace' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bNormalMap) == 0x000010, "Member 'FMaterialProxySettings::bNormalMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bMetallicMap) == 0x000011, "Member 'FMaterialProxySettings::bMetallicMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, MetallicConstant) == 0x000014, "Member 'FMaterialProxySettings::MetallicConstant' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bRoughnessMap) == 0x000018, "Member 'FMaterialProxySettings::bRoughnessMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, RoughnessConstant) == 0x00001C, "Member 'FMaterialProxySettings::RoughnessConstant' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bSpecularMap) == 0x000020, "Member 'FMaterialProxySettings::bSpecularMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, SpecularConstant) == 0x000024, "Member 'FMaterialProxySettings::SpecularConstant' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bEmissiveMap) == 0x000028, "Member 'FMaterialProxySettings::bEmissiveMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, bOpacityMap) == 0x000029, "Member 'FMaterialProxySettings::bOpacityMap' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, DiffuseTextureSize) == 0x00002C, "Member 'FMaterialProxySettings::DiffuseTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, NormalTextureSize) == 0x000034, "Member 'FMaterialProxySettings::NormalTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, MetallicTextureSize) == 0x00003C, "Member 'FMaterialProxySettings::MetallicTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, RoughnessTextureSize) == 0x000044, "Member 'FMaterialProxySettings::RoughnessTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, SpecularTextureSize) == 0x00004C, "Member 'FMaterialProxySettings::SpecularTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, EmissiveTextureSize) == 0x000054, "Member 'FMaterialProxySettings::EmissiveTextureSize' has a wrong offset!");
static_assert(offsetof(FMaterialProxySettings, OpacityTextureSize) == 0x00005C, "Member 'FMaterialProxySettings::OpacityTextureSize' has a wrong offset!");

// ScriptStruct Engine.MaterialSimplificationSettings
// 0x0044 (0x0044 - 0x0000)
struct FMaterialSimplificationSettings final
{
public:
	struct FIntPoint                              BaseColorMapSize;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNormalMap;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              NormalMapSize;                                     // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MetallicConstant;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMetallicMap;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              MetallicMapSize;                                   // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RoughnessConstant;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoughnessMap;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              RoughnessMapSize;                                  // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpecularConstant;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecularMap;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              SpecularMapSize;                                   // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSimplificationSettings) == 0x000004, "Wrong alignment on FMaterialSimplificationSettings");
static_assert(sizeof(FMaterialSimplificationSettings) == 0x000044, "Wrong size on FMaterialSimplificationSettings");
static_assert(offsetof(FMaterialSimplificationSettings, BaseColorMapSize) == 0x000000, "Member 'FMaterialSimplificationSettings::BaseColorMapSize' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, bNormalMap) == 0x000008, "Member 'FMaterialSimplificationSettings::bNormalMap' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, NormalMapSize) == 0x00000C, "Member 'FMaterialSimplificationSettings::NormalMapSize' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, MetallicConstant) == 0x000014, "Member 'FMaterialSimplificationSettings::MetallicConstant' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, bMetallicMap) == 0x000018, "Member 'FMaterialSimplificationSettings::bMetallicMap' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, MetallicMapSize) == 0x00001C, "Member 'FMaterialSimplificationSettings::MetallicMapSize' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, RoughnessConstant) == 0x000024, "Member 'FMaterialSimplificationSettings::RoughnessConstant' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, bRoughnessMap) == 0x000028, "Member 'FMaterialSimplificationSettings::bRoughnessMap' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, RoughnessMapSize) == 0x00002C, "Member 'FMaterialSimplificationSettings::RoughnessMapSize' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, SpecularConstant) == 0x000034, "Member 'FMaterialSimplificationSettings::SpecularConstant' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, bSpecularMap) == 0x000038, "Member 'FMaterialSimplificationSettings::bSpecularMap' has a wrong offset!");
static_assert(offsetof(FMaterialSimplificationSettings, SpecularMapSize) == 0x00003C, "Member 'FMaterialSimplificationSettings::SpecularMapSize' has a wrong offset!");

// ScriptStruct Engine.MeshProxySettings
// 0x00D4 (0x00D4 - 0x0000)
struct FMeshProxySettings final
{
public:
	int32                                         ScreenSize;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 MaterialSettings;                                  // 0x0004(0x0064)(Edit, NativeAccessSpecifierPublic)
	int32                                         TextureWidth;                                      // 0x0068(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureHeight;                                     // 0x006C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportNormalMap;                                  // 0x0070(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportMetallicMap;                                // 0x0071(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportRoughnessMap;                               // 0x0072(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportSpecularMap;                                // 0x0073(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMaterialSimplificationSettings        Material;                                          // 0x0074(0x0044)(Deprecated, NativeAccessSpecifierPublic)
	float                                         MergeDistance;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardAngleThreshold;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMapResolution;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalculateNormals;                               // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseClippingPlane;                                 // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClippingLevel;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AxisIndex;                                         // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaneNegativeHalfspace;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBakeVertexData;                                   // 0x00D1(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshProxySettings) == 0x000004, "Wrong alignment on FMeshProxySettings");
static_assert(sizeof(FMeshProxySettings) == 0x0000D4, "Wrong size on FMeshProxySettings");
static_assert(offsetof(FMeshProxySettings, ScreenSize) == 0x000000, "Member 'FMeshProxySettings::ScreenSize' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, MaterialSettings) == 0x000004, "Member 'FMeshProxySettings::MaterialSettings' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, TextureWidth) == 0x000068, "Member 'FMeshProxySettings::TextureWidth' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, TextureHeight) == 0x00006C, "Member 'FMeshProxySettings::TextureHeight' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bExportNormalMap) == 0x000070, "Member 'FMeshProxySettings::bExportNormalMap' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bExportMetallicMap) == 0x000071, "Member 'FMeshProxySettings::bExportMetallicMap' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bExportRoughnessMap) == 0x000072, "Member 'FMeshProxySettings::bExportRoughnessMap' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bExportSpecularMap) == 0x000073, "Member 'FMeshProxySettings::bExportSpecularMap' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, Material) == 0x000074, "Member 'FMeshProxySettings::Material' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, MergeDistance) == 0x0000B8, "Member 'FMeshProxySettings::MergeDistance' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, HardAngleThreshold) == 0x0000BC, "Member 'FMeshProxySettings::HardAngleThreshold' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, LightMapResolution) == 0x0000C0, "Member 'FMeshProxySettings::LightMapResolution' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bRecalculateNormals) == 0x0000C4, "Member 'FMeshProxySettings::bRecalculateNormals' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bUseClippingPlane) == 0x0000C5, "Member 'FMeshProxySettings::bUseClippingPlane' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, ClippingLevel) == 0x0000C8, "Member 'FMeshProxySettings::ClippingLevel' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, AxisIndex) == 0x0000CC, "Member 'FMeshProxySettings::AxisIndex' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bPlaneNegativeHalfspace) == 0x0000D0, "Member 'FMeshProxySettings::bPlaneNegativeHalfspace' has a wrong offset!");
static_assert(offsetof(FMeshProxySettings, bBakeVertexData) == 0x0000D1, "Member 'FMeshProxySettings::bBakeVertexData' has a wrong offset!");

// ScriptStruct Engine.InterpControlPoint
// 0x001C (0x001C - 0x0000)
struct FInterpControlPoint final
{
public:
	struct FVector                                PositionControlPoint;                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPositionIsRelative;                               // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0xF];                                        // 0x000D(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpControlPoint) == 0x000004, "Wrong alignment on FInterpControlPoint");
static_assert(sizeof(FInterpControlPoint) == 0x00001C, "Wrong size on FInterpControlPoint");
static_assert(offsetof(FInterpControlPoint, PositionControlPoint) == 0x000000, "Member 'FInterpControlPoint::PositionControlPoint' has a wrong offset!");
static_assert(offsetof(FInterpControlPoint, bPositionIsRelative) == 0x00000C, "Member 'FInterpControlPoint::bPositionIsRelative' has a wrong offset!");

// ScriptStruct Engine.DepthFieldGlowInfo
// 0x0024 (0x0024 - 0x0000)
struct FDepthFieldGlowInfo final
{
public:
	uint8                                         bEnableGlow : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           GlowColor;                                         // 0x0004(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              GlowOuterRadius;                                   // 0x0014(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              GlowInnerRadius;                                   // 0x001C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDepthFieldGlowInfo) == 0x000004, "Wrong alignment on FDepthFieldGlowInfo");
static_assert(sizeof(FDepthFieldGlowInfo) == 0x000024, "Wrong size on FDepthFieldGlowInfo");
static_assert(offsetof(FDepthFieldGlowInfo, GlowColor) == 0x000004, "Member 'FDepthFieldGlowInfo::GlowColor' has a wrong offset!");
static_assert(offsetof(FDepthFieldGlowInfo, GlowOuterRadius) == 0x000014, "Member 'FDepthFieldGlowInfo::GlowOuterRadius' has a wrong offset!");
static_assert(offsetof(FDepthFieldGlowInfo, GlowInnerRadius) == 0x00001C, "Member 'FDepthFieldGlowInfo::GlowInnerRadius' has a wrong offset!");

// ScriptStruct Engine.FontRenderInfo
// 0x0028 (0x0028 - 0x0000)
struct FFontRenderInfo final
{
public:
	uint8                                         bClipText : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableShadow : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDepthFieldGlowInfo                    GlowInfo;                                          // 0x0004(0x0024)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontRenderInfo) == 0x000004, "Wrong alignment on FFontRenderInfo");
static_assert(sizeof(FFontRenderInfo) == 0x000028, "Wrong size on FFontRenderInfo");
static_assert(offsetof(FFontRenderInfo, GlowInfo) == 0x000004, "Member 'FFontRenderInfo::GlowInfo' has a wrong offset!");

// ScriptStruct Engine.CollectionScalarParameter
// 0x0004 (0x001C - 0x0018)
struct FCollectionScalarParameter final : public FCollectionParameterBase
{
public:
	float                                         DefaultValue;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionScalarParameter) == 0x000004, "Wrong alignment on FCollectionScalarParameter");
static_assert(sizeof(FCollectionScalarParameter) == 0x00001C, "Wrong size on FCollectionScalarParameter");
static_assert(offsetof(FCollectionScalarParameter, DefaultValue) == 0x000018, "Member 'FCollectionScalarParameter::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.AnimCurveBase
// 0x0014 (0x0014 - 0x0000)
struct FAnimCurveBase
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastObservedName;                                  // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurveTypeFlags;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimCurveBase) == 0x000004, "Wrong alignment on FAnimCurveBase");
static_assert(sizeof(FAnimCurveBase) == 0x000014, "Wrong size on FAnimCurveBase");
static_assert(offsetof(FAnimCurveBase, LastObservedName) == 0x000004, "Member 'FAnimCurveBase::LastObservedName' has a wrong offset!");
static_assert(offsetof(FAnimCurveBase, CurveTypeFlags) == 0x000010, "Member 'FAnimCurveBase::CurveTypeFlags' has a wrong offset!");

// ScriptStruct Engine.FloatCurve
// 0x0054 (0x0068 - 0x0014)
struct FFloatCurve final : public FAnimCurveBase
{
public:
	struct FRichCurve                             FloatCurve;                                        // 0x0014(0x0054)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatCurve) == 0x000004, "Wrong alignment on FFloatCurve");
static_assert(sizeof(FFloatCurve) == 0x000068, "Wrong size on FFloatCurve");
static_assert(offsetof(FFloatCurve, FloatCurve) == 0x000014, "Member 'FFloatCurve::FloatCurve' has a wrong offset!");

// ScriptStruct Engine.RawCurveTracks
// 0x000C (0x000C - 0x0000)
struct FRawCurveTracks final
{
public:
	TArray<struct FFloatCurve>                    FloatCurves;                                       // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRawCurveTracks) == 0x000004, "Wrong alignment on FRawCurveTracks");
static_assert(sizeof(FRawCurveTracks) == 0x00000C, "Wrong size on FRawCurveTracks");
static_assert(offsetof(FRawCurveTracks, FloatCurves) == 0x000000, "Member 'FRawCurveTracks::FloatCurves' has a wrong offset!");

// ScriptStruct Engine.PlatformInterfaceData
// 0x0024 (0x0024 - 0x0000)
struct FPlatformInterfaceData final
{
public:
	class FName                                   DataName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlatformInterfaceDataType                    Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntValue;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringValue;                                       // 0x0014(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ObjectValue;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformInterfaceData) == 0x000004, "Wrong alignment on FPlatformInterfaceData");
static_assert(sizeof(FPlatformInterfaceData) == 0x000024, "Wrong size on FPlatformInterfaceData");
static_assert(offsetof(FPlatformInterfaceData, DataName) == 0x000000, "Member 'FPlatformInterfaceData::DataName' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceData, Type) == 0x000008, "Member 'FPlatformInterfaceData::Type' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceData, IntValue) == 0x00000C, "Member 'FPlatformInterfaceData::IntValue' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceData, FloatValue) == 0x000010, "Member 'FPlatformInterfaceData::FloatValue' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceData, StringValue) == 0x000014, "Member 'FPlatformInterfaceData::StringValue' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceData, ObjectValue) == 0x000020, "Member 'FPlatformInterfaceData::ObjectValue' has a wrong offset!");

// ScriptStruct Engine.PlatformInterfaceDelegateResult
// 0x0028 (0x0028 - 0x0000)
struct FPlatformInterfaceDelegateResult final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlatformInterfaceData                 Data;                                              // 0x0004(0x0024)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlatformInterfaceDelegateResult) == 0x000004, "Wrong alignment on FPlatformInterfaceDelegateResult");
static_assert(sizeof(FPlatformInterfaceDelegateResult) == 0x000028, "Wrong size on FPlatformInterfaceDelegateResult");
static_assert(offsetof(FPlatformInterfaceDelegateResult, bSuccessful) == 0x000000, "Member 'FPlatformInterfaceDelegateResult::bSuccessful' has a wrong offset!");
static_assert(offsetof(FPlatformInterfaceDelegateResult, Data) == 0x000004, "Member 'FPlatformInterfaceDelegateResult::Data' has a wrong offset!");

// ScriptStruct Engine.AssetEditorOrbitCameraPosition
// 0x0028 (0x0028 - 0x0000)
struct FAssetEditorOrbitCameraPosition final
{
public:
	bool                                          bIsSet;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CamOrbitPoint;                                     // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CamOrbitZoom;                                      // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CamOrbitRotation;                                  // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetEditorOrbitCameraPosition) == 0x000004, "Wrong alignment on FAssetEditorOrbitCameraPosition");
static_assert(sizeof(FAssetEditorOrbitCameraPosition) == 0x000028, "Wrong size on FAssetEditorOrbitCameraPosition");
static_assert(offsetof(FAssetEditorOrbitCameraPosition, bIsSet) == 0x000000, "Member 'FAssetEditorOrbitCameraPosition::bIsSet' has a wrong offset!");
static_assert(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitPoint) == 0x000004, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitPoint' has a wrong offset!");
static_assert(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitZoom) == 0x000010, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitZoom' has a wrong offset!");
static_assert(offsetof(FAssetEditorOrbitCameraPosition, CamOrbitRotation) == 0x00001C, "Member 'FAssetEditorOrbitCameraPosition::CamOrbitRotation' has a wrong offset!");

// ScriptStruct Engine.DebugFloatHistory
// 0x001C (0x001C - 0x0000)
struct FDebugFloatHistory final
{
public:
	TArray<float>                                 Samples;                                           // 0x0000(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         MaxSamples;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAdjustMinMax;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugFloatHistory) == 0x000004, "Wrong alignment on FDebugFloatHistory");
static_assert(sizeof(FDebugFloatHistory) == 0x00001C, "Wrong size on FDebugFloatHistory");
static_assert(offsetof(FDebugFloatHistory, Samples) == 0x000000, "Member 'FDebugFloatHistory::Samples' has a wrong offset!");
static_assert(offsetof(FDebugFloatHistory, MaxSamples) == 0x00000C, "Member 'FDebugFloatHistory::MaxSamples' has a wrong offset!");
static_assert(offsetof(FDebugFloatHistory, MinValue) == 0x000010, "Member 'FDebugFloatHistory::MinValue' has a wrong offset!");
static_assert(offsetof(FDebugFloatHistory, MaxValue) == 0x000014, "Member 'FDebugFloatHistory::MaxValue' has a wrong offset!");
static_assert(offsetof(FDebugFloatHistory, bAutoAdjustMinMax) == 0x000018, "Member 'FDebugFloatHistory::bAutoAdjustMinMax' has a wrong offset!");

// ScriptStruct Engine.LatentActionInfo
// 0x0014 (0x0014 - 0x0000)
struct FLatentActionInfo final
{
public:
	int32                                         Linkage;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UUID;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExecutionFunction;                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CallbackTarget;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLatentActionInfo) == 0x000004, "Wrong alignment on FLatentActionInfo");
static_assert(sizeof(FLatentActionInfo) == 0x000014, "Wrong size on FLatentActionInfo");
static_assert(offsetof(FLatentActionInfo, Linkage) == 0x000000, "Member 'FLatentActionInfo::Linkage' has a wrong offset!");
static_assert(offsetof(FLatentActionInfo, UUID) == 0x000004, "Member 'FLatentActionInfo::UUID' has a wrong offset!");
static_assert(offsetof(FLatentActionInfo, ExecutionFunction) == 0x000008, "Member 'FLatentActionInfo::ExecutionFunction' has a wrong offset!");
static_assert(offsetof(FLatentActionInfo, CallbackTarget) == 0x000010, "Member 'FLatentActionInfo::CallbackTarget' has a wrong offset!");

// ScriptStruct Engine.FOscillator
// 0x000C (0x000C - 0x0000)
struct FFOscillator final
{
public:
	float                                         Amplitude;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInitialOscillatorOffset                      InitialOffset;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFOscillator) == 0x000004, "Wrong alignment on FFOscillator");
static_assert(sizeof(FFOscillator) == 0x00000C, "Wrong size on FFOscillator");
static_assert(offsetof(FFOscillator, Amplitude) == 0x000000, "Member 'FFOscillator::Amplitude' has a wrong offset!");
static_assert(offsetof(FFOscillator, Frequency) == 0x000004, "Member 'FFOscillator::Frequency' has a wrong offset!");
static_assert(offsetof(FFOscillator, InitialOffset) == 0x000008, "Member 'FFOscillator::InitialOffset' has a wrong offset!");

// ScriptStruct Engine.ROscillator
// 0x0024 (0x0024 - 0x0000)
struct FROscillator final
{
public:
	struct FFOscillator                           Pitch;                                             // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFOscillator                           Yaw;                                               // 0x000C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFOscillator                           Roll;                                              // 0x0018(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FROscillator) == 0x000004, "Wrong alignment on FROscillator");
static_assert(sizeof(FROscillator) == 0x000024, "Wrong size on FROscillator");
static_assert(offsetof(FROscillator, Pitch) == 0x000000, "Member 'FROscillator::Pitch' has a wrong offset!");
static_assert(offsetof(FROscillator, Yaw) == 0x00000C, "Member 'FROscillator::Yaw' has a wrong offset!");
static_assert(offsetof(FROscillator, Roll) == 0x000018, "Member 'FROscillator::Roll' has a wrong offset!");

// ScriptStruct Engine.TimerHandle
// 0x0004 (0x0004 - 0x0000)
struct FTimerHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTimerHandle) == 0x000004, "Wrong alignment on FTimerHandle");
static_assert(sizeof(FTimerHandle) == 0x000004, "Wrong size on FTimerHandle");
static_assert(offsetof(FTimerHandle, Handle) == 0x000000, "Member 'FTimerHandle::Handle' has a wrong offset!");

// ScriptStruct Engine.TouchInputControl
// 0x0050 (0x0050 - 0x0000)
struct FTouchInputControl final
{
public:
	class UTexture2D*                             Image1;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Image2;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Center;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              VisualSize;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ThumbSize;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InteractionSize;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InputScale;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FKey                                   MainInputKey;                                      // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FKey                                   AltInputKey;                                       // 0x0040(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTouchInputControl) == 0x000004, "Wrong alignment on FTouchInputControl");
static_assert(sizeof(FTouchInputControl) == 0x000050, "Wrong size on FTouchInputControl");
static_assert(offsetof(FTouchInputControl, Image1) == 0x000000, "Member 'FTouchInputControl::Image1' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, Image2) == 0x000004, "Member 'FTouchInputControl::Image2' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, Center) == 0x000008, "Member 'FTouchInputControl::Center' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, VisualSize) == 0x000010, "Member 'FTouchInputControl::VisualSize' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, ThumbSize) == 0x000018, "Member 'FTouchInputControl::ThumbSize' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, InteractionSize) == 0x000020, "Member 'FTouchInputControl::InteractionSize' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, InputScale) == 0x000028, "Member 'FTouchInputControl::InputScale' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, MainInputKey) == 0x000030, "Member 'FTouchInputControl::MainInputKey' has a wrong offset!");
static_assert(offsetof(FTouchInputControl, AltInputKey) == 0x000040, "Member 'FTouchInputControl::AltInputKey' has a wrong offset!");

// ScriptStruct Engine.AnimTickRecord
// 0x0030 (0x0030 - 0x0000)
struct FAnimTickRecord final
{
public:
	class UAnimationAsset*                        SourceAsset;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x2C];                                       // 0x0004(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimTickRecord) == 0x000004, "Wrong alignment on FAnimTickRecord");
static_assert(sizeof(FAnimTickRecord) == 0x000030, "Wrong size on FAnimTickRecord");
static_assert(offsetof(FAnimTickRecord, SourceAsset) == 0x000000, "Member 'FAnimTickRecord::SourceAsset' has a wrong offset!");

// ScriptStruct Engine.NavGraphEdge
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FNavGraphEdge final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavGraphEdge) == 0x000004, "Wrong alignment on FNavGraphEdge");
static_assert(sizeof(FNavGraphEdge) == 0x00000C, "Wrong size on FNavGraphEdge");

// ScriptStruct Engine.BlendFilter
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FBlendFilter final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendFilter) == 0x000004, "Wrong alignment on FBlendFilter");
static_assert(sizeof(FBlendFilter) == 0x00006C, "Wrong size on FBlendFilter");

// ScriptStruct Engine.LevelViewportInfo
// 0x0020 (0x0020 - 0x0000)
struct FLevelViewportInfo final
{
public:
	struct FVector                                CamPosition;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CamRotation;                                       // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CamOrthoZoom;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CamUpdated;                                        // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelViewportInfo) == 0x000004, "Wrong alignment on FLevelViewportInfo");
static_assert(sizeof(FLevelViewportInfo) == 0x000020, "Wrong size on FLevelViewportInfo");
static_assert(offsetof(FLevelViewportInfo, CamPosition) == 0x000000, "Member 'FLevelViewportInfo::CamPosition' has a wrong offset!");
static_assert(offsetof(FLevelViewportInfo, CamRotation) == 0x00000C, "Member 'FLevelViewportInfo::CamRotation' has a wrong offset!");
static_assert(offsetof(FLevelViewportInfo, CamOrthoZoom) == 0x000018, "Member 'FLevelViewportInfo::CamOrthoZoom' has a wrong offset!");
static_assert(offsetof(FLevelViewportInfo, CamUpdated) == 0x00001C, "Member 'FLevelViewportInfo::CamUpdated' has a wrong offset!");

// ScriptStruct Engine.CollisionProfileName
// 0x0008 (0x0008 - 0x0000)
struct FCollisionProfileName final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollisionProfileName) == 0x000004, "Wrong alignment on FCollisionProfileName");
static_assert(sizeof(FCollisionProfileName) == 0x000008, "Wrong size on FCollisionProfileName");
static_assert(offsetof(FCollisionProfileName, Name) == 0x000000, "Member 'FCollisionProfileName::Name' has a wrong offset!");

// ScriptStruct Engine.EdGraphSchemaAction
// 0x0078 (0x0078 - 0x0000)
struct FEdGraphSchemaAction
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MenuDescription;                                   // 0x0004(0x000C)(NativeAccessSpecifierPrivate)
	class FString                                 TooltipDescription;                                // 0x0010(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   Category;                                          // 0x001C(0x000C)(NativeAccessSpecifierPrivate)
	class FText                                   Keywords;                                          // 0x0028(0x000C)(NativeAccessSpecifierPrivate)
	int32                                         Grouping;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionID;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MenuDescriptionArray;                              // 0x003C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchTitlesArray;                             // 0x0048(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchKeywordsArray;                           // 0x0054(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FullSearchCategoryArray;                           // 0x0060(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SearchText;                                        // 0x006C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEdGraphSchemaAction) == 0x000004, "Wrong alignment on FEdGraphSchemaAction");
static_assert(sizeof(FEdGraphSchemaAction) == 0x000078, "Wrong size on FEdGraphSchemaAction");
static_assert(offsetof(FEdGraphSchemaAction, MenuDescription) == 0x000004, "Member 'FEdGraphSchemaAction::MenuDescription' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, TooltipDescription) == 0x000010, "Member 'FEdGraphSchemaAction::TooltipDescription' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, Category) == 0x00001C, "Member 'FEdGraphSchemaAction::Category' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, Keywords) == 0x000028, "Member 'FEdGraphSchemaAction::Keywords' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, Grouping) == 0x000034, "Member 'FEdGraphSchemaAction::Grouping' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, SectionID) == 0x000038, "Member 'FEdGraphSchemaAction::SectionID' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, MenuDescriptionArray) == 0x00003C, "Member 'FEdGraphSchemaAction::MenuDescriptionArray' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, FullSearchTitlesArray) == 0x000048, "Member 'FEdGraphSchemaAction::FullSearchTitlesArray' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, FullSearchKeywordsArray) == 0x000054, "Member 'FEdGraphSchemaAction::FullSearchKeywordsArray' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, FullSearchCategoryArray) == 0x000060, "Member 'FEdGraphSchemaAction::FullSearchCategoryArray' has a wrong offset!");
static_assert(offsetof(FEdGraphSchemaAction, SearchText) == 0x00006C, "Member 'FEdGraphSchemaAction::SearchText' has a wrong offset!");

// ScriptStruct Engine.EdGraphSchemaAction_NewNode
// 0x0004 (0x007C - 0x0078)
struct FEdGraphSchemaAction_NewNode final : public FEdGraphSchemaAction
{
public:
	class UEdGraphNode*                           NodeTemplate;                                      // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEdGraphSchemaAction_NewNode) == 0x000004, "Wrong alignment on FEdGraphSchemaAction_NewNode");
static_assert(sizeof(FEdGraphSchemaAction_NewNode) == 0x00007C, "Wrong size on FEdGraphSchemaAction_NewNode");
static_assert(offsetof(FEdGraphSchemaAction_NewNode, NodeTemplate) == 0x000078, "Member 'FEdGraphSchemaAction_NewNode::NodeTemplate' has a wrong offset!");

// ScriptStruct Engine.CurveTableRowHandle
// 0x000C (0x000C - 0x0000)
struct FCurveTableRowHandle final
{
public:
	class UCurveTable*                            CurveTable;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveTableRowHandle) == 0x000004, "Wrong alignment on FCurveTableRowHandle");
static_assert(sizeof(FCurveTableRowHandle) == 0x00000C, "Wrong size on FCurveTableRowHandle");
static_assert(offsetof(FCurveTableRowHandle, CurveTable) == 0x000000, "Member 'FCurveTableRowHandle::CurveTable' has a wrong offset!");
static_assert(offsetof(FCurveTableRowHandle, RowName) == 0x000004, "Member 'FCurveTableRowHandle::RowName' has a wrong offset!");

// ScriptStruct Engine.BranchFilter
// 0x000C (0x000C - 0x0000)
struct FBranchFilter final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendDepth;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchFilter) == 0x000004, "Wrong alignment on FBranchFilter");
static_assert(sizeof(FBranchFilter) == 0x00000C, "Wrong size on FBranchFilter");
static_assert(offsetof(FBranchFilter, BoneName) == 0x000000, "Member 'FBranchFilter::BoneName' has a wrong offset!");
static_assert(offsetof(FBranchFilter, BlendDepth) == 0x000008, "Member 'FBranchFilter::BlendDepth' has a wrong offset!");

// ScriptStruct Engine.InputBlendPose
// 0x000C (0x000C - 0x0000)
struct FInputBlendPose final
{
public:
	TArray<struct FBranchFilter>                  BranchFilters;                                     // 0x0000(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputBlendPose) == 0x000004, "Wrong alignment on FInputBlendPose");
static_assert(sizeof(FInputBlendPose) == 0x00000C, "Wrong size on FInputBlendPose");
static_assert(offsetof(FInputBlendPose, BranchFilters) == 0x000000, "Member 'FInputBlendPose::BranchFilters' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputDelegateBinding
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FBlueprintInputDelegateBinding
{
public:
	uint8                                         bConsumeInput : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bExecuteWhenPaused : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideParentBinding : 1;                        // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlueprintInputDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputDelegateBinding");
static_assert(sizeof(FBlueprintInputDelegateBinding) == 0x000004, "Wrong size on FBlueprintInputDelegateBinding");

// ScriptStruct Engine.BlueprintInputKeyDelegateBinding
// 0x0020 (0x0024 - 0x0004)
struct FBlueprintInputKeyDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	struct FInputChord                            InputChord;                                        // 0x0004(0x0014)(NativeAccessSpecifierPublic)
	EInputEvent                                   InputKeyEvent;                                     // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintInputKeyDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputKeyDelegateBinding");
static_assert(sizeof(FBlueprintInputKeyDelegateBinding) == 0x000024, "Wrong size on FBlueprintInputKeyDelegateBinding");
static_assert(offsetof(FBlueprintInputKeyDelegateBinding, InputChord) == 0x000004, "Member 'FBlueprintInputKeyDelegateBinding::InputChord' has a wrong offset!");
static_assert(offsetof(FBlueprintInputKeyDelegateBinding, InputKeyEvent) == 0x000018, "Member 'FBlueprintInputKeyDelegateBinding::InputKeyEvent' has a wrong offset!");
static_assert(offsetof(FBlueprintInputKeyDelegateBinding, FunctionNameToBind) == 0x00001C, "Member 'FBlueprintInputKeyDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.Vector_NetQuantize10
// 0x0000 (0x000C - 0x000C)
struct FVector_NetQuantize10 final : public FVector
{
};
static_assert(alignof(FVector_NetQuantize10) == 0x000004, "Wrong alignment on FVector_NetQuantize10");
static_assert(sizeof(FVector_NetQuantize10) == 0x00000C, "Wrong size on FVector_NetQuantize10");

// ScriptStruct Engine.Vector_NetQuantize100
// 0x0000 (0x000C - 0x000C)
struct FVector_NetQuantize100 final : public FVector
{
};
static_assert(alignof(FVector_NetQuantize100) == 0x000004, "Wrong alignment on FVector_NetQuantize100");
static_assert(sizeof(FVector_NetQuantize100) == 0x00000C, "Wrong size on FVector_NetQuantize100");

// ScriptStruct Engine.ComponentSpacePoseLink
// 0x0000 (0x000C - 0x000C)
struct FComponentSpacePoseLink final : public FPoseLinkBase
{
};
static_assert(alignof(FComponentSpacePoseLink) == 0x000004, "Wrong alignment on FComponentSpacePoseLink");
static_assert(sizeof(FComponentSpacePoseLink) == 0x00000C, "Wrong size on FComponentSpacePoseLink");

// ScriptStruct Engine.AnimNode_ConvertComponentToLocalSpace
// 0x000C (0x002C - 0x0020)
struct FAnimNode_ConvertComponentToLocalSpace final : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0020(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_ConvertComponentToLocalSpace) == 0x000004, "Wrong alignment on FAnimNode_ConvertComponentToLocalSpace");
static_assert(sizeof(FAnimNode_ConvertComponentToLocalSpace) == 0x00002C, "Wrong size on FAnimNode_ConvertComponentToLocalSpace");
static_assert(offsetof(FAnimNode_ConvertComponentToLocalSpace, ComponentPose) == 0x000020, "Member 'FAnimNode_ConvertComponentToLocalSpace::ComponentPose' has a wrong offset!");

// ScriptStruct Engine.DataTableRowHandle
// 0x000C (0x000C - 0x0000)
struct FDataTableRowHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableRowHandle) == 0x000004, "Wrong alignment on FDataTableRowHandle");
static_assert(sizeof(FDataTableRowHandle) == 0x00000C, "Wrong size on FDataTableRowHandle");
static_assert(offsetof(FDataTableRowHandle, DataTable) == 0x000000, "Member 'FDataTableRowHandle::DataTable' has a wrong offset!");
static_assert(offsetof(FDataTableRowHandle, RowName) == 0x000004, "Member 'FDataTableRowHandle::RowName' has a wrong offset!");

// ScriptStruct Engine.KShapeElem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FKShapeElem
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKShapeElem) == 0x000004, "Wrong alignment on FKShapeElem");
static_assert(sizeof(FKShapeElem) == 0x000010, "Wrong size on FKShapeElem");

// ScriptStruct Engine.KSphereElem
// 0x0050 (0x0060 - 0x0010)
struct FKSphereElem final : public FKShapeElem
{
public:
	struct FMatrix                                TM;                                                // 0x0010(0x0040)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKSphereElem) == 0x000010, "Wrong alignment on FKSphereElem");
static_assert(sizeof(FKSphereElem) == 0x000060, "Wrong size on FKSphereElem");
static_assert(offsetof(FKSphereElem, TM) == 0x000010, "Member 'FKSphereElem::TM' has a wrong offset!");
static_assert(offsetof(FKSphereElem, Center) == 0x000050, "Member 'FKSphereElem::Center' has a wrong offset!");
static_assert(offsetof(FKSphereElem, Radius) == 0x00005C, "Member 'FKSphereElem::Radius' has a wrong offset!");

// ScriptStruct Engine.KBoxElem
// 0x0070 (0x0080 - 0x0010)
struct FKBoxElem final : public FKShapeElem
{
public:
	struct FMatrix                                TM;                                                // 0x0010(0x0040)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Orientation;                                       // 0x0060(0x0010)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKBoxElem) == 0x000010, "Wrong alignment on FKBoxElem");
static_assert(sizeof(FKBoxElem) == 0x000080, "Wrong size on FKBoxElem");
static_assert(offsetof(FKBoxElem, TM) == 0x000010, "Member 'FKBoxElem::TM' has a wrong offset!");
static_assert(offsetof(FKBoxElem, Center) == 0x000050, "Member 'FKBoxElem::Center' has a wrong offset!");
static_assert(offsetof(FKBoxElem, Orientation) == 0x000060, "Member 'FKBoxElem::Orientation' has a wrong offset!");
static_assert(offsetof(FKBoxElem, X) == 0x000070, "Member 'FKBoxElem::X' has a wrong offset!");
static_assert(offsetof(FKBoxElem, Y) == 0x000074, "Member 'FKBoxElem::Y' has a wrong offset!");
static_assert(offsetof(FKBoxElem, Z) == 0x000078, "Member 'FKBoxElem::Z' has a wrong offset!");

// ScriptStruct Engine.KSphylElem
// 0x0070 (0x0080 - 0x0010)
struct FKSphylElem final : public FKShapeElem
{
public:
	struct FMatrix                                TM;                                                // 0x0010(0x0040)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Orientation;                                       // 0x0060(0x0010)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKSphylElem) == 0x000010, "Wrong alignment on FKSphylElem");
static_assert(sizeof(FKSphylElem) == 0x000080, "Wrong size on FKSphylElem");
static_assert(offsetof(FKSphylElem, TM) == 0x000010, "Member 'FKSphylElem::TM' has a wrong offset!");
static_assert(offsetof(FKSphylElem, Center) == 0x000050, "Member 'FKSphylElem::Center' has a wrong offset!");
static_assert(offsetof(FKSphylElem, Orientation) == 0x000060, "Member 'FKSphylElem::Orientation' has a wrong offset!");
static_assert(offsetof(FKSphylElem, Radius) == 0x000070, "Member 'FKSphylElem::Radius' has a wrong offset!");
static_assert(offsetof(FKSphylElem, Length) == 0x000074, "Member 'FKSphylElem::Length' has a wrong offset!");

// ScriptStruct Engine.KConvexElem
// 0x0070 (0x0080 - 0x0010)
struct FKConvexElem final : public FKShapeElem
{
public:
	TArray<struct FVector>                        VertexData;                                        // 0x0010(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   ElemBox;                                           // 0x001C(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKConvexElem) == 0x000010, "Wrong alignment on FKConvexElem");
static_assert(sizeof(FKConvexElem) == 0x000080, "Wrong size on FKConvexElem");
static_assert(offsetof(FKConvexElem, VertexData) == 0x000010, "Member 'FKConvexElem::VertexData' has a wrong offset!");
static_assert(offsetof(FKConvexElem, ElemBox) == 0x00001C, "Member 'FKConvexElem::ElemBox' has a wrong offset!");
static_assert(offsetof(FKConvexElem, Transform) == 0x000040, "Member 'FKConvexElem::Transform' has a wrong offset!");

// ScriptStruct Engine.KAggregateGeom
// 0x0034 (0x0034 - 0x0000)
struct FKAggregateGeom final
{
public:
	TArray<struct FKSphereElem>                   SphereElems;                                       // 0x0000(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKBoxElem>                      BoxElems;                                          // 0x000C(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKSphylElem>                    SphylElems;                                        // 0x0018(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKConvexElem>                   ConvexElems;                                       // 0x0024(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKAggregateGeom) == 0x000004, "Wrong alignment on FKAggregateGeom");
static_assert(sizeof(FKAggregateGeom) == 0x000034, "Wrong size on FKAggregateGeom");
static_assert(offsetof(FKAggregateGeom, SphereElems) == 0x000000, "Member 'FKAggregateGeom::SphereElems' has a wrong offset!");
static_assert(offsetof(FKAggregateGeom, BoxElems) == 0x00000C, "Member 'FKAggregateGeom::BoxElems' has a wrong offset!");
static_assert(offsetof(FKAggregateGeom, SphylElems) == 0x000018, "Member 'FKAggregateGeom::SphylElems' has a wrong offset!");
static_assert(offsetof(FKAggregateGeom, ConvexElems) == 0x000024, "Member 'FKAggregateGeom::ConvexElems' has a wrong offset!");

// ScriptStruct Engine.DestructibleDamageParameters
// 0x001C (0x001C - 0x0000)
struct FDestructibleDamageParameters final
{
public:
	float                                         DamageThreshold;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSpread;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableImpactDamage;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactDamage;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultImpactDamageDepth;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomImpactResistance;                           // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactResistance;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleDamageParameters) == 0x000004, "Wrong alignment on FDestructibleDamageParameters");
static_assert(sizeof(FDestructibleDamageParameters) == 0x00001C, "Wrong size on FDestructibleDamageParameters");
static_assert(offsetof(FDestructibleDamageParameters, DamageThreshold) == 0x000000, "Member 'FDestructibleDamageParameters::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, DamageSpread) == 0x000004, "Member 'FDestructibleDamageParameters::DamageSpread' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, bEnableImpactDamage) == 0x000008, "Member 'FDestructibleDamageParameters::bEnableImpactDamage' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, ImpactDamage) == 0x00000C, "Member 'FDestructibleDamageParameters::ImpactDamage' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, DefaultImpactDamageDepth) == 0x000010, "Member 'FDestructibleDamageParameters::DefaultImpactDamageDepth' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, bCustomImpactResistance) == 0x000014, "Member 'FDestructibleDamageParameters::bCustomImpactResistance' has a wrong offset!");
static_assert(offsetof(FDestructibleDamageParameters, ImpactResistance) == 0x000018, "Member 'FDestructibleDamageParameters::ImpactResistance' has a wrong offset!");

// ScriptStruct Engine.DestructibleAdvancedParameters
// 0x0010 (0x0010 - 0x0000)
struct FDestructibleAdvancedParameters final
{
public:
	float                                         DamageCap;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactVelocityThreshold;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxChunkSpeed;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractureImpulseScale;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleAdvancedParameters) == 0x000004, "Wrong alignment on FDestructibleAdvancedParameters");
static_assert(sizeof(FDestructibleAdvancedParameters) == 0x000010, "Wrong size on FDestructibleAdvancedParameters");
static_assert(offsetof(FDestructibleAdvancedParameters, DamageCap) == 0x000000, "Member 'FDestructibleAdvancedParameters::DamageCap' has a wrong offset!");
static_assert(offsetof(FDestructibleAdvancedParameters, ImpactVelocityThreshold) == 0x000004, "Member 'FDestructibleAdvancedParameters::ImpactVelocityThreshold' has a wrong offset!");
static_assert(offsetof(FDestructibleAdvancedParameters, MaxChunkSpeed) == 0x000008, "Member 'FDestructibleAdvancedParameters::MaxChunkSpeed' has a wrong offset!");
static_assert(offsetof(FDestructibleAdvancedParameters, FractureImpulseScale) == 0x00000C, "Member 'FDestructibleAdvancedParameters::FractureImpulseScale' has a wrong offset!");

// ScriptStruct Engine.DestructibleParametersFlag
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FDestructibleParametersFlag final
{
public:
	uint8                                         bAccumulateDamage : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAssetDefinedSupport : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bWorldSupport : 1;                                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebrisTimeout : 1;                                // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebrisMaxSeparation : 1;                          // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCrumbleSmallestChunks : 1;                        // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAccurateRaycasts : 1;                             // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseValidBounds : 1;                               // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bFormExtendedStructures : 1;                       // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleParametersFlag) == 0x000004, "Wrong alignment on FDestructibleParametersFlag");
static_assert(sizeof(FDestructibleParametersFlag) == 0x000004, "Wrong size on FDestructibleParametersFlag");

// ScriptStruct Engine.DestructibleParameters
// 0x007C (0x007C - 0x0000)
struct FDestructibleParameters final
{
public:
	struct FDestructibleDamageParameters          DamageParameters;                                  // 0x0000(0x001C)(Edit, NativeAccessSpecifierPublic)
	struct FDestructibleDebrisParameters          DebrisParameters;                                  // 0x001C(0x002C)(Edit, NativeAccessSpecifierPublic)
	struct FDestructibleAdvancedParameters        AdvancedParameters;                                // 0x0048(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FDestructibleSpecialHierarchyDepths    SpecialHierarchyDepths;                            // 0x0058(0x0014)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FDestructibleDepthParameters>   DepthParameters;                                   // 0x006C(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDestructibleParametersFlag            Flags;                                             // 0x0078(0x0004)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleParameters) == 0x000004, "Wrong alignment on FDestructibleParameters");
static_assert(sizeof(FDestructibleParameters) == 0x00007C, "Wrong size on FDestructibleParameters");
static_assert(offsetof(FDestructibleParameters, DamageParameters) == 0x000000, "Member 'FDestructibleParameters::DamageParameters' has a wrong offset!");
static_assert(offsetof(FDestructibleParameters, DebrisParameters) == 0x00001C, "Member 'FDestructibleParameters::DebrisParameters' has a wrong offset!");
static_assert(offsetof(FDestructibleParameters, AdvancedParameters) == 0x000048, "Member 'FDestructibleParameters::AdvancedParameters' has a wrong offset!");
static_assert(offsetof(FDestructibleParameters, SpecialHierarchyDepths) == 0x000058, "Member 'FDestructibleParameters::SpecialHierarchyDepths' has a wrong offset!");
static_assert(offsetof(FDestructibleParameters, DepthParameters) == 0x00006C, "Member 'FDestructibleParameters::DepthParameters' has a wrong offset!");
static_assert(offsetof(FDestructibleParameters, Flags) == 0x000078, "Member 'FDestructibleParameters::Flags' has a wrong offset!");

// ScriptStruct Engine.DebugTextInfo
// 0x004C (0x004C - 0x0000)
struct FDebugTextInfo final
{
public:
	class AActor*                                 SrcActor;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SrcActorOffset;                                    // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SrcActorDesiredOffset;                             // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 DebugText;                                         // 0x001C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bAbsoluteLocation : 1;                             // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bKeepAttachedToActor : 1;                          // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDrawShadow : 1;                                   // 0x0034(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OrigActorLocation;                                 // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugTextInfo) == 0x000004, "Wrong alignment on FDebugTextInfo");
static_assert(sizeof(FDebugTextInfo) == 0x00004C, "Wrong size on FDebugTextInfo");
static_assert(offsetof(FDebugTextInfo, SrcActor) == 0x000000, "Member 'FDebugTextInfo::SrcActor' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, SrcActorOffset) == 0x000004, "Member 'FDebugTextInfo::SrcActorOffset' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, SrcActorDesiredOffset) == 0x000010, "Member 'FDebugTextInfo::SrcActorDesiredOffset' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, DebugText) == 0x00001C, "Member 'FDebugTextInfo::DebugText' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, TimeRemaining) == 0x000028, "Member 'FDebugTextInfo::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, Duration) == 0x00002C, "Member 'FDebugTextInfo::Duration' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, TextColor) == 0x000030, "Member 'FDebugTextInfo::TextColor' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, OrigActorLocation) == 0x000038, "Member 'FDebugTextInfo::OrigActorLocation' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, Font) == 0x000044, "Member 'FDebugTextInfo::Font' has a wrong offset!");
static_assert(offsetof(FDebugTextInfo, FontScale) == 0x000048, "Member 'FDebugTextInfo::FontScale' has a wrong offset!");

// ScriptStruct Engine.CustomInput
// 0x0038 (0x0038 - 0x0000)
struct FCustomInput final
{
public:
	class FString                                 InputName;                                         // 0x0000(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Input;                                             // 0x000C(0x002C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomInput) == 0x000004, "Wrong alignment on FCustomInput");
static_assert(sizeof(FCustomInput) == 0x000038, "Wrong size on FCustomInput");
static_assert(offsetof(FCustomInput, InputName) == 0x000000, "Member 'FCustomInput::InputName' has a wrong offset!");
static_assert(offsetof(FCustomInput, Input) == 0x00000C, "Member 'FCustomInput::Input' has a wrong offset!");

// ScriptStruct Engine.AutoCompleteNode
// 0x001C (0x001C - 0x0000)
struct FAutoCompleteNode final
{
public:
	int32                                         IndexChar;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AutoCompleteListIndices;                           // 0x0004(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xC];                                       // 0x0010(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAutoCompleteNode) == 0x000004, "Wrong alignment on FAutoCompleteNode");
static_assert(sizeof(FAutoCompleteNode) == 0x00001C, "Wrong size on FAutoCompleteNode");
static_assert(offsetof(FAutoCompleteNode, IndexChar) == 0x000000, "Member 'FAutoCompleteNode::IndexChar' has a wrong offset!");
static_assert(offsetof(FAutoCompleteNode, AutoCompleteListIndices) == 0x000004, "Member 'FAutoCompleteNode::AutoCompleteListIndices' has a wrong offset!");

// ScriptStruct Engine.PrimitiveComponentPostPhysicsTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FPrimitiveComponentPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrimitiveComponentPostPhysicsTickFunction) == 0x000004, "Wrong alignment on FPrimitiveComponentPostPhysicsTickFunction");
static_assert(sizeof(FPrimitiveComponentPostPhysicsTickFunction) == 0x000038, "Wrong size on FPrimitiveComponentPostPhysicsTickFunction");

// ScriptStruct Engine.AlphaBlend
// 0x002C (0x002C - 0x0000)
struct FAlphaBlend final
{
public:
	EAlphaBlendOption                             BlendOption;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x20];                                       // 0x000C(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAlphaBlend) == 0x000004, "Wrong alignment on FAlphaBlend");
static_assert(sizeof(FAlphaBlend) == 0x00002C, "Wrong size on FAlphaBlend");
static_assert(offsetof(FAlphaBlend, BlendOption) == 0x000000, "Member 'FAlphaBlend::BlendOption' has a wrong offset!");
static_assert(offsetof(FAlphaBlend, CustomCurve) == 0x000004, "Member 'FAlphaBlend::CustomCurve' has a wrong offset!");
static_assert(offsetof(FAlphaBlend, BlendTime) == 0x000008, "Member 'FAlphaBlend::BlendTime' has a wrong offset!");

// ScriptStruct Engine.CurveEdEntry
// 0x002C (0x002C - 0x0000)
struct FCurveEdEntry final
{
public:
	class UObject*                                CurveObject;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CurveColor;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 CurveName;                                         // 0x0008(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bHideCurve;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bColorCurve;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bFloatingPointColorCurve;                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bClamp;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampLow;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampHigh;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveEdEntry) == 0x000004, "Wrong alignment on FCurveEdEntry");
static_assert(sizeof(FCurveEdEntry) == 0x00002C, "Wrong size on FCurveEdEntry");
static_assert(offsetof(FCurveEdEntry, CurveObject) == 0x000000, "Member 'FCurveEdEntry::CurveObject' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, CurveColor) == 0x000004, "Member 'FCurveEdEntry::CurveColor' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, CurveName) == 0x000008, "Member 'FCurveEdEntry::CurveName' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, bHideCurve) == 0x000014, "Member 'FCurveEdEntry::bHideCurve' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, bColorCurve) == 0x000018, "Member 'FCurveEdEntry::bColorCurve' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, bFloatingPointColorCurve) == 0x00001C, "Member 'FCurveEdEntry::bFloatingPointColorCurve' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, bClamp) == 0x000020, "Member 'FCurveEdEntry::bClamp' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, ClampLow) == 0x000024, "Member 'FCurveEdEntry::ClampLow' has a wrong offset!");
static_assert(offsetof(FCurveEdEntry, ClampHigh) == 0x000028, "Member 'FCurveEdEntry::ClampHigh' has a wrong offset!");

// ScriptStruct Engine.AnimNode_AssetPlayerBase
// 0x0028 (0x0048 - 0x0020)
struct FAnimNode_AssetPlayerBase : public FAnimNode_Base
{
public:
	bool                                          bIgnoreForRelevancyTest;                           // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupIndex;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGroupRole                                GroupRole;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendWeight;                                       // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InternalTimeAccumulator;                           // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_AssetPlayerBase) == 0x000004, "Wrong alignment on FAnimNode_AssetPlayerBase");
static_assert(sizeof(FAnimNode_AssetPlayerBase) == 0x000048, "Wrong size on FAnimNode_AssetPlayerBase");
static_assert(offsetof(FAnimNode_AssetPlayerBase, bIgnoreForRelevancyTest) == 0x000020, "Member 'FAnimNode_AssetPlayerBase::bIgnoreForRelevancyTest' has a wrong offset!");
static_assert(offsetof(FAnimNode_AssetPlayerBase, GroupIndex) == 0x000024, "Member 'FAnimNode_AssetPlayerBase::GroupIndex' has a wrong offset!");
static_assert(offsetof(FAnimNode_AssetPlayerBase, GroupRole) == 0x000028, "Member 'FAnimNode_AssetPlayerBase::GroupRole' has a wrong offset!");
static_assert(offsetof(FAnimNode_AssetPlayerBase, BlendWeight) == 0x00002C, "Member 'FAnimNode_AssetPlayerBase::BlendWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_AssetPlayerBase, InternalTimeAccumulator) == 0x000030, "Member 'FAnimNode_AssetPlayerBase::InternalTimeAccumulator' has a wrong offset!");

// ScriptStruct Engine.InputActionKeyMapping
// 0x001C (0x001C - 0x0000)
struct FInputActionKeyMapping final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x0018(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputActionKeyMapping) == 0x000004, "Wrong alignment on FInputActionKeyMapping");
static_assert(sizeof(FInputActionKeyMapping) == 0x00001C, "Wrong size on FInputActionKeyMapping");
static_assert(offsetof(FInputActionKeyMapping, ActionName) == 0x000000, "Member 'FInputActionKeyMapping::ActionName' has a wrong offset!");
static_assert(offsetof(FInputActionKeyMapping, Key) == 0x000008, "Member 'FInputActionKeyMapping::Key' has a wrong offset!");

// ScriptStruct Engine.VectorCurve
// 0x00FC (0x0110 - 0x0014)
struct FVectorCurve final : public FAnimCurveBase
{
public:
	struct FRichCurve                             FloatCurves[0x3];                                  // 0x0014(0x0054)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorCurve) == 0x000004, "Wrong alignment on FVectorCurve");
static_assert(sizeof(FVectorCurve) == 0x000110, "Wrong size on FVectorCurve");
static_assert(offsetof(FVectorCurve, FloatCurves) == 0x000014, "Member 'FVectorCurve::FloatCurves' has a wrong offset!");

// ScriptStruct Engine.ExposureSettings
// 0x0008 (0x0008 - 0x0000)
struct FExposureSettings final
{
public:
	int32                                         LogOffset;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixed;                                            // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExposureSettings) == 0x000004, "Wrong alignment on FExposureSettings");
static_assert(sizeof(FExposureSettings) == 0x000008, "Wrong size on FExposureSettings");
static_assert(offsetof(FExposureSettings, LogOffset) == 0x000000, "Member 'FExposureSettings::LogOffset' has a wrong offset!");
static_assert(offsetof(FExposureSettings, bFixed) == 0x000004, "Member 'FExposureSettings::bFixed' has a wrong offset!");

// ScriptStruct Engine.ActorTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FActorTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorTickFunction) == 0x000004, "Wrong alignment on FActorTickFunction");
static_assert(sizeof(FActorTickFunction) == 0x000038, "Wrong size on FActorTickFunction");

// ScriptStruct Engine.TickPrerequisite
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FTickPrerequisite final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTickPrerequisite) == 0x000004, "Wrong alignment on FTickPrerequisite");
static_assert(sizeof(FTickPrerequisite) == 0x00000C, "Wrong size on FTickPrerequisite");

// ScriptStruct Engine.PerBoneBlendWeight
// 0x0008 (0x0008 - 0x0000)
struct FPerBoneBlendWeight final
{
public:
	int32                                         SourceIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerBoneBlendWeight) == 0x000004, "Wrong alignment on FPerBoneBlendWeight");
static_assert(sizeof(FPerBoneBlendWeight) == 0x000008, "Wrong size on FPerBoneBlendWeight");
static_assert(offsetof(FPerBoneBlendWeight, SourceIndex) == 0x000000, "Member 'FPerBoneBlendWeight::SourceIndex' has a wrong offset!");
static_assert(offsetof(FPerBoneBlendWeight, BlendWeight) == 0x000004, "Member 'FPerBoneBlendWeight::BlendWeight' has a wrong offset!");

// ScriptStruct Engine.Redirector
// 0x0010 (0x0010 - 0x0000)
struct FRedirector final
{
public:
	class FName                                   OldName;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewName;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRedirector) == 0x000004, "Wrong alignment on FRedirector");
static_assert(sizeof(FRedirector) == 0x000010, "Wrong size on FRedirector");
static_assert(offsetof(FRedirector, OldName) == 0x000000, "Member 'FRedirector::OldName' has a wrong offset!");
static_assert(offsetof(FRedirector, NewName) == 0x000008, "Member 'FRedirector::NewName' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionNewProjectSettings
// 0x0018 (0x0018 - 0x0000)
struct FBuildPromotionNewProjectSettings final
{
public:
	struct FDirectoryPath                         NewProjectFolderOverride;                          // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	class FString                                 NewProjectNameOverride;                            // 0x000C(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildPromotionNewProjectSettings) == 0x000004, "Wrong alignment on FBuildPromotionNewProjectSettings");
static_assert(sizeof(FBuildPromotionNewProjectSettings) == 0x000018, "Wrong size on FBuildPromotionNewProjectSettings");
static_assert(offsetof(FBuildPromotionNewProjectSettings, NewProjectFolderOverride) == 0x000000, "Member 'FBuildPromotionNewProjectSettings::NewProjectFolderOverride' has a wrong offset!");
static_assert(offsetof(FBuildPromotionNewProjectSettings, NewProjectNameOverride) == 0x00000C, "Member 'FBuildPromotionNewProjectSettings::NewProjectNameOverride' has a wrong offset!");

// ScriptStruct Engine.BlendParameter
// 0x0018 (0x0018 - 0x0000)
struct FBlendParameter final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GridNum;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendParameter) == 0x000004, "Wrong alignment on FBlendParameter");
static_assert(sizeof(FBlendParameter) == 0x000018, "Wrong size on FBlendParameter");
static_assert(offsetof(FBlendParameter, DisplayName) == 0x000000, "Member 'FBlendParameter::DisplayName' has a wrong offset!");
static_assert(offsetof(FBlendParameter, Min) == 0x00000C, "Member 'FBlendParameter::Min' has a wrong offset!");
static_assert(offsetof(FBlendParameter, Max) == 0x000010, "Member 'FBlendParameter::Max' has a wrong offset!");
static_assert(offsetof(FBlendParameter, GridNum) == 0x000014, "Member 'FBlendParameter::GridNum' has a wrong offset!");

// ScriptStruct Engine.FilePath
// 0x000C (0x000C - 0x0000)
struct FFilePath final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilePath) == 0x000004, "Wrong alignment on FFilePath");
static_assert(sizeof(FFilePath) == 0x00000C, "Wrong size on FFilePath");
static_assert(offsetof(FFilePath, FilePath) == 0x000000, "Member 'FFilePath::FilePath' has a wrong offset!");

// ScriptStruct Engine.VehicleDifferential4WData
// 0x001C (0x001C - 0x0000)
struct FVehicleDifferential4WData final
{
public:
	EVehicleDifferential4W                        DifferentialType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrontRearSplit;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontLeftRightSplit;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RearLeftRightSplit;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CentreBias;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontBias;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RearBias;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleDifferential4WData) == 0x000004, "Wrong alignment on FVehicleDifferential4WData");
static_assert(sizeof(FVehicleDifferential4WData) == 0x00001C, "Wrong size on FVehicleDifferential4WData");
static_assert(offsetof(FVehicleDifferential4WData, DifferentialType) == 0x000000, "Member 'FVehicleDifferential4WData::DifferentialType' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, FrontRearSplit) == 0x000004, "Member 'FVehicleDifferential4WData::FrontRearSplit' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, FrontLeftRightSplit) == 0x000008, "Member 'FVehicleDifferential4WData::FrontLeftRightSplit' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, RearLeftRightSplit) == 0x00000C, "Member 'FVehicleDifferential4WData::RearLeftRightSplit' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, CentreBias) == 0x000010, "Member 'FVehicleDifferential4WData::CentreBias' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, FrontBias) == 0x000014, "Member 'FVehicleDifferential4WData::FrontBias' has a wrong offset!");
static_assert(offsetof(FVehicleDifferential4WData, RearBias) == 0x000018, "Member 'FVehicleDifferential4WData::RearBias' has a wrong offset!");

// ScriptStruct Engine.ComponentReference
// 0x0014 (0x0014 - 0x0000)
struct FComponentReference final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentProperty;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x8];                                        // 0x000C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComponentReference) == 0x000004, "Wrong alignment on FComponentReference");
static_assert(sizeof(FComponentReference) == 0x000014, "Wrong size on FComponentReference");
static_assert(offsetof(FComponentReference, OtherActor) == 0x000000, "Member 'FComponentReference::OtherActor' has a wrong offset!");
static_assert(offsetof(FComponentReference, ComponentProperty) == 0x000004, "Member 'FComponentReference::ComponentProperty' has a wrong offset!");

// ScriptStruct Engine.ConstrainComponentPropName
// 0x0008 (0x0008 - 0x0000)
struct FConstrainComponentPropName final
{
public:
	class FName                                   ComponentName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstrainComponentPropName) == 0x000004, "Wrong alignment on FConstrainComponentPropName");
static_assert(sizeof(FConstrainComponentPropName) == 0x000008, "Wrong size on FConstrainComponentPropName");
static_assert(offsetof(FConstrainComponentPropName, ComponentName) == 0x000000, "Member 'FConstrainComponentPropName::ComponentName' has a wrong offset!");

// ScriptStruct Engine.StartAsyncSimulationFunction
// 0x0004 (0x0038 - 0x0034)
struct FStartAsyncSimulationFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartAsyncSimulationFunction) == 0x000004, "Wrong alignment on FStartAsyncSimulationFunction");
static_assert(sizeof(FStartAsyncSimulationFunction) == 0x000038, "Wrong size on FStartAsyncSimulationFunction");

// ScriptStruct Engine.WalkableSlopeOverride
// 0x0008 (0x0008 - 0x0000)
struct FWalkableSlopeOverride final
{
public:
	EWalkableSlopeBehavior                        WalkableSlopeBehavior;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkableSlopeAngle;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWalkableSlopeOverride) == 0x000004, "Wrong alignment on FWalkableSlopeOverride");
static_assert(sizeof(FWalkableSlopeOverride) == 0x000008, "Wrong size on FWalkableSlopeOverride");
static_assert(offsetof(FWalkableSlopeOverride, WalkableSlopeBehavior) == 0x000000, "Member 'FWalkableSlopeOverride::WalkableSlopeBehavior' has a wrong offset!");
static_assert(offsetof(FWalkableSlopeOverride, WalkableSlopeAngle) == 0x000004, "Member 'FWalkableSlopeOverride::WalkableSlopeAngle' has a wrong offset!");

// ScriptStruct Engine.ImportFactorySettingValues
// 0x0018 (0x0018 - 0x0000)
struct FImportFactorySettingValues final
{
public:
	class FString                                 SettingName;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x000C(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImportFactorySettingValues) == 0x000004, "Wrong alignment on FImportFactorySettingValues");
static_assert(sizeof(FImportFactorySettingValues) == 0x000018, "Wrong size on FImportFactorySettingValues");
static_assert(offsetof(FImportFactorySettingValues, SettingName) == 0x000000, "Member 'FImportFactorySettingValues::SettingName' has a wrong offset!");
static_assert(offsetof(FImportFactorySettingValues, Value) == 0x00000C, "Member 'FImportFactorySettingValues::Value' has a wrong offset!");

// ScriptStruct Engine.AnimExtractContext
// 0x0008 (0x0008 - 0x0000)
struct FAnimExtractContext final
{
public:
	bool                                          bExtractRootMotion;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTime;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimExtractContext) == 0x000004, "Wrong alignment on FAnimExtractContext");
static_assert(sizeof(FAnimExtractContext) == 0x000008, "Wrong size on FAnimExtractContext");
static_assert(offsetof(FAnimExtractContext, bExtractRootMotion) == 0x000000, "Member 'FAnimExtractContext::bExtractRootMotion' has a wrong offset!");
static_assert(offsetof(FAnimExtractContext, CurrentTime) == 0x000004, "Member 'FAnimExtractContext::CurrentTime' has a wrong offset!");

// ScriptStruct Engine.RepAttachment
// 0x0034 (0x0034 - 0x0000)
struct FRepAttachment final
{
public:
	class AActor*                                 AttachParent;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LocationOffset;                                    // 0x0004(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 RelativeScale3D;                                   // 0x0010(0x000C)(NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachComponent;                                   // 0x0030(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepAttachment) == 0x000004, "Wrong alignment on FRepAttachment");
static_assert(sizeof(FRepAttachment) == 0x000034, "Wrong size on FRepAttachment");
static_assert(offsetof(FRepAttachment, AttachParent) == 0x000000, "Member 'FRepAttachment::AttachParent' has a wrong offset!");
static_assert(offsetof(FRepAttachment, LocationOffset) == 0x000004, "Member 'FRepAttachment::LocationOffset' has a wrong offset!");
static_assert(offsetof(FRepAttachment, RelativeScale3D) == 0x000010, "Member 'FRepAttachment::RelativeScale3D' has a wrong offset!");
static_assert(offsetof(FRepAttachment, RotationOffset) == 0x00001C, "Member 'FRepAttachment::RotationOffset' has a wrong offset!");
static_assert(offsetof(FRepAttachment, AttachSocket) == 0x000028, "Member 'FRepAttachment::AttachSocket' has a wrong offset!");
static_assert(offsetof(FRepAttachment, AttachComponent) == 0x000030, "Member 'FRepAttachment::AttachComponent' has a wrong offset!");

// ScriptStruct Engine.RepMovement
// 0x0034 (0x0034 - 0x0000)
struct FRepMovement final
{
public:
	struct FVector                                LinearVelocity;                                    // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSimulatedPhysicSleep : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRepPhysics : 1;                                   // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	EVectorQuantization                           LocationQuantizationLevel;                         // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVectorQuantization                           VelocityQuantizationLevel;                         // 0x0032(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotatorQuantization                          RotationQuantizationLevel;                         // 0x0033(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepMovement) == 0x000004, "Wrong alignment on FRepMovement");
static_assert(sizeof(FRepMovement) == 0x000034, "Wrong size on FRepMovement");
static_assert(offsetof(FRepMovement, LinearVelocity) == 0x000000, "Member 'FRepMovement::LinearVelocity' has a wrong offset!");
static_assert(offsetof(FRepMovement, AngularVelocity) == 0x00000C, "Member 'FRepMovement::AngularVelocity' has a wrong offset!");
static_assert(offsetof(FRepMovement, Location) == 0x000018, "Member 'FRepMovement::Location' has a wrong offset!");
static_assert(offsetof(FRepMovement, Rotation) == 0x000024, "Member 'FRepMovement::Rotation' has a wrong offset!");
static_assert(offsetof(FRepMovement, LocationQuantizationLevel) == 0x000031, "Member 'FRepMovement::LocationQuantizationLevel' has a wrong offset!");
static_assert(offsetof(FRepMovement, VelocityQuantizationLevel) == 0x000032, "Member 'FRepMovement::VelocityQuantizationLevel' has a wrong offset!");
static_assert(offsetof(FRepMovement, RotationQuantizationLevel) == 0x000033, "Member 'FRepMovement::RotationQuantizationLevel' has a wrong offset!");

// ScriptStruct Engine.RadialDamageParams
// 0x0014 (0x0014 - 0x0000)
struct FRadialDamageParams final
{
public:
	float                                         BaseDamage;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialDamageParams) == 0x000004, "Wrong alignment on FRadialDamageParams");
static_assert(sizeof(FRadialDamageParams) == 0x000014, "Wrong size on FRadialDamageParams");
static_assert(offsetof(FRadialDamageParams, BaseDamage) == 0x000000, "Member 'FRadialDamageParams::BaseDamage' has a wrong offset!");
static_assert(offsetof(FRadialDamageParams, MinimumDamage) == 0x000004, "Member 'FRadialDamageParams::MinimumDamage' has a wrong offset!");
static_assert(offsetof(FRadialDamageParams, InnerRadius) == 0x000008, "Member 'FRadialDamageParams::InnerRadius' has a wrong offset!");
static_assert(offsetof(FRadialDamageParams, OuterRadius) == 0x00000C, "Member 'FRadialDamageParams::OuterRadius' has a wrong offset!");
static_assert(offsetof(FRadialDamageParams, DamageFalloff) == 0x000010, "Member 'FRadialDamageParams::DamageFalloff' has a wrong offset!");

// ScriptStruct Engine.DamageEvent
// 0x0008 (0x0008 - 0x0000)
struct FDamageEvent
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageEvent) == 0x000004, "Wrong alignment on FDamageEvent");
static_assert(sizeof(FDamageEvent) == 0x000008, "Wrong size on FDamageEvent");
static_assert(offsetof(FDamageEvent, DamageTypeClass) == 0x000004, "Member 'FDamageEvent::DamageTypeClass' has a wrong offset!");

// ScriptStruct Engine.RadialDamageEvent
// 0x002C (0x0034 - 0x0008)
struct FRadialDamageEvent final : public FDamageEvent
{
public:
	struct FRadialDamageParams                    Params;                                            // 0x0008(0x0014)(NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     ComponentHits;                                     // 0x0028(0x000C)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialDamageEvent) == 0x000004, "Wrong alignment on FRadialDamageEvent");
static_assert(sizeof(FRadialDamageEvent) == 0x000034, "Wrong size on FRadialDamageEvent");
static_assert(offsetof(FRadialDamageEvent, Params) == 0x000008, "Member 'FRadialDamageEvent::Params' has a wrong offset!");
static_assert(offsetof(FRadialDamageEvent, Origin) == 0x00001C, "Member 'FRadialDamageEvent::Origin' has a wrong offset!");
static_assert(offsetof(FRadialDamageEvent, ComponentHits) == 0x000028, "Member 'FRadialDamageEvent::ComponentHits' has a wrong offset!");

// ScriptStruct Engine.AnimationStateBase
// 0x0008 (0x0008 - 0x0000)
struct FAnimationStateBase
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationStateBase) == 0x000004, "Wrong alignment on FAnimationStateBase");
static_assert(sizeof(FAnimationStateBase) == 0x000008, "Wrong size on FAnimationStateBase");
static_assert(offsetof(FAnimationStateBase, StateName) == 0x000000, "Member 'FAnimationStateBase::StateName' has a wrong offset!");

// ScriptStruct Engine.CollisionResponseContainer
// 0x0020 (0x0020 - 0x0000)
struct FCollisionResponseContainer final
{
public:
	ECollisionResponse                            WorldStatic;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            WorldDynamic;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Pawn;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Visibility;                                        // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Camera;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            PhysicsBody;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Vehicle;                                           // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Destructible;                                      // 0x0007(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel1;                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel2;                               // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel3;                               // 0x000A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel4;                               // 0x000B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel5;                               // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            EngineTraceChannel6;                               // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel1;                                 // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel2;                                 // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel3;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel4;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel5;                                 // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel6;                                 // 0x0013(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel7;                                 // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel8;                                 // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel9;                                 // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel10;                                // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel11;                                // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel12;                                // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel13;                                // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel14;                                // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel15;                                // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel16;                                // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel17;                                // 0x001E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            GameTraceChannel18;                                // 0x001F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollisionResponseContainer) == 0x000001, "Wrong alignment on FCollisionResponseContainer");
static_assert(sizeof(FCollisionResponseContainer) == 0x000020, "Wrong size on FCollisionResponseContainer");
static_assert(offsetof(FCollisionResponseContainer, WorldStatic) == 0x000000, "Member 'FCollisionResponseContainer::WorldStatic' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, WorldDynamic) == 0x000001, "Member 'FCollisionResponseContainer::WorldDynamic' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, Pawn) == 0x000002, "Member 'FCollisionResponseContainer::Pawn' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, Visibility) == 0x000003, "Member 'FCollisionResponseContainer::Visibility' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, Camera) == 0x000004, "Member 'FCollisionResponseContainer::Camera' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, PhysicsBody) == 0x000005, "Member 'FCollisionResponseContainer::PhysicsBody' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, Vehicle) == 0x000006, "Member 'FCollisionResponseContainer::Vehicle' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, Destructible) == 0x000007, "Member 'FCollisionResponseContainer::Destructible' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel1) == 0x000008, "Member 'FCollisionResponseContainer::EngineTraceChannel1' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel2) == 0x000009, "Member 'FCollisionResponseContainer::EngineTraceChannel2' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel3) == 0x00000A, "Member 'FCollisionResponseContainer::EngineTraceChannel3' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel4) == 0x00000B, "Member 'FCollisionResponseContainer::EngineTraceChannel4' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel5) == 0x00000C, "Member 'FCollisionResponseContainer::EngineTraceChannel5' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, EngineTraceChannel6) == 0x00000D, "Member 'FCollisionResponseContainer::EngineTraceChannel6' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel1) == 0x00000E, "Member 'FCollisionResponseContainer::GameTraceChannel1' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel2) == 0x00000F, "Member 'FCollisionResponseContainer::GameTraceChannel2' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel3) == 0x000010, "Member 'FCollisionResponseContainer::GameTraceChannel3' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel4) == 0x000011, "Member 'FCollisionResponseContainer::GameTraceChannel4' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel5) == 0x000012, "Member 'FCollisionResponseContainer::GameTraceChannel5' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel6) == 0x000013, "Member 'FCollisionResponseContainer::GameTraceChannel6' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel7) == 0x000014, "Member 'FCollisionResponseContainer::GameTraceChannel7' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel8) == 0x000015, "Member 'FCollisionResponseContainer::GameTraceChannel8' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel9) == 0x000016, "Member 'FCollisionResponseContainer::GameTraceChannel9' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel10) == 0x000017, "Member 'FCollisionResponseContainer::GameTraceChannel10' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel11) == 0x000018, "Member 'FCollisionResponseContainer::GameTraceChannel11' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel12) == 0x000019, "Member 'FCollisionResponseContainer::GameTraceChannel12' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel13) == 0x00001A, "Member 'FCollisionResponseContainer::GameTraceChannel13' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel14) == 0x00001B, "Member 'FCollisionResponseContainer::GameTraceChannel14' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel15) == 0x00001C, "Member 'FCollisionResponseContainer::GameTraceChannel15' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel16) == 0x00001D, "Member 'FCollisionResponseContainer::GameTraceChannel16' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel17) == 0x00001E, "Member 'FCollisionResponseContainer::GameTraceChannel17' has a wrong offset!");
static_assert(offsetof(FCollisionResponseContainer, GameTraceChannel18) == 0x00001F, "Member 'FCollisionResponseContainer::GameTraceChannel18' has a wrong offset!");

// ScriptStruct Engine.CollisionResponse
// 0x002C (0x002C - 0x0000)
struct FCollisionResponse final
{
public:
	struct FCollisionResponseContainer            ResponseToChannels;                                // 0x0000(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FResponseChannel>               ResponseArray;                                     // 0x0020(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCollisionResponse) == 0x000004, "Wrong alignment on FCollisionResponse");
static_assert(sizeof(FCollisionResponse) == 0x00002C, "Wrong size on FCollisionResponse");
static_assert(offsetof(FCollisionResponse, ResponseToChannels) == 0x000000, "Member 'FCollisionResponse::ResponseToChannels' has a wrong offset!");
static_assert(offsetof(FCollisionResponse, ResponseArray) == 0x000020, "Member 'FCollisionResponse::ResponseArray' has a wrong offset!");

// ScriptStruct Engine.BodyInstance
// 0x0128 (0x0128 - 0x0000)
struct FBodyInstance final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale3D;                                           // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionResponseContainer            ResponseToChannels;                                // 0x0014(0x0020)(Deprecated, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileName;                              // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCollisionResponse                     CollisionResponses;                                // 0x003C(0x002C)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x4];                                       // 0x0068(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseCCD : 1;                                       // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bNotifyRigidBodyCollision : 1;                     // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSimulatePhysics : 1;                              // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideMass : 1;                                 // 0x006C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableGravity : 1;                                // 0x006C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAutoWeld : 1;                                     // 0x006C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6C_6 : 1;                                   // 0x006C(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bStartAwake : 1;                                   // 0x006C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bGenerateWakeEvents : 1;                           // 0x006D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bUpdateMassWhenScaleChanges : 1;                   // 0x006D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockTranslation : 1;                              // 0x006D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockRotation : 1;                                 // 0x006D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockXTranslation : 1;                             // 0x006D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockYTranslation : 1;                             // 0x006D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockZTranslation : 1;                             // 0x006D(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockXRotation : 1;                                // 0x006D(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockYRotation : 1;                                // 0x006E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLockZRotation : 1;                                // 0x006E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverrideMaxAngularVelocity : 1;                   // 0x006E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6E_3 : 1;                                   // 0x006E(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUseAsyncScene : 1;                                // 0x006E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bOverrideMaxDepenetrationVelocity : 1;             // 0x006E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bOverrideWalkableSlopeOnInstance : 1;              // 0x006E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDepenetrationVelocity;                          // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MassInKg;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDamping;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomDOFPlaneNormal;                              // 0x0080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                COMNudge;                                          // 0x008C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         MassScale;                                         // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x8];                                       // 0x009C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWalkableSlopeOverride                 WalkableSlopeOverride;                             // 0x00A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class UPhysicalMaterial*                      PhysMaterialOverride;                              // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngularVelocity;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomSleepThresholdMultiplier;                    // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PositionSolverIterationCount;                      // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x14];                                      // 0x00C0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        RigidActorSyncId;                                  // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        RigidActorAsyncId;                                 // 0x00DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VelocitySolverIterationCount;                      // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x3C];                                      // 0x00E8(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	ESleepFamily                                  SleepFamily;                                       // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDOFMode                                      DOFMode;                                           // 0x0125(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0126(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             ObjectType;                                        // 0x0127(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBodyInstance) == 0x000004, "Wrong alignment on FBodyInstance");
static_assert(sizeof(FBodyInstance) == 0x000128, "Wrong size on FBodyInstance");
static_assert(offsetof(FBodyInstance, Scale3D) == 0x000004, "Member 'FBodyInstance::Scale3D' has a wrong offset!");
static_assert(offsetof(FBodyInstance, ResponseToChannels) == 0x000014, "Member 'FBodyInstance::ResponseToChannels' has a wrong offset!");
static_assert(offsetof(FBodyInstance, CollisionProfileName) == 0x000034, "Member 'FBodyInstance::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FBodyInstance, CollisionResponses) == 0x00003C, "Member 'FBodyInstance::CollisionResponses' has a wrong offset!");
static_assert(offsetof(FBodyInstance, MaxDepenetrationVelocity) == 0x000070, "Member 'FBodyInstance::MaxDepenetrationVelocity' has a wrong offset!");
static_assert(offsetof(FBodyInstance, MassInKg) == 0x000074, "Member 'FBodyInstance::MassInKg' has a wrong offset!");
static_assert(offsetof(FBodyInstance, LinearDamping) == 0x000078, "Member 'FBodyInstance::LinearDamping' has a wrong offset!");
static_assert(offsetof(FBodyInstance, AngularDamping) == 0x00007C, "Member 'FBodyInstance::AngularDamping' has a wrong offset!");
static_assert(offsetof(FBodyInstance, CustomDOFPlaneNormal) == 0x000080, "Member 'FBodyInstance::CustomDOFPlaneNormal' has a wrong offset!");
static_assert(offsetof(FBodyInstance, COMNudge) == 0x00008C, "Member 'FBodyInstance::COMNudge' has a wrong offset!");
static_assert(offsetof(FBodyInstance, MassScale) == 0x000098, "Member 'FBodyInstance::MassScale' has a wrong offset!");
static_assert(offsetof(FBodyInstance, WalkableSlopeOverride) == 0x0000A4, "Member 'FBodyInstance::WalkableSlopeOverride' has a wrong offset!");
static_assert(offsetof(FBodyInstance, PhysMaterialOverride) == 0x0000AC, "Member 'FBodyInstance::PhysMaterialOverride' has a wrong offset!");
static_assert(offsetof(FBodyInstance, MaxAngularVelocity) == 0x0000B0, "Member 'FBodyInstance::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(FBodyInstance, CustomSleepThresholdMultiplier) == 0x0000B4, "Member 'FBodyInstance::CustomSleepThresholdMultiplier' has a wrong offset!");
static_assert(offsetof(FBodyInstance, PhysicsBlendWeight) == 0x0000B8, "Member 'FBodyInstance::PhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(FBodyInstance, PositionSolverIterationCount) == 0x0000BC, "Member 'FBodyInstance::PositionSolverIterationCount' has a wrong offset!");
static_assert(offsetof(FBodyInstance, RigidActorSyncId) == 0x0000D4, "Member 'FBodyInstance::RigidActorSyncId' has a wrong offset!");
static_assert(offsetof(FBodyInstance, RigidActorAsyncId) == 0x0000DC, "Member 'FBodyInstance::RigidActorAsyncId' has a wrong offset!");
static_assert(offsetof(FBodyInstance, VelocitySolverIterationCount) == 0x0000E4, "Member 'FBodyInstance::VelocitySolverIterationCount' has a wrong offset!");
static_assert(offsetof(FBodyInstance, SleepFamily) == 0x000124, "Member 'FBodyInstance::SleepFamily' has a wrong offset!");
static_assert(offsetof(FBodyInstance, DOFMode) == 0x000125, "Member 'FBodyInstance::DOFMode' has a wrong offset!");
static_assert(offsetof(FBodyInstance, CollisionEnabled) == 0x000126, "Member 'FBodyInstance::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(FBodyInstance, ObjectType) == 0x000127, "Member 'FBodyInstance::ObjectType' has a wrong offset!");

// ScriptStruct Engine.PreviewAttachedObjectPair
// 0x0024 (0x0024 - 0x0000)
struct FPreviewAttachedObjectPair final
{
public:
	TSoftObjectPtr<class UObject>                 AttachedObject;                                    // 0x0000(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                Object;                                            // 0x0018(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachedTo;                                        // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreviewAttachedObjectPair) == 0x000004, "Wrong alignment on FPreviewAttachedObjectPair");
static_assert(sizeof(FPreviewAttachedObjectPair) == 0x000024, "Wrong size on FPreviewAttachedObjectPair");
static_assert(offsetof(FPreviewAttachedObjectPair, AttachedObject) == 0x000000, "Member 'FPreviewAttachedObjectPair::AttachedObject' has a wrong offset!");
static_assert(offsetof(FPreviewAttachedObjectPair, Object) == 0x000018, "Member 'FPreviewAttachedObjectPair::Object' has a wrong offset!");
static_assert(offsetof(FPreviewAttachedObjectPair, AttachedTo) == 0x00001C, "Member 'FPreviewAttachedObjectPair::AttachedTo' has a wrong offset!");

// ScriptStruct Engine.AnimNode_UseCachedPose
// 0x000C (0x002C - 0x0020)
struct FAnimNode_UseCachedPose final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LinkToCachingNode;                                 // 0x0020(0x000C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_UseCachedPose) == 0x000004, "Wrong alignment on FAnimNode_UseCachedPose");
static_assert(sizeof(FAnimNode_UseCachedPose) == 0x00002C, "Wrong size on FAnimNode_UseCachedPose");
static_assert(offsetof(FAnimNode_UseCachedPose, LinkToCachingNode) == 0x000020, "Member 'FAnimNode_UseCachedPose::LinkToCachingNode' has a wrong offset!");

// ScriptStruct Engine.PointDamageEvent
// 0x0090 (0x0098 - 0x0008)
struct FPointDamageEvent final : public FDamageEvent
{
public:
	float                                         Damage;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ShotDirection;                                     // 0x000C(0x000C)(NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0018(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPointDamageEvent) == 0x000004, "Wrong alignment on FPointDamageEvent");
static_assert(sizeof(FPointDamageEvent) == 0x000098, "Wrong size on FPointDamageEvent");
static_assert(offsetof(FPointDamageEvent, Damage) == 0x000008, "Member 'FPointDamageEvent::Damage' has a wrong offset!");
static_assert(offsetof(FPointDamageEvent, ShotDirection) == 0x00000C, "Member 'FPointDamageEvent::ShotDirection' has a wrong offset!");
static_assert(offsetof(FPointDamageEvent, HitInfo) == 0x000018, "Member 'FPointDamageEvent::HitInfo' has a wrong offset!");

// ScriptStruct Engine.RotationTrack
// 0x0018 (0x0018 - 0x0000)
struct FRotationTrack final
{
public:
	TArray<struct FQuat>                          RotKeys;                                           // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotationTrack) == 0x000004, "Wrong alignment on FRotationTrack");
static_assert(sizeof(FRotationTrack) == 0x000018, "Wrong size on FRotationTrack");
static_assert(offsetof(FRotationTrack, RotKeys) == 0x000000, "Member 'FRotationTrack::RotKeys' has a wrong offset!");
static_assert(offsetof(FRotationTrack, Times) == 0x00000C, "Member 'FRotationTrack::Times' has a wrong offset!");

// ScriptStruct Engine.MeshMergingSettings
// 0x0080 (0x0080 - 0x0000)
struct FMeshMergingSettings final
{
public:
	bool                                          bGenerateLightMapUV;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetLightMapUVChannel;                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetLightMapResolution;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportVertexColors;                               // 0x000C(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPivotPointAtZero;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMergePhysicsData;                                 // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMergeMaterials;                                   // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 MaterialSettings;                                  // 0x0010(0x0064)(Edit, NativeAccessSpecifierPublic)
	bool                                          bBakeVertexData;                                   // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportNormalMap;                                  // 0x0075(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportMetallicMap;                                // 0x0076(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportRoughnessMap;                               // 0x0077(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExportSpecularMap;                                // 0x0078(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MergedMaterialAtlasResolution;                     // 0x007C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshMergingSettings) == 0x000004, "Wrong alignment on FMeshMergingSettings");
static_assert(sizeof(FMeshMergingSettings) == 0x000080, "Wrong size on FMeshMergingSettings");
static_assert(offsetof(FMeshMergingSettings, bGenerateLightMapUV) == 0x000000, "Member 'FMeshMergingSettings::bGenerateLightMapUV' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, TargetLightMapUVChannel) == 0x000004, "Member 'FMeshMergingSettings::TargetLightMapUVChannel' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, TargetLightMapResolution) == 0x000008, "Member 'FMeshMergingSettings::TargetLightMapResolution' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bImportVertexColors) == 0x00000C, "Member 'FMeshMergingSettings::bImportVertexColors' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bPivotPointAtZero) == 0x00000D, "Member 'FMeshMergingSettings::bPivotPointAtZero' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bMergePhysicsData) == 0x00000E, "Member 'FMeshMergingSettings::bMergePhysicsData' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bMergeMaterials) == 0x00000F, "Member 'FMeshMergingSettings::bMergeMaterials' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, MaterialSettings) == 0x000010, "Member 'FMeshMergingSettings::MaterialSettings' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bBakeVertexData) == 0x000074, "Member 'FMeshMergingSettings::bBakeVertexData' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bExportNormalMap) == 0x000075, "Member 'FMeshMergingSettings::bExportNormalMap' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bExportMetallicMap) == 0x000076, "Member 'FMeshMergingSettings::bExportMetallicMap' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bExportRoughnessMap) == 0x000077, "Member 'FMeshMergingSettings::bExportRoughnessMap' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, bExportSpecularMap) == 0x000078, "Member 'FMeshMergingSettings::bExportSpecularMap' has a wrong offset!");
static_assert(offsetof(FMeshMergingSettings, MergedMaterialAtlasResolution) == 0x00007C, "Member 'FMeshMergingSettings::MergedMaterialAtlasResolution' has a wrong offset!");

// ScriptStruct Engine.RawDistributionFloat
// 0x000C (0x0028 - 0x001C)
struct FRawDistributionFloat final : public FRawDistribution
{
public:
	float                                         MinValue;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxValue;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDistributionFloat*                     Distribution;                                      // 0x0024(0x0004)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRawDistributionFloat) == 0x000004, "Wrong alignment on FRawDistributionFloat");
static_assert(sizeof(FRawDistributionFloat) == 0x000028, "Wrong size on FRawDistributionFloat");
static_assert(offsetof(FRawDistributionFloat, MinValue) == 0x00001C, "Member 'FRawDistributionFloat::MinValue' has a wrong offset!");
static_assert(offsetof(FRawDistributionFloat, MaxValue) == 0x000020, "Member 'FRawDistributionFloat::MaxValue' has a wrong offset!");
static_assert(offsetof(FRawDistributionFloat, Distribution) == 0x000024, "Member 'FRawDistributionFloat::Distribution' has a wrong offset!");

// ScriptStruct Engine.MeshReductionSettings
// 0x0020 (0x0020 - 0x0000)
struct FMeshReductionSettings final
{
public:
	float                                         PercentTriangles;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviation;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeldingThreshold;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HardAngleThreshold;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        SilhouetteImportance;                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        TextureImportance;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        ShadingImportance;                                 // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalculateNormals;                               // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BaseLODModel;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateUniqueLightmapUVs;                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bKeepSymmetry;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bVisibilityAided;                                  // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCullOccluded;                                     // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        VisibilityAggressiveness;                          // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshFeatureImportance                        VertexColorImportance;                             // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshReductionSettings) == 0x000004, "Wrong alignment on FMeshReductionSettings");
static_assert(sizeof(FMeshReductionSettings) == 0x000020, "Wrong size on FMeshReductionSettings");
static_assert(offsetof(FMeshReductionSettings, PercentTriangles) == 0x000000, "Member 'FMeshReductionSettings::PercentTriangles' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, MaxDeviation) == 0x000004, "Member 'FMeshReductionSettings::MaxDeviation' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, WeldingThreshold) == 0x000008, "Member 'FMeshReductionSettings::WeldingThreshold' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, HardAngleThreshold) == 0x00000C, "Member 'FMeshReductionSettings::HardAngleThreshold' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, SilhouetteImportance) == 0x000010, "Member 'FMeshReductionSettings::SilhouetteImportance' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, TextureImportance) == 0x000011, "Member 'FMeshReductionSettings::TextureImportance' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, ShadingImportance) == 0x000012, "Member 'FMeshReductionSettings::ShadingImportance' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, bRecalculateNormals) == 0x000013, "Member 'FMeshReductionSettings::bRecalculateNormals' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, BaseLODModel) == 0x000014, "Member 'FMeshReductionSettings::BaseLODModel' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, bGenerateUniqueLightmapUVs) == 0x000018, "Member 'FMeshReductionSettings::bGenerateUniqueLightmapUVs' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, bKeepSymmetry) == 0x000019, "Member 'FMeshReductionSettings::bKeepSymmetry' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, bVisibilityAided) == 0x00001A, "Member 'FMeshReductionSettings::bVisibilityAided' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, bCullOccluded) == 0x00001B, "Member 'FMeshReductionSettings::bCullOccluded' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, VisibilityAggressiveness) == 0x00001C, "Member 'FMeshReductionSettings::VisibilityAggressiveness' has a wrong offset!");
static_assert(offsetof(FMeshReductionSettings, VertexColorImportance) == 0x00001D, "Member 'FMeshReductionSettings::VertexColorImportance' has a wrong offset!");

// ScriptStruct Engine.Node
// 0x0050 (0x0050 - 0x0000)
struct FNode final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0040(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvanced;                                         // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNode) == 0x000010, "Wrong alignment on FNode");
static_assert(sizeof(FNode) == 0x000050, "Wrong size on FNode");
static_assert(offsetof(FNode, Name) == 0x000000, "Member 'FNode::Name' has a wrong offset!");
static_assert(offsetof(FNode, ParentName) == 0x000008, "Member 'FNode::ParentName' has a wrong offset!");
static_assert(offsetof(FNode, Transform) == 0x000010, "Member 'FNode::Transform' has a wrong offset!");
static_assert(offsetof(FNode, DisplayName) == 0x000040, "Member 'FNode::DisplayName' has a wrong offset!");
static_assert(offsetof(FNode, bAdvanced) == 0x00004C, "Member 'FNode::bAdvanced' has a wrong offset!");

// ScriptStruct Engine.POV
// 0x001C (0x001C - 0x0000)
struct FPOV final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPOV) == 0x000004, "Wrong alignment on FPOV");
static_assert(sizeof(FPOV) == 0x00001C, "Wrong size on FPOV");
static_assert(offsetof(FPOV, Location) == 0x000000, "Member 'FPOV::Location' has a wrong offset!");
static_assert(offsetof(FPOV, Rotation) == 0x00000C, "Member 'FPOV::Rotation' has a wrong offset!");
static_assert(offsetof(FPOV, FOV) == 0x000018, "Member 'FPOV::FOV' has a wrong offset!");

// ScriptStruct Engine.AnimUpdateRateParameters
// 0x0070 (0x0070 - 0x0000)
struct FAnimUpdateRateParameters final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UpdateRate;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvaluationRate;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolateSkippedFrames;                         // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldUseLodMap;                                  // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSkipUpdate;                                       // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSkipEvaluation;                                   // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TickedPoseOffestTime;                              // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalTime;                                    // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseNonRenderedUpdateRate;                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 BaseVisibleDistanceFactorThesholds;                // 0x0020(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            LODToFrameSkipMap;                                 // 0x002C(0x003C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxEvalRateForInterpolation;                       // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUpdateRateShiftBucket                        ShiftBucket;                                       // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimUpdateRateParameters) == 0x000004, "Wrong alignment on FAnimUpdateRateParameters");
static_assert(sizeof(FAnimUpdateRateParameters) == 0x000070, "Wrong size on FAnimUpdateRateParameters");
static_assert(offsetof(FAnimUpdateRateParameters, UpdateRate) == 0x000004, "Member 'FAnimUpdateRateParameters::UpdateRate' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, EvaluationRate) == 0x000008, "Member 'FAnimUpdateRateParameters::EvaluationRate' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, bInterpolateSkippedFrames) == 0x00000C, "Member 'FAnimUpdateRateParameters::bInterpolateSkippedFrames' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, bShouldUseLodMap) == 0x00000D, "Member 'FAnimUpdateRateParameters::bShouldUseLodMap' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, bSkipUpdate) == 0x00000E, "Member 'FAnimUpdateRateParameters::bSkipUpdate' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, bSkipEvaluation) == 0x00000F, "Member 'FAnimUpdateRateParameters::bSkipEvaluation' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, TickedPoseOffestTime) == 0x000010, "Member 'FAnimUpdateRateParameters::TickedPoseOffestTime' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, AdditionalTime) == 0x000014, "Member 'FAnimUpdateRateParameters::AdditionalTime' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, BaseNonRenderedUpdateRate) == 0x00001C, "Member 'FAnimUpdateRateParameters::BaseNonRenderedUpdateRate' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, BaseVisibleDistanceFactorThesholds) == 0x000020, "Member 'FAnimUpdateRateParameters::BaseVisibleDistanceFactorThesholds' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, LODToFrameSkipMap) == 0x00002C, "Member 'FAnimUpdateRateParameters::LODToFrameSkipMap' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, MaxEvalRateForInterpolation) == 0x000068, "Member 'FAnimUpdateRateParameters::MaxEvalRateForInterpolation' has a wrong offset!");
static_assert(offsetof(FAnimUpdateRateParameters, ShiftBucket) == 0x00006C, "Member 'FAnimUpdateRateParameters::ShiftBucket' has a wrong offset!");

// ScriptStruct Engine.AnimInstanceProxy
// 0x0270 (0x0270 - 0x0000)
struct alignas(0x10) FAnimInstanceProxy
{
public:
	uint8                                         Pad_0[0x270];                                      // 0x0000(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimInstanceProxy) == 0x000010, "Wrong alignment on FAnimInstanceProxy");
static_assert(sizeof(FAnimInstanceProxy) == 0x000270, "Wrong size on FAnimInstanceProxy");

// ScriptStruct Engine.AnimSingleNodeInstanceProxy
// 0x00B0 (0x0320 - 0x0270)
struct FAnimSingleNodeInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_270[0xB0];                                     // 0x0270(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSingleNodeInstanceProxy) == 0x000010, "Wrong alignment on FAnimSingleNodeInstanceProxy");
static_assert(sizeof(FAnimSingleNodeInstanceProxy) == 0x000320, "Wrong size on FAnimSingleNodeInstanceProxy");

// ScriptStruct Engine.AnimSlotDesc
// 0x000C (0x000C - 0x0000)
struct FAnimSlotDesc final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChannels;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSlotDesc) == 0x000004, "Wrong alignment on FAnimSlotDesc");
static_assert(sizeof(FAnimSlotDesc) == 0x00000C, "Wrong size on FAnimSlotDesc");
static_assert(offsetof(FAnimSlotDesc, SlotName) == 0x000000, "Member 'FAnimSlotDesc::SlotName' has a wrong offset!");
static_assert(offsetof(FAnimSlotDesc, NumChannels) == 0x000008, "Member 'FAnimSlotDesc::NumChannels' has a wrong offset!");

// ScriptStruct Engine.AnimSlotInfo
// 0x0014 (0x0014 - 0x0000)
struct FAnimSlotInfo final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ChannelWeights;                                    // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSlotInfo) == 0x000004, "Wrong alignment on FAnimSlotInfo");
static_assert(sizeof(FAnimSlotInfo) == 0x000014, "Wrong size on FAnimSlotInfo");
static_assert(offsetof(FAnimSlotInfo, SlotName) == 0x000000, "Member 'FAnimSlotInfo::SlotName' has a wrong offset!");
static_assert(offsetof(FAnimSlotInfo, ChannelWeights) == 0x000008, "Member 'FAnimSlotInfo::ChannelWeights' has a wrong offset!");

// ScriptStruct Engine.TransformCurve
// 0x0330 (0x0344 - 0x0014)
struct FTransformCurve final : public FAnimCurveBase
{
public:
	struct FVectorCurve                           TranslationCurve;                                  // 0x0014(0x0110)(NativeAccessSpecifierPublic)
	struct FVectorCurve                           RotationCurve;                                     // 0x0124(0x0110)(NativeAccessSpecifierPublic)
	struct FVectorCurve                           ScaleCurve;                                        // 0x0234(0x0110)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformCurve) == 0x000004, "Wrong alignment on FTransformCurve");
static_assert(sizeof(FTransformCurve) == 0x000344, "Wrong size on FTransformCurve");
static_assert(offsetof(FTransformCurve, TranslationCurve) == 0x000014, "Member 'FTransformCurve::TranslationCurve' has a wrong offset!");
static_assert(offsetof(FTransformCurve, RotationCurve) == 0x000124, "Member 'FTransformCurve::RotationCurve' has a wrong offset!");
static_assert(offsetof(FTransformCurve, ScaleCurve) == 0x000234, "Member 'FTransformCurve::ScaleCurve' has a wrong offset!");

// ScriptStruct Engine.MTDResult
// 0x0010 (0x0010 - 0x0000)
struct FMTDResult final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMTDResult) == 0x000004, "Wrong alignment on FMTDResult");
static_assert(sizeof(FMTDResult) == 0x000010, "Wrong size on FMTDResult");
static_assert(offsetof(FMTDResult, Direction) == 0x000000, "Member 'FMTDResult::Direction' has a wrong offset!");
static_assert(offsetof(FMTDResult, Distance) == 0x00000C, "Member 'FMTDResult::Distance' has a wrong offset!");

// ScriptStruct Engine.OverlapResult
// 0x0018 (0x0018 - 0x0000)
struct FOverlapResult final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBlockingHit : 1;                                  // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverlapResult) == 0x000004, "Wrong alignment on FOverlapResult");
static_assert(sizeof(FOverlapResult) == 0x000018, "Wrong size on FOverlapResult");
static_assert(offsetof(FOverlapResult, Actor) == 0x000000, "Member 'FOverlapResult::Actor' has a wrong offset!");
static_assert(offsetof(FOverlapResult, Component) == 0x000008, "Member 'FOverlapResult::Component' has a wrong offset!");

// ScriptStruct Engine.PrimitiveMaterialRef
// 0x000C (0x000C - 0x0000)
struct FPrimitiveMaterialRef final
{
public:
	class UPrimitiveComponent*                    Primitive;                                         // 0x0000(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        Decal;                                             // 0x0004(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElementIndex;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimitiveMaterialRef) == 0x000004, "Wrong alignment on FPrimitiveMaterialRef");
static_assert(sizeof(FPrimitiveMaterialRef) == 0x00000C, "Wrong size on FPrimitiveMaterialRef");
static_assert(offsetof(FPrimitiveMaterialRef, Primitive) == 0x000000, "Member 'FPrimitiveMaterialRef::Primitive' has a wrong offset!");
static_assert(offsetof(FPrimitiveMaterialRef, Decal) == 0x000004, "Member 'FPrimitiveMaterialRef::Decal' has a wrong offset!");
static_assert(offsetof(FPrimitiveMaterialRef, ElementIndex) == 0x000008, "Member 'FPrimitiveMaterialRef::ElementIndex' has a wrong offset!");

// ScriptStruct Engine.TimelineFloatTrack
// 0x0028 (0x0028 - 0x0000)
struct FTimelineFloatTrack final
{
public:
	class UCurveFloat*                            FloatCurve;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Output)>                 InterpFunc;                                        // 0x0004(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FloatPropertyName;                                 // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFloatProperty*                         FloatProperty;                                     // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineFloatTrack) == 0x000004, "Wrong alignment on FTimelineFloatTrack");
static_assert(sizeof(FTimelineFloatTrack) == 0x000028, "Wrong size on FTimelineFloatTrack");
static_assert(offsetof(FTimelineFloatTrack, FloatCurve) == 0x000000, "Member 'FTimelineFloatTrack::FloatCurve' has a wrong offset!");
static_assert(offsetof(FTimelineFloatTrack, InterpFunc) == 0x000004, "Member 'FTimelineFloatTrack::InterpFunc' has a wrong offset!");
static_assert(offsetof(FTimelineFloatTrack, FloatPropertyName) == 0x000014, "Member 'FTimelineFloatTrack::FloatPropertyName' has a wrong offset!");
static_assert(offsetof(FTimelineFloatTrack, FloatProperty) == 0x00001C, "Member 'FTimelineFloatTrack::FloatProperty' has a wrong offset!");

// ScriptStruct Engine.AttenuationSettings
// 0x00CC (0x00CC - 0x0000)
struct FAttenuationSettings final
{
public:
	uint8                                         bAttenuate : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSpatialize : 1;                                   // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAttenuateWithLPF : 1;                             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableListenerFocus : 1;                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableOcclusion : 1;                              // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseComplexCollisionForOcclusion : 1;              // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESoundDistanceModel                           DistanceAlgorithm;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CustomAttenuationCurve;                            // 0x0008(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESoundDistanceCalc                            DistanceType;                                      // 0x0060(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttenuationShape                             AttenuationShape;                                  // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         dBAttenuationAtMax;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OmniRadius;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StereoSpread;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundSpatializationAlgorithm                 SpatializationAlgorithm;                           // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RadiusMin;                                         // 0x0074(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusMax;                                         // 0x0078(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttenuationShapeExtents;                           // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConeOffset;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffDistance;                                   // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFRadiusMin;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFRadiusMax;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFFrequencyAtMin;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPFFrequencyAtMax;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusAzimuth;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusAzimuth;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusDistanceScale;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusDistanceScale;                             // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPriorityScale;                                // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusPriorityScale;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusVolumeAttenuation;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusVolumeAttenuation;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionLowPassFilterFrequency;                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionVolumeAttenuation;                        // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionInterpolationTime;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttenuationSettings) == 0x000004, "Wrong alignment on FAttenuationSettings");
static_assert(sizeof(FAttenuationSettings) == 0x0000CC, "Wrong size on FAttenuationSettings");
static_assert(offsetof(FAttenuationSettings, DistanceAlgorithm) == 0x000004, "Member 'FAttenuationSettings::DistanceAlgorithm' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, CustomAttenuationCurve) == 0x000008, "Member 'FAttenuationSettings::CustomAttenuationCurve' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, DistanceType) == 0x000060, "Member 'FAttenuationSettings::DistanceType' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, AttenuationShape) == 0x000061, "Member 'FAttenuationSettings::AttenuationShape' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, dBAttenuationAtMax) == 0x000064, "Member 'FAttenuationSettings::dBAttenuationAtMax' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, OmniRadius) == 0x000068, "Member 'FAttenuationSettings::OmniRadius' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, StereoSpread) == 0x00006C, "Member 'FAttenuationSettings::StereoSpread' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, SpatializationAlgorithm) == 0x000070, "Member 'FAttenuationSettings::SpatializationAlgorithm' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, RadiusMin) == 0x000074, "Member 'FAttenuationSettings::RadiusMin' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, RadiusMax) == 0x000078, "Member 'FAttenuationSettings::RadiusMax' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, AttenuationShapeExtents) == 0x00007C, "Member 'FAttenuationSettings::AttenuationShapeExtents' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, ConeOffset) == 0x000088, "Member 'FAttenuationSettings::ConeOffset' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, FalloffDistance) == 0x00008C, "Member 'FAttenuationSettings::FalloffDistance' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, LPFRadiusMin) == 0x000090, "Member 'FAttenuationSettings::LPFRadiusMin' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, LPFRadiusMax) == 0x000094, "Member 'FAttenuationSettings::LPFRadiusMax' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, LPFFrequencyAtMin) == 0x000098, "Member 'FAttenuationSettings::LPFFrequencyAtMin' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, LPFFrequencyAtMax) == 0x00009C, "Member 'FAttenuationSettings::LPFFrequencyAtMax' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, FocusAzimuth) == 0x0000A0, "Member 'FAttenuationSettings::FocusAzimuth' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, NonFocusAzimuth) == 0x0000A4, "Member 'FAttenuationSettings::NonFocusAzimuth' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, FocusDistanceScale) == 0x0000A8, "Member 'FAttenuationSettings::FocusDistanceScale' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, NonFocusDistanceScale) == 0x0000AC, "Member 'FAttenuationSettings::NonFocusDistanceScale' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, FocusPriorityScale) == 0x0000B0, "Member 'FAttenuationSettings::FocusPriorityScale' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, NonFocusPriorityScale) == 0x0000B4, "Member 'FAttenuationSettings::NonFocusPriorityScale' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, FocusVolumeAttenuation) == 0x0000B8, "Member 'FAttenuationSettings::FocusVolumeAttenuation' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, NonFocusVolumeAttenuation) == 0x0000BC, "Member 'FAttenuationSettings::NonFocusVolumeAttenuation' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, OcclusionLowPassFilterFrequency) == 0x0000C0, "Member 'FAttenuationSettings::OcclusionLowPassFilterFrequency' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, OcclusionVolumeAttenuation) == 0x0000C4, "Member 'FAttenuationSettings::OcclusionVolumeAttenuation' has a wrong offset!");
static_assert(offsetof(FAttenuationSettings, OcclusionInterpolationTime) == 0x0000C8, "Member 'FAttenuationSettings::OcclusionInterpolationTime' has a wrong offset!");

// ScriptStruct Engine.SwarmDebugOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FSwarmDebugOptions final
{
public:
	uint8                                         bDistributionEnabled : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bForceContentExport : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bInitialized : 1;                                  // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwarmDebugOptions) == 0x000004, "Wrong alignment on FSwarmDebugOptions");
static_assert(sizeof(FSwarmDebugOptions) == 0x000004, "Wrong size on FSwarmDebugOptions");

// ScriptStruct Engine.GameplayDebuggerShapeElement
// 0x0070 (0x0070 - 0x0000)
struct FGameplayDebuggerShapeElement final
{
public:
	class FString                                 Description;                                       // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformationMatrix;                              // 0x0020(0x0040)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EGameplayDebuggerShapeElement                 Type;                                              // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Color;                                             // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ThicknesOrRadius;                                  // 0x0062(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayDebuggerShapeElement) == 0x000010, "Wrong alignment on FGameplayDebuggerShapeElement");
static_assert(sizeof(FGameplayDebuggerShapeElement) == 0x000070, "Wrong size on FGameplayDebuggerShapeElement");
static_assert(offsetof(FGameplayDebuggerShapeElement, Description) == 0x000000, "Member 'FGameplayDebuggerShapeElement::Description' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerShapeElement, Points) == 0x00000C, "Member 'FGameplayDebuggerShapeElement::Points' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerShapeElement, TransformationMatrix) == 0x000020, "Member 'FGameplayDebuggerShapeElement::TransformationMatrix' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerShapeElement, Type) == 0x000060, "Member 'FGameplayDebuggerShapeElement::Type' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerShapeElement, Color) == 0x000061, "Member 'FGameplayDebuggerShapeElement::Color' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerShapeElement, ThicknesOrRadius) == 0x000062, "Member 'FGameplayDebuggerShapeElement::ThicknesOrRadius' has a wrong offset!");

// ScriptStruct Engine.LightmassDebugOptions
// 0x0010 (0x0010 - 0x0000)
struct FLightmassDebugOptions final
{
public:
	uint8                                         bDebugMode : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bStatsEnabled : 1;                                 // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGatherBSPSurfacesAcrossComponents : 1;            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoplanarTolerance;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseImmediateImport : 1;                           // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bImmediateProcessMappings : 1;                     // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSortMappings : 1;                                 // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDumpBinaryFiles : 1;                              // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugMaterials : 1;                               // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bPadMappings : 1;                                  // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugPaddings : 1;                                // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOnlyCalcDebugTexelMappings : 1;                   // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseRandomColors : 1;                              // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bColorBordersGreen : 1;                            // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bColorByExecutionTime : 1;                         // 0x0009(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExecutionTimeDivisor;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightmassDebugOptions) == 0x000004, "Wrong alignment on FLightmassDebugOptions");
static_assert(sizeof(FLightmassDebugOptions) == 0x000010, "Wrong size on FLightmassDebugOptions");
static_assert(offsetof(FLightmassDebugOptions, CoplanarTolerance) == 0x000004, "Member 'FLightmassDebugOptions::CoplanarTolerance' has a wrong offset!");
static_assert(offsetof(FLightmassDebugOptions, ExecutionTimeDivisor) == 0x00000C, "Member 'FLightmassDebugOptions::ExecutionTimeDivisor' has a wrong offset!");

// ScriptStruct Engine.LightmassPrimitiveSettings
// 0x0018 (0x0018 - 0x0000)
struct FLightmassPrimitiveSettings final
{
public:
	uint8                                         bUseTwoSidedLighting : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShadowIndirectOnly : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseEmissiveForStaticLighting : 1;                 // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseVertexNormalForHemisphereGather : 1;           // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmissiveLightFalloffExponent;                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveLightExplicitInfluenceRadius;              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBoost;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyOccludedSamplesFraction;                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightmassPrimitiveSettings) == 0x000004, "Wrong alignment on FLightmassPrimitiveSettings");
static_assert(sizeof(FLightmassPrimitiveSettings) == 0x000018, "Wrong size on FLightmassPrimitiveSettings");
static_assert(offsetof(FLightmassPrimitiveSettings, EmissiveLightFalloffExponent) == 0x000004, "Member 'FLightmassPrimitiveSettings::EmissiveLightFalloffExponent' has a wrong offset!");
static_assert(offsetof(FLightmassPrimitiveSettings, EmissiveLightExplicitInfluenceRadius) == 0x000008, "Member 'FLightmassPrimitiveSettings::EmissiveLightExplicitInfluenceRadius' has a wrong offset!");
static_assert(offsetof(FLightmassPrimitiveSettings, EmissiveBoost) == 0x00000C, "Member 'FLightmassPrimitiveSettings::EmissiveBoost' has a wrong offset!");
static_assert(offsetof(FLightmassPrimitiveSettings, DiffuseBoost) == 0x000010, "Member 'FLightmassPrimitiveSettings::DiffuseBoost' has a wrong offset!");
static_assert(offsetof(FLightmassPrimitiveSettings, FullyOccludedSamplesFraction) == 0x000014, "Member 'FLightmassPrimitiveSettings::FullyOccludedSamplesFraction' has a wrong offset!");

// ScriptStruct Engine.AnimSegment
// 0x0018 (0x0018 - 0x0000)
struct FAnimSegment final
{
public:
	class UAnimSequenceBase*                      AnimReference;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPos;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStartTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimEndTime;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopingCount;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSegment) == 0x000004, "Wrong alignment on FAnimSegment");
static_assert(sizeof(FAnimSegment) == 0x000018, "Wrong size on FAnimSegment");
static_assert(offsetof(FAnimSegment, AnimReference) == 0x000000, "Member 'FAnimSegment::AnimReference' has a wrong offset!");
static_assert(offsetof(FAnimSegment, StartPos) == 0x000004, "Member 'FAnimSegment::StartPos' has a wrong offset!");
static_assert(offsetof(FAnimSegment, AnimStartTime) == 0x000008, "Member 'FAnimSegment::AnimStartTime' has a wrong offset!");
static_assert(offsetof(FAnimSegment, AnimEndTime) == 0x00000C, "Member 'FAnimSegment::AnimEndTime' has a wrong offset!");
static_assert(offsetof(FAnimSegment, AnimPlayRate) == 0x000010, "Member 'FAnimSegment::AnimPlayRate' has a wrong offset!");
static_assert(offsetof(FAnimSegment, LoopingCount) == 0x000014, "Member 'FAnimSegment::LoopingCount' has a wrong offset!");

// ScriptStruct Engine.AnimTrack
// 0x000C (0x000C - 0x0000)
struct FAnimTrack final
{
public:
	TArray<struct FAnimSegment>                   AnimSegments;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimTrack) == 0x000004, "Wrong alignment on FAnimTrack");
static_assert(sizeof(FAnimTrack) == 0x00000C, "Wrong size on FAnimTrack");
static_assert(offsetof(FAnimTrack, AnimSegments) == 0x000000, "Member 'FAnimTrack::AnimSegments' has a wrong offset!");

// ScriptStruct Engine.SlotAnimationTrack
// 0x0014 (0x0014 - 0x0000)
struct FSlotAnimationTrack final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimTrack                             AnimTrack;                                         // 0x0008(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotAnimationTrack) == 0x000004, "Wrong alignment on FSlotAnimationTrack");
static_assert(sizeof(FSlotAnimationTrack) == 0x000014, "Wrong size on FSlotAnimationTrack");
static_assert(offsetof(FSlotAnimationTrack, SlotName) == 0x000000, "Member 'FSlotAnimationTrack::SlotName' has a wrong offset!");
static_assert(offsetof(FSlotAnimationTrack, AnimTrack) == 0x000008, "Member 'FSlotAnimationTrack::AnimTrack' has a wrong offset!");

// ScriptStruct Engine.LightmassLightSettings
// 0x000C (0x000C - 0x0000)
struct FLightmassLightSettings
{
public:
	float                                         IndirectLightingSaturation;                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowExponent;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAreaShadowsForStationaryLight;                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightmassLightSettings) == 0x000004, "Wrong alignment on FLightmassLightSettings");
static_assert(sizeof(FLightmassLightSettings) == 0x00000C, "Wrong size on FLightmassLightSettings");
static_assert(offsetof(FLightmassLightSettings, IndirectLightingSaturation) == 0x000000, "Member 'FLightmassLightSettings::IndirectLightingSaturation' has a wrong offset!");
static_assert(offsetof(FLightmassLightSettings, ShadowExponent) == 0x000004, "Member 'FLightmassLightSettings::ShadowExponent' has a wrong offset!");
static_assert(offsetof(FLightmassLightSettings, bUseAreaShadowsForStationaryLight) == 0x000008, "Member 'FLightmassLightSettings::bUseAreaShadowsForStationaryLight' has a wrong offset!");

// ScriptStruct Engine.LightmassDirectionalLightSettings
// 0x0004 (0x0010 - 0x000C)
struct FLightmassDirectionalLightSettings final : public FLightmassLightSettings
{
public:
	float                                         LightSourceAngle;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightmassDirectionalLightSettings) == 0x000004, "Wrong alignment on FLightmassDirectionalLightSettings");
static_assert(sizeof(FLightmassDirectionalLightSettings) == 0x000010, "Wrong size on FLightmassDirectionalLightSettings");
static_assert(offsetof(FLightmassDirectionalLightSettings, LightSourceAngle) == 0x00000C, "Member 'FLightmassDirectionalLightSettings::LightSourceAngle' has a wrong offset!");

// ScriptStruct Engine.GameNameRedirect
// 0x0010 (0x0010 - 0x0000)
struct FGameNameRedirect final
{
public:
	class FName                                   OldGameName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewGameName;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameNameRedirect) == 0x000004, "Wrong alignment on FGameNameRedirect");
static_assert(sizeof(FGameNameRedirect) == 0x000010, "Wrong size on FGameNameRedirect");
static_assert(offsetof(FGameNameRedirect, OldGameName) == 0x000000, "Member 'FGameNameRedirect::OldGameName' has a wrong offset!");
static_assert(offsetof(FGameNameRedirect, NewGameName) == 0x000008, "Member 'FGameNameRedirect::NewGameName' has a wrong offset!");

// ScriptStruct Engine.LightmassPointLightSettings
// 0x0000 (0x000C - 0x000C)
struct FLightmassPointLightSettings final : public FLightmassLightSettings
{
};
static_assert(alignof(FLightmassPointLightSettings) == 0x000004, "Wrong alignment on FLightmassPointLightSettings");
static_assert(sizeof(FLightmassPointLightSettings) == 0x00000C, "Wrong size on FLightmassPointLightSettings");

// ScriptStruct Engine.ClothingAssetData
// 0x00C8 (0x00C8 - 0x0000)
struct FClothingAssetData final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ApexFileName;                                      // 0x0008(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClothPropertiesChanged;                           // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClothPhysicsProperties                PhysicsProperties;                                 // 0x0018(0x0050)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x60];                                      // 0x0068(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClothingAssetData) == 0x000004, "Wrong alignment on FClothingAssetData");
static_assert(sizeof(FClothingAssetData) == 0x0000C8, "Wrong size on FClothingAssetData");
static_assert(offsetof(FClothingAssetData, AssetName) == 0x000000, "Member 'FClothingAssetData::AssetName' has a wrong offset!");
static_assert(offsetof(FClothingAssetData, ApexFileName) == 0x000008, "Member 'FClothingAssetData::ApexFileName' has a wrong offset!");
static_assert(offsetof(FClothingAssetData, bClothPropertiesChanged) == 0x000014, "Member 'FClothingAssetData::bClothPropertiesChanged' has a wrong offset!");
static_assert(offsetof(FClothingAssetData, PhysicsProperties) == 0x000018, "Member 'FClothingAssetData::PhysicsProperties' has a wrong offset!");

// ScriptStruct Engine.LocalizedSubtitle
// 0x001C (0x001C - 0x0000)
struct FLocalizedSubtitle final
{
public:
	class FString                                 LanguageExt;                                       // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSubtitleCue>                   Subtitles;                                         // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bMature : 1;                                       // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bManualWordWrap : 1;                               // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSingleLine : 1;                                   // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocalizedSubtitle) == 0x000004, "Wrong alignment on FLocalizedSubtitle");
static_assert(sizeof(FLocalizedSubtitle) == 0x00001C, "Wrong size on FLocalizedSubtitle");
static_assert(offsetof(FLocalizedSubtitle, LanguageExt) == 0x000000, "Member 'FLocalizedSubtitle::LanguageExt' has a wrong offset!");
static_assert(offsetof(FLocalizedSubtitle, Subtitles) == 0x00000C, "Member 'FLocalizedSubtitle::Subtitles' has a wrong offset!");

// ScriptStruct Engine.WrappedStringElement
// 0x0014 (0x0014 - 0x0000)
struct FWrappedStringElement final
{
public:
	class FString                                 Value;                                             // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LineExtent;                                        // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWrappedStringElement) == 0x000004, "Wrong alignment on FWrappedStringElement");
static_assert(sizeof(FWrappedStringElement) == 0x000014, "Wrong size on FWrappedStringElement");
static_assert(offsetof(FWrappedStringElement, Value) == 0x000000, "Member 'FWrappedStringElement::Value' has a wrong offset!");
static_assert(offsetof(FWrappedStringElement, LineExtent) == 0x00000C, "Member 'FWrappedStringElement::LineExtent' has a wrong offset!");

// ScriptStruct Engine.MaterialRelevance
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FMaterialRelevance final
{
public:
	uint8                                         bOpaque : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bMasked : 1;                                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDistortion : 1;                                   // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSeparateTranslucency : 1;                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNormalTranslucency : 1;                           // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableDepthTest : 1;                             // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOutputsVelocityInBasePass : 1;                    // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUsesGlobalDistanceField : 1;                      // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        ShadingModelMask;                                  // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialRelevance) == 0x000004, "Wrong alignment on FMaterialRelevance");
static_assert(sizeof(FMaterialRelevance) == 0x000008, "Wrong size on FMaterialRelevance");
static_assert(offsetof(FMaterialRelevance, ShadingModelMask) == 0x000004, "Member 'FMaterialRelevance::ShadingModelMask' has a wrong offset!");

// ScriptStruct Engine.BasedPosition
// 0x0034 (0x0034 - 0x0000)
struct FBasedPosition final
{
public:
	class AActor*                                 Base;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedBaseLocation;                                // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CachedBaseRotation;                                // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CachedTransPosition;                               // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasedPosition) == 0x000004, "Wrong alignment on FBasedPosition");
static_assert(sizeof(FBasedPosition) == 0x000034, "Wrong size on FBasedPosition");
static_assert(offsetof(FBasedPosition, Base) == 0x000000, "Member 'FBasedPosition::Base' has a wrong offset!");
static_assert(offsetof(FBasedPosition, Position) == 0x000004, "Member 'FBasedPosition::Position' has a wrong offset!");
static_assert(offsetof(FBasedPosition, CachedBaseLocation) == 0x000010, "Member 'FBasedPosition::CachedBaseLocation' has a wrong offset!");
static_assert(offsetof(FBasedPosition, CachedBaseRotation) == 0x00001C, "Member 'FBasedPosition::CachedBaseRotation' has a wrong offset!");
static_assert(offsetof(FBasedPosition, CachedTransPosition) == 0x000028, "Member 'FBasedPosition::CachedTransPosition' has a wrong offset!");

// ScriptStruct Engine.TextureLODGroup
// 0x0034 (0x0034 - 0x0000)
struct FTextureLODGroup final
{
public:
	ETextureGroup                                 Group;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xB];                                        // 0x0001(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODBias;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumStreamedMips;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureMipGenSettings                        MipGenSettings;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLODSize;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLODSize;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MinMagFilter;                                      // 0x0024(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MipFilter;                                         // 0x002C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureLODGroup) == 0x000004, "Wrong alignment on FTextureLODGroup");
static_assert(sizeof(FTextureLODGroup) == 0x000034, "Wrong size on FTextureLODGroup");
static_assert(offsetof(FTextureLODGroup, Group) == 0x000000, "Member 'FTextureLODGroup::Group' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, LODBias) == 0x00000C, "Member 'FTextureLODGroup::LODBias' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, NumStreamedMips) == 0x000014, "Member 'FTextureLODGroup::NumStreamedMips' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, MipGenSettings) == 0x000018, "Member 'FTextureLODGroup::MipGenSettings' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, MinLODSize) == 0x00001C, "Member 'FTextureLODGroup::MinLODSize' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, MaxLODSize) == 0x000020, "Member 'FTextureLODGroup::MaxLODSize' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, MinMagFilter) == 0x000024, "Member 'FTextureLODGroup::MinMagFilter' has a wrong offset!");
static_assert(offsetof(FTextureLODGroup, MipFilter) == 0x00002C, "Member 'FTextureLODGroup::MipFilter' has a wrong offset!");

// ScriptStruct Engine.FractureEffect
// 0x0008 (0x0008 - 0x0000)
struct FFractureEffect final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFractureEffect) == 0x000004, "Wrong alignment on FFractureEffect");
static_assert(sizeof(FFractureEffect) == 0x000008, "Wrong size on FFractureEffect");
static_assert(offsetof(FFractureEffect, ParticleSystem) == 0x000000, "Member 'FFractureEffect::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FFractureEffect, Sound) == 0x000004, "Member 'FFractureEffect::Sound' has a wrong offset!");

// ScriptStruct Engine.TextureSource
// 0x0054 (0x0054 - 0x0000)
struct alignas(0x04) FTextureSource final
{
public:
	uint8                                         Pad_0[0x54];                                       // 0x0000(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextureSource) == 0x000004, "Wrong alignment on FTextureSource");
static_assert(sizeof(FTextureSource) == 0x000054, "Wrong size on FTextureSource");

// ScriptStruct Engine.RigTransformConstraint
// 0x0010 (0x0010 - 0x0000)
struct FRigTransformConstraint final
{
public:
	EConstraintTransform                          TranformType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentSpace;                                       // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigTransformConstraint) == 0x000004, "Wrong alignment on FRigTransformConstraint");
static_assert(sizeof(FRigTransformConstraint) == 0x000010, "Wrong size on FRigTransformConstraint");
static_assert(offsetof(FRigTransformConstraint, TranformType) == 0x000000, "Member 'FRigTransformConstraint::TranformType' has a wrong offset!");
static_assert(offsetof(FRigTransformConstraint, ParentSpace) == 0x000004, "Member 'FRigTransformConstraint::ParentSpace' has a wrong offset!");
static_assert(offsetof(FRigTransformConstraint, Weight) == 0x00000C, "Member 'FRigTransformConstraint::Weight' has a wrong offset!");

// ScriptStruct Engine.TransformBaseConstraint
// 0x000C (0x000C - 0x0000)
struct FTransformBaseConstraint final
{
public:
	TArray<struct FRigTransformConstraint>        TransformConstraints;                              // 0x0000(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformBaseConstraint) == 0x000004, "Wrong alignment on FTransformBaseConstraint");
static_assert(sizeof(FTransformBaseConstraint) == 0x00000C, "Wrong size on FTransformBaseConstraint");
static_assert(offsetof(FTransformBaseConstraint, TransformConstraints) == 0x000000, "Member 'FTransformBaseConstraint::TransformConstraints' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshOptimizationSettings
// 0x0034 (0x0034 - 0x0000)
struct FSkeletalMeshOptimizationSettings final
{
public:
	ESkeletalMeshOptimizationType                 ReductionMethod;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumOfTrianglesPercentage;                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviationPercentage;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeldingThreshold;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalcNormals;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalsThreshold;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           SilhouetteImportance;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           TextureImportance;                                 // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           ShadingImportance;                                 // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkeletalMeshOptimizationImportance           SkinningImportance;                                // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneReductionRatio;                                // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBonesPerVertex;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 BonesToRemove;                                     // 0x0024(0x000C)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	int32                                         BaseLOD;                                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshOptimizationSettings) == 0x000004, "Wrong alignment on FSkeletalMeshOptimizationSettings");
static_assert(sizeof(FSkeletalMeshOptimizationSettings) == 0x000034, "Wrong size on FSkeletalMeshOptimizationSettings");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, ReductionMethod) == 0x000000, "Member 'FSkeletalMeshOptimizationSettings::ReductionMethod' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, NumOfTrianglesPercentage) == 0x000004, "Member 'FSkeletalMeshOptimizationSettings::NumOfTrianglesPercentage' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, MaxDeviationPercentage) == 0x000008, "Member 'FSkeletalMeshOptimizationSettings::MaxDeviationPercentage' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, WeldingThreshold) == 0x00000C, "Member 'FSkeletalMeshOptimizationSettings::WeldingThreshold' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, bRecalcNormals) == 0x000010, "Member 'FSkeletalMeshOptimizationSettings::bRecalcNormals' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, NormalsThreshold) == 0x000014, "Member 'FSkeletalMeshOptimizationSettings::NormalsThreshold' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, SilhouetteImportance) == 0x000018, "Member 'FSkeletalMeshOptimizationSettings::SilhouetteImportance' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, TextureImportance) == 0x000019, "Member 'FSkeletalMeshOptimizationSettings::TextureImportance' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, ShadingImportance) == 0x00001A, "Member 'FSkeletalMeshOptimizationSettings::ShadingImportance' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, SkinningImportance) == 0x00001B, "Member 'FSkeletalMeshOptimizationSettings::SkinningImportance' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, BoneReductionRatio) == 0x00001C, "Member 'FSkeletalMeshOptimizationSettings::BoneReductionRatio' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, MaxBonesPerVertex) == 0x000020, "Member 'FSkeletalMeshOptimizationSettings::MaxBonesPerVertex' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, BonesToRemove) == 0x000024, "Member 'FSkeletalMeshOptimizationSettings::BonesToRemove' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshOptimizationSettings, BaseLOD) == 0x000030, "Member 'FSkeletalMeshOptimizationSettings::BaseLOD' has a wrong offset!");

// ScriptStruct Engine.RigidBodyContactInfo
// 0x0024 (0x0024 - 0x0000)
struct FRigidBodyContactInfo final
{
public:
	struct FVector                                ContactPosition;                                   // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ContactNormal;                                     // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ContactPenetration;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysMaterial[0x2];                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigidBodyContactInfo) == 0x000004, "Wrong alignment on FRigidBodyContactInfo");
static_assert(sizeof(FRigidBodyContactInfo) == 0x000024, "Wrong size on FRigidBodyContactInfo");
static_assert(offsetof(FRigidBodyContactInfo, ContactPosition) == 0x000000, "Member 'FRigidBodyContactInfo::ContactPosition' has a wrong offset!");
static_assert(offsetof(FRigidBodyContactInfo, ContactNormal) == 0x00000C, "Member 'FRigidBodyContactInfo::ContactNormal' has a wrong offset!");
static_assert(offsetof(FRigidBodyContactInfo, ContactPenetration) == 0x000018, "Member 'FRigidBodyContactInfo::ContactPenetration' has a wrong offset!");
static_assert(offsetof(FRigidBodyContactInfo, PhysMaterial) == 0x00001C, "Member 'FRigidBodyContactInfo::PhysMaterial' has a wrong offset!");

// ScriptStruct Engine.CollisionImpactData
// 0x0024 (0x0024 - 0x0000)
struct FCollisionImpactData final
{
public:
	TArray<struct FRigidBodyContactInfo>          ContactInfos;                                      // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                TotalNormalImpulse;                                // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TotalFrictionImpulse;                              // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollisionImpactData) == 0x000004, "Wrong alignment on FCollisionImpactData");
static_assert(sizeof(FCollisionImpactData) == 0x000024, "Wrong size on FCollisionImpactData");
static_assert(offsetof(FCollisionImpactData, ContactInfos) == 0x000000, "Member 'FCollisionImpactData::ContactInfos' has a wrong offset!");
static_assert(offsetof(FCollisionImpactData, TotalNormalImpulse) == 0x00000C, "Member 'FCollisionImpactData::TotalNormalImpulse' has a wrong offset!");
static_assert(offsetof(FCollisionImpactData, TotalFrictionImpulse) == 0x000018, "Member 'FCollisionImpactData::TotalFrictionImpulse' has a wrong offset!");

// ScriptStruct Engine.PaintedVertex
// 0x0014 (0x0014 - 0x0000)
struct FPaintedVertex final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPackedNormal                          Normal;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPaintedVertex) == 0x000004, "Wrong alignment on FPaintedVertex");
static_assert(sizeof(FPaintedVertex) == 0x000014, "Wrong size on FPaintedVertex");
static_assert(offsetof(FPaintedVertex, Position) == 0x000000, "Member 'FPaintedVertex::Position' has a wrong offset!");
static_assert(offsetof(FPaintedVertex, Normal) == 0x00000C, "Member 'FPaintedVertex::Normal' has a wrong offset!");
static_assert(offsetof(FPaintedVertex, Color) == 0x000010, "Member 'FPaintedVertex::Color' has a wrong offset!");

// ScriptStruct Engine.RigidBodyErrorCorrection
// 0x001C (0x001C - 0x0000)
struct FRigidBodyErrorCorrection final
{
public:
	float                                         LinearDeltaThresholdSq;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearInterpAlpha;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearRecipFixTime;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDeltaThreshold;                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularInterpAlpha;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularRecipFixTime;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodySpeedThresholdSq;                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigidBodyErrorCorrection) == 0x000004, "Wrong alignment on FRigidBodyErrorCorrection");
static_assert(sizeof(FRigidBodyErrorCorrection) == 0x00001C, "Wrong size on FRigidBodyErrorCorrection");
static_assert(offsetof(FRigidBodyErrorCorrection, LinearDeltaThresholdSq) == 0x000000, "Member 'FRigidBodyErrorCorrection::LinearDeltaThresholdSq' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, LinearInterpAlpha) == 0x000004, "Member 'FRigidBodyErrorCorrection::LinearInterpAlpha' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, LinearRecipFixTime) == 0x000008, "Member 'FRigidBodyErrorCorrection::LinearRecipFixTime' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, AngularDeltaThreshold) == 0x00000C, "Member 'FRigidBodyErrorCorrection::AngularDeltaThreshold' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, AngularInterpAlpha) == 0x000010, "Member 'FRigidBodyErrorCorrection::AngularInterpAlpha' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, AngularRecipFixTime) == 0x000014, "Member 'FRigidBodyErrorCorrection::AngularRecipFixTime' has a wrong offset!");
static_assert(offsetof(FRigidBodyErrorCorrection, BodySpeedThresholdSq) == 0x000018, "Member 'FRigidBodyErrorCorrection::BodySpeedThresholdSq' has a wrong offset!");

// ScriptStruct Engine.RigidBodyState
// 0x0040 (0x0040 - 0x0000)
struct FRigidBodyState final
{
public:
	struct FVector_NetQuantize100                 Position;                                          // 0x0000(0x000C)(NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LinVel;                                            // 0x0020(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 AngVel;                                            // 0x002C(0x000C)(NativeAccessSpecifierPublic)
	uint8                                         Flags;                                             // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigidBodyState) == 0x000010, "Wrong alignment on FRigidBodyState");
static_assert(sizeof(FRigidBodyState) == 0x000040, "Wrong size on FRigidBodyState");
static_assert(offsetof(FRigidBodyState, Position) == 0x000000, "Member 'FRigidBodyState::Position' has a wrong offset!");
static_assert(offsetof(FRigidBodyState, Quaternion) == 0x000010, "Member 'FRigidBodyState::Quaternion' has a wrong offset!");
static_assert(offsetof(FRigidBodyState, LinVel) == 0x000020, "Member 'FRigidBodyState::LinVel' has a wrong offset!");
static_assert(offsetof(FRigidBodyState, AngVel) == 0x00002C, "Member 'FRigidBodyState::AngVel' has a wrong offset!");
static_assert(offsetof(FRigidBodyState, Flags) == 0x000038, "Member 'FRigidBodyState::Flags' has a wrong offset!");

// ScriptStruct Engine.MeshSectionInfo
// 0x0008 (0x0008 - 0x0000)
struct FMeshSectionInfo final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshSectionInfo) == 0x000004, "Wrong alignment on FMeshSectionInfo");
static_assert(sizeof(FMeshSectionInfo) == 0x000008, "Wrong size on FMeshSectionInfo");
static_assert(offsetof(FMeshSectionInfo, MaterialIndex) == 0x000000, "Member 'FMeshSectionInfo::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FMeshSectionInfo, bEnableCollision) == 0x000004, "Member 'FMeshSectionInfo::bEnableCollision' has a wrong offset!");
static_assert(offsetof(FMeshSectionInfo, bCastShadow) == 0x000005, "Member 'FMeshSectionInfo::bCastShadow' has a wrong offset!");

// ScriptStruct Engine.LightingChannels
// 0x0003 (0x0003 - 0x0000)
struct FLightingChannels final
{
public:
	bool                                          bChannel0;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bChannel1;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bChannel2;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightingChannels) == 0x000001, "Wrong alignment on FLightingChannels");
static_assert(sizeof(FLightingChannels) == 0x000003, "Wrong size on FLightingChannels");
static_assert(offsetof(FLightingChannels, bChannel0) == 0x000000, "Member 'FLightingChannels::bChannel0' has a wrong offset!");
static_assert(offsetof(FLightingChannels, bChannel1) == 0x000001, "Member 'FLightingChannels::bChannel1' has a wrong offset!");
static_assert(offsetof(FLightingChannels, bChannel2) == 0x000002, "Member 'FLightingChannels::bChannel2' has a wrong offset!");

// ScriptStruct Engine.NodeToCodeAssociation
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FNodeToCodeAssociation final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNodeToCodeAssociation) == 0x000004, "Wrong alignment on FNodeToCodeAssociation");
static_assert(sizeof(FNodeToCodeAssociation) == 0x000014, "Wrong size on FNodeToCodeAssociation");

// ScriptStruct Engine.RawAnimSequenceTrack
// 0x0024 (0x0024 - 0x0000)
struct FRawAnimSequenceTrack final
{
public:
	TArray<struct FVector>                        PosKeys;                                           // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          RotKeys;                                           // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ScaleKeys;                                         // 0x0018(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRawAnimSequenceTrack) == 0x000004, "Wrong alignment on FRawAnimSequenceTrack");
static_assert(sizeof(FRawAnimSequenceTrack) == 0x000024, "Wrong size on FRawAnimSequenceTrack");
static_assert(offsetof(FRawAnimSequenceTrack, PosKeys) == 0x000000, "Member 'FRawAnimSequenceTrack::PosKeys' has a wrong offset!");
static_assert(offsetof(FRawAnimSequenceTrack, RotKeys) == 0x00000C, "Member 'FRawAnimSequenceTrack::RotKeys' has a wrong offset!");
static_assert(offsetof(FRawAnimSequenceTrack, ScaleKeys) == 0x000018, "Member 'FRawAnimSequenceTrack::ScaleKeys' has a wrong offset!");

// ScriptStruct Engine.AnimSequenceTrackContainer
// 0x0018 (0x0018 - 0x0000)
struct FAnimSequenceTrackContainer final
{
public:
	TArray<struct FRawAnimSequenceTrack>          AnimationTracks;                                   // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           TrackNames;                                        // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSequenceTrackContainer) == 0x000004, "Wrong alignment on FAnimSequenceTrackContainer");
static_assert(sizeof(FAnimSequenceTrackContainer) == 0x000018, "Wrong size on FAnimSequenceTrackContainer");
static_assert(offsetof(FAnimSequenceTrackContainer, AnimationTracks) == 0x000000, "Member 'FAnimSequenceTrackContainer::AnimationTracks' has a wrong offset!");
static_assert(offsetof(FAnimSequenceTrackContainer, TrackNames) == 0x00000C, "Member 'FAnimSequenceTrackContainer::TrackNames' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputAxisKeyDelegateBinding
// 0x0018 (0x001C - 0x0004)
struct FBlueprintInputAxisKeyDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	struct FKey                                   AxisKey;                                           // 0x0004(0x0010)(NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintInputAxisKeyDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputAxisKeyDelegateBinding");
static_assert(sizeof(FBlueprintInputAxisKeyDelegateBinding) == 0x00001C, "Wrong size on FBlueprintInputAxisKeyDelegateBinding");
static_assert(offsetof(FBlueprintInputAxisKeyDelegateBinding, AxisKey) == 0x000004, "Member 'FBlueprintInputAxisKeyDelegateBinding::AxisKey' has a wrong offset!");
static_assert(offsetof(FBlueprintInputAxisKeyDelegateBinding, FunctionNameToBind) == 0x000014, "Member 'FBlueprintInputAxisKeyDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.EditedDocumentInfo
// 0x0010 (0x0010 - 0x0000)
struct FEditedDocumentInfo final
{
public:
	class UObject*                                EditedObject;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SavedViewOffset;                                   // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SavedZoomAmount;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditedDocumentInfo) == 0x000004, "Wrong alignment on FEditedDocumentInfo");
static_assert(sizeof(FEditedDocumentInfo) == 0x000010, "Wrong size on FEditedDocumentInfo");
static_assert(offsetof(FEditedDocumentInfo, EditedObject) == 0x000000, "Member 'FEditedDocumentInfo::EditedObject' has a wrong offset!");
static_assert(offsetof(FEditedDocumentInfo, SavedViewOffset) == 0x000004, "Member 'FEditedDocumentInfo::SavedViewOffset' has a wrong offset!");
static_assert(offsetof(FEditedDocumentInfo, SavedZoomAmount) == 0x00000C, "Member 'FEditedDocumentInfo::SavedZoomAmount' has a wrong offset!");

// ScriptStruct Engine.TriangleSortSettings
// 0x000C (0x000C - 0x0000)
struct FTriangleSortSettings final
{
public:
	ETriangleSortOption                           TriangleSorting;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETriangleSortAxis                             CustomLeftRightAxis;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomLeftRightBoneName;                           // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriangleSortSettings) == 0x000004, "Wrong alignment on FTriangleSortSettings");
static_assert(sizeof(FTriangleSortSettings) == 0x00000C, "Wrong size on FTriangleSortSettings");
static_assert(offsetof(FTriangleSortSettings, TriangleSorting) == 0x000000, "Member 'FTriangleSortSettings::TriangleSorting' has a wrong offset!");
static_assert(offsetof(FTriangleSortSettings, CustomLeftRightAxis) == 0x000001, "Member 'FTriangleSortSettings::CustomLeftRightAxis' has a wrong offset!");
static_assert(offsetof(FTriangleSortSettings, CustomLeftRightBoneName) == 0x000004, "Member 'FTriangleSortSettings::CustomLeftRightBoneName' has a wrong offset!");

// ScriptStruct Engine.BPInterfaceDescription
// 0x0010 (0x0010 - 0x0000)
struct FBPInterfaceDescription final
{
public:
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEdGraph*>                       Graphs;                                            // 0x0004(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBPInterfaceDescription) == 0x000004, "Wrong alignment on FBPInterfaceDescription");
static_assert(sizeof(FBPInterfaceDescription) == 0x000010, "Wrong size on FBPInterfaceDescription");
static_assert(offsetof(FBPInterfaceDescription, Interface) == 0x000000, "Member 'FBPInterfaceDescription::Interface' has a wrong offset!");
static_assert(offsetof(FBPInterfaceDescription, Graphs) == 0x000004, "Member 'FBPInterfaceDescription::Graphs' has a wrong offset!");

// ScriptStruct Engine.BlueprintComponentDelegateBinding
// 0x0018 (0x0018 - 0x0000)
struct FBlueprintComponentDelegateBinding final
{
public:
	class FName                                   ComponentPropertyName;                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DelegatePropertyName;                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintComponentDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintComponentDelegateBinding");
static_assert(sizeof(FBlueprintComponentDelegateBinding) == 0x000018, "Wrong size on FBlueprintComponentDelegateBinding");
static_assert(offsetof(FBlueprintComponentDelegateBinding, ComponentPropertyName) == 0x000000, "Member 'FBlueprintComponentDelegateBinding::ComponentPropertyName' has a wrong offset!");
static_assert(offsetof(FBlueprintComponentDelegateBinding, DelegatePropertyName) == 0x000008, "Member 'FBlueprintComponentDelegateBinding::DelegatePropertyName' has a wrong offset!");
static_assert(offsetof(FBlueprintComponentDelegateBinding, FunctionNameToBind) == 0x000010, "Member 'FBlueprintComponentDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.MemberReference
// 0x002C (0x002C - 0x0000)
struct FMemberReference final
{
public:
	class UObject*                                MemberParent;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MemberScope;                                       // 0x0004(0x000C)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MemberName;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  MemberGuid;                                        // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSelfContext;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bWasDeprecated;                                    // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMemberReference) == 0x000004, "Wrong alignment on FMemberReference");
static_assert(sizeof(FMemberReference) == 0x00002C, "Wrong size on FMemberReference");
static_assert(offsetof(FMemberReference, MemberParent) == 0x000000, "Member 'FMemberReference::MemberParent' has a wrong offset!");
static_assert(offsetof(FMemberReference, MemberScope) == 0x000004, "Member 'FMemberReference::MemberScope' has a wrong offset!");
static_assert(offsetof(FMemberReference, MemberName) == 0x000010, "Member 'FMemberReference::MemberName' has a wrong offset!");
static_assert(offsetof(FMemberReference, MemberGuid) == 0x000018, "Member 'FMemberReference::MemberGuid' has a wrong offset!");
static_assert(offsetof(FMemberReference, bSelfContext) == 0x000028, "Member 'FMemberReference::bSelfContext' has a wrong offset!");
static_assert(offsetof(FMemberReference, bWasDeprecated) == 0x000029, "Member 'FMemberReference::bWasDeprecated' has a wrong offset!");

// ScriptStruct Engine.ParticleSystemLOD
// 0x0001 (0x0001 - 0x0000)
struct FParticleSystemLOD final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleSystemLOD) == 0x000001, "Wrong alignment on FParticleSystemLOD");
static_assert(sizeof(FParticleSystemLOD) == 0x000001, "Wrong size on FParticleSystemLOD");

// ScriptStruct Engine.OverlapInfo
// 0x0084 (0x0084 - 0x0000)
struct alignas(0x04) FOverlapInfo final
{
public:
	uint8                                         Pad_0[0x84];                                       // 0x0000(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverlapInfo) == 0x000004, "Wrong alignment on FOverlapInfo");
static_assert(sizeof(FOverlapInfo) == 0x000084, "Wrong size on FOverlapInfo");

// ScriptStruct Engine.AnimNotifyTrack
// 0x0030 (0x0030 - 0x0000)
struct FAnimNotifyTrack final
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TrackColor;                                        // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNotifyTrack) == 0x000004, "Wrong alignment on FAnimNotifyTrack");
static_assert(sizeof(FAnimNotifyTrack) == 0x000030, "Wrong size on FAnimNotifyTrack");
static_assert(offsetof(FAnimNotifyTrack, TrackName) == 0x000000, "Member 'FAnimNotifyTrack::TrackName' has a wrong offset!");
static_assert(offsetof(FAnimNotifyTrack, TrackColor) == 0x000008, "Member 'FAnimNotifyTrack::TrackColor' has a wrong offset!");

// ScriptStruct Engine.LatentActionManager
// 0x00B4 (0x00B4 - 0x0000)
struct alignas(0x04) FLatentActionManager final
{
public:
	uint8                                         Pad_0[0xB4];                                       // 0x0000(0x00B4)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLatentActionManager) == 0x000004, "Wrong alignment on FLatentActionManager");
static_assert(sizeof(FLatentActionManager) == 0x0000B4, "Wrong size on FLatentActionManager");

// ScriptStruct Engine.EndPhysicsTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FEndPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndPhysicsTickFunction) == 0x000004, "Wrong alignment on FEndPhysicsTickFunction");
static_assert(sizeof(FEndPhysicsTickFunction) == 0x000038, "Wrong size on FEndPhysicsTickFunction");

// ScriptStruct Engine.LevelSimplificationDetails
// 0x016C (0x016C - 0x0000)
struct FLevelSimplificationDetails final
{
public:
	bool                                          bCreatePackagePerAsset;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DetailsPercentage;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialSimplificationSettings        StaticMeshMaterial;                                // 0x0008(0x0044)(Deprecated, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 StaticMeshMaterialSettings;                        // 0x004C(0x0064)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideLandscapeExportLOD;                       // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LandscapeExportLOD;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMaterialSimplificationSettings        LandscapeMaterial;                                 // 0x00B8(0x0044)(Deprecated, NativeAccessSpecifierPublic)
	struct FMaterialProxySettings                 LandscapeMaterialSettings;                         // 0x00FC(0x0064)(Edit, NativeAccessSpecifierPublic)
	bool                                          bBakeFoliageToLandscape;                           // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBakeGrassToLandscape;                             // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateMeshNormalMap;                            // 0x0162(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateMeshMetallicMap;                          // 0x0163(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateMeshRoughnessMap;                         // 0x0164(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateMeshSpecularMap;                          // 0x0165(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateLandscapeNormalMap;                       // 0x0166(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateLandscapeMetallicMap;                     // 0x0167(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateLandscapeRoughnessMap;                    // 0x0168(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGenerateLandscapeSpecularMap;                     // 0x0169(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelSimplificationDetails) == 0x000004, "Wrong alignment on FLevelSimplificationDetails");
static_assert(sizeof(FLevelSimplificationDetails) == 0x00016C, "Wrong size on FLevelSimplificationDetails");
static_assert(offsetof(FLevelSimplificationDetails, bCreatePackagePerAsset) == 0x000000, "Member 'FLevelSimplificationDetails::bCreatePackagePerAsset' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, DetailsPercentage) == 0x000004, "Member 'FLevelSimplificationDetails::DetailsPercentage' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, StaticMeshMaterial) == 0x000008, "Member 'FLevelSimplificationDetails::StaticMeshMaterial' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, StaticMeshMaterialSettings) == 0x00004C, "Member 'FLevelSimplificationDetails::StaticMeshMaterialSettings' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bOverrideLandscapeExportLOD) == 0x0000B0, "Member 'FLevelSimplificationDetails::bOverrideLandscapeExportLOD' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, LandscapeExportLOD) == 0x0000B4, "Member 'FLevelSimplificationDetails::LandscapeExportLOD' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, LandscapeMaterial) == 0x0000B8, "Member 'FLevelSimplificationDetails::LandscapeMaterial' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, LandscapeMaterialSettings) == 0x0000FC, "Member 'FLevelSimplificationDetails::LandscapeMaterialSettings' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bBakeFoliageToLandscape) == 0x000160, "Member 'FLevelSimplificationDetails::bBakeFoliageToLandscape' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bBakeGrassToLandscape) == 0x000161, "Member 'FLevelSimplificationDetails::bBakeGrassToLandscape' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateMeshNormalMap) == 0x000162, "Member 'FLevelSimplificationDetails::bGenerateMeshNormalMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateMeshMetallicMap) == 0x000163, "Member 'FLevelSimplificationDetails::bGenerateMeshMetallicMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateMeshRoughnessMap) == 0x000164, "Member 'FLevelSimplificationDetails::bGenerateMeshRoughnessMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateMeshSpecularMap) == 0x000165, "Member 'FLevelSimplificationDetails::bGenerateMeshSpecularMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateLandscapeNormalMap) == 0x000166, "Member 'FLevelSimplificationDetails::bGenerateLandscapeNormalMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateLandscapeMetallicMap) == 0x000167, "Member 'FLevelSimplificationDetails::bGenerateLandscapeMetallicMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateLandscapeRoughnessMap) == 0x000168, "Member 'FLevelSimplificationDetails::bGenerateLandscapeRoughnessMap' has a wrong offset!");
static_assert(offsetof(FLevelSimplificationDetails, bGenerateLandscapeSpecularMap) == 0x000169, "Member 'FLevelSimplificationDetails::bGenerateLandscapeSpecularMap' has a wrong offset!");

// ScriptStruct Engine.A2Pose
// 0x000C (0x000C - 0x0000)
struct FA2Pose
{
public:
	TArray<struct FTransform>                     Bones;                                             // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FA2Pose) == 0x000004, "Wrong alignment on FA2Pose");
static_assert(sizeof(FA2Pose) == 0x00000C, "Wrong size on FA2Pose");
static_assert(offsetof(FA2Pose, Bones) == 0x000000, "Member 'FA2Pose::Bones' has a wrong offset!");

// ScriptStruct Engine.A2CSPose
// 0x0010 (0x001C - 0x000C)
struct FA2CSPose final : public FA2Pose
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ComponentSpaceFlags;                               // 0x0010(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FA2CSPose) == 0x000004, "Wrong alignment on FA2CSPose");
static_assert(sizeof(FA2CSPose) == 0x00001C, "Wrong size on FA2CSPose");
static_assert(offsetof(FA2CSPose, ComponentSpaceFlags) == 0x000010, "Member 'FA2CSPose::ComponentSpaceFlags' has a wrong offset!");

// ScriptStruct Engine.StreamableTextureInstance
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FStreamableTextureInstance
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamableTextureInstance) == 0x000004, "Wrong alignment on FStreamableTextureInstance");
static_assert(sizeof(FStreamableTextureInstance) == 0x000028, "Wrong size on FStreamableTextureInstance");

// ScriptStruct Engine.DynamicTextureInstance
// 0x000C (0x0034 - 0x0028)
struct FDynamicTextureInstance final : public FStreamableTextureInstance
{
public:
	class UTexture2D*                             Texture;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OriginalRadius;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicTextureInstance) == 0x000004, "Wrong alignment on FDynamicTextureInstance");
static_assert(sizeof(FDynamicTextureInstance) == 0x000034, "Wrong size on FDynamicTextureInstance");
static_assert(offsetof(FDynamicTextureInstance, Texture) == 0x000028, "Member 'FDynamicTextureInstance::Texture' has a wrong offset!");
static_assert(offsetof(FDynamicTextureInstance, bAttached) == 0x00002C, "Member 'FDynamicTextureInstance::bAttached' has a wrong offset!");
static_assert(offsetof(FDynamicTextureInstance, OriginalRadius) == 0x000030, "Member 'FDynamicTextureInstance::OriginalRadius' has a wrong offset!");

// ScriptStruct Engine.CameraPreviewInfo
// 0x0024 (0x0024 - 0x0000)
struct FCameraPreviewInfo final
{
public:
	TSubclassOf<class APawn>                      PawnClass;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class APawn*                                  PawnInst;                                          // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraPreviewInfo) == 0x000004, "Wrong alignment on FCameraPreviewInfo");
static_assert(sizeof(FCameraPreviewInfo) == 0x000024, "Wrong size on FCameraPreviewInfo");
static_assert(offsetof(FCameraPreviewInfo, PawnClass) == 0x000000, "Member 'FCameraPreviewInfo::PawnClass' has a wrong offset!");
static_assert(offsetof(FCameraPreviewInfo, AnimSeq) == 0x000004, "Member 'FCameraPreviewInfo::AnimSeq' has a wrong offset!");
static_assert(offsetof(FCameraPreviewInfo, Location) == 0x000008, "Member 'FCameraPreviewInfo::Location' has a wrong offset!");
static_assert(offsetof(FCameraPreviewInfo, Rotation) == 0x000014, "Member 'FCameraPreviewInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FCameraPreviewInfo, PawnInst) == 0x000020, "Member 'FCameraPreviewInfo::PawnInst' has a wrong offset!");

// ScriptStruct Engine.NavCollisionCylinder
// 0x0014 (0x0014 - 0x0000)
struct FNavCollisionCylinder final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavCollisionCylinder) == 0x000004, "Wrong alignment on FNavCollisionCylinder");
static_assert(sizeof(FNavCollisionCylinder) == 0x000014, "Wrong size on FNavCollisionCylinder");
static_assert(offsetof(FNavCollisionCylinder, Offset) == 0x000000, "Member 'FNavCollisionCylinder::Offset' has a wrong offset!");
static_assert(offsetof(FNavCollisionCylinder, Radius) == 0x00000C, "Member 'FNavCollisionCylinder::Radius' has a wrong offset!");
static_assert(offsetof(FNavCollisionCylinder, Height) == 0x000010, "Member 'FNavCollisionCylinder::Height' has a wrong offset!");

// ScriptStruct Engine.GeomSelection
// 0x000C (0x000C - 0x0000)
struct FGeomSelection final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         INDEX;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectionIndex;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeomSelection) == 0x000004, "Wrong alignment on FGeomSelection");
static_assert(sizeof(FGeomSelection) == 0x00000C, "Wrong size on FGeomSelection");
static_assert(offsetof(FGeomSelection, Type) == 0x000000, "Member 'FGeomSelection::Type' has a wrong offset!");
static_assert(offsetof(FGeomSelection, INDEX) == 0x000004, "Member 'FGeomSelection::INDEX' has a wrong offset!");
static_assert(offsetof(FGeomSelection, SelectionIndex) == 0x000008, "Member 'FGeomSelection::SelectionIndex' has a wrong offset!");

// ScriptStruct Engine.SoundGroup
// 0x0018 (0x0018 - 0x0000)
struct FSoundGroup final
{
public:
	ESoundGroup                                   SoundGroup;                                        // 0x0000(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0004(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysDecompressOnLoad : 1;                       // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecompressedDuration;                              // 0x0014(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundGroup) == 0x000004, "Wrong alignment on FSoundGroup");
static_assert(sizeof(FSoundGroup) == 0x000018, "Wrong size on FSoundGroup");
static_assert(offsetof(FSoundGroup, SoundGroup) == 0x000000, "Member 'FSoundGroup::SoundGroup' has a wrong offset!");
static_assert(offsetof(FSoundGroup, DisplayName) == 0x000004, "Member 'FSoundGroup::DisplayName' has a wrong offset!");
static_assert(offsetof(FSoundGroup, DecompressedDuration) == 0x000014, "Member 'FSoundGroup::DecompressedDuration' has a wrong offset!");

// ScriptStruct Engine.InteriorSettings
// 0x0024 (0x0024 - 0x0000)
struct FInteriorSettings final
{
public:
	uint8                                         bIsWorldSettings : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExteriorVolume;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorTime;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPF;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExteriorLPFTime;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorVolume;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPF;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorLPFTime;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteriorSettings) == 0x000004, "Wrong alignment on FInteriorSettings");
static_assert(sizeof(FInteriorSettings) == 0x000024, "Wrong size on FInteriorSettings");
static_assert(offsetof(FInteriorSettings, ExteriorVolume) == 0x000004, "Member 'FInteriorSettings::ExteriorVolume' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, ExteriorTime) == 0x000008, "Member 'FInteriorSettings::ExteriorTime' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, ExteriorLPF) == 0x00000C, "Member 'FInteriorSettings::ExteriorLPF' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, ExteriorLPFTime) == 0x000010, "Member 'FInteriorSettings::ExteriorLPFTime' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, InteriorVolume) == 0x000014, "Member 'FInteriorSettings::InteriorVolume' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, InteriorTime) == 0x000018, "Member 'FInteriorSettings::InteriorTime' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, InteriorLPF) == 0x00001C, "Member 'FInteriorSettings::InteriorLPF' has a wrong offset!");
static_assert(offsetof(FInteriorSettings, InteriorLPFTime) == 0x000020, "Member 'FInteriorSettings::InteriorLPFTime' has a wrong offset!");

// ScriptStruct Engine.ReverbSettings
// 0x0014 (0x0014 - 0x0000)
struct FReverbSettings final
{
public:
	uint8                                         bApplyReverb : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EReverbPreset                                 ReverbType;                                        // 0x0004(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UReverbEffect*                          ReverbEffect;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReverbSettings) == 0x000004, "Wrong alignment on FReverbSettings");
static_assert(sizeof(FReverbSettings) == 0x000014, "Wrong size on FReverbSettings");
static_assert(offsetof(FReverbSettings, ReverbType) == 0x000004, "Member 'FReverbSettings::ReverbType' has a wrong offset!");
static_assert(offsetof(FReverbSettings, ReverbEffect) == 0x000008, "Member 'FReverbSettings::ReverbEffect' has a wrong offset!");
static_assert(offsetof(FReverbSettings, Volume) == 0x00000C, "Member 'FReverbSettings::Volume' has a wrong offset!");
static_assert(offsetof(FReverbSettings, FadeTime) == 0x000010, "Member 'FReverbSettings::FadeTime' has a wrong offset!");

// ScriptStruct Engine.DataTableCategoryHandle
// 0x0014 (0x0014 - 0x0000)
struct FDataTableCategoryHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColumnName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowContents;                                       // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableCategoryHandle) == 0x000004, "Wrong alignment on FDataTableCategoryHandle");
static_assert(sizeof(FDataTableCategoryHandle) == 0x000014, "Wrong size on FDataTableCategoryHandle");
static_assert(offsetof(FDataTableCategoryHandle, DataTable) == 0x000000, "Member 'FDataTableCategoryHandle::DataTable' has a wrong offset!");
static_assert(offsetof(FDataTableCategoryHandle, ColumnName) == 0x000004, "Member 'FDataTableCategoryHandle::ColumnName' has a wrong offset!");
static_assert(offsetof(FDataTableCategoryHandle, RowContents) == 0x00000C, "Member 'FDataTableCategoryHandle::RowContents' has a wrong offset!");

// ScriptStruct Engine.CullDistanceSizePair
// 0x0008 (0x0008 - 0x0000)
struct FCullDistanceSizePair final
{
public:
	float                                         Size;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistance;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCullDistanceSizePair) == 0x000004, "Wrong alignment on FCullDistanceSizePair");
static_assert(sizeof(FCullDistanceSizePair) == 0x000008, "Wrong size on FCullDistanceSizePair");
static_assert(offsetof(FCullDistanceSizePair, Size) == 0x000000, "Member 'FCullDistanceSizePair::Size' has a wrong offset!");
static_assert(offsetof(FCullDistanceSizePair, CullDistance) == 0x000004, "Member 'FCullDistanceSizePair::CullDistance' has a wrong offset!");

// ScriptStruct Engine.NavigationFilterFlags
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavigationFilterFlags final
{
public:
	uint8                                         bNavFlag0 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag1 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag2 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag3 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag4 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag5 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag6 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag7 : 1;                                     // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag8 : 1;                                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag9 : 1;                                     // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag10 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag11 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag12 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag13 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag14 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNavFlag15 : 1;                                    // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationFilterFlags) == 0x000004, "Wrong alignment on FNavigationFilterFlags");
static_assert(sizeof(FNavigationFilterFlags) == 0x000004, "Wrong size on FNavigationFilterFlags");

// ScriptStruct Engine.TTTrackBase
// 0x000C (0x000C - 0x0000)
struct FTTTrackBase
{
public:
	class FName                                   TrackName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExternalCurve;                                  // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTTTrackBase) == 0x000004, "Wrong alignment on FTTTrackBase");
static_assert(sizeof(FTTTrackBase) == 0x00000C, "Wrong size on FTTTrackBase");
static_assert(offsetof(FTTTrackBase, TrackName) == 0x000000, "Member 'FTTTrackBase::TrackName' has a wrong offset!");
static_assert(offsetof(FTTTrackBase, bIsExternalCurve) == 0x000008, "Member 'FTTTrackBase::bIsExternalCurve' has a wrong offset!");

// ScriptStruct Engine.TTFloatTrack
// 0x0004 (0x0010 - 0x000C)
struct FTTFloatTrack final : public FTTTrackBase
{
public:
	class UCurveFloat*                            CurveFloat;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTTFloatTrack) == 0x000004, "Wrong alignment on FTTFloatTrack");
static_assert(sizeof(FTTFloatTrack) == 0x000010, "Wrong size on FTTFloatTrack");
static_assert(offsetof(FTTFloatTrack, CurveFloat) == 0x00000C, "Member 'FTTFloatTrack::CurveFloat' has a wrong offset!");

// ScriptStruct Engine.MovementProperties
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FMovementProperties
{
public:
	uint8                                         bCanCrouch : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanJump : 1;                                      // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanWalk : 1;                                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanSwim : 1;                                      // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanFly : 1;                                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementProperties) == 0x000004, "Wrong alignment on FMovementProperties");
static_assert(sizeof(FMovementProperties) == 0x000004, "Wrong size on FMovementProperties");

// ScriptStruct Engine.NavAgentProperties
// 0x0014 (0x0018 - 0x0004)
struct FNavAgentProperties : public FMovementProperties
{
public:
	float                                         AgentRadius;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentHeight;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AgentStepHeight;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkingSearchHeightScale;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ANavigationData>            PreferredNavData;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavAgentProperties) == 0x000004, "Wrong alignment on FNavAgentProperties");
static_assert(sizeof(FNavAgentProperties) == 0x000018, "Wrong size on FNavAgentProperties");
static_assert(offsetof(FNavAgentProperties, AgentRadius) == 0x000004, "Member 'FNavAgentProperties::AgentRadius' has a wrong offset!");
static_assert(offsetof(FNavAgentProperties, AgentHeight) == 0x000008, "Member 'FNavAgentProperties::AgentHeight' has a wrong offset!");
static_assert(offsetof(FNavAgentProperties, AgentStepHeight) == 0x00000C, "Member 'FNavAgentProperties::AgentStepHeight' has a wrong offset!");
static_assert(offsetof(FNavAgentProperties, NavWalkingSearchHeightScale) == 0x000010, "Member 'FNavAgentProperties::NavWalkingSearchHeightScale' has a wrong offset!");
static_assert(offsetof(FNavAgentProperties, PreferredNavData) == 0x000014, "Member 'FNavAgentProperties::PreferredNavData' has a wrong offset!");

// ScriptStruct Engine.NavDataConfig
// 0x0028 (0x0040 - 0x0018)
struct FNavDataConfig final : public FNavAgentProperties
{
public:
	class FName                                   Name;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DefaultQueryExtent;                                // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ANavigationData>            NavigationDataClass;                               // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStringClassReference                  NavigationDataClassName;                           // 0x0034(0x000C)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavDataConfig) == 0x000004, "Wrong alignment on FNavDataConfig");
static_assert(sizeof(FNavDataConfig) == 0x000040, "Wrong size on FNavDataConfig");
static_assert(offsetof(FNavDataConfig, Name) == 0x000018, "Member 'FNavDataConfig::Name' has a wrong offset!");
static_assert(offsetof(FNavDataConfig, Color) == 0x000020, "Member 'FNavDataConfig::Color' has a wrong offset!");
static_assert(offsetof(FNavDataConfig, DefaultQueryExtent) == 0x000024, "Member 'FNavDataConfig::DefaultQueryExtent' has a wrong offset!");
static_assert(offsetof(FNavDataConfig, NavigationDataClass) == 0x000030, "Member 'FNavDataConfig::NavigationDataClass' has a wrong offset!");
static_assert(offsetof(FNavDataConfig, NavigationDataClassName) == 0x000034, "Member 'FNavDataConfig::NavigationDataClassName' has a wrong offset!");

// ScriptStruct Engine.WeightedBlendable
// 0x0008 (0x0008 - 0x0000)
struct FWeightedBlendable final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedBlendable) == 0x000004, "Wrong alignment on FWeightedBlendable");
static_assert(sizeof(FWeightedBlendable) == 0x000008, "Wrong size on FWeightedBlendable");
static_assert(offsetof(FWeightedBlendable, Weight) == 0x000000, "Member 'FWeightedBlendable::Weight' has a wrong offset!");
static_assert(offsetof(FWeightedBlendable, Object) == 0x000004, "Member 'FWeightedBlendable::Object' has a wrong offset!");

// ScriptStruct Engine.WeightedBlendables
// 0x000C (0x000C - 0x0000)
struct FWeightedBlendables final
{
public:
	TArray<struct FWeightedBlendable>             Array;                                             // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedBlendables) == 0x000004, "Wrong alignment on FWeightedBlendables");
static_assert(sizeof(FWeightedBlendables) == 0x00000C, "Wrong size on FWeightedBlendables");
static_assert(offsetof(FWeightedBlendables, Array) == 0x000000, "Member 'FWeightedBlendables::Array' has a wrong offset!");

// ScriptStruct Engine.PostProcessSettings
// 0x0374 (0x0374 - 0x0000)
struct FPostProcessSettings final
{
public:
	uint8                                         bOverride_WhiteTemp : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WhiteTint : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorSaturation : 1;                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorContrast : 1;                       // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGamma : 1;                          // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGain : 1;                           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorOffset : 1;                         // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmWhitePoint : 1;                      // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmSaturation : 1;                      // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmChannelMixerRed : 1;                 // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmChannelMixerGreen : 1;               // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmChannelMixerBlue : 1;                // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmContrast : 1;                        // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmDynamicRange : 1;                    // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmHealAmount : 1;                      // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmToeAmount : 1;                       // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmShadowTint : 1;                      // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmShadowTintBlend : 1;                 // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmShadowTintAmount : 1;                // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmSlope : 1;                           // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmToe : 1;                             // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmShoulder : 1;                        // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmBlackClip : 1;                       // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FilmWhiteClip : 1;                       // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SceneColorTint : 1;                      // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SceneFringeIntensity : 1;                // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientCubemapTint : 1;                  // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientCubemapIntensity : 1;             // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomIntensity : 1;                      // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomThreshold : 1;                      // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom1Tint : 1;                          // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom1Size : 1;                          // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom2Size : 1;                          // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom2Tint : 1;                          // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom3Tint : 1;                          // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom3Size : 1;                          // 0x0004(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom4Tint : 1;                          // 0x0004(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom4Size : 1;                          // 0x0004(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom5Tint : 1;                          // 0x0004(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom5Size : 1;                          // 0x0004(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom6Tint : 1;                          // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Bloom6Size : 1;                          // 0x0005(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomSizeScale : 1;                      // 0x0005(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMaskIntensity : 1;              // 0x0005(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMaskTint : 1;                   // 0x0005(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomDirtMask : 1;                       // 0x0005(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMethod : 1;                  // 0x0005(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureLowPercent : 1;              // 0x0005(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureHighPercent : 1;             // 0x0006(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMinBrightness : 1;           // 0x0006(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureMaxBrightness : 1;           // 0x0006(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureSpeedUp : 1;                 // 0x0006(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureSpeedDown : 1;               // 0x0006(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AutoExposureBias : 1;                    // 0x0006(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HistogramLogMin : 1;                     // 0x0006(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HistogramLogMax : 1;                     // 0x0006(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareIntensity : 1;                  // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareTint : 1;                       // 0x0007(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareTints : 1;                      // 0x0007(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareBokehSize : 1;                  // 0x0007(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareBokehShape : 1;                 // 0x0007(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LensFlareThreshold : 1;                  // 0x0007(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VignetteIntensity : 1;                   // 0x0007(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainIntensity : 1;                      // 0x0007(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_GrainJitter : 1;                         // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionIntensity : 1;           // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionStaticFraction : 1;      // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionRadius : 1;              // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionFadeDistance : 1;        // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionFadeRadius : 1;          // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionDistance : 1;            // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionRadiusInWS : 1;          // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionPower : 1;               // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionBias : 1;                // 0x0009(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionQuality : 1;             // 0x0009(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipBlend : 1;            // 0x0009(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipScale : 1;            // 0x0009(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AmbientOcclusionMipThreshold : 1;        // 0x0009(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVIntensity : 1;                        // 0x0009(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDirectionalOcclusionIntensity : 1;    // 0x0009(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDirectionalOcclusionRadius : 1;       // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDiffuseOcclusionExponent : 1;         // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSpecularOcclusionExponent : 1;        // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVDiffuseOcclusionIntensity : 1;        // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSpecularOcclusionIntensity : 1;       // 0x000A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSize : 1;                             // 0x000A(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSecondaryOcclusionIntensity : 1;      // 0x000A(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVSecondaryBounceIntensity : 1;         // 0x000A(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVGeometryVolumeBias : 1;               // 0x000B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVVplInjectionBias : 1;                 // 0x000B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LPVEmissiveInjectionIntensity : 1;       // 0x000B(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_IndirectLightingColor : 1;               // 0x000B(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_IndirectLightingIntensity : 1;           // 0x000B(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGradingIntensity : 1;               // 0x000B(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ColorGradingLUT : 1;                     // 0x000B(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFocalDistance : 1;           // 0x000B(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFstop : 1;                   // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldDepthBlurRadius : 1;         // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldDepthBlurAmount : 1;         // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFocalRegion : 1;             // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldNearTransitionRegion : 1;    // 0x000C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFarTransitionRegion : 1;     // 0x000C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldScale : 1;                   // 0x000C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldMaxBokehSize : 1;            // 0x000C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldNearBlurSize : 1;            // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldFarBlurSize : 1;             // 0x000D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldMethod : 1;                  // 0x000D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldBokehShape : 1;              // 0x000D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldOcclusion : 1;               // 0x000D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldColorThreshold : 1;          // 0x000D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldSizeThreshold : 1;           // 0x000D(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldSkyFocusDistance : 1;        // 0x000D(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DepthOfFieldVignetteSize : 1;            // 0x000E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurAmount : 1;                    // 0x000E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurMax : 1;                       // 0x000E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MotionBlurPerObjectSize : 1;             // 0x000E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenPercentage : 1;                    // 0x000E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AntiAliasingMethod : 1;                  // 0x000E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionIntensity : 1;      // 0x000E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionQuality : 1;        // 0x000E(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionMaxRoughness : 1;   // 0x000F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ScreenSpaceReflectionRoughnessScale : 1; // 0x000F(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	float                                         WhiteTemp;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhiteTint;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ColorSaturation;                                   // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ColorContrast;                                     // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ColorGamma;                                        // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ColorGain;                                         // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ColorOffset;                                       // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FilmWhitePoint;                                    // 0x0054(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FilmShadowTint;                                    // 0x0064(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         FilmShadowTintBlend;                               // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmShadowTintAmount;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmSaturation;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FilmChannelMixerRed;                               // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           FilmChannelMixerGreen;                             // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           FilmChannelMixerBlue;                              // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         FilmContrast;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmToeAmount;                                     // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmHealAmount;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmDynamicRange;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmSlope;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmToe;                                           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmShoulder;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmBlackClip;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilmWhiteClip;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SceneColorTint;                                    // 0x00D4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         SceneFringeIntensity;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomIntensity;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomThreshold;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomSizeScale;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom1Size;                                        // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom2Size;                                        // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom3Size;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom4Size;                                        // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom5Size;                                        // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloom6Size;                                        // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom1Tint;                                        // 0x010C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom2Tint;                                        // 0x011C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom3Tint;                                        // 0x012C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom4Tint;                                        // 0x013C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom5Tint;                                        // 0x014C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FLinearColor                           Bloom6Tint;                                        // 0x015C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         BloomDirtMaskIntensity;                            // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BloomDirtMaskTint;                                 // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UTexture*                               BloomDirtMask;                                     // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVIntensity;                                      // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVVplInjectionBias;                               // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSize;                                           // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSecondaryOcclusionIntensity;                    // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSecondaryBounceIntensity;                       // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVGeometryVolumeBias;                             // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVEmissiveInjectionIntensity;                     // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDirectionalOcclusionIntensity;                  // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDirectionalOcclusionRadius;                     // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDiffuseOcclusionExponent;                       // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSpecularOcclusionExponent;                      // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVDiffuseOcclusionIntensity;                      // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LPVSpecularOcclusionIntensity;                     // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmbientCubemapTint;                                // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         AmbientCubemapIntensity;                           // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           AmbientCubemap;                                    // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoExposureMethod                           AutoExposureMethod;                                // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoExposureLowPercent;                            // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureHighPercent;                           // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureMinBrightness;                         // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureMaxBrightness;                         // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureSpeedUp;                               // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureSpeedDown;                             // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExposureBias;                                  // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMin;                                   // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistogramLogMax;                                   // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareIntensity;                                // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTint;                                     // 0x01FC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         LensFlareBokehSize;                                // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareThreshold;                                // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               LensFlareBokehShape;                               // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTints[0x8];                               // 0x0218(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VignetteIntensity;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrainJitter;                                       // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrainIntensity;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionIntensity;                         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionStaticFraction;                    // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionRadius;                            // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AmbientOcclusionRadiusInWS : 1;                    // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmbientOcclusionFadeDistance;                      // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionFadeRadius;                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionDistance;                          // 0x02BC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionPower;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionBias;                              // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionQuality;                           // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipBlend;                          // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipScale;                          // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientOcclusionMipThreshold;                      // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IndirectLightingColor;                             // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IndirectLightingIntensity;                         // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorGradingIntensity;                             // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ColorGradingLUT;                                   // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDepthOfFieldMethod                           DepthOfFieldMethod;                                // 0x02F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DepthOfFieldFstop;                                 // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalDistance;                         // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurAmount;                       // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldDepthBlurRadius;                       // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFocalRegion;                           // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldNearTransitionRegion;                  // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFarTransitionRegion;                   // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldScale;                                 // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldMaxBokehSize;                          // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldNearBlurSize;                          // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldFarBlurSize;                           // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               DepthOfFieldBokehShape;                            // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldOcclusion;                             // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldColorThreshold;                        // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSizeThreshold;                         // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldSkyFocusDistance;                      // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthOfFieldVignetteSize;                          // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurAmount;                                  // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurMax;                                     // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlurPerObjectSize;                           // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenPercentage;                                  // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAntiAliasingMethod                           AntiAliasingMethod;                                // 0x034C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenSpaceReflectionIntensity;                    // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSpaceReflectionQuality;                      // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSpaceReflectionMaxRoughness;                 // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeightedBlendables                    WeightedBlendables;                                // 0x035C(0x000C)(Edit, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Blendables;                                        // 0x0368(0x000C)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPostProcessSettings) == 0x000004, "Wrong alignment on FPostProcessSettings");
static_assert(sizeof(FPostProcessSettings) == 0x000374, "Wrong size on FPostProcessSettings");
static_assert(offsetof(FPostProcessSettings, WhiteTemp) == 0x000010, "Member 'FPostProcessSettings::WhiteTemp' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, WhiteTint) == 0x000014, "Member 'FPostProcessSettings::WhiteTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorSaturation) == 0x000018, "Member 'FPostProcessSettings::ColorSaturation' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorContrast) == 0x000024, "Member 'FPostProcessSettings::ColorContrast' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorGamma) == 0x000030, "Member 'FPostProcessSettings::ColorGamma' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorGain) == 0x00003C, "Member 'FPostProcessSettings::ColorGain' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorOffset) == 0x000048, "Member 'FPostProcessSettings::ColorOffset' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmWhitePoint) == 0x000054, "Member 'FPostProcessSettings::FilmWhitePoint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmShadowTint) == 0x000064, "Member 'FPostProcessSettings::FilmShadowTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmShadowTintBlend) == 0x000074, "Member 'FPostProcessSettings::FilmShadowTintBlend' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmShadowTintAmount) == 0x000078, "Member 'FPostProcessSettings::FilmShadowTintAmount' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmSaturation) == 0x00007C, "Member 'FPostProcessSettings::FilmSaturation' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmChannelMixerRed) == 0x000080, "Member 'FPostProcessSettings::FilmChannelMixerRed' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmChannelMixerGreen) == 0x000090, "Member 'FPostProcessSettings::FilmChannelMixerGreen' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmChannelMixerBlue) == 0x0000A0, "Member 'FPostProcessSettings::FilmChannelMixerBlue' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmContrast) == 0x0000B0, "Member 'FPostProcessSettings::FilmContrast' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmToeAmount) == 0x0000B4, "Member 'FPostProcessSettings::FilmToeAmount' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmHealAmount) == 0x0000B8, "Member 'FPostProcessSettings::FilmHealAmount' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmDynamicRange) == 0x0000BC, "Member 'FPostProcessSettings::FilmDynamicRange' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmSlope) == 0x0000C0, "Member 'FPostProcessSettings::FilmSlope' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmToe) == 0x0000C4, "Member 'FPostProcessSettings::FilmToe' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmShoulder) == 0x0000C8, "Member 'FPostProcessSettings::FilmShoulder' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmBlackClip) == 0x0000CC, "Member 'FPostProcessSettings::FilmBlackClip' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, FilmWhiteClip) == 0x0000D0, "Member 'FPostProcessSettings::FilmWhiteClip' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, SceneColorTint) == 0x0000D4, "Member 'FPostProcessSettings::SceneColorTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, SceneFringeIntensity) == 0x0000E4, "Member 'FPostProcessSettings::SceneFringeIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomIntensity) == 0x0000E8, "Member 'FPostProcessSettings::BloomIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomThreshold) == 0x0000EC, "Member 'FPostProcessSettings::BloomThreshold' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomSizeScale) == 0x0000F0, "Member 'FPostProcessSettings::BloomSizeScale' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom1Size) == 0x0000F4, "Member 'FPostProcessSettings::Bloom1Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom2Size) == 0x0000F8, "Member 'FPostProcessSettings::Bloom2Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom3Size) == 0x0000FC, "Member 'FPostProcessSettings::Bloom3Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom4Size) == 0x000100, "Member 'FPostProcessSettings::Bloom4Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom5Size) == 0x000104, "Member 'FPostProcessSettings::Bloom5Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom6Size) == 0x000108, "Member 'FPostProcessSettings::Bloom6Size' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom1Tint) == 0x00010C, "Member 'FPostProcessSettings::Bloom1Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom2Tint) == 0x00011C, "Member 'FPostProcessSettings::Bloom2Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom3Tint) == 0x00012C, "Member 'FPostProcessSettings::Bloom3Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom4Tint) == 0x00013C, "Member 'FPostProcessSettings::Bloom4Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom5Tint) == 0x00014C, "Member 'FPostProcessSettings::Bloom5Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Bloom6Tint) == 0x00015C, "Member 'FPostProcessSettings::Bloom6Tint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomDirtMaskIntensity) == 0x00016C, "Member 'FPostProcessSettings::BloomDirtMaskIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomDirtMaskTint) == 0x000170, "Member 'FPostProcessSettings::BloomDirtMaskTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, BloomDirtMask) == 0x000180, "Member 'FPostProcessSettings::BloomDirtMask' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVIntensity) == 0x000184, "Member 'FPostProcessSettings::LPVIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVVplInjectionBias) == 0x000188, "Member 'FPostProcessSettings::LPVVplInjectionBias' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVSize) == 0x00018C, "Member 'FPostProcessSettings::LPVSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVSecondaryOcclusionIntensity) == 0x000190, "Member 'FPostProcessSettings::LPVSecondaryOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVSecondaryBounceIntensity) == 0x000194, "Member 'FPostProcessSettings::LPVSecondaryBounceIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVGeometryVolumeBias) == 0x000198, "Member 'FPostProcessSettings::LPVGeometryVolumeBias' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVEmissiveInjectionIntensity) == 0x00019C, "Member 'FPostProcessSettings::LPVEmissiveInjectionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVDirectionalOcclusionIntensity) == 0x0001A0, "Member 'FPostProcessSettings::LPVDirectionalOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVDirectionalOcclusionRadius) == 0x0001A4, "Member 'FPostProcessSettings::LPVDirectionalOcclusionRadius' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVDiffuseOcclusionExponent) == 0x0001A8, "Member 'FPostProcessSettings::LPVDiffuseOcclusionExponent' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVSpecularOcclusionExponent) == 0x0001AC, "Member 'FPostProcessSettings::LPVSpecularOcclusionExponent' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVDiffuseOcclusionIntensity) == 0x0001B0, "Member 'FPostProcessSettings::LPVDiffuseOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LPVSpecularOcclusionIntensity) == 0x0001B4, "Member 'FPostProcessSettings::LPVSpecularOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientCubemapTint) == 0x0001B8, "Member 'FPostProcessSettings::AmbientCubemapTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientCubemapIntensity) == 0x0001C8, "Member 'FPostProcessSettings::AmbientCubemapIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientCubemap) == 0x0001CC, "Member 'FPostProcessSettings::AmbientCubemap' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureMethod) == 0x0001D0, "Member 'FPostProcessSettings::AutoExposureMethod' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureLowPercent) == 0x0001D4, "Member 'FPostProcessSettings::AutoExposureLowPercent' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureHighPercent) == 0x0001D8, "Member 'FPostProcessSettings::AutoExposureHighPercent' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureMinBrightness) == 0x0001DC, "Member 'FPostProcessSettings::AutoExposureMinBrightness' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureMaxBrightness) == 0x0001E0, "Member 'FPostProcessSettings::AutoExposureMaxBrightness' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureSpeedUp) == 0x0001E4, "Member 'FPostProcessSettings::AutoExposureSpeedUp' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureSpeedDown) == 0x0001E8, "Member 'FPostProcessSettings::AutoExposureSpeedDown' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AutoExposureBias) == 0x0001EC, "Member 'FPostProcessSettings::AutoExposureBias' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, HistogramLogMin) == 0x0001F0, "Member 'FPostProcessSettings::HistogramLogMin' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, HistogramLogMax) == 0x0001F4, "Member 'FPostProcessSettings::HistogramLogMax' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareIntensity) == 0x0001F8, "Member 'FPostProcessSettings::LensFlareIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareTint) == 0x0001FC, "Member 'FPostProcessSettings::LensFlareTint' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareBokehSize) == 0x00020C, "Member 'FPostProcessSettings::LensFlareBokehSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareThreshold) == 0x000210, "Member 'FPostProcessSettings::LensFlareThreshold' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareBokehShape) == 0x000214, "Member 'FPostProcessSettings::LensFlareBokehShape' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, LensFlareTints) == 0x000218, "Member 'FPostProcessSettings::LensFlareTints' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, VignetteIntensity) == 0x000298, "Member 'FPostProcessSettings::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, GrainJitter) == 0x00029C, "Member 'FPostProcessSettings::GrainJitter' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, GrainIntensity) == 0x0002A0, "Member 'FPostProcessSettings::GrainIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionIntensity) == 0x0002A4, "Member 'FPostProcessSettings::AmbientOcclusionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionStaticFraction) == 0x0002A8, "Member 'FPostProcessSettings::AmbientOcclusionStaticFraction' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionRadius) == 0x0002AC, "Member 'FPostProcessSettings::AmbientOcclusionRadius' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionFadeDistance) == 0x0002B4, "Member 'FPostProcessSettings::AmbientOcclusionFadeDistance' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionFadeRadius) == 0x0002B8, "Member 'FPostProcessSettings::AmbientOcclusionFadeRadius' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionDistance) == 0x0002BC, "Member 'FPostProcessSettings::AmbientOcclusionDistance' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionPower) == 0x0002C0, "Member 'FPostProcessSettings::AmbientOcclusionPower' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionBias) == 0x0002C4, "Member 'FPostProcessSettings::AmbientOcclusionBias' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionQuality) == 0x0002C8, "Member 'FPostProcessSettings::AmbientOcclusionQuality' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionMipBlend) == 0x0002CC, "Member 'FPostProcessSettings::AmbientOcclusionMipBlend' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionMipScale) == 0x0002D0, "Member 'FPostProcessSettings::AmbientOcclusionMipScale' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AmbientOcclusionMipThreshold) == 0x0002D4, "Member 'FPostProcessSettings::AmbientOcclusionMipThreshold' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, IndirectLightingColor) == 0x0002D8, "Member 'FPostProcessSettings::IndirectLightingColor' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, IndirectLightingIntensity) == 0x0002E8, "Member 'FPostProcessSettings::IndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorGradingIntensity) == 0x0002EC, "Member 'FPostProcessSettings::ColorGradingIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ColorGradingLUT) == 0x0002F0, "Member 'FPostProcessSettings::ColorGradingLUT' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldMethod) == 0x0002F4, "Member 'FPostProcessSettings::DepthOfFieldMethod' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldFstop) == 0x0002F8, "Member 'FPostProcessSettings::DepthOfFieldFstop' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldFocalDistance) == 0x0002FC, "Member 'FPostProcessSettings::DepthOfFieldFocalDistance' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldDepthBlurAmount) == 0x000300, "Member 'FPostProcessSettings::DepthOfFieldDepthBlurAmount' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldDepthBlurRadius) == 0x000304, "Member 'FPostProcessSettings::DepthOfFieldDepthBlurRadius' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldFocalRegion) == 0x000308, "Member 'FPostProcessSettings::DepthOfFieldFocalRegion' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldNearTransitionRegion) == 0x00030C, "Member 'FPostProcessSettings::DepthOfFieldNearTransitionRegion' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldFarTransitionRegion) == 0x000310, "Member 'FPostProcessSettings::DepthOfFieldFarTransitionRegion' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldScale) == 0x000314, "Member 'FPostProcessSettings::DepthOfFieldScale' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldMaxBokehSize) == 0x000318, "Member 'FPostProcessSettings::DepthOfFieldMaxBokehSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldNearBlurSize) == 0x00031C, "Member 'FPostProcessSettings::DepthOfFieldNearBlurSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldFarBlurSize) == 0x000320, "Member 'FPostProcessSettings::DepthOfFieldFarBlurSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldBokehShape) == 0x000324, "Member 'FPostProcessSettings::DepthOfFieldBokehShape' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldOcclusion) == 0x000328, "Member 'FPostProcessSettings::DepthOfFieldOcclusion' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldColorThreshold) == 0x00032C, "Member 'FPostProcessSettings::DepthOfFieldColorThreshold' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldSizeThreshold) == 0x000330, "Member 'FPostProcessSettings::DepthOfFieldSizeThreshold' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldSkyFocusDistance) == 0x000334, "Member 'FPostProcessSettings::DepthOfFieldSkyFocusDistance' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, DepthOfFieldVignetteSize) == 0x000338, "Member 'FPostProcessSettings::DepthOfFieldVignetteSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, MotionBlurAmount) == 0x00033C, "Member 'FPostProcessSettings::MotionBlurAmount' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, MotionBlurMax) == 0x000340, "Member 'FPostProcessSettings::MotionBlurMax' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, MotionBlurPerObjectSize) == 0x000344, "Member 'FPostProcessSettings::MotionBlurPerObjectSize' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ScreenPercentage) == 0x000348, "Member 'FPostProcessSettings::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, AntiAliasingMethod) == 0x00034C, "Member 'FPostProcessSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ScreenSpaceReflectionIntensity) == 0x000350, "Member 'FPostProcessSettings::ScreenSpaceReflectionIntensity' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ScreenSpaceReflectionQuality) == 0x000354, "Member 'FPostProcessSettings::ScreenSpaceReflectionQuality' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, ScreenSpaceReflectionMaxRoughness) == 0x000358, "Member 'FPostProcessSettings::ScreenSpaceReflectionMaxRoughness' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, WeightedBlendables) == 0x00035C, "Member 'FPostProcessSettings::WeightedBlendables' has a wrong offset!");
static_assert(offsetof(FPostProcessSettings, Blendables) == 0x000368, "Member 'FPostProcessSettings::Blendables' has a wrong offset!");

// ScriptStruct Engine.NavAgentSelector
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavAgentSelector final
{
public:
	uint8                                         bSupportsAgent0 : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent1 : 1;                               // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent2 : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent3 : 1;                               // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent4 : 1;                               // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent5 : 1;                               // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent6 : 1;                               // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent7 : 1;                               // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent8 : 1;                               // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent9 : 1;                               // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent10 : 1;                              // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent11 : 1;                              // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent12 : 1;                              // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent13 : 1;                              // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent14 : 1;                              // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent15 : 1;                              // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavAgentSelector) == 0x000004, "Wrong alignment on FNavAgentSelector");
static_assert(sizeof(FNavAgentSelector) == 0x000004, "Wrong size on FNavAgentSelector");

// ScriptStruct Engine.InterpGroupActorInfo
// 0x0014 (0x0014 - 0x0000)
struct FInterpGroupActorInfo final
{
public:
	class FName                                   ObjectName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpGroupActorInfo) == 0x000004, "Wrong alignment on FInterpGroupActorInfo");
static_assert(sizeof(FInterpGroupActorInfo) == 0x000014, "Wrong size on FInterpGroupActorInfo");
static_assert(offsetof(FInterpGroupActorInfo, ObjectName) == 0x000000, "Member 'FInterpGroupActorInfo::ObjectName' has a wrong offset!");
static_assert(offsetof(FInterpGroupActorInfo, Actors) == 0x000008, "Member 'FInterpGroupActorInfo::Actors' has a wrong offset!");

// ScriptStruct Engine.BlendSample
// 0x0014 (0x0014 - 0x0000)
struct FBlendSample final
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SampleValue;                                       // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendSample) == 0x000004, "Wrong alignment on FBlendSample");
static_assert(sizeof(FBlendSample) == 0x000014, "Wrong size on FBlendSample");
static_assert(offsetof(FBlendSample, Animation) == 0x000000, "Member 'FBlendSample::Animation' has a wrong offset!");
static_assert(offsetof(FBlendSample, SampleValue) == 0x000004, "Member 'FBlendSample::SampleValue' has a wrong offset!");

// ScriptStruct Engine.PlayerMuteList
// 0x002C (0x002C - 0x0000)
struct FPlayerMuteList final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasVoiceHandshakeCompleted;                       // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceChannelIdx;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerMuteList) == 0x000004, "Wrong alignment on FPlayerMuteList");
static_assert(sizeof(FPlayerMuteList) == 0x00002C, "Wrong size on FPlayerMuteList");
static_assert(offsetof(FPlayerMuteList, bHasVoiceHandshakeCompleted) == 0x000024, "Member 'FPlayerMuteList::bHasVoiceHandshakeCompleted' has a wrong offset!");
static_assert(offsetof(FPlayerMuteList, VoiceChannelIdx) == 0x000028, "Member 'FPlayerMuteList::VoiceChannelIdx' has a wrong offset!");

// ScriptStruct Engine.BuilderPoly
// 0x001C (0x001C - 0x0000)
struct FBuilderPoly final
{
public:
	TArray<int32>                                 VertexIndices;                                     // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Direction;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemName;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PolyFlags;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuilderPoly) == 0x000004, "Wrong alignment on FBuilderPoly");
static_assert(sizeof(FBuilderPoly) == 0x00001C, "Wrong size on FBuilderPoly");
static_assert(offsetof(FBuilderPoly, VertexIndices) == 0x000000, "Member 'FBuilderPoly::VertexIndices' has a wrong offset!");
static_assert(offsetof(FBuilderPoly, Direction) == 0x00000C, "Member 'FBuilderPoly::Direction' has a wrong offset!");
static_assert(offsetof(FBuilderPoly, ItemName) == 0x000010, "Member 'FBuilderPoly::ItemName' has a wrong offset!");
static_assert(offsetof(FBuilderPoly, PolyFlags) == 0x000018, "Member 'FBuilderPoly::PolyFlags' has a wrong offset!");

// ScriptStruct Engine.MinimalViewInfo
// 0x03AC (0x03AC - 0x0000)
struct FMinimalViewInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoWidth;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoNearClipPlane;                                // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoFarClipPlane;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bConstrainAspectRatio : 1;                         // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseFieldOfViewForLOD : 1;                         // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraProjectionMode                         ProjectionMode;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostProcessBlendWeight;                            // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0038(0x0374)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalViewInfo) == 0x000004, "Wrong alignment on FMinimalViewInfo");
static_assert(sizeof(FMinimalViewInfo) == 0x0003AC, "Wrong size on FMinimalViewInfo");
static_assert(offsetof(FMinimalViewInfo, Location) == 0x000000, "Member 'FMinimalViewInfo::Location' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, Rotation) == 0x00000C, "Member 'FMinimalViewInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, FOV) == 0x000018, "Member 'FMinimalViewInfo::FOV' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, OrthoWidth) == 0x00001C, "Member 'FMinimalViewInfo::OrthoWidth' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, OrthoNearClipPlane) == 0x000020, "Member 'FMinimalViewInfo::OrthoNearClipPlane' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, OrthoFarClipPlane) == 0x000024, "Member 'FMinimalViewInfo::OrthoFarClipPlane' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, AspectRatio) == 0x000028, "Member 'FMinimalViewInfo::AspectRatio' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, ProjectionMode) == 0x000030, "Member 'FMinimalViewInfo::ProjectionMode' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, PostProcessBlendWeight) == 0x000034, "Member 'FMinimalViewInfo::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(FMinimalViewInfo, PostProcessSettings) == 0x000038, "Member 'FMinimalViewInfo::PostProcessSettings' has a wrong offset!");

// ScriptStruct Engine.ParticleCurvePair
// 0x0010 (0x0010 - 0x0000)
struct FParticleCurvePair final
{
public:
	class FString                                 CurveName;                                         // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                CurveObject;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleCurvePair) == 0x000004, "Wrong alignment on FParticleCurvePair");
static_assert(sizeof(FParticleCurvePair) == 0x000010, "Wrong size on FParticleCurvePair");
static_assert(offsetof(FParticleCurvePair, CurveName) == 0x000000, "Member 'FParticleCurvePair::CurveName' has a wrong offset!");
static_assert(offsetof(FParticleCurvePair, CurveObject) == 0x00000C, "Member 'FParticleCurvePair::CurveObject' has a wrong offset!");

// ScriptStruct Engine.KeyBind
// 0x0020 (0x0020 - 0x0000)
struct FKeyBind final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0010)(Config, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0010(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Control : 1;                                       // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Shift : 1;                                         // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Alt : 1;                                           // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Cmd : 1;                                           // 0x001C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCtrl : 1;                                   // 0x001C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreShift : 1;                                  // 0x001C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreAlt : 1;                                    // 0x001C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreCmd : 1;                                    // 0x001C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyBind) == 0x000004, "Wrong alignment on FKeyBind");
static_assert(sizeof(FKeyBind) == 0x000020, "Wrong size on FKeyBind");
static_assert(offsetof(FKeyBind, Key) == 0x000000, "Member 'FKeyBind::Key' has a wrong offset!");
static_assert(offsetof(FKeyBind, Command) == 0x000010, "Member 'FKeyBind::Command' has a wrong offset!");

// ScriptStruct Engine.VOscillator
// 0x0024 (0x0024 - 0x0000)
struct FVOscillator final
{
public:
	struct FFOscillator                           X;                                                 // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFOscillator                           Y;                                                 // 0x000C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFOscillator                           Z;                                                 // 0x0018(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVOscillator) == 0x000004, "Wrong alignment on FVOscillator");
static_assert(sizeof(FVOscillator) == 0x000024, "Wrong size on FVOscillator");
static_assert(offsetof(FVOscillator, X) == 0x000000, "Member 'FVOscillator::X' has a wrong offset!");
static_assert(offsetof(FVOscillator, Y) == 0x00000C, "Member 'FVOscillator::Y' has a wrong offset!");
static_assert(offsetof(FVOscillator, Z) == 0x000018, "Member 'FVOscillator::Z' has a wrong offset!");

// ScriptStruct Engine.FunctionExpressionOutput
// 0x0034 (0x0034 - 0x0000)
struct FFunctionExpressionOutput final
{
public:
	class UMaterialExpressionFunctionOutput*      ExpressionOutput;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionOutputId;                                // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionOutput                      Output;                                            // 0x0014(0x0020)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFunctionExpressionOutput) == 0x000004, "Wrong alignment on FFunctionExpressionOutput");
static_assert(sizeof(FFunctionExpressionOutput) == 0x000034, "Wrong size on FFunctionExpressionOutput");
static_assert(offsetof(FFunctionExpressionOutput, ExpressionOutput) == 0x000000, "Member 'FFunctionExpressionOutput::ExpressionOutput' has a wrong offset!");
static_assert(offsetof(FFunctionExpressionOutput, ExpressionOutputId) == 0x000004, "Member 'FFunctionExpressionOutput::ExpressionOutputId' has a wrong offset!");
static_assert(offsetof(FFunctionExpressionOutput, Output) == 0x000014, "Member 'FFunctionExpressionOutput::Output' has a wrong offset!");

// ScriptStruct Engine.StaticMeshOptimizationSettings
// 0x001C (0x001C - 0x0000)
struct FStaticMeshOptimizationSettings final
{
public:
	EOptimizationType                             ReductionMethod;                                   // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumOfTrianglesPercentage;                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeviationPercentage;                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeldingThreshold;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalcNormals;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalsThreshold;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SilhouetteImportance;                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TextureImportance;                                 // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShadingImportance;                                 // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticMeshOptimizationSettings) == 0x000004, "Wrong alignment on FStaticMeshOptimizationSettings");
static_assert(sizeof(FStaticMeshOptimizationSettings) == 0x00001C, "Wrong size on FStaticMeshOptimizationSettings");
static_assert(offsetof(FStaticMeshOptimizationSettings, ReductionMethod) == 0x000000, "Member 'FStaticMeshOptimizationSettings::ReductionMethod' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, NumOfTrianglesPercentage) == 0x000004, "Member 'FStaticMeshOptimizationSettings::NumOfTrianglesPercentage' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, MaxDeviationPercentage) == 0x000008, "Member 'FStaticMeshOptimizationSettings::MaxDeviationPercentage' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, WeldingThreshold) == 0x00000C, "Member 'FStaticMeshOptimizationSettings::WeldingThreshold' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, bRecalcNormals) == 0x000010, "Member 'FStaticMeshOptimizationSettings::bRecalcNormals' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, NormalsThreshold) == 0x000014, "Member 'FStaticMeshOptimizationSettings::NormalsThreshold' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, SilhouetteImportance) == 0x000018, "Member 'FStaticMeshOptimizationSettings::SilhouetteImportance' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, TextureImportance) == 0x000019, "Member 'FStaticMeshOptimizationSettings::TextureImportance' has a wrong offset!");
static_assert(offsetof(FStaticMeshOptimizationSettings, ShadingImportance) == 0x00001A, "Member 'FStaticMeshOptimizationSettings::ShadingImportance' has a wrong offset!");

// ScriptStruct Engine.ViewTargetTransitionParams
// 0x0010 (0x0010 - 0x0000)
struct FViewTargetTransitionParams final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockOutgoing : 1;                                 // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FViewTargetTransitionParams) == 0x000004, "Wrong alignment on FViewTargetTransitionParams");
static_assert(sizeof(FViewTargetTransitionParams) == 0x000010, "Wrong size on FViewTargetTransitionParams");
static_assert(offsetof(FViewTargetTransitionParams, BlendTime) == 0x000000, "Member 'FViewTargetTransitionParams::BlendTime' has a wrong offset!");
static_assert(offsetof(FViewTargetTransitionParams, BlendFunction) == 0x000004, "Member 'FViewTargetTransitionParams::BlendFunction' has a wrong offset!");
static_assert(offsetof(FViewTargetTransitionParams, BlendExp) == 0x000008, "Member 'FViewTargetTransitionParams::BlendExp' has a wrong offset!");

// ScriptStruct Engine.TViewTarget
// 0x03B4 (0x03B4 - 0x0000)
struct FTViewTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinimalViewInfo                       POV;                                               // 0x0004(0x03AC)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class APlayerState*                           PlayerState;                                       // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FTViewTarget) == 0x000004, "Wrong alignment on FTViewTarget");
static_assert(sizeof(FTViewTarget) == 0x0003B4, "Wrong size on FTViewTarget");
static_assert(offsetof(FTViewTarget, Target) == 0x000000, "Member 'FTViewTarget::Target' has a wrong offset!");
static_assert(offsetof(FTViewTarget, POV) == 0x000004, "Member 'FTViewTarget::POV' has a wrong offset!");
static_assert(offsetof(FTViewTarget, PlayerState) == 0x0003B0, "Member 'FTViewTarget::PlayerState' has a wrong offset!");

// ScriptStruct Engine.MaterialFunctionInfo
// 0x0014 (0x0014 - 0x0000)
struct FMaterialFunctionInfo final
{
public:
	struct FGuid                                  StateId;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialFunction*                      Function;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialFunctionInfo) == 0x000004, "Wrong alignment on FMaterialFunctionInfo");
static_assert(sizeof(FMaterialFunctionInfo) == 0x000014, "Wrong size on FMaterialFunctionInfo");
static_assert(offsetof(FMaterialFunctionInfo, StateId) == 0x000000, "Member 'FMaterialFunctionInfo::StateId' has a wrong offset!");
static_assert(offsetof(FMaterialFunctionInfo, Function) == 0x000010, "Member 'FMaterialFunctionInfo::Function' has a wrong offset!");

// ScriptStruct Engine.CameraCacheEntry
// 0x03B0 (0x03B0 - 0x0000)
struct FCameraCacheEntry final
{
public:
	float                                         TimeStamp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMinimalViewInfo                       POV;                                               // 0x0004(0x03AC)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraCacheEntry) == 0x000004, "Wrong alignment on FCameraCacheEntry");
static_assert(sizeof(FCameraCacheEntry) == 0x0003B0, "Wrong size on FCameraCacheEntry");
static_assert(offsetof(FCameraCacheEntry, TimeStamp) == 0x000000, "Member 'FCameraCacheEntry::TimeStamp' has a wrong offset!");
static_assert(offsetof(FCameraCacheEntry, POV) == 0x000004, "Member 'FCameraCacheEntry::POV' has a wrong offset!");

// ScriptStruct Engine.IntegralKey
// 0x0008 (0x0008 - 0x0000)
struct FIntegralKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntegralKey) == 0x000004, "Wrong alignment on FIntegralKey");
static_assert(sizeof(FIntegralKey) == 0x000008, "Wrong size on FIntegralKey");
static_assert(offsetof(FIntegralKey, Time) == 0x000000, "Member 'FIntegralKey::Time' has a wrong offset!");
static_assert(offsetof(FIntegralKey, Value) == 0x000004, "Member 'FIntegralKey::Value' has a wrong offset!");

// ScriptStruct Engine.IntegralCurve
// 0x0014 (0x0054 - 0x0040)
struct FIntegralCurve final : public FIndexedCurve
{
public:
	TArray<struct FIntegralKey>                   Keys;                                              // 0x0040(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         DefaultValue;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseDefaultValueBeforeFirstKey;                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntegralCurve) == 0x000004, "Wrong alignment on FIntegralCurve");
static_assert(sizeof(FIntegralCurve) == 0x000054, "Wrong size on FIntegralCurve");
static_assert(offsetof(FIntegralCurve, Keys) == 0x000040, "Member 'FIntegralCurve::Keys' has a wrong offset!");
static_assert(offsetof(FIntegralCurve, DefaultValue) == 0x00004C, "Member 'FIntegralCurve::DefaultValue' has a wrong offset!");
static_assert(offsetof(FIntegralCurve, bUseDefaultValueBeforeFirstKey) == 0x000050, "Member 'FIntegralCurve::bUseDefaultValueBeforeFirstKey' has a wrong offset!");

// ScriptStruct Engine.BeamTargetData
// 0x000C (0x000C - 0x0000)
struct FBeamTargetData final
{
public:
	class FName                                   TargetName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPercentage;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeamTargetData) == 0x000004, "Wrong alignment on FBeamTargetData");
static_assert(sizeof(FBeamTargetData) == 0x00000C, "Wrong size on FBeamTargetData");
static_assert(offsetof(FBeamTargetData, TargetName) == 0x000000, "Member 'FBeamTargetData::TargetName' has a wrong offset!");
static_assert(offsetof(FBeamTargetData, TargetPercentage) == 0x000008, "Member 'FBeamTargetData::TargetPercentage' has a wrong offset!");

// ScriptStruct Engine.NameCurveKey
// 0x000C (0x000C - 0x0000)
struct FNameCurveKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameCurveKey) == 0x000004, "Wrong alignment on FNameCurveKey");
static_assert(sizeof(FNameCurveKey) == 0x00000C, "Wrong size on FNameCurveKey");
static_assert(offsetof(FNameCurveKey, Time) == 0x000000, "Member 'FNameCurveKey::Time' has a wrong offset!");
static_assert(offsetof(FNameCurveKey, Value) == 0x000004, "Member 'FNameCurveKey::Value' has a wrong offset!");

// ScriptStruct Engine.NameCurve
// 0x000C (0x004C - 0x0040)
struct FNameCurve final : public FIndexedCurve
{
public:
	TArray<struct FNameCurveKey>                  Keys;                                              // 0x0040(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameCurve) == 0x000004, "Wrong alignment on FNameCurve");
static_assert(sizeof(FNameCurve) == 0x00004C, "Wrong size on FNameCurve");
static_assert(offsetof(FNameCurve, Keys) == 0x000040, "Member 'FNameCurve::Keys' has a wrong offset!");

// ScriptStruct Engine.InterpEdSelKey
// 0x0010 (0x0010 - 0x0000)
struct FInterpEdSelKey final
{
public:
	class UInterpGroup*                           Group;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInterpTrack*                           Track;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeyIndex;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsnappedPosition;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpEdSelKey) == 0x000004, "Wrong alignment on FInterpEdSelKey");
static_assert(sizeof(FInterpEdSelKey) == 0x000010, "Wrong size on FInterpEdSelKey");
static_assert(offsetof(FInterpEdSelKey, Group) == 0x000000, "Member 'FInterpEdSelKey::Group' has a wrong offset!");
static_assert(offsetof(FInterpEdSelKey, Track) == 0x000004, "Member 'FInterpEdSelKey::Track' has a wrong offset!");
static_assert(offsetof(FInterpEdSelKey, KeyIndex) == 0x000008, "Member 'FInterpEdSelKey::KeyIndex' has a wrong offset!");
static_assert(offsetof(FInterpEdSelKey, UnsnappedPosition) == 0x00000C, "Member 'FInterpEdSelKey::UnsnappedPosition' has a wrong offset!");

// ScriptStruct Engine.InterpolationParameter
// 0x0008 (0x0008 - 0x0000)
struct FInterpolationParameter final
{
public:
	float                                         InterpolationTime;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFilterInterpolationType                      InterpolationType;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpolationParameter) == 0x000004, "Wrong alignment on FInterpolationParameter");
static_assert(sizeof(FInterpolationParameter) == 0x000008, "Wrong size on FInterpolationParameter");
static_assert(offsetof(FInterpolationParameter, InterpolationTime) == 0x000000, "Member 'FInterpolationParameter::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FInterpolationParameter, InterpolationType) == 0x000004, "Member 'FInterpolationParameter::InterpolationType' has a wrong offset!");

// ScriptStruct Engine.ForceFeedbackChannelDetails
// 0x005C (0x005C - 0x0000)
struct FForceFeedbackChannelDetails final
{
public:
	uint8                                         bAffectsLeftLarge : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAffectsLeftSmall : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAffectsRightLarge : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAffectsRightSmall : 1;                            // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0004(0x0058)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FForceFeedbackChannelDetails) == 0x000004, "Wrong alignment on FForceFeedbackChannelDetails");
static_assert(sizeof(FForceFeedbackChannelDetails) == 0x00005C, "Wrong size on FForceFeedbackChannelDetails");
static_assert(offsetof(FForceFeedbackChannelDetails, Curve) == 0x000004, "Member 'FForceFeedbackChannelDetails::Curve' has a wrong offset!");

// ScriptStruct Engine.GameClassShortName
// 0x0018 (0x0018 - 0x0000)
struct FGameClassShortName final
{
public:
	class FString                                 ShortName;                                         // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameClassName;                                     // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameClassShortName) == 0x000004, "Wrong alignment on FGameClassShortName");
static_assert(sizeof(FGameClassShortName) == 0x000018, "Wrong size on FGameClassShortName");
static_assert(offsetof(FGameClassShortName, ShortName) == 0x000000, "Member 'FGameClassShortName::ShortName' has a wrong offset!");
static_assert(offsetof(FGameClassShortName, GameClassName) == 0x00000C, "Member 'FGameClassShortName::GameClassName' has a wrong offset!");

// ScriptStruct Engine.HierarchicalSimplification
// 0x016C (0x016C - 0x0000)
struct FHierarchicalSimplification final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionScreenSize;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimplifyMesh;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMeshProxySettings                     ProxySetting;                                      // 0x000C(0x00D4)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FMeshMergingSettings                   MergeSetting;                                      // 0x00E0(0x0080)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         DesiredBoundRadius;                                // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredFillingPercentage;                          // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumberOfActorsToBuild;                          // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHierarchicalSimplification) == 0x000004, "Wrong alignment on FHierarchicalSimplification");
static_assert(sizeof(FHierarchicalSimplification) == 0x00016C, "Wrong size on FHierarchicalSimplification");
static_assert(offsetof(FHierarchicalSimplification, TransitionScreenSize) == 0x000004, "Member 'FHierarchicalSimplification::TransitionScreenSize' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, bSimplifyMesh) == 0x000008, "Member 'FHierarchicalSimplification::bSimplifyMesh' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, ProxySetting) == 0x00000C, "Member 'FHierarchicalSimplification::ProxySetting' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, MergeSetting) == 0x0000E0, "Member 'FHierarchicalSimplification::MergeSetting' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, DesiredBoundRadius) == 0x000160, "Member 'FHierarchicalSimplification::DesiredBoundRadius' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, DesiredFillingPercentage) == 0x000164, "Member 'FHierarchicalSimplification::DesiredFillingPercentage' has a wrong offset!");
static_assert(offsetof(FHierarchicalSimplification, MinNumberOfActorsToBuild) == 0x000168, "Member 'FHierarchicalSimplification::MinNumberOfActorsToBuild' has a wrong offset!");

// ScriptStruct Engine.NetViewer
// 0x0024 (0x0024 - 0x0000)
struct FNetViewer final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InViewer;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTarget;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ViewDir;                                           // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetViewer) == 0x000004, "Wrong alignment on FNetViewer");
static_assert(sizeof(FNetViewer) == 0x000024, "Wrong size on FNetViewer");
static_assert(offsetof(FNetViewer, Connection) == 0x000000, "Member 'FNetViewer::Connection' has a wrong offset!");
static_assert(offsetof(FNetViewer, InViewer) == 0x000004, "Member 'FNetViewer::InViewer' has a wrong offset!");
static_assert(offsetof(FNetViewer, ViewTarget) == 0x000008, "Member 'FNetViewer::ViewTarget' has a wrong offset!");
static_assert(offsetof(FNetViewer, ViewLocation) == 0x00000C, "Member 'FNetViewer::ViewLocation' has a wrong offset!");
static_assert(offsetof(FNetViewer, ViewDir) == 0x000018, "Member 'FNetViewer::ViewDir' has a wrong offset!");

// ScriptStruct Engine.LightmassWorldInfoSettings
// 0x0044 (0x0044 - 0x0000)
struct FLightmassWorldInfoSettings final
{
public:
	float                                         StaticLightingLevelScale;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumIndirectLightingBounces;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingQuality;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingSmoothness;                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 EnvironmentColor;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EnvironmentIntensity;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmissiveBoost;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffuseBoost;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAmbientOcclusion : 1;                          // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGenerateAmbientOcclusionMaterialMask : 1;         // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectIlluminationOcclusionFraction;               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectIlluminationOcclusionFraction;             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionExponent;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FullyOccludedSamplesFraction;                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOcclusionDistance;                              // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bVisualizeMaterialDiffuse : 1;                     // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bVisualizeAmbientOcclusion : 1;                    // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeLightSamplePlacementScale;                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompressLightmaps : 1;                            // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightmassWorldInfoSettings) == 0x000004, "Wrong alignment on FLightmassWorldInfoSettings");
static_assert(sizeof(FLightmassWorldInfoSettings) == 0x000044, "Wrong size on FLightmassWorldInfoSettings");
static_assert(offsetof(FLightmassWorldInfoSettings, StaticLightingLevelScale) == 0x000000, "Member 'FLightmassWorldInfoSettings::StaticLightingLevelScale' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, NumIndirectLightingBounces) == 0x000004, "Member 'FLightmassWorldInfoSettings::NumIndirectLightingBounces' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, IndirectLightingQuality) == 0x000008, "Member 'FLightmassWorldInfoSettings::IndirectLightingQuality' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, IndirectLightingSmoothness) == 0x00000C, "Member 'FLightmassWorldInfoSettings::IndirectLightingSmoothness' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, EnvironmentColor) == 0x000010, "Member 'FLightmassWorldInfoSettings::EnvironmentColor' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, EnvironmentIntensity) == 0x000014, "Member 'FLightmassWorldInfoSettings::EnvironmentIntensity' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, EmissiveBoost) == 0x000018, "Member 'FLightmassWorldInfoSettings::EmissiveBoost' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, DiffuseBoost) == 0x00001C, "Member 'FLightmassWorldInfoSettings::DiffuseBoost' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, DirectIlluminationOcclusionFraction) == 0x000024, "Member 'FLightmassWorldInfoSettings::DirectIlluminationOcclusionFraction' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, IndirectIlluminationOcclusionFraction) == 0x000028, "Member 'FLightmassWorldInfoSettings::IndirectIlluminationOcclusionFraction' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, OcclusionExponent) == 0x00002C, "Member 'FLightmassWorldInfoSettings::OcclusionExponent' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, FullyOccludedSamplesFraction) == 0x000030, "Member 'FLightmassWorldInfoSettings::FullyOccludedSamplesFraction' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, MaxOcclusionDistance) == 0x000034, "Member 'FLightmassWorldInfoSettings::MaxOcclusionDistance' has a wrong offset!");
static_assert(offsetof(FLightmassWorldInfoSettings, VolumeLightSamplePlacementScale) == 0x00003C, "Member 'FLightmassWorldInfoSettings::VolumeLightSamplePlacementScale' has a wrong offset!");

// ScriptStruct Engine.CharacterMovementComponentPostPhysicsTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FCharacterMovementComponentPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMovementComponentPostPhysicsTickFunction) == 0x000004, "Wrong alignment on FCharacterMovementComponentPostPhysicsTickFunction");
static_assert(sizeof(FCharacterMovementComponentPostPhysicsTickFunction) == 0x000038, "Wrong size on FCharacterMovementComponentPostPhysicsTickFunction");

// ScriptStruct Engine.GameModePrefix
// 0x0018 (0x0018 - 0x0000)
struct FGameModePrefix final
{
public:
	class FString                                 Prefix;                                            // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameModePrefix) == 0x000004, "Wrong alignment on FGameModePrefix");
static_assert(sizeof(FGameModePrefix) == 0x000018, "Wrong size on FGameModePrefix");
static_assert(offsetof(FGameModePrefix, Prefix) == 0x000000, "Member 'FGameModePrefix::Prefix' has a wrong offset!");
static_assert(offsetof(FGameModePrefix, GameMode) == 0x00000C, "Member 'FGameModePrefix::GameMode' has a wrong offset!");

// ScriptStruct Engine.CameraCutInfo
// 0x0010 (0x0010 - 0x0000)
struct FCameraCutInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeStamp;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraCutInfo) == 0x000004, "Wrong alignment on FCameraCutInfo");
static_assert(sizeof(FCameraCutInfo) == 0x000010, "Wrong size on FCameraCutInfo");
static_assert(offsetof(FCameraCutInfo, Location) == 0x000000, "Member 'FCameraCutInfo::Location' has a wrong offset!");
static_assert(offsetof(FCameraCutInfo, TimeStamp) == 0x00000C, "Member 'FCameraCutInfo::TimeStamp' has a wrong offset!");

// ScriptStruct Engine.NavGraphNode
// 0x0010 (0x0010 - 0x0000)
struct FNavGraphNode final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavGraphNode) == 0x000004, "Wrong alignment on FNavGraphNode");
static_assert(sizeof(FNavGraphNode) == 0x000010, "Wrong size on FNavGraphNode");
static_assert(offsetof(FNavGraphNode, Owner) == 0x000000, "Member 'FNavGraphNode::Owner' has a wrong offset!");

// ScriptStruct Engine.NavigationLinkBase
// 0x0028 (0x0028 - 0x0000)
struct FNavigationLinkBase
{
public:
	float                                         LeftProjectHeight;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFallDownLength;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             Direction;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SnapRadius;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapHeight;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseSnapHeight : 1;                                // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSnapToCheapestArea : 1;                           // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNavAgentSelector                      SupportedAgents;                                   // 0x0020(0x0004)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bSupportsAgent0 : 1;                               // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent1 : 1;                               // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent2 : 1;                               // 0x0024(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent3 : 1;                               // 0x0024(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent4 : 1;                               // 0x0024(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent5 : 1;                               // 0x0024(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent6 : 1;                               // 0x0024(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent7 : 1;                               // 0x0024(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent8 : 1;                               // 0x0025(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent9 : 1;                               // 0x0025(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent10 : 1;                              // 0x0025(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent11 : 1;                              // 0x0025(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent12 : 1;                              // 0x0025(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent13 : 1;                              // 0x0025(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent14 : 1;                              // 0x0025(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsAgent15 : 1;                              // 0x0025(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavigationLinkBase) == 0x000004, "Wrong alignment on FNavigationLinkBase");
static_assert(sizeof(FNavigationLinkBase) == 0x000028, "Wrong size on FNavigationLinkBase");
static_assert(offsetof(FNavigationLinkBase, LeftProjectHeight) == 0x000000, "Member 'FNavigationLinkBase::LeftProjectHeight' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, MaxFallDownLength) == 0x000004, "Member 'FNavigationLinkBase::MaxFallDownLength' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, Direction) == 0x000008, "Member 'FNavigationLinkBase::Direction' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, SnapRadius) == 0x000010, "Member 'FNavigationLinkBase::SnapRadius' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, SnapHeight) == 0x000014, "Member 'FNavigationLinkBase::SnapHeight' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, AreaClass) == 0x00001C, "Member 'FNavigationLinkBase::AreaClass' has a wrong offset!");
static_assert(offsetof(FNavigationLinkBase, SupportedAgents) == 0x000020, "Member 'FNavigationLinkBase::SupportedAgents' has a wrong offset!");

// ScriptStruct Engine.NavigationSegmentLink
// 0x0030 (0x0058 - 0x0028)
struct FNavigationSegmentLink final : public FNavigationLinkBase
{
public:
	struct FVector                                LeftStart;                                         // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEnd;                                           // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightStart;                                        // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEnd;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationSegmentLink) == 0x000004, "Wrong alignment on FNavigationSegmentLink");
static_assert(sizeof(FNavigationSegmentLink) == 0x000058, "Wrong size on FNavigationSegmentLink");
static_assert(offsetof(FNavigationSegmentLink, LeftStart) == 0x000028, "Member 'FNavigationSegmentLink::LeftStart' has a wrong offset!");
static_assert(offsetof(FNavigationSegmentLink, LeftEnd) == 0x000034, "Member 'FNavigationSegmentLink::LeftEnd' has a wrong offset!");
static_assert(offsetof(FNavigationSegmentLink, RightStart) == 0x000040, "Member 'FNavigationSegmentLink::RightStart' has a wrong offset!");
static_assert(offsetof(FNavigationSegmentLink, RightEnd) == 0x00004C, "Member 'FNavigationSegmentLink::RightEnd' has a wrong offset!");

// ScriptStruct Engine.NavigationLink
// 0x0018 (0x0040 - 0x0028)
struct FNavigationLink final : public FNavigationLinkBase
{
public:
	struct FVector                                Left;                                              // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Right;                                             // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavigationLink) == 0x000004, "Wrong alignment on FNavigationLink");
static_assert(sizeof(FNavigationLink) == 0x000040, "Wrong size on FNavigationLink");
static_assert(offsetof(FNavigationLink, Left) == 0x000028, "Member 'FNavigationLink::Left' has a wrong offset!");
static_assert(offsetof(FNavigationLink, Right) == 0x000034, "Member 'FNavigationLink::Right' has a wrong offset!");

// ScriptStruct Engine.PreviewAssetAttachContainer
// 0x000C (0x000C - 0x0000)
struct FPreviewAssetAttachContainer final
{
public:
	TArray<struct FPreviewAttachedObjectPair>     AttachedObjects;                                   // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPreviewAssetAttachContainer) == 0x000004, "Wrong alignment on FPreviewAssetAttachContainer");
static_assert(sizeof(FPreviewAssetAttachContainer) == 0x00000C, "Wrong size on FPreviewAssetAttachContainer");
static_assert(offsetof(FPreviewAssetAttachContainer, AttachedObjects) == 0x000000, "Member 'FPreviewAssetAttachContainer::AttachedObjects' has a wrong offset!");

// ScriptStruct Engine.SingleAnimationPlayData
// 0x0014 (0x0014 - 0x0000)
struct FSingleAnimationPlayData final
{
public:
	class UAnimationAsset*                        AnimToPlay;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVertexAnimation*                       VertexAnimToPlay;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSavedLooping : 1;                                 // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSavedPlaying : 1;                                 // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SavedPosition;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SavedPlayRate;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleAnimationPlayData) == 0x000004, "Wrong alignment on FSingleAnimationPlayData");
static_assert(sizeof(FSingleAnimationPlayData) == 0x000014, "Wrong size on FSingleAnimationPlayData");
static_assert(offsetof(FSingleAnimationPlayData, AnimToPlay) == 0x000000, "Member 'FSingleAnimationPlayData::AnimToPlay' has a wrong offset!");
static_assert(offsetof(FSingleAnimationPlayData, VertexAnimToPlay) == 0x000004, "Member 'FSingleAnimationPlayData::VertexAnimToPlay' has a wrong offset!");
static_assert(offsetof(FSingleAnimationPlayData, SavedPosition) == 0x00000C, "Member 'FSingleAnimationPlayData::SavedPosition' has a wrong offset!");
static_assert(offsetof(FSingleAnimationPlayData, SavedPlayRate) == 0x000010, "Member 'FSingleAnimationPlayData::SavedPlayRate' has a wrong offset!");

// ScriptStruct Engine.SmartNameContainer
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FSmartNameContainer final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartNameContainer) == 0x000004, "Wrong alignment on FSmartNameContainer");
static_assert(sizeof(FSmartNameContainer) == 0x00003C, "Wrong size on FSmartNameContainer");

// ScriptStruct Engine.AudioQualitySettings
// 0x0010 (0x0010 - 0x0000)
struct FAudioQualitySettings final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	int32                                         MaxChannels;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioQualitySettings) == 0x000004, "Wrong alignment on FAudioQualitySettings");
static_assert(sizeof(FAudioQualitySettings) == 0x000010, "Wrong size on FAudioQualitySettings");
static_assert(offsetof(FAudioQualitySettings, DisplayName) == 0x000000, "Member 'FAudioQualitySettings::DisplayName' has a wrong offset!");
static_assert(offsetof(FAudioQualitySettings, MaxChannels) == 0x00000C, "Member 'FAudioQualitySettings::MaxChannels' has a wrong offset!");

// ScriptStruct Engine.TranslationTrack
// 0x0018 (0x0018 - 0x0000)
struct FTranslationTrack final
{
public:
	TArray<struct FVector>                        PosKeys;                                           // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTranslationTrack) == 0x000004, "Wrong alignment on FTranslationTrack");
static_assert(sizeof(FTranslationTrack) == 0x000018, "Wrong size on FTranslationTrack");
static_assert(offsetof(FTranslationTrack, PosKeys) == 0x000000, "Member 'FTranslationTrack::PosKeys' has a wrong offset!");
static_assert(offsetof(FTranslationTrack, Times) == 0x00000C, "Member 'FTranslationTrack::Times' has a wrong offset!");

// ScriptStruct Engine.SmartNameMapping
// 0x004C (0x004C - 0x0000)
struct alignas(0x04) FSmartNameMapping final
{
public:
	uint8                                         Pad_0[0x4C];                                       // 0x0000(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartNameMapping) == 0x000004, "Wrong alignment on FSmartNameMapping");
static_assert(sizeof(FSmartNameMapping) == 0x00004C, "Wrong size on FSmartNameMapping");

// ScriptStruct Engine.AnimSlotGroup
// 0x0014 (0x0014 - 0x0000)
struct FAnimSlotGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SlotNames;                                         // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSlotGroup) == 0x000004, "Wrong alignment on FAnimSlotGroup");
static_assert(sizeof(FAnimSlotGroup) == 0x000014, "Wrong size on FAnimSlotGroup");
static_assert(offsetof(FAnimSlotGroup, GroupName) == 0x000000, "Member 'FAnimSlotGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FAnimSlotGroup, SlotNames) == 0x000008, "Member 'FAnimSlotGroup::SlotNames' has a wrong offset!");

// ScriptStruct Engine.NameMapping
// 0x0010 (0x0010 - 0x0000)
struct FNameMapping final
{
public:
	class FName                                   NodeName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNameMapping) == 0x000004, "Wrong alignment on FNameMapping");
static_assert(sizeof(FNameMapping) == 0x000010, "Wrong size on FNameMapping");
static_assert(offsetof(FNameMapping, NodeName) == 0x000000, "Member 'FNameMapping::NodeName' has a wrong offset!");
static_assert(offsetof(FNameMapping, BoneName) == 0x000008, "Member 'FNameMapping::BoneName' has a wrong offset!");

// ScriptStruct Engine.RigConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FRigConfiguration final
{
public:
	class URig*                                   Rig;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNameMapping>                   BoneMappingTable;                                  // 0x0004(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigConfiguration) == 0x000004, "Wrong alignment on FRigConfiguration");
static_assert(sizeof(FRigConfiguration) == 0x000010, "Wrong size on FRigConfiguration");
static_assert(offsetof(FRigConfiguration, Rig) == 0x000000, "Member 'FRigConfiguration::Rig' has a wrong offset!");
static_assert(offsetof(FRigConfiguration, BoneMappingTable) == 0x000004, "Member 'FRigConfiguration::BoneMappingTable' has a wrong offset!");

// ScriptStruct Engine.GraphReference
// 0x0018 (0x0018 - 0x0000)
struct FGraphReference final
{
public:
	class UEdGraph*                               MacroGraph;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlueprint*                             GraphBlueprint;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GraphGuid;                                         // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGraphReference) == 0x000004, "Wrong alignment on FGraphReference");
static_assert(sizeof(FGraphReference) == 0x000018, "Wrong size on FGraphReference");
static_assert(offsetof(FGraphReference, MacroGraph) == 0x000000, "Member 'FGraphReference::MacroGraph' has a wrong offset!");
static_assert(offsetof(FGraphReference, GraphBlueprint) == 0x000004, "Member 'FGraphReference::GraphBlueprint' has a wrong offset!");
static_assert(offsetof(FGraphReference, GraphGuid) == 0x000008, "Member 'FGraphReference::GraphGuid' has a wrong offset!");

// ScriptStruct Engine.BoneReductionSetting
// 0x000C (0x000C - 0x0000)
struct FBoneReductionSetting final
{
public:
	TArray<class FName>                           BonesToRemove;                                     // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneReductionSetting) == 0x000004, "Wrong alignment on FBoneReductionSetting");
static_assert(sizeof(FBoneReductionSetting) == 0x00000C, "Wrong size on FBoneReductionSetting");
static_assert(offsetof(FBoneReductionSetting, BonesToRemove) == 0x000000, "Member 'FBoneReductionSetting::BonesToRemove' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputTouchDelegateBinding
// 0x000C (0x0010 - 0x0004)
struct FBlueprintInputTouchDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	EInputEvent                                   InputKeyEvent;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintInputTouchDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputTouchDelegateBinding");
static_assert(sizeof(FBlueprintInputTouchDelegateBinding) == 0x000010, "Wrong size on FBlueprintInputTouchDelegateBinding");
static_assert(offsetof(FBlueprintInputTouchDelegateBinding, InputKeyEvent) == 0x000004, "Member 'FBlueprintInputTouchDelegateBinding::InputKeyEvent' has a wrong offset!");
static_assert(offsetof(FBlueprintInputTouchDelegateBinding, FunctionNameToBind) == 0x000008, "Member 'FBlueprintInputTouchDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.ReferencePose
// 0x0014 (0x0014 - 0x0000)
struct FReferencePose final
{
public:
	class FName                                   PoseName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReferencePose;                                     // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferencePose) == 0x000004, "Wrong alignment on FReferencePose");
static_assert(sizeof(FReferencePose) == 0x000014, "Wrong size on FReferencePose");
static_assert(offsetof(FReferencePose, PoseName) == 0x000000, "Member 'FReferencePose::PoseName' has a wrong offset!");
static_assert(offsetof(FReferencePose, ReferencePose) == 0x000008, "Member 'FReferencePose::ReferencePose' has a wrong offset!");

// ScriptStruct Engine.AtmospherePrecomputeParameters
// 0x002C (0x002C - 0x0000)
struct FAtmospherePrecomputeParameters final
{
public:
	float                                         DensityHeight;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayHeight;                                       // 0x0004(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScatteringOrder;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransmittanceTexWidth;                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransmittanceTexHeight;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IrradianceTexWidth;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IrradianceTexHeight;                               // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InscatterAltitudeSampleNum;                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InscatterMuNum;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InscatterMuSNum;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InscatterNuNum;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtmospherePrecomputeParameters) == 0x000004, "Wrong alignment on FAtmospherePrecomputeParameters");
static_assert(sizeof(FAtmospherePrecomputeParameters) == 0x00002C, "Wrong size on FAtmospherePrecomputeParameters");
static_assert(offsetof(FAtmospherePrecomputeParameters, DensityHeight) == 0x000000, "Member 'FAtmospherePrecomputeParameters::DensityHeight' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, DecayHeight) == 0x000004, "Member 'FAtmospherePrecomputeParameters::DecayHeight' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, MaxScatteringOrder) == 0x000008, "Member 'FAtmospherePrecomputeParameters::MaxScatteringOrder' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, TransmittanceTexWidth) == 0x00000C, "Member 'FAtmospherePrecomputeParameters::TransmittanceTexWidth' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, TransmittanceTexHeight) == 0x000010, "Member 'FAtmospherePrecomputeParameters::TransmittanceTexHeight' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, IrradianceTexWidth) == 0x000014, "Member 'FAtmospherePrecomputeParameters::IrradianceTexWidth' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, IrradianceTexHeight) == 0x000018, "Member 'FAtmospherePrecomputeParameters::IrradianceTexHeight' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, InscatterAltitudeSampleNum) == 0x00001C, "Member 'FAtmospherePrecomputeParameters::InscatterAltitudeSampleNum' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, InscatterMuNum) == 0x000020, "Member 'FAtmospherePrecomputeParameters::InscatterMuNum' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, InscatterMuSNum) == 0x000024, "Member 'FAtmospherePrecomputeParameters::InscatterMuSNum' has a wrong offset!");
static_assert(offsetof(FAtmospherePrecomputeParameters, InscatterNuNum) == 0x000028, "Member 'FAtmospherePrecomputeParameters::InscatterNuNum' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_ConstantForce
// 0x0010 (0x0090 - 0x0080)
struct FRootMotionSource_ConstantForce final : public FRootMotionSource
{
public:
	struct FVector                                Force;                                             // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_ConstantForce) == 0x000010, "Wrong alignment on FRootMotionSource_ConstantForce");
static_assert(sizeof(FRootMotionSource_ConstantForce) == 0x000090, "Wrong size on FRootMotionSource_ConstantForce");
static_assert(offsetof(FRootMotionSource_ConstantForce, Force) == 0x000080, "Member 'FRootMotionSource_ConstantForce::Force' has a wrong offset!");

// ScriptStruct Engine.BoneNode
// 0x0010 (0x0010 - 0x0000)
struct FBoneNode final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0008(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneTranslationRetargetingMode               TranslationRetargetingMode;                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneNode) == 0x000004, "Wrong alignment on FBoneNode");
static_assert(sizeof(FBoneNode) == 0x000010, "Wrong size on FBoneNode");
static_assert(offsetof(FBoneNode, Name) == 0x000000, "Member 'FBoneNode::Name' has a wrong offset!");
static_assert(offsetof(FBoneNode, ParentIndex) == 0x000008, "Member 'FBoneNode::ParentIndex' has a wrong offset!");
static_assert(offsetof(FBoneNode, TranslationRetargetingMode) == 0x00000C, "Member 'FBoneNode::TranslationRetargetingMode' has a wrong offset!");

// ScriptStruct Engine.SkeletonToMeshLinkup
// 0x0018 (0x0018 - 0x0000)
struct FSkeletonToMeshLinkup final
{
public:
	TArray<int32>                                 SkeletonToMeshTable;                               // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 MeshToSkeletonTable;                               // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonToMeshLinkup) == 0x000004, "Wrong alignment on FSkeletonToMeshLinkup");
static_assert(sizeof(FSkeletonToMeshLinkup) == 0x000018, "Wrong size on FSkeletonToMeshLinkup");
static_assert(offsetof(FSkeletonToMeshLinkup, SkeletonToMeshTable) == 0x000000, "Member 'FSkeletonToMeshLinkup::SkeletonToMeshTable' has a wrong offset!");
static_assert(offsetof(FSkeletonToMeshLinkup, MeshToSkeletonTable) == 0x00000C, "Member 'FSkeletonToMeshLinkup::MeshToSkeletonTable' has a wrong offset!");

// ScriptStruct Engine.DialogueContext
// 0x0010 (0x0010 - 0x0000)
struct FDialogueContext final
{
public:
	class UDialogueVoice*                         Speaker;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDialogueVoice*>                 Targets;                                           // 0x0004(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueContext) == 0x000004, "Wrong alignment on FDialogueContext");
static_assert(sizeof(FDialogueContext) == 0x000010, "Wrong size on FDialogueContext");
static_assert(offsetof(FDialogueContext, Speaker) == 0x000000, "Member 'FDialogueContext::Speaker' has a wrong offset!");
static_assert(offsetof(FDialogueContext, Targets) == 0x000004, "Member 'FDialogueContext::Targets' has a wrong offset!");

// ScriptStruct Engine.TriIndices
// 0x000C (0x000C - 0x0000)
struct FTriIndices final
{
public:
	int32                                         v0;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         v1;                                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         v2;                                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriIndices) == 0x000004, "Wrong alignment on FTriIndices");
static_assert(sizeof(FTriIndices) == 0x00000C, "Wrong size on FTriIndices");
static_assert(offsetof(FTriIndices, v0) == 0x000000, "Member 'FTriIndices::v0' has a wrong offset!");
static_assert(offsetof(FTriIndices, v1) == 0x000004, "Member 'FTriIndices::v1' has a wrong offset!");
static_assert(offsetof(FTriIndices, v2) == 0x000008, "Member 'FTriIndices::v2' has a wrong offset!");

// ScriptStruct Engine.TriMeshCollisionData
// 0x0028 (0x0028 - 0x0000)
struct FTriMeshCollisionData final
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x0000(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTriIndices>                    Indices;                                           // 0x000C(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bFlipNormals : 1;                                  // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTriMeshCollisionData) == 0x000004, "Wrong alignment on FTriMeshCollisionData");
static_assert(sizeof(FTriMeshCollisionData) == 0x000028, "Wrong size on FTriMeshCollisionData");
static_assert(offsetof(FTriMeshCollisionData, Vertices) == 0x000000, "Member 'FTriMeshCollisionData::Vertices' has a wrong offset!");
static_assert(offsetof(FTriMeshCollisionData, Indices) == 0x00000C, "Member 'FTriMeshCollisionData::Indices' has a wrong offset!");

// ScriptStruct Engine.SkeletalMaterial
// 0x0008 (0x0008 - 0x0000)
struct FSkeletalMaterial final
{
public:
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableShadowCasting;                              // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMaterial) == 0x000004, "Wrong alignment on FSkeletalMaterial");
static_assert(sizeof(FSkeletalMaterial) == 0x000008, "Wrong size on FSkeletalMaterial");
static_assert(offsetof(FSkeletalMaterial, MaterialInterface) == 0x000000, "Member 'FSkeletalMaterial::MaterialInterface' has a wrong offset!");
static_assert(offsetof(FSkeletalMaterial, bEnableShadowCasting) == 0x000004, "Member 'FSkeletalMaterial::bEnableShadowCasting' has a wrong offset!");

// ScriptStruct Engine.MorphTargetMap
// 0x000C (0x000C - 0x0000)
struct FMorphTargetMap final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMorphTarget*                           MorphTarget;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMorphTargetMap) == 0x000004, "Wrong alignment on FMorphTargetMap");
static_assert(sizeof(FMorphTargetMap) == 0x00000C, "Wrong size on FMorphTargetMap");
static_assert(offsetof(FMorphTargetMap, Name) == 0x000000, "Member 'FMorphTargetMap::Name' has a wrong offset!");
static_assert(offsetof(FMorphTargetMap, MorphTarget) == 0x000008, "Member 'FMorphTargetMap::MorphTarget' has a wrong offset!");

// ScriptStruct Engine.HapticFeedbackDetails
// 0x00B0 (0x00B0 - 0x0000)
struct FHapticFeedbackDetails final
{
public:
	struct FRuntimeFloatCurve                     Frequency;                                         // 0x0000(0x0058)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Amplitude;                                         // 0x0058(0x0058)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHapticFeedbackDetails) == 0x000004, "Wrong alignment on FHapticFeedbackDetails");
static_assert(sizeof(FHapticFeedbackDetails) == 0x0000B0, "Wrong size on FHapticFeedbackDetails");
static_assert(offsetof(FHapticFeedbackDetails, Frequency) == 0x000000, "Member 'FHapticFeedbackDetails::Frequency' has a wrong offset!");
static_assert(offsetof(FHapticFeedbackDetails, Amplitude) == 0x000058, "Member 'FHapticFeedbackDetails::Amplitude' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshLODInfo
// 0x0070 (0x0070 - 0x0000)
struct FSkeletalMeshLODInfo final
{
public:
	float                                         ScreenSize;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODHysteresis;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 LODMaterialMap;                                    // 0x0008(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  bEnableShadowCasting;                              // 0x0014(0x000C)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FTriangleSortSettings>          TriangleSortSettings;                              // 0x0020(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bHasBeenSimplified : 1;                            // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkeletalMeshOptimizationSettings      ReductionSettings;                                 // 0x0030(0x0034)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           RemovedBones;                                      // 0x0064(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletalMeshLODInfo) == 0x000004, "Wrong alignment on FSkeletalMeshLODInfo");
static_assert(sizeof(FSkeletalMeshLODInfo) == 0x000070, "Wrong size on FSkeletalMeshLODInfo");
static_assert(offsetof(FSkeletalMeshLODInfo, ScreenSize) == 0x000000, "Member 'FSkeletalMeshLODInfo::ScreenSize' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, LODHysteresis) == 0x000004, "Member 'FSkeletalMeshLODInfo::LODHysteresis' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, LODMaterialMap) == 0x000008, "Member 'FSkeletalMeshLODInfo::LODMaterialMap' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, bEnableShadowCasting) == 0x000014, "Member 'FSkeletalMeshLODInfo::bEnableShadowCasting' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, TriangleSortSettings) == 0x000020, "Member 'FSkeletalMeshLODInfo::TriangleSortSettings' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, ReductionSettings) == 0x000030, "Member 'FSkeletalMeshLODInfo::ReductionSettings' has a wrong offset!");
static_assert(offsetof(FSkeletalMeshLODInfo, RemovedBones) == 0x000064, "Member 'FSkeletalMeshLODInfo::RemovedBones' has a wrong offset!");

// ScriptStruct Engine.StructRedirect
// 0x0010 (0x0010 - 0x0000)
struct FStructRedirect final
{
public:
	class FName                                   OldStructName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewStructName;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStructRedirect) == 0x000004, "Wrong alignment on FStructRedirect");
static_assert(sizeof(FStructRedirect) == 0x000010, "Wrong size on FStructRedirect");
static_assert(offsetof(FStructRedirect, OldStructName) == 0x000000, "Member 'FStructRedirect::OldStructName' has a wrong offset!");
static_assert(offsetof(FStructRedirect, NewStructName) == 0x000008, "Member 'FStructRedirect::NewStructName' has a wrong offset!");

// ScriptStruct Engine.BoneMirrorExport
// 0x0014 (0x0014 - 0x0000)
struct FBoneMirrorExport final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceBoneName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         BoneFlipAxis;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneMirrorExport) == 0x000004, "Wrong alignment on FBoneMirrorExport");
static_assert(sizeof(FBoneMirrorExport) == 0x000014, "Wrong size on FBoneMirrorExport");
static_assert(offsetof(FBoneMirrorExport, BoneName) == 0x000000, "Member 'FBoneMirrorExport::BoneName' has a wrong offset!");
static_assert(offsetof(FBoneMirrorExport, SourceBoneName) == 0x000008, "Member 'FBoneMirrorExport::SourceBoneName' has a wrong offset!");
static_assert(offsetof(FBoneMirrorExport, BoneFlipAxis) == 0x000010, "Member 'FBoneMirrorExport::BoneFlipAxis' has a wrong offset!");

// ScriptStruct Engine.BoneMirrorInfo
// 0x0008 (0x0008 - 0x0000)
struct FBoneMirrorInfo final
{
public:
	int32                                         SourceIndex;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         BoneFlipAxis;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneMirrorInfo) == 0x000004, "Wrong alignment on FBoneMirrorInfo");
static_assert(sizeof(FBoneMirrorInfo) == 0x000008, "Wrong size on FBoneMirrorInfo");
static_assert(offsetof(FBoneMirrorInfo, SourceIndex) == 0x000000, "Member 'FBoneMirrorInfo::SourceIndex' has a wrong offset!");
static_assert(offsetof(FBoneMirrorInfo, BoneFlipAxis) == 0x000004, "Member 'FBoneMirrorInfo::BoneFlipAxis' has a wrong offset!");

// ScriptStruct Engine.DistanceDatum
// 0x0014 (0x0014 - 0x0000)
struct FDistanceDatum final
{
public:
	float                                         FadeInDistanceStart;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInDistanceEnd;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDistanceStart;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDistanceEnd;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceDatum) == 0x000004, "Wrong alignment on FDistanceDatum");
static_assert(sizeof(FDistanceDatum) == 0x000014, "Wrong size on FDistanceDatum");
static_assert(offsetof(FDistanceDatum, FadeInDistanceStart) == 0x000000, "Member 'FDistanceDatum::FadeInDistanceStart' has a wrong offset!");
static_assert(offsetof(FDistanceDatum, FadeInDistanceEnd) == 0x000004, "Member 'FDistanceDatum::FadeInDistanceEnd' has a wrong offset!");
static_assert(offsetof(FDistanceDatum, FadeOutDistanceStart) == 0x000008, "Member 'FDistanceDatum::FadeOutDistanceStart' has a wrong offset!");
static_assert(offsetof(FDistanceDatum, FadeOutDistanceEnd) == 0x00000C, "Member 'FDistanceDatum::FadeOutDistanceEnd' has a wrong offset!");
static_assert(offsetof(FDistanceDatum, Volume) == 0x000010, "Member 'FDistanceDatum::Volume' has a wrong offset!");

// ScriptStruct Engine.AnimationGroupReference
// 0x000C (0x000C - 0x0000)
struct FAnimationGroupReference final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimGroupRole                                GroupRole;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationGroupReference) == 0x000004, "Wrong alignment on FAnimationGroupReference");
static_assert(sizeof(FAnimationGroupReference) == 0x00000C, "Wrong size on FAnimationGroupReference");
static_assert(offsetof(FAnimationGroupReference, GroupName) == 0x000000, "Member 'FAnimationGroupReference::GroupName' has a wrong offset!");
static_assert(offsetof(FAnimationGroupReference, GroupRole) == 0x000008, "Member 'FAnimationGroupReference::GroupRole' has a wrong offset!");

// ScriptStruct Engine.AnimGroupInstance
// 0x0064 (0x0064 - 0x0000)
struct alignas(0x04) FAnimGroupInstance final
{
public:
	uint8                                         Pad_0[0x64];                                       // 0x0000(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimGroupInstance) == 0x000004, "Wrong alignment on FAnimGroupInstance");
static_assert(sizeof(FAnimGroupInstance) == 0x000064, "Wrong size on FAnimGroupInstance");

// ScriptStruct Engine.InterpLookupPoint
// 0x000C (0x000C - 0x0000)
struct FInterpLookupPoint final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpLookupPoint) == 0x000004, "Wrong alignment on FInterpLookupPoint");
static_assert(sizeof(FInterpLookupPoint) == 0x00000C, "Wrong size on FInterpLookupPoint");
static_assert(offsetof(FInterpLookupPoint, GroupName) == 0x000000, "Member 'FInterpLookupPoint::GroupName' has a wrong offset!");
static_assert(offsetof(FInterpLookupPoint, Time) == 0x000008, "Member 'FInterpLookupPoint::Time' has a wrong offset!");

// ScriptStruct Engine.InterpLookupTrack
// 0x000C (0x000C - 0x0000)
struct FInterpLookupTrack final
{
public:
	TArray<struct FInterpLookupPoint>             Points;                                            // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpLookupTrack) == 0x000004, "Wrong alignment on FInterpLookupTrack");
static_assert(sizeof(FInterpLookupTrack) == 0x00000C, "Wrong size on FInterpLookupTrack");
static_assert(offsetof(FInterpLookupTrack, Points) == 0x000000, "Member 'FInterpLookupTrack::Points' has a wrong offset!");

// ScriptStruct Engine.MarkerSyncAnimPosition
// 0x0014 (0x0014 - 0x0000)
struct FMarkerSyncAnimPosition final
{
public:
	class FName                                   PreviousMarkerName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextMarkerName;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionBetweenMarkers;                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMarkerSyncAnimPosition) == 0x000004, "Wrong alignment on FMarkerSyncAnimPosition");
static_assert(sizeof(FMarkerSyncAnimPosition) == 0x000014, "Wrong size on FMarkerSyncAnimPosition");
static_assert(offsetof(FMarkerSyncAnimPosition, PreviousMarkerName) == 0x000000, "Member 'FMarkerSyncAnimPosition::PreviousMarkerName' has a wrong offset!");
static_assert(offsetof(FMarkerSyncAnimPosition, NextMarkerName) == 0x000008, "Member 'FMarkerSyncAnimPosition::NextMarkerName' has a wrong offset!");
static_assert(offsetof(FMarkerSyncAnimPosition, PositionBetweenMarkers) == 0x000010, "Member 'FMarkerSyncAnimPosition::PositionBetweenMarkers' has a wrong offset!");

// ScriptStruct Engine.EditorImportWorkflowDefinition
// 0x0018 (0x0018 - 0x0000)
struct FEditorImportWorkflowDefinition final
{
public:
	struct FFilePath                              ImportFilePath;                                    // 0x0000(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FImportFactorySettingValues>    FactorySettings;                                   // 0x000C(0x000C)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorImportWorkflowDefinition) == 0x000004, "Wrong alignment on FEditorImportWorkflowDefinition");
static_assert(sizeof(FEditorImportWorkflowDefinition) == 0x000018, "Wrong size on FEditorImportWorkflowDefinition");
static_assert(offsetof(FEditorImportWorkflowDefinition, ImportFilePath) == 0x000000, "Member 'FEditorImportWorkflowDefinition::ImportFilePath' has a wrong offset!");
static_assert(offsetof(FEditorImportWorkflowDefinition, FactorySettings) == 0x00000C, "Member 'FEditorImportWorkflowDefinition::FactorySettings' has a wrong offset!");

// ScriptStruct Engine.BatchedPoint
// 0x0028 (0x0028 - 0x0000)
struct FBatchedPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PointSize;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingLifeTime;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBatchedPoint) == 0x000004, "Wrong alignment on FBatchedPoint");
static_assert(sizeof(FBatchedPoint) == 0x000028, "Wrong size on FBatchedPoint");
static_assert(offsetof(FBatchedPoint, Position) == 0x000000, "Member 'FBatchedPoint::Position' has a wrong offset!");
static_assert(offsetof(FBatchedPoint, Color) == 0x00000C, "Member 'FBatchedPoint::Color' has a wrong offset!");
static_assert(offsetof(FBatchedPoint, PointSize) == 0x00001C, "Member 'FBatchedPoint::PointSize' has a wrong offset!");
static_assert(offsetof(FBatchedPoint, RemainingLifeTime) == 0x000020, "Member 'FBatchedPoint::RemainingLifeTime' has a wrong offset!");
static_assert(offsetof(FBatchedPoint, DepthPriority) == 0x000024, "Member 'FBatchedPoint::DepthPriority' has a wrong offset!");

// ScriptStruct Engine.RootMotionSourceGroup
// 0x0090 (0x0090 - 0x0000)
struct FRootMotionSourceGroup final
{
public:
	uint8                                         Pad_0[0x7C];                                       // 0x0000(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasAdditiveSources;                               // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasOverrideSources;                               // 0x007D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastPreAdditiveVelocity;                           // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsAdditiveVelocityApplied;                        // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRootMotionSourceSettings              LastAccumulatedSettings;                           // 0x008D(0x0001)(NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSourceGroup) == 0x000004, "Wrong alignment on FRootMotionSourceGroup");
static_assert(sizeof(FRootMotionSourceGroup) == 0x000090, "Wrong size on FRootMotionSourceGroup");
static_assert(offsetof(FRootMotionSourceGroup, bHasAdditiveSources) == 0x00007C, "Member 'FRootMotionSourceGroup::bHasAdditiveSources' has a wrong offset!");
static_assert(offsetof(FRootMotionSourceGroup, bHasOverrideSources) == 0x00007D, "Member 'FRootMotionSourceGroup::bHasOverrideSources' has a wrong offset!");
static_assert(offsetof(FRootMotionSourceGroup, LastPreAdditiveVelocity) == 0x000080, "Member 'FRootMotionSourceGroup::LastPreAdditiveVelocity' has a wrong offset!");
static_assert(offsetof(FRootMotionSourceGroup, bIsAdditiveVelocityApplied) == 0x00008C, "Member 'FRootMotionSourceGroup::bIsAdditiveVelocityApplied' has a wrong offset!");
static_assert(offsetof(FRootMotionSourceGroup, LastAccumulatedSettings) == 0x00008D, "Member 'FRootMotionSourceGroup::LastAccumulatedSettings' has a wrong offset!");

// ScriptStruct Engine.StatColorMapEntry
// 0x0008 (0x0008 - 0x0000)
struct FStatColorMapEntry final
{
public:
	float                                         In;                                                // 0x0000(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Out;                                               // 0x0004(0x0004)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatColorMapEntry) == 0x000004, "Wrong alignment on FStatColorMapEntry");
static_assert(sizeof(FStatColorMapEntry) == 0x000008, "Wrong size on FStatColorMapEntry");
static_assert(offsetof(FStatColorMapEntry, In) == 0x000000, "Member 'FStatColorMapEntry::In' has a wrong offset!");
static_assert(offsetof(FStatColorMapEntry, Out) == 0x000004, "Member 'FStatColorMapEntry::Out' has a wrong offset!");

// ScriptStruct Engine.StatColorMapping
// 0x001C (0x001C - 0x0000)
struct FStatColorMapping final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x000C)(ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FStatColorMapEntry>             ColorMap;                                          // 0x000C(0x000C)(ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	uint8                                         DisableBlend : 1;                                  // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, GlobalConfig, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatColorMapping) == 0x000004, "Wrong alignment on FStatColorMapping");
static_assert(sizeof(FStatColorMapping) == 0x00001C, "Wrong size on FStatColorMapping");
static_assert(offsetof(FStatColorMapping, StatName) == 0x000000, "Member 'FStatColorMapping::StatName' has a wrong offset!");
static_assert(offsetof(FStatColorMapping, ColorMap) == 0x00000C, "Member 'FStatColorMapping::ColorMap' has a wrong offset!");

// ScriptStruct Engine.RootMotionExtractionStep
// 0x000C (0x000C - 0x0000)
struct FRootMotionExtractionStep final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPosition;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionExtractionStep) == 0x000004, "Wrong alignment on FRootMotionExtractionStep");
static_assert(sizeof(FRootMotionExtractionStep) == 0x00000C, "Wrong size on FRootMotionExtractionStep");
static_assert(offsetof(FRootMotionExtractionStep, AnimSequence) == 0x000000, "Member 'FRootMotionExtractionStep::AnimSequence' has a wrong offset!");
static_assert(offsetof(FRootMotionExtractionStep, StartPosition) == 0x000004, "Member 'FRootMotionExtractionStep::StartPosition' has a wrong offset!");
static_assert(offsetof(FRootMotionExtractionStep, EndPosition) == 0x000008, "Member 'FRootMotionExtractionStep::EndPosition' has a wrong offset!");

// ScriptStruct Engine.CurveEdTab
// 0x0028 (0x0028 - 0x0000)
struct FCurveEdTab final
{
public:
	class FString                                 TabName;                                           // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCurveEdEntry>                  Curves;                                            // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ViewStartInput;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewEndInput;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewStartOutput;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewEndOutput;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveEdTab) == 0x000004, "Wrong alignment on FCurveEdTab");
static_assert(sizeof(FCurveEdTab) == 0x000028, "Wrong size on FCurveEdTab");
static_assert(offsetof(FCurveEdTab, TabName) == 0x000000, "Member 'FCurveEdTab::TabName' has a wrong offset!");
static_assert(offsetof(FCurveEdTab, Curves) == 0x00000C, "Member 'FCurveEdTab::Curves' has a wrong offset!");
static_assert(offsetof(FCurveEdTab, ViewStartInput) == 0x000018, "Member 'FCurveEdTab::ViewStartInput' has a wrong offset!");
static_assert(offsetof(FCurveEdTab, ViewEndInput) == 0x00001C, "Member 'FCurveEdTab::ViewEndInput' has a wrong offset!");
static_assert(offsetof(FCurveEdTab, ViewStartOutput) == 0x000020, "Member 'FCurveEdTab::ViewStartOutput' has a wrong offset!");
static_assert(offsetof(FCurveEdTab, ViewEndOutput) == 0x000024, "Member 'FCurveEdTab::ViewEndOutput' has a wrong offset!");

// ScriptStruct Engine.VehicleInputRate
// 0x0008 (0x0008 - 0x0000)
struct FVehicleInputRate final
{
public:
	float                                         RiseRate;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallRate;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleInputRate) == 0x000004, "Wrong alignment on FVehicleInputRate");
static_assert(sizeof(FVehicleInputRate) == 0x000008, "Wrong size on FVehicleInputRate");
static_assert(offsetof(FVehicleInputRate, RiseRate) == 0x000000, "Member 'FVehicleInputRate::RiseRate' has a wrong offset!");
static_assert(offsetof(FVehicleInputRate, FallRate) == 0x000004, "Member 'FVehicleInputRate::FallRate' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_MoveToForce
// 0x0020 (0x00A0 - 0x0080)
struct FRootMotionSource_MoveToForce final : public FRootMotionSource
{
public:
	struct FVector                                StartLocation;                                     // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRestrictSpeedToExpected;                          // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMotionSource_MoveToForce) == 0x000010, "Wrong alignment on FRootMotionSource_MoveToForce");
static_assert(sizeof(FRootMotionSource_MoveToForce) == 0x0000A0, "Wrong size on FRootMotionSource_MoveToForce");
static_assert(offsetof(FRootMotionSource_MoveToForce, StartLocation) == 0x000080, "Member 'FRootMotionSource_MoveToForce::StartLocation' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_MoveToForce, TargetLocation) == 0x00008C, "Member 'FRootMotionSource_MoveToForce::TargetLocation' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_MoveToForce, bRestrictSpeedToExpected) == 0x000098, "Member 'FRootMotionSource_MoveToForce::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_MoveToForce, PathOffsetCurve) == 0x00009C, "Member 'FRootMotionSource_MoveToForce::PathOffsetCurve' has a wrong offset!");

// ScriptStruct Engine.RootMotionSource_RadialForce
// 0x0030 (0x00B0 - 0x0080)
struct FRootMotionSource_RadialForce final : public FRootMotionSource
{
public:
	struct FVector                                Location;                                          // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 LocationActor;                                     // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPush;                                           // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNoZForce;                                         // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthDistanceFalloff;                           // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionSource_RadialForce) == 0x000010, "Wrong alignment on FRootMotionSource_RadialForce");
static_assert(sizeof(FRootMotionSource_RadialForce) == 0x0000B0, "Wrong size on FRootMotionSource_RadialForce");
static_assert(offsetof(FRootMotionSource_RadialForce, Location) == 0x000080, "Member 'FRootMotionSource_RadialForce::Location' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, LocationActor) == 0x00008C, "Member 'FRootMotionSource_RadialForce::LocationActor' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, Radius) == 0x000090, "Member 'FRootMotionSource_RadialForce::Radius' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, Strength) == 0x000094, "Member 'FRootMotionSource_RadialForce::Strength' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, bIsPush) == 0x000098, "Member 'FRootMotionSource_RadialForce::bIsPush' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, bNoZForce) == 0x000099, "Member 'FRootMotionSource_RadialForce::bNoZForce' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, StrengthDistanceFalloff) == 0x00009C, "Member 'FRootMotionSource_RadialForce::StrengthDistanceFalloff' has a wrong offset!");
static_assert(offsetof(FRootMotionSource_RadialForce, StrengthOverTime) == 0x0000A0, "Member 'FRootMotionSource_RadialForce::StrengthOverTime' has a wrong offset!");

// ScriptStruct Engine.BasedMovementInfo
// 0x0028 (0x0028 - 0x0000)
struct FBasedMovementInfo final
{
public:
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0000(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Location;                                          // 0x000C(0x000C)(NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bServerHasBaseComponent;                           // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bServerHasVelocity;                                // 0x0026(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBasedMovementInfo) == 0x000004, "Wrong alignment on FBasedMovementInfo");
static_assert(sizeof(FBasedMovementInfo) == 0x000028, "Wrong size on FBasedMovementInfo");
static_assert(offsetof(FBasedMovementInfo, MovementBase) == 0x000000, "Member 'FBasedMovementInfo::MovementBase' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, BoneName) == 0x000004, "Member 'FBasedMovementInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, Location) == 0x00000C, "Member 'FBasedMovementInfo::Location' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, Rotation) == 0x000018, "Member 'FBasedMovementInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, bServerHasBaseComponent) == 0x000024, "Member 'FBasedMovementInfo::bServerHasBaseComponent' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, bRelativeRotation) == 0x000025, "Member 'FBasedMovementInfo::bRelativeRotation' has a wrong offset!");
static_assert(offsetof(FBasedMovementInfo, bServerHasVelocity) == 0x000026, "Member 'FBasedMovementInfo::bServerHasVelocity' has a wrong offset!");

// ScriptStruct Engine.RepRootMotionMontage
// 0x00DC (0x00DC - 0x0000)
struct FRepRootMotionMontage final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Location;                                          // 0x000C(0x000C)(NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0024(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovementBaseBoneName;                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativePosition;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRelativeRotation;                                 // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionSourceGroup                 AuthoritativeRootMotion;                           // 0x0034(0x0090)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Acceleration;                                      // 0x00C4(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  LinearVelocity;                                    // 0x00D0(0x000C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepRootMotionMontage) == 0x000004, "Wrong alignment on FRepRootMotionMontage");
static_assert(sizeof(FRepRootMotionMontage) == 0x0000DC, "Wrong size on FRepRootMotionMontage");
static_assert(offsetof(FRepRootMotionMontage, bIsActive) == 0x000000, "Member 'FRepRootMotionMontage::bIsActive' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, AnimMontage) == 0x000004, "Member 'FRepRootMotionMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, Position) == 0x000008, "Member 'FRepRootMotionMontage::Position' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, Location) == 0x00000C, "Member 'FRepRootMotionMontage::Location' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, Rotation) == 0x000018, "Member 'FRepRootMotionMontage::Rotation' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, MovementBase) == 0x000024, "Member 'FRepRootMotionMontage::MovementBase' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, MovementBaseBoneName) == 0x000028, "Member 'FRepRootMotionMontage::MovementBaseBoneName' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, bRelativePosition) == 0x000030, "Member 'FRepRootMotionMontage::bRelativePosition' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, bRelativeRotation) == 0x000031, "Member 'FRepRootMotionMontage::bRelativeRotation' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, AuthoritativeRootMotion) == 0x000034, "Member 'FRepRootMotionMontage::AuthoritativeRootMotion' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, Acceleration) == 0x0000C4, "Member 'FRepRootMotionMontage::Acceleration' has a wrong offset!");
static_assert(offsetof(FRepRootMotionMontage, LinearVelocity) == 0x0000D0, "Member 'FRepRootMotionMontage::LinearVelocity' has a wrong offset!");

// ScriptStruct Engine.SimulatedRootMotionReplicatedMove
// 0x00E0 (0x00E0 - 0x0000)
struct FSimulatedRootMotionReplicatedMove final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRepRootMotionMontage                  RootMotion;                                        // 0x0004(0x00DC)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimulatedRootMotionReplicatedMove) == 0x000004, "Wrong alignment on FSimulatedRootMotionReplicatedMove");
static_assert(sizeof(FSimulatedRootMotionReplicatedMove) == 0x0000E0, "Wrong size on FSimulatedRootMotionReplicatedMove");
static_assert(offsetof(FSimulatedRootMotionReplicatedMove, Time) == 0x000000, "Member 'FSimulatedRootMotionReplicatedMove::Time' has a wrong offset!");
static_assert(offsetof(FSimulatedRootMotionReplicatedMove, RootMotion) == 0x000004, "Member 'FSimulatedRootMotionReplicatedMove::RootMotion' has a wrong offset!");

// ScriptStruct Engine.AnimationTransitionRule
// 0x0010 (0x0010 - 0x0000)
struct FAnimationTransitionRule final
{
public:
	class FName                                   RuleToExecute;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TransitionReturnVal;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TransitionIndex;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationTransitionRule) == 0x000004, "Wrong alignment on FAnimationTransitionRule");
static_assert(sizeof(FAnimationTransitionRule) == 0x000010, "Wrong size on FAnimationTransitionRule");
static_assert(offsetof(FAnimationTransitionRule, RuleToExecute) == 0x000000, "Member 'FAnimationTransitionRule::RuleToExecute' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionRule, TransitionReturnVal) == 0x000008, "Member 'FAnimationTransitionRule::TransitionReturnVal' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionRule, TransitionIndex) == 0x00000C, "Member 'FAnimationTransitionRule::TransitionIndex' has a wrong offset!");

// ScriptStruct Engine.SpriteCategoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FSpriteCategoryInfo final
{
public:
	class FName                                   Category;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x000C)(NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0014(0x000C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpriteCategoryInfo) == 0x000004, "Wrong alignment on FSpriteCategoryInfo");
static_assert(sizeof(FSpriteCategoryInfo) == 0x000020, "Wrong size on FSpriteCategoryInfo");
static_assert(offsetof(FSpriteCategoryInfo, Category) == 0x000000, "Member 'FSpriteCategoryInfo::Category' has a wrong offset!");
static_assert(offsetof(FSpriteCategoryInfo, DisplayName) == 0x000008, "Member 'FSpriteCategoryInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FSpriteCategoryInfo, Description) == 0x000014, "Member 'FSpriteCategoryInfo::Description' has a wrong offset!");

// ScriptStruct Engine.SkelMeshComponentLODInfo
// 0x000C (0x000C - 0x0000)
struct FSkelMeshComponentLODInfo final
{
public:
	TArray<bool>                                  HiddenMaterials;                                   // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkelMeshComponentLODInfo) == 0x000004, "Wrong alignment on FSkelMeshComponentLODInfo");
static_assert(sizeof(FSkelMeshComponentLODInfo) == 0x00000C, "Wrong size on FSkelMeshComponentLODInfo");
static_assert(offsetof(FSkelMeshComponentLODInfo, HiddenMaterials) == 0x000000, "Member 'FSkelMeshComponentLODInfo::HiddenMaterials' has a wrong offset!");

// ScriptStruct Engine.ConvexElement2D
// 0x000C (0x000C - 0x0000)
struct FConvexElement2D final
{
public:
	TArray<struct FVector2D>                      VertexData;                                        // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConvexElement2D) == 0x000004, "Wrong alignment on FConvexElement2D");
static_assert(sizeof(FConvexElement2D) == 0x00000C, "Wrong size on FConvexElement2D");
static_assert(offsetof(FConvexElement2D, VertexData) == 0x000000, "Member 'FConvexElement2D::VertexData' has a wrong offset!");

// ScriptStruct Engine.TimelineVectorTrack
// 0x0028 (0x0028 - 0x0000)
struct FTimelineVectorTrack final
{
public:
	class UCurveVector*                           VectorCurve;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector& Output)> InterpFunc;                                        // 0x0004(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   VectorPropertyName;                                // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStructProperty*                        VectorProperty;                                    // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineVectorTrack) == 0x000004, "Wrong alignment on FTimelineVectorTrack");
static_assert(sizeof(FTimelineVectorTrack) == 0x000028, "Wrong size on FTimelineVectorTrack");
static_assert(offsetof(FTimelineVectorTrack, VectorCurve) == 0x000000, "Member 'FTimelineVectorTrack::VectorCurve' has a wrong offset!");
static_assert(offsetof(FTimelineVectorTrack, InterpFunc) == 0x000004, "Member 'FTimelineVectorTrack::InterpFunc' has a wrong offset!");
static_assert(offsetof(FTimelineVectorTrack, VectorPropertyName) == 0x000014, "Member 'FTimelineVectorTrack::VectorPropertyName' has a wrong offset!");
static_assert(offsetof(FTimelineVectorTrack, VectorProperty) == 0x00001C, "Member 'FTimelineVectorTrack::VectorProperty' has a wrong offset!");

// ScriptStruct Engine.ActiveVertexAnim
// 0x000C (0x000C - 0x0000)
struct FActiveVertexAnim final
{
public:
	class UVertexAnimBase*                        VertAnim;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveVertexAnim) == 0x000004, "Wrong alignment on FActiveVertexAnim");
static_assert(sizeof(FActiveVertexAnim) == 0x00000C, "Wrong size on FActiveVertexAnim");
static_assert(offsetof(FActiveVertexAnim, VertAnim) == 0x000000, "Member 'FActiveVertexAnim::VertAnim' has a wrong offset!");
static_assert(offsetof(FActiveVertexAnim, Weight) == 0x000004, "Member 'FActiveVertexAnim::Weight' has a wrong offset!");
static_assert(offsetof(FActiveVertexAnim, Time) == 0x000008, "Member 'FActiveVertexAnim::Time' has a wrong offset!");

// ScriptStruct Engine.VehicleEngineData
// 0x006C (0x006C - 0x0000)
struct FVehicleEngineData final
{
public:
	struct FRuntimeFloatCurve                     TorqueCurve;                                       // 0x0000(0x0058)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxRPM;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MOI;                                               // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRateFullThrottle;                           // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRateZeroThrottleClutchEngaged;              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DampingRateZeroThrottleClutchDisengaged;           // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleEngineData) == 0x000004, "Wrong alignment on FVehicleEngineData");
static_assert(sizeof(FVehicleEngineData) == 0x00006C, "Wrong size on FVehicleEngineData");
static_assert(offsetof(FVehicleEngineData, TorqueCurve) == 0x000000, "Member 'FVehicleEngineData::TorqueCurve' has a wrong offset!");
static_assert(offsetof(FVehicleEngineData, MaxRPM) == 0x000058, "Member 'FVehicleEngineData::MaxRPM' has a wrong offset!");
static_assert(offsetof(FVehicleEngineData, MOI) == 0x00005C, "Member 'FVehicleEngineData::MOI' has a wrong offset!");
static_assert(offsetof(FVehicleEngineData, DampingRateFullThrottle) == 0x000060, "Member 'FVehicleEngineData::DampingRateFullThrottle' has a wrong offset!");
static_assert(offsetof(FVehicleEngineData, DampingRateZeroThrottleClutchEngaged) == 0x000064, "Member 'FVehicleEngineData::DampingRateZeroThrottleClutchEngaged' has a wrong offset!");
static_assert(offsetof(FVehicleEngineData, DampingRateZeroThrottleClutchDisengaged) == 0x000068, "Member 'FVehicleEngineData::DampingRateZeroThrottleClutchDisengaged' has a wrong offset!");

// ScriptStruct Engine.ConstraintInstance
// 0x0150 (0x0150 - 0x0000)
struct FConstraintInstance final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        OwnerComponent;                                    // 0x0004(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   JointName;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBone1;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBone2;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos1;                                              // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PriAxis1;                                          // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SecAxis1;                                          // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Pos2;                                              // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PriAxis2;                                          // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SecAxis2;                                          // 0x0064(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bDisableCollision : 1;                             // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableProjection : 1;                             // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectionLinearTolerance;                         // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectionAngularTolerance;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       LinearXMotion;                                     // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       LinearYMotion;                                     // 0x007D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinearConstraintMotion                       LinearZMotion;                                     // 0x007E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearLimitSize;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLinearLimitSoft : 1;                              // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearLimitStiffness;                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearLimitDamping;                                // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLinearBreakable : 1;                              // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearBreakThreshold;                              // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      AngularSwing1Motion;                               // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      AngularTwistMotion;                                // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngularConstraintMotion                      AngularSwing2Motion;                               // 0x009A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSwingLimitSoft : 1;                               // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bTwistLimitSoft : 1;                               // 0x009C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Swing1LimitAngle;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistLimitAngle;                                   // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing2LimitAngle;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingLimitStiffness;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingLimitDamping;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistLimitStiffness;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistLimitDamping;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AngularRotationOffset;                             // 0x00BC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bAngularBreakable : 1;                             // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularBreakThreshold;                             // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLinearXPositionDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearXVelocityDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearYPositionDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearYVelocityDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearZPositionDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearZVelocityDrive : 1;                         // 0x00D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bLinearPositionDrive : 1;                          // 0x00D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLinearVelocityDrive : 1;                          // 0x00D0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinearPositionTarget;                              // 0x00D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocityTarget;                              // 0x00E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LinearDriveSpring;                                 // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDriveDamping;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDriveForceLimit;                             // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSwingPositionDrive : 1;                           // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSwingVelocityDrive : 1;                           // 0x00F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTwistPositionDrive : 1;                           // 0x00F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTwistVelocityDrive : 1;                           // 0x00F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAngularSlerpDrive : 1;                            // 0x00F8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Deprecated, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAngularOrientationDrive : 1;                      // 0x00F8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableSwingDrive : 1;                             // 0x00F8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bEnableTwistDrive : 1;                             // 0x00F8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bAngularVelocityDrive : 1;                         // 0x00F9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  AngularPositionTarget;                             // 0x0100(0x0010)(Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAngularDriveMode                             AngularDriveMode;                                  // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AngularOrientationTarget;                          // 0x0114(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocityTarget;                             // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AngularDriveSpring;                                // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDriveDamping;                               // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDriveForceLimit;                            // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintInstance) == 0x000010, "Wrong alignment on FConstraintInstance");
static_assert(sizeof(FConstraintInstance) == 0x000150, "Wrong size on FConstraintInstance");
static_assert(offsetof(FConstraintInstance, OwnerComponent) == 0x000004, "Member 'FConstraintInstance::OwnerComponent' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, JointName) == 0x000010, "Member 'FConstraintInstance::JointName' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, ConstraintBone1) == 0x000018, "Member 'FConstraintInstance::ConstraintBone1' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, ConstraintBone2) == 0x000020, "Member 'FConstraintInstance::ConstraintBone2' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, Pos1) == 0x000028, "Member 'FConstraintInstance::Pos1' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, PriAxis1) == 0x000034, "Member 'FConstraintInstance::PriAxis1' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, SecAxis1) == 0x000040, "Member 'FConstraintInstance::SecAxis1' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, Pos2) == 0x00004C, "Member 'FConstraintInstance::Pos2' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, PriAxis2) == 0x000058, "Member 'FConstraintInstance::PriAxis2' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, SecAxis2) == 0x000064, "Member 'FConstraintInstance::SecAxis2' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, ProjectionLinearTolerance) == 0x000074, "Member 'FConstraintInstance::ProjectionLinearTolerance' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, ProjectionAngularTolerance) == 0x000078, "Member 'FConstraintInstance::ProjectionAngularTolerance' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearXMotion) == 0x00007C, "Member 'FConstraintInstance::LinearXMotion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearYMotion) == 0x00007D, "Member 'FConstraintInstance::LinearYMotion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearZMotion) == 0x00007E, "Member 'FConstraintInstance::LinearZMotion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearLimitSize) == 0x000080, "Member 'FConstraintInstance::LinearLimitSize' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearLimitStiffness) == 0x000088, "Member 'FConstraintInstance::LinearLimitStiffness' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearLimitDamping) == 0x00008C, "Member 'FConstraintInstance::LinearLimitDamping' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearBreakThreshold) == 0x000094, "Member 'FConstraintInstance::LinearBreakThreshold' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularSwing1Motion) == 0x000098, "Member 'FConstraintInstance::AngularSwing1Motion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularTwistMotion) == 0x000099, "Member 'FConstraintInstance::AngularTwistMotion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularSwing2Motion) == 0x00009A, "Member 'FConstraintInstance::AngularSwing2Motion' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, Swing1LimitAngle) == 0x0000A0, "Member 'FConstraintInstance::Swing1LimitAngle' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, TwistLimitAngle) == 0x0000A4, "Member 'FConstraintInstance::TwistLimitAngle' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, Swing2LimitAngle) == 0x0000A8, "Member 'FConstraintInstance::Swing2LimitAngle' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, SwingLimitStiffness) == 0x0000AC, "Member 'FConstraintInstance::SwingLimitStiffness' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, SwingLimitDamping) == 0x0000B0, "Member 'FConstraintInstance::SwingLimitDamping' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, TwistLimitStiffness) == 0x0000B4, "Member 'FConstraintInstance::TwistLimitStiffness' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, TwistLimitDamping) == 0x0000B8, "Member 'FConstraintInstance::TwistLimitDamping' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularRotationOffset) == 0x0000BC, "Member 'FConstraintInstance::AngularRotationOffset' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularBreakThreshold) == 0x0000CC, "Member 'FConstraintInstance::AngularBreakThreshold' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearPositionTarget) == 0x0000D4, "Member 'FConstraintInstance::LinearPositionTarget' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearVelocityTarget) == 0x0000E0, "Member 'FConstraintInstance::LinearVelocityTarget' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearDriveSpring) == 0x0000EC, "Member 'FConstraintInstance::LinearDriveSpring' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearDriveDamping) == 0x0000F0, "Member 'FConstraintInstance::LinearDriveDamping' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, LinearDriveForceLimit) == 0x0000F4, "Member 'FConstraintInstance::LinearDriveForceLimit' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularPositionTarget) == 0x000100, "Member 'FConstraintInstance::AngularPositionTarget' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularDriveMode) == 0x000110, "Member 'FConstraintInstance::AngularDriveMode' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularOrientationTarget) == 0x000114, "Member 'FConstraintInstance::AngularOrientationTarget' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularVelocityTarget) == 0x000120, "Member 'FConstraintInstance::AngularVelocityTarget' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularDriveSpring) == 0x00012C, "Member 'FConstraintInstance::AngularDriveSpring' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularDriveDamping) == 0x000130, "Member 'FConstraintInstance::AngularDriveDamping' has a wrong offset!");
static_assert(offsetof(FConstraintInstance, AngularDriveForceLimit) == 0x000134, "Member 'FConstraintInstance::AngularDriveForceLimit' has a wrong offset!");

// ScriptStruct Engine.AnimLinkableElement
// 0x0024 (0x0024 - 0x0000)
struct FAnimLinkableElement
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           LinkedMontage;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SegmentIndex;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimLinkMethod                               LinkMethod;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimLinkMethod                               CachedLinkMethod;                                  // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentBeginTime;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SegmentLength;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LinkValue;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      LinkedSequence;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAnimLinkableElement) == 0x000004, "Wrong alignment on FAnimLinkableElement");
static_assert(sizeof(FAnimLinkableElement) == 0x000024, "Wrong size on FAnimLinkableElement");
static_assert(offsetof(FAnimLinkableElement, LinkedMontage) == 0x000004, "Member 'FAnimLinkableElement::LinkedMontage' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, SlotIndex) == 0x000008, "Member 'FAnimLinkableElement::SlotIndex' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, SegmentIndex) == 0x00000C, "Member 'FAnimLinkableElement::SegmentIndex' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, LinkMethod) == 0x000010, "Member 'FAnimLinkableElement::LinkMethod' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, CachedLinkMethod) == 0x000011, "Member 'FAnimLinkableElement::CachedLinkMethod' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, SegmentBeginTime) == 0x000014, "Member 'FAnimLinkableElement::SegmentBeginTime' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, SegmentLength) == 0x000018, "Member 'FAnimLinkableElement::SegmentLength' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, LinkValue) == 0x00001C, "Member 'FAnimLinkableElement::LinkValue' has a wrong offset!");
static_assert(offsetof(FAnimLinkableElement, LinkedSequence) == 0x000020, "Member 'FAnimLinkableElement::LinkedSequence' has a wrong offset!");

// ScriptStruct Engine.AnimControlTrackKey
// 0x0018 (0x0018 - 0x0000)
struct FAnimControlTrackKey final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSeq;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimStartOffset;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimEndOffset;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPlayRate;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLooping : 1;                                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bReverse : 1;                                      // 0x0014(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimControlTrackKey) == 0x000004, "Wrong alignment on FAnimControlTrackKey");
static_assert(sizeof(FAnimControlTrackKey) == 0x000018, "Wrong size on FAnimControlTrackKey");
static_assert(offsetof(FAnimControlTrackKey, StartTime) == 0x000000, "Member 'FAnimControlTrackKey::StartTime' has a wrong offset!");
static_assert(offsetof(FAnimControlTrackKey, AnimSeq) == 0x000004, "Member 'FAnimControlTrackKey::AnimSeq' has a wrong offset!");
static_assert(offsetof(FAnimControlTrackKey, AnimStartOffset) == 0x000008, "Member 'FAnimControlTrackKey::AnimStartOffset' has a wrong offset!");
static_assert(offsetof(FAnimControlTrackKey, AnimEndOffset) == 0x00000C, "Member 'FAnimControlTrackKey::AnimEndOffset' has a wrong offset!");
static_assert(offsetof(FAnimControlTrackKey, AnimPlayRate) == 0x000010, "Member 'FAnimControlTrackKey::AnimPlayRate' has a wrong offset!");

// ScriptStruct Engine.AnimSyncMarker
// 0x000C (0x000C - 0x0000)
struct FAnimSyncMarker final
{
public:
	class FName                                   MarkerName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSyncMarker) == 0x000004, "Wrong alignment on FAnimSyncMarker");
static_assert(sizeof(FAnimSyncMarker) == 0x00000C, "Wrong size on FAnimSyncMarker");
static_assert(offsetof(FAnimSyncMarker, MarkerName) == 0x000000, "Member 'FAnimSyncMarker::MarkerName' has a wrong offset!");
static_assert(offsetof(FAnimSyncMarker, Time) == 0x000008, "Member 'FAnimSyncMarker::Time' has a wrong offset!");

// ScriptStruct Engine.MarkerSyncData
// 0x0018 (0x0018 - 0x0000)
struct FMarkerSyncData final
{
public:
	TArray<struct FAnimSyncMarker>                AuthoredSyncMarkers;                               // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarkerSyncData) == 0x000004, "Wrong alignment on FMarkerSyncData");
static_assert(sizeof(FMarkerSyncData) == 0x000018, "Wrong size on FMarkerSyncData");
static_assert(offsetof(FMarkerSyncData, AuthoredSyncMarkers) == 0x000000, "Member 'FMarkerSyncData::AuthoredSyncMarkers' has a wrong offset!");

// ScriptStruct Engine.AssetImportInfo
// 0x0001 (0x0001 - 0x0000)
struct FAssetImportInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetImportInfo) == 0x000001, "Wrong alignment on FAssetImportInfo");
static_assert(sizeof(FAssetImportInfo) == 0x000001, "Wrong size on FAssetImportInfo");

// ScriptStruct Engine.AnimNotifyEvent
// 0x0060 (0x0084 - 0x0024)
struct FAnimNotifyEvent final : public FAnimLinkableElement
{
public:
	float                                         DisplayTime;                                       // 0x0024(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTimeOffset;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTriggerTimeOffset;                              // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerWeightThreshold;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyName;                                        // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotify*                            Notify;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimNotifyState*                       NotifyStateClass;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimLinkableElement                   EndLink;                                           // 0x0048(0x0024)(NativeAccessSpecifierPublic)
	bool                                          bConvertedFromBranchingPoint;                      // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EMontageNotifyTickType                        MontageTickType;                                   // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotifyTriggerChance;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyFilterType                             NotifyFilterType;                                  // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NotifyFilterLOD;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnDedicatedServer;                         // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrackIndex;                                        // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNotifyEvent) == 0x000004, "Wrong alignment on FAnimNotifyEvent");
static_assert(sizeof(FAnimNotifyEvent) == 0x000084, "Wrong size on FAnimNotifyEvent");
static_assert(offsetof(FAnimNotifyEvent, DisplayTime) == 0x000024, "Member 'FAnimNotifyEvent::DisplayTime' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, TriggerTimeOffset) == 0x000028, "Member 'FAnimNotifyEvent::TriggerTimeOffset' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, EndTriggerTimeOffset) == 0x00002C, "Member 'FAnimNotifyEvent::EndTriggerTimeOffset' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, TriggerWeightThreshold) == 0x000030, "Member 'FAnimNotifyEvent::TriggerWeightThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, NotifyName) == 0x000034, "Member 'FAnimNotifyEvent::NotifyName' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, Notify) == 0x00003C, "Member 'FAnimNotifyEvent::Notify' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, NotifyStateClass) == 0x000040, "Member 'FAnimNotifyEvent::NotifyStateClass' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, Duration) == 0x000044, "Member 'FAnimNotifyEvent::Duration' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, EndLink) == 0x000048, "Member 'FAnimNotifyEvent::EndLink' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, bConvertedFromBranchingPoint) == 0x00006C, "Member 'FAnimNotifyEvent::bConvertedFromBranchingPoint' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, MontageTickType) == 0x00006D, "Member 'FAnimNotifyEvent::MontageTickType' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, NotifyTriggerChance) == 0x000070, "Member 'FAnimNotifyEvent::NotifyTriggerChance' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, NotifyFilterType) == 0x000074, "Member 'FAnimNotifyEvent::NotifyFilterType' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, NotifyFilterLOD) == 0x000078, "Member 'FAnimNotifyEvent::NotifyFilterLOD' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, bTriggerOnDedicatedServer) == 0x00007C, "Member 'FAnimNotifyEvent::bTriggerOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(FAnimNotifyEvent, TrackIndex) == 0x000080, "Member 'FAnimNotifyEvent::TrackIndex' has a wrong offset!");

// ScriptStruct Engine.BranchingPointMarker
// 0x000C (0x000C - 0x0000)
struct FBranchingPointMarker final
{
public:
	int32                                         NotifyIndex;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTime;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimNotifyEventType                          NotifyEventType;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBranchingPointMarker) == 0x000004, "Wrong alignment on FBranchingPointMarker");
static_assert(sizeof(FBranchingPointMarker) == 0x00000C, "Wrong size on FBranchingPointMarker");
static_assert(offsetof(FBranchingPointMarker, NotifyIndex) == 0x000000, "Member 'FBranchingPointMarker::NotifyIndex' has a wrong offset!");
static_assert(offsetof(FBranchingPointMarker, TriggerTime) == 0x000004, "Member 'FBranchingPointMarker::TriggerTime' has a wrong offset!");
static_assert(offsetof(FBranchingPointMarker, NotifyEventType) == 0x000008, "Member 'FBranchingPointMarker::NotifyEventType' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshComponentClothTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FSkeletalMeshComponentClothTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMeshComponentClothTickFunction) == 0x000004, "Wrong alignment on FSkeletalMeshComponentClothTickFunction");
static_assert(sizeof(FSkeletalMeshComponentClothTickFunction) == 0x000038, "Wrong size on FSkeletalMeshComponentClothTickFunction");

// ScriptStruct Engine.InputAxisKeyMapping
// 0x001C (0x001C - 0x0000)
struct FInputAxisKeyMapping final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputAxisKeyMapping) == 0x000004, "Wrong alignment on FInputAxisKeyMapping");
static_assert(sizeof(FInputAxisKeyMapping) == 0x00001C, "Wrong size on FInputAxisKeyMapping");
static_assert(offsetof(FInputAxisKeyMapping, AxisName) == 0x000000, "Member 'FInputAxisKeyMapping::AxisName' has a wrong offset!");
static_assert(offsetof(FInputAxisKeyMapping, Key) == 0x000008, "Member 'FInputAxisKeyMapping::Key' has a wrong offset!");
static_assert(offsetof(FInputAxisKeyMapping, Scale) == 0x000018, "Member 'FInputAxisKeyMapping::Scale' has a wrong offset!");

// ScriptStruct Engine.SkeletalMeshComponentPostPhysicsTickFunction
// 0x0004 (0x0038 - 0x0034)
struct FSkeletalMeshComponentPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkeletalMeshComponentPostPhysicsTickFunction) == 0x000004, "Wrong alignment on FSkeletalMeshComponentPostPhysicsTickFunction");
static_assert(sizeof(FSkeletalMeshComponentPostPhysicsTickFunction) == 0x000038, "Wrong size on FSkeletalMeshComponentPostPhysicsTickFunction");

// ScriptStruct Engine.NavAvoidanceMask
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FNavAvoidanceMask final
{
public:
	uint8                                         bGroup0 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup1 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup2 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup3 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup4 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup5 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup6 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup7 : 1;                                       // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup8 : 1;                                       // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup9 : 1;                                       // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup10 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup11 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup12 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup13 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup14 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup15 : 1;                                      // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup16 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup17 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup18 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup19 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup20 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup21 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup22 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup23 : 1;                                      // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup24 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup25 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup26 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup27 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup28 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup29 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup30 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGroup31 : 1;                                      // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
};
static_assert(alignof(FNavAvoidanceMask) == 0x000004, "Wrong alignment on FNavAvoidanceMask");
static_assert(sizeof(FNavAvoidanceMask) == 0x000004, "Wrong size on FNavAvoidanceMask");

// ScriptStruct Engine.FindFloorResult
// 0x008C (0x008C - 0x0000)
struct FFindFloorResult final
{
public:
	uint8                                         bBlockingHit : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bWalkableFloor : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLineTrace : 1;                                    // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloorDist;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDist;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x000C(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFindFloorResult) == 0x000004, "Wrong alignment on FFindFloorResult");
static_assert(sizeof(FFindFloorResult) == 0x00008C, "Wrong size on FFindFloorResult");
static_assert(offsetof(FFindFloorResult, FloorDist) == 0x000004, "Member 'FFindFloorResult::FloorDist' has a wrong offset!");
static_assert(offsetof(FFindFloorResult, LineDist) == 0x000008, "Member 'FFindFloorResult::LineDist' has a wrong offset!");
static_assert(offsetof(FFindFloorResult, HitResult) == 0x00000C, "Member 'FFindFloorResult::HitResult' has a wrong offset!");

// ScriptStruct Engine.ReplicatedVehicleState
// 0x0014 (0x0014 - 0x0000)
struct FReplicatedVehicleState final
{
public:
	float                                         SteeringInput;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInput;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeInput;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandbrakeInput;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentGear;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedVehicleState) == 0x000004, "Wrong alignment on FReplicatedVehicleState");
static_assert(sizeof(FReplicatedVehicleState) == 0x000014, "Wrong size on FReplicatedVehicleState");
static_assert(offsetof(FReplicatedVehicleState, SteeringInput) == 0x000000, "Member 'FReplicatedVehicleState::SteeringInput' has a wrong offset!");
static_assert(offsetof(FReplicatedVehicleState, ThrottleInput) == 0x000004, "Member 'FReplicatedVehicleState::ThrottleInput' has a wrong offset!");
static_assert(offsetof(FReplicatedVehicleState, BrakeInput) == 0x000008, "Member 'FReplicatedVehicleState::BrakeInput' has a wrong offset!");
static_assert(offsetof(FReplicatedVehicleState, HandbrakeInput) == 0x00000C, "Member 'FReplicatedVehicleState::HandbrakeInput' has a wrong offset!");
static_assert(offsetof(FReplicatedVehicleState, CurrentGear) == 0x000010, "Member 'FReplicatedVehicleState::CurrentGear' has a wrong offset!");

// ScriptStruct Engine.WheelSetup
// 0x0018 (0x0018 - 0x0000)
struct FWheelSetup final
{
public:
	TSubclassOf<class UVehicleWheel>              WheelClass;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdditionalOffset;                                  // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWheelSetup) == 0x000004, "Wrong alignment on FWheelSetup");
static_assert(sizeof(FWheelSetup) == 0x000018, "Wrong size on FWheelSetup");
static_assert(offsetof(FWheelSetup, WheelClass) == 0x000000, "Member 'FWheelSetup::WheelClass' has a wrong offset!");
static_assert(offsetof(FWheelSetup, BoneName) == 0x000004, "Member 'FWheelSetup::BoneName' has a wrong offset!");
static_assert(offsetof(FWheelSetup, AdditionalOffset) == 0x00000C, "Member 'FWheelSetup::AdditionalOffset' has a wrong offset!");

// ScriptStruct Engine.VehicleGearData
// 0x000C (0x000C - 0x0000)
struct FVehicleGearData final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownRatio;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpRatio;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleGearData) == 0x000004, "Wrong alignment on FVehicleGearData");
static_assert(sizeof(FVehicleGearData) == 0x00000C, "Wrong size on FVehicleGearData");
static_assert(offsetof(FVehicleGearData, Ratio) == 0x000000, "Member 'FVehicleGearData::Ratio' has a wrong offset!");
static_assert(offsetof(FVehicleGearData, DownRatio) == 0x000004, "Member 'FVehicleGearData::DownRatio' has a wrong offset!");
static_assert(offsetof(FVehicleGearData, UpRatio) == 0x000008, "Member 'FVehicleGearData::UpRatio' has a wrong offset!");

// ScriptStruct Engine.VehicleTransmissionData
// 0x0028 (0x0028 - 0x0000)
struct FVehicleTransmissionData final
{
public:
	bool                                          bUseGearAutoBox;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GearSwitchTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GearAutoBoxLatency;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRatio;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVehicleGearData>               ForwardGears;                                      // 0x0010(0x000C)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         ReverseGearRatio;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeutralGearUpRatio;                                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClutchStrength;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleTransmissionData) == 0x000004, "Wrong alignment on FVehicleTransmissionData");
static_assert(sizeof(FVehicleTransmissionData) == 0x000028, "Wrong size on FVehicleTransmissionData");
static_assert(offsetof(FVehicleTransmissionData, bUseGearAutoBox) == 0x000000, "Member 'FVehicleTransmissionData::bUseGearAutoBox' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, GearSwitchTime) == 0x000004, "Member 'FVehicleTransmissionData::GearSwitchTime' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, GearAutoBoxLatency) == 0x000008, "Member 'FVehicleTransmissionData::GearAutoBoxLatency' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, FinalRatio) == 0x00000C, "Member 'FVehicleTransmissionData::FinalRatio' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, ForwardGears) == 0x000010, "Member 'FVehicleTransmissionData::ForwardGears' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, ReverseGearRatio) == 0x00001C, "Member 'FVehicleTransmissionData::ReverseGearRatio' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, NeutralGearUpRatio) == 0x000020, "Member 'FVehicleTransmissionData::NeutralGearUpRatio' has a wrong offset!");
static_assert(offsetof(FVehicleTransmissionData, ClutchStrength) == 0x000024, "Member 'FVehicleTransmissionData::ClutchStrength' has a wrong offset!");

// ScriptStruct Engine.AudioComponentParam
// 0x0018 (0x0018 - 0x0000)
struct FAudioComponentParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatParam;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolParam;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntParam;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             SoundWaveParam;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioComponentParam) == 0x000004, "Wrong alignment on FAudioComponentParam");
static_assert(sizeof(FAudioComponentParam) == 0x000018, "Wrong size on FAudioComponentParam");
static_assert(offsetof(FAudioComponentParam, ParamName) == 0x000000, "Member 'FAudioComponentParam::ParamName' has a wrong offset!");
static_assert(offsetof(FAudioComponentParam, FloatParam) == 0x000008, "Member 'FAudioComponentParam::FloatParam' has a wrong offset!");
static_assert(offsetof(FAudioComponentParam, BoolParam) == 0x00000C, "Member 'FAudioComponentParam::BoolParam' has a wrong offset!");
static_assert(offsetof(FAudioComponentParam, IntParam) == 0x000010, "Member 'FAudioComponentParam::IntParam' has a wrong offset!");
static_assert(offsetof(FAudioComponentParam, SoundWaveParam) == 0x000014, "Member 'FAudioComponentParam::SoundWaveParam' has a wrong offset!");

// ScriptStruct Engine.BatchedLine
// 0x0034 (0x0034 - 0x0000)
struct FBatchedLine final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingLifeTime;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBatchedLine) == 0x000004, "Wrong alignment on FBatchedLine");
static_assert(sizeof(FBatchedLine) == 0x000034, "Wrong size on FBatchedLine");
static_assert(offsetof(FBatchedLine, Start) == 0x000000, "Member 'FBatchedLine::Start' has a wrong offset!");
static_assert(offsetof(FBatchedLine, End) == 0x00000C, "Member 'FBatchedLine::End' has a wrong offset!");
static_assert(offsetof(FBatchedLine, Color) == 0x000018, "Member 'FBatchedLine::Color' has a wrong offset!");
static_assert(offsetof(FBatchedLine, Thickness) == 0x000028, "Member 'FBatchedLine::Thickness' has a wrong offset!");
static_assert(offsetof(FBatchedLine, RemainingLifeTime) == 0x00002C, "Member 'FBatchedLine::RemainingLifeTime' has a wrong offset!");
static_assert(offsetof(FBatchedLine, DepthPriority) == 0x000030, "Member 'FBatchedLine::DepthPriority' has a wrong offset!");

// ScriptStruct Engine.MaterialSpriteElement
// 0x0018 (0x0018 - 0x0000)
struct FMaterialSpriteElement final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceToOpacityCurve;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSizeIsInScreenSpace : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSizeX;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSizeY;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceToSizeCurve;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSpriteElement) == 0x000004, "Wrong alignment on FMaterialSpriteElement");
static_assert(sizeof(FMaterialSpriteElement) == 0x000018, "Wrong size on FMaterialSpriteElement");
static_assert(offsetof(FMaterialSpriteElement, Material) == 0x000000, "Member 'FMaterialSpriteElement::Material' has a wrong offset!");
static_assert(offsetof(FMaterialSpriteElement, DistanceToOpacityCurve) == 0x000004, "Member 'FMaterialSpriteElement::DistanceToOpacityCurve' has a wrong offset!");
static_assert(offsetof(FMaterialSpriteElement, BaseSizeX) == 0x00000C, "Member 'FMaterialSpriteElement::BaseSizeX' has a wrong offset!");
static_assert(offsetof(FMaterialSpriteElement, BaseSizeY) == 0x000010, "Member 'FMaterialSpriteElement::BaseSizeY' has a wrong offset!");
static_assert(offsetof(FMaterialSpriteElement, DistanceToSizeCurve) == 0x000014, "Member 'FMaterialSpriteElement::DistanceToSizeCurve' has a wrong offset!");

// ScriptStruct Engine.CollectionVectorParameter
// 0x0010 (0x0028 - 0x0018)
struct FCollectionVectorParameter final : public FCollectionParameterBase
{
public:
	struct FLinearColor                           DefaultValue;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionVectorParameter) == 0x000004, "Wrong alignment on FCollectionVectorParameter");
static_assert(sizeof(FCollectionVectorParameter) == 0x000028, "Wrong size on FCollectionVectorParameter");
static_assert(offsetof(FCollectionVectorParameter, DefaultValue) == 0x000018, "Member 'FCollectionVectorParameter::DefaultValue' has a wrong offset!");

// ScriptStruct Engine.StaticMeshComponentLODInfo
// 0x0058 (0x0058 - 0x0000)
struct FStaticMeshComponentLODInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPaintedVertex>                 PaintedVertices;                                   // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x44];                                      // 0x0014(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticMeshComponentLODInfo) == 0x000004, "Wrong alignment on FStaticMeshComponentLODInfo");
static_assert(sizeof(FStaticMeshComponentLODInfo) == 0x000058, "Wrong size on FStaticMeshComponentLODInfo");
static_assert(offsetof(FStaticMeshComponentLODInfo, PaintedVertices) == 0x000008, "Member 'FStaticMeshComponentLODInfo::PaintedVertices' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshMappingInfo
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FInstancedStaticMeshMappingInfo final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstancedStaticMeshMappingInfo) == 0x000004, "Wrong alignment on FInstancedStaticMeshMappingInfo");
static_assert(sizeof(FInstancedStaticMeshMappingInfo) == 0x000004, "Wrong size on FInstancedStaticMeshMappingInfo");

// ScriptStruct Engine.ComponentKey
// 0x001C (0x001C - 0x0000)
struct FComponentKey final
{
public:
	class UClass*                                 OwnerClass;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SCSVariableName;                                   // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  AssociatedGuid;                                    // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FComponentKey) == 0x000004, "Wrong alignment on FComponentKey");
static_assert(sizeof(FComponentKey) == 0x00001C, "Wrong size on FComponentKey");
static_assert(offsetof(FComponentKey, OwnerClass) == 0x000000, "Member 'FComponentKey::OwnerClass' has a wrong offset!");
static_assert(offsetof(FComponentKey, SCSVariableName) == 0x000004, "Member 'FComponentKey::SCSVariableName' has a wrong offset!");
static_assert(offsetof(FComponentKey, AssociatedGuid) == 0x00000C, "Member 'FComponentKey::AssociatedGuid' has a wrong offset!");

// ScriptStruct Engine.EditorImportExportTestDefinition
// 0x0028 (0x0028 - 0x0000)
struct FEditorImportExportTestDefinition final
{
public:
	struct FFilePath                              ImportFilePath;                                    // 0x0000(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 ExportFileExtension;                               // 0x000C(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipExport;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FImportFactorySettingValues>    FactorySettings;                                   // 0x001C(0x000C)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorImportExportTestDefinition) == 0x000004, "Wrong alignment on FEditorImportExportTestDefinition");
static_assert(sizeof(FEditorImportExportTestDefinition) == 0x000028, "Wrong size on FEditorImportExportTestDefinition");
static_assert(offsetof(FEditorImportExportTestDefinition, ImportFilePath) == 0x000000, "Member 'FEditorImportExportTestDefinition::ImportFilePath' has a wrong offset!");
static_assert(offsetof(FEditorImportExportTestDefinition, ExportFileExtension) == 0x00000C, "Member 'FEditorImportExportTestDefinition::ExportFileExtension' has a wrong offset!");
static_assert(offsetof(FEditorImportExportTestDefinition, bSkipExport) == 0x000018, "Member 'FEditorImportExportTestDefinition::bSkipExport' has a wrong offset!");
static_assert(offsetof(FEditorImportExportTestDefinition, FactorySettings) == 0x00001C, "Member 'FEditorImportExportTestDefinition::FactorySettings' has a wrong offset!");

// ScriptStruct Engine.InstancedStaticMeshInstanceData
// 0x0050 (0x0050 - 0x0000)
struct FInstancedStaticMeshInstanceData final
{
public:
	struct FMatrix                                Transform;                                         // 0x0000(0x0040)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              LightmapUVBias;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowmapUVBias;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstancedStaticMeshInstanceData) == 0x000010, "Wrong alignment on FInstancedStaticMeshInstanceData");
static_assert(sizeof(FInstancedStaticMeshInstanceData) == 0x000050, "Wrong size on FInstancedStaticMeshInstanceData");
static_assert(offsetof(FInstancedStaticMeshInstanceData, Transform) == 0x000000, "Member 'FInstancedStaticMeshInstanceData::Transform' has a wrong offset!");
static_assert(offsetof(FInstancedStaticMeshInstanceData, LightmapUVBias) == 0x000040, "Member 'FInstancedStaticMeshInstanceData::LightmapUVBias' has a wrong offset!");
static_assert(offsetof(FInstancedStaticMeshInstanceData, ShadowmapUVBias) == 0x000048, "Member 'FInstancedStaticMeshInstanceData::ShadowmapUVBias' has a wrong offset!");

// ScriptStruct Engine.ClusterNode
// 0x0028 (0x0028 - 0x0000)
struct FClusterNode final
{
public:
	struct FVector                                BoundMin;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FirstChild;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundMax;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LastChild;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstInstance;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastInstance;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterNode) == 0x000004, "Wrong alignment on FClusterNode");
static_assert(sizeof(FClusterNode) == 0x000028, "Wrong size on FClusterNode");
static_assert(offsetof(FClusterNode, BoundMin) == 0x000000, "Member 'FClusterNode::BoundMin' has a wrong offset!");
static_assert(offsetof(FClusterNode, FirstChild) == 0x00000C, "Member 'FClusterNode::FirstChild' has a wrong offset!");
static_assert(offsetof(FClusterNode, BoundMax) == 0x000010, "Member 'FClusterNode::BoundMax' has a wrong offset!");
static_assert(offsetof(FClusterNode, LastChild) == 0x00001C, "Member 'FClusterNode::LastChild' has a wrong offset!");
static_assert(offsetof(FClusterNode, FirstInstance) == 0x000020, "Member 'FClusterNode::FirstInstance' has a wrong offset!");
static_assert(offsetof(FClusterNode, LastInstance) == 0x000024, "Member 'FClusterNode::LastInstance' has a wrong offset!");

// ScriptStruct Engine.SplineMeshParams
// 0x0058 (0x0058 - 0x0000)
struct FSplineMeshParams final
{
public:
	struct FVector                                StartPos;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StartScale;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         StartRoll;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartOffset;                                       // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              EndScale;                                          // 0x0044(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         EndRoll;                                           // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EndOffset;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineMeshParams) == 0x000004, "Wrong alignment on FSplineMeshParams");
static_assert(sizeof(FSplineMeshParams) == 0x000058, "Wrong size on FSplineMeshParams");
static_assert(offsetof(FSplineMeshParams, StartPos) == 0x000000, "Member 'FSplineMeshParams::StartPos' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, StartTangent) == 0x00000C, "Member 'FSplineMeshParams::StartTangent' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, StartScale) == 0x000018, "Member 'FSplineMeshParams::StartScale' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, StartRoll) == 0x000020, "Member 'FSplineMeshParams::StartRoll' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, StartOffset) == 0x000024, "Member 'FSplineMeshParams::StartOffset' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, EndPos) == 0x00002C, "Member 'FSplineMeshParams::EndPos' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, EndTangent) == 0x000038, "Member 'FSplineMeshParams::EndTangent' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, EndScale) == 0x000044, "Member 'FSplineMeshParams::EndScale' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, EndRoll) == 0x00004C, "Member 'FSplineMeshParams::EndRoll' has a wrong offset!");
static_assert(offsetof(FSplineMeshParams, EndOffset) == 0x000050, "Member 'FSplineMeshParams::EndOffset' has a wrong offset!");

// ScriptStruct Engine.NamedEmitterMaterial
// 0x000C (0x000C - 0x0000)
struct FNamedEmitterMaterial final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNamedEmitterMaterial) == 0x000004, "Wrong alignment on FNamedEmitterMaterial");
static_assert(sizeof(FNamedEmitterMaterial) == 0x00000C, "Wrong size on FNamedEmitterMaterial");
static_assert(offsetof(FNamedEmitterMaterial, Name) == 0x000000, "Member 'FNamedEmitterMaterial::Name' has a wrong offset!");
static_assert(offsetof(FNamedEmitterMaterial, Material) == 0x000008, "Member 'FNamedEmitterMaterial::Material' has a wrong offset!");

// ScriptStruct Engine.AnimNode_ConvertLocalToComponentSpace
// 0x000C (0x002C - 0x0020)
struct FAnimNode_ConvertLocalToComponentSpace final : public FAnimNode_Base
{
public:
	struct FPoseLink                              LocalPose;                                         // 0x0020(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_ConvertLocalToComponentSpace) == 0x000004, "Wrong alignment on FAnimNode_ConvertLocalToComponentSpace");
static_assert(sizeof(FAnimNode_ConvertLocalToComponentSpace) == 0x00002C, "Wrong size on FAnimNode_ConvertLocalToComponentSpace");
static_assert(offsetof(FAnimNode_ConvertLocalToComponentSpace, LocalPose) == 0x000020, "Member 'FAnimNode_ConvertLocalToComponentSpace::LocalPose' has a wrong offset!");

// ScriptStruct Engine.LODSoloTrack
// 0x000C (0x000C - 0x0000)
struct FLODSoloTrack final
{
public:
	TArray<uint8>                                 SoloEnableSetting;                                 // 0x0000(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLODSoloTrack) == 0x000004, "Wrong alignment on FLODSoloTrack");
static_assert(sizeof(FLODSoloTrack) == 0x00000C, "Wrong size on FLODSoloTrack");
static_assert(offsetof(FLODSoloTrack, SoloEnableSetting) == 0x000000, "Member 'FLODSoloTrack::SoloEnableSetting' has a wrong offset!");

// ScriptStruct Engine.ParticleEvent_GenerateInfo
// 0x0024 (0x0024 - 0x0000)
struct FParticleEvent_GenerateInfo final
{
public:
	EParticleEventType                            Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Frequency;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParticleFrequency;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FirstTimeOnly : 1;                                 // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         LastTimeOnly : 1;                                  // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         UseReflectedImpactVector : 1;                      // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseOrbitOffset : 1;                               // 0x000C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomName;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;                  // 0x0018(0x000C)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleEvent_GenerateInfo) == 0x000004, "Wrong alignment on FParticleEvent_GenerateInfo");
static_assert(sizeof(FParticleEvent_GenerateInfo) == 0x000024, "Wrong size on FParticleEvent_GenerateInfo");
static_assert(offsetof(FParticleEvent_GenerateInfo, Type) == 0x000000, "Member 'FParticleEvent_GenerateInfo::Type' has a wrong offset!");
static_assert(offsetof(FParticleEvent_GenerateInfo, Frequency) == 0x000004, "Member 'FParticleEvent_GenerateInfo::Frequency' has a wrong offset!");
static_assert(offsetof(FParticleEvent_GenerateInfo, ParticleFrequency) == 0x000008, "Member 'FParticleEvent_GenerateInfo::ParticleFrequency' has a wrong offset!");
static_assert(offsetof(FParticleEvent_GenerateInfo, CustomName) == 0x000010, "Member 'FParticleEvent_GenerateInfo::CustomName' has a wrong offset!");
static_assert(offsetof(FParticleEvent_GenerateInfo, ParticleModuleEventsToSendToGame) == 0x000018, "Member 'FParticleEvent_GenerateInfo::ParticleModuleEventsToSendToGame' has a wrong offset!");

// ScriptStruct Engine.ParticleSysParam
// 0x0038 (0x0038 - 0x0000)
struct FParticleSysParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSysParamType                         ParamType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scalar;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scalar_Low;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Vector_Low;                                        // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleSysParam) == 0x000004, "Wrong alignment on FParticleSysParam");
static_assert(sizeof(FParticleSysParam) == 0x000038, "Wrong size on FParticleSysParam");
static_assert(offsetof(FParticleSysParam, Name) == 0x000000, "Member 'FParticleSysParam::Name' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, ParamType) == 0x000008, "Member 'FParticleSysParam::ParamType' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Scalar) == 0x00000C, "Member 'FParticleSysParam::Scalar' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Scalar_Low) == 0x000010, "Member 'FParticleSysParam::Scalar_Low' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Vector) == 0x000014, "Member 'FParticleSysParam::Vector' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Vector_Low) == 0x000020, "Member 'FParticleSysParam::Vector_Low' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Color) == 0x00002C, "Member 'FParticleSysParam::Color' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Actor) == 0x000030, "Member 'FParticleSysParam::Actor' has a wrong offset!");
static_assert(offsetof(FParticleSysParam, Material) == 0x000034, "Member 'FParticleSysParam::Material' has a wrong offset!");

// ScriptStruct Engine.EngineShowFlagsSetting
// 0x0010 (0x0010 - 0x0000)
struct FEngineShowFlagsSetting final
{
public:
	class FString                                 ShowFlagName;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEngineShowFlagsSetting) == 0x000004, "Wrong alignment on FEngineShowFlagsSetting");
static_assert(sizeof(FEngineShowFlagsSetting) == 0x000010, "Wrong size on FEngineShowFlagsSetting");
static_assert(offsetof(FEngineShowFlagsSetting, ShowFlagName) == 0x000000, "Member 'FEngineShowFlagsSetting::ShowFlagName' has a wrong offset!");
static_assert(offsetof(FEngineShowFlagsSetting, Enabled) == 0x00000C, "Member 'FEngineShowFlagsSetting::Enabled' has a wrong offset!");

// ScriptStruct Engine.BoolTrackKey
// 0x0008 (0x0008 - 0x0000)
struct FBoolTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value : 1;                                         // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoolTrackKey) == 0x000004, "Wrong alignment on FBoolTrackKey");
static_assert(sizeof(FBoolTrackKey) == 0x000008, "Wrong size on FBoolTrackKey");
static_assert(offsetof(FBoolTrackKey, Time) == 0x000000, "Member 'FBoolTrackKey::Time' has a wrong offset!");

// ScriptStruct Engine.TimelineEventEntry
// 0x0014 (0x0014 - 0x0000)
struct FTimelineEventEntry final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             EventFunc;                                         // 0x0004(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimelineEventEntry) == 0x000004, "Wrong alignment on FTimelineEventEntry");
static_assert(sizeof(FTimelineEventEntry) == 0x000014, "Wrong size on FTimelineEventEntry");
static_assert(offsetof(FTimelineEventEntry, Time) == 0x000000, "Member 'FTimelineEventEntry::Time' has a wrong offset!");
static_assert(offsetof(FTimelineEventEntry, EventFunc) == 0x000004, "Member 'FTimelineEventEntry::EventFunc' has a wrong offset!");

// ScriptStruct Engine.TimelineLinearColorTrack
// 0x0028 (0x0028 - 0x0000)
struct FTimelineLinearColorTrack final
{
public:
	class UCurveLinearColor*                      LinearColorCurve;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FLinearColor& Output)> InterpFunc;                                        // 0x0004(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LinearColorPropertyName;                           // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStructProperty*                        LinearColorProperty;                               // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimelineLinearColorTrack) == 0x000004, "Wrong alignment on FTimelineLinearColorTrack");
static_assert(sizeof(FTimelineLinearColorTrack) == 0x000028, "Wrong size on FTimelineLinearColorTrack");
static_assert(offsetof(FTimelineLinearColorTrack, LinearColorCurve) == 0x000000, "Member 'FTimelineLinearColorTrack::LinearColorCurve' has a wrong offset!");
static_assert(offsetof(FTimelineLinearColorTrack, InterpFunc) == 0x000004, "Member 'FTimelineLinearColorTrack::InterpFunc' has a wrong offset!");
static_assert(offsetof(FTimelineLinearColorTrack, LinearColorPropertyName) == 0x000014, "Member 'FTimelineLinearColorTrack::LinearColorPropertyName' has a wrong offset!");
static_assert(offsetof(FTimelineLinearColorTrack, LinearColorProperty) == 0x00001C, "Member 'FTimelineLinearColorTrack::LinearColorProperty' has a wrong offset!");

// ScriptStruct Engine.Timeline
// 0x0080 (0x0080 - 0x0000)
struct FTimeline final
{
public:
	ETimelineLengthMode                           LengthMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Length;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bLooping : 1;                                      // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bReversePlayback : 1;                              // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bPlaying : 1;                                      // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Position;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineEventEntry>            Events;                                            // 0x0014(0x000C)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineVectorTrack>           InterpVectors;                                     // 0x0020(0x000C)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineFloatTrack>            InterpFloats;                                      // 0x002C(0x000C)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FTimelineLinearColorTrack>      InterpLinearColors;                                // 0x0038(0x000C)(ZeroConstructor, RepSkip, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             TimelinePostUpdateFunc;                            // 0x0044(0x0010)(ZeroConstructor, InstancedReference, RepSkip, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             TimelineFinishedFunc;                              // 0x0054(0x0010)(ZeroConstructor, InstancedReference, RepSkip, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x8];                                       // 0x0064(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 PropertySetObject;                                 // 0x006C(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   DirectionPropertyName;                             // 0x0074(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UByteProperty*                          DirectionProperty;                                 // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTimeline) == 0x000004, "Wrong alignment on FTimeline");
static_assert(sizeof(FTimeline) == 0x000080, "Wrong size on FTimeline");
static_assert(offsetof(FTimeline, LengthMode) == 0x000000, "Member 'FTimeline::LengthMode' has a wrong offset!");
static_assert(offsetof(FTimeline, Length) == 0x000004, "Member 'FTimeline::Length' has a wrong offset!");
static_assert(offsetof(FTimeline, PlayRate) == 0x00000C, "Member 'FTimeline::PlayRate' has a wrong offset!");
static_assert(offsetof(FTimeline, Position) == 0x000010, "Member 'FTimeline::Position' has a wrong offset!");
static_assert(offsetof(FTimeline, Events) == 0x000014, "Member 'FTimeline::Events' has a wrong offset!");
static_assert(offsetof(FTimeline, InterpVectors) == 0x000020, "Member 'FTimeline::InterpVectors' has a wrong offset!");
static_assert(offsetof(FTimeline, InterpFloats) == 0x00002C, "Member 'FTimeline::InterpFloats' has a wrong offset!");
static_assert(offsetof(FTimeline, InterpLinearColors) == 0x000038, "Member 'FTimeline::InterpLinearColors' has a wrong offset!");
static_assert(offsetof(FTimeline, TimelinePostUpdateFunc) == 0x000044, "Member 'FTimeline::TimelinePostUpdateFunc' has a wrong offset!");
static_assert(offsetof(FTimeline, TimelineFinishedFunc) == 0x000054, "Member 'FTimeline::TimelineFinishedFunc' has a wrong offset!");
static_assert(offsetof(FTimeline, PropertySetObject) == 0x00006C, "Member 'FTimeline::PropertySetObject' has a wrong offset!");
static_assert(offsetof(FTimeline, DirectionPropertyName) == 0x000074, "Member 'FTimeline::DirectionPropertyName' has a wrong offset!");
static_assert(offsetof(FTimeline, DirectionProperty) == 0x00007C, "Member 'FTimeline::DirectionProperty' has a wrong offset!");

// ScriptStruct Engine.EventTrackKey
// 0x000C (0x000C - 0x0000)
struct FEventTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventTrackKey) == 0x000004, "Wrong alignment on FEventTrackKey");
static_assert(sizeof(FEventTrackKey) == 0x00000C, "Wrong size on FEventTrackKey");
static_assert(offsetof(FEventTrackKey, Time) == 0x000000, "Member 'FEventTrackKey::Time' has a wrong offset!");
static_assert(offsetof(FEventTrackKey, EventName) == 0x000004, "Member 'FEventTrackKey::EventName' has a wrong offset!");

// ScriptStruct Engine.SoundClassEditorData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSoundClassEditorData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundClassEditorData) == 0x000004, "Wrong alignment on FSoundClassEditorData");
static_assert(sizeof(FSoundClassEditorData) == 0x000008, "Wrong size on FSoundClassEditorData");

// ScriptStruct Engine.BakedStateExitTransition
// 0x001C (0x001C - 0x0000)
struct FBakedStateExitTransition final
{
public:
	int32                                         CanTakeDelegateIndex;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CustomResultNodeIndex;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionIndex;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesiredTransitionReturnValue;                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutomaticRemainingTimeRule;                       // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PoseEvaluatorLinks;                                // 0x0010(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedStateExitTransition) == 0x000004, "Wrong alignment on FBakedStateExitTransition");
static_assert(sizeof(FBakedStateExitTransition) == 0x00001C, "Wrong size on FBakedStateExitTransition");
static_assert(offsetof(FBakedStateExitTransition, CanTakeDelegateIndex) == 0x000000, "Member 'FBakedStateExitTransition::CanTakeDelegateIndex' has a wrong offset!");
static_assert(offsetof(FBakedStateExitTransition, CustomResultNodeIndex) == 0x000004, "Member 'FBakedStateExitTransition::CustomResultNodeIndex' has a wrong offset!");
static_assert(offsetof(FBakedStateExitTransition, TransitionIndex) == 0x000008, "Member 'FBakedStateExitTransition::TransitionIndex' has a wrong offset!");
static_assert(offsetof(FBakedStateExitTransition, bDesiredTransitionReturnValue) == 0x00000C, "Member 'FBakedStateExitTransition::bDesiredTransitionReturnValue' has a wrong offset!");
static_assert(offsetof(FBakedStateExitTransition, bAutomaticRemainingTimeRule) == 0x00000D, "Member 'FBakedStateExitTransition::bAutomaticRemainingTimeRule' has a wrong offset!");
static_assert(offsetof(FBakedStateExitTransition, PoseEvaluatorLinks) == 0x000010, "Member 'FBakedStateExitTransition::PoseEvaluatorLinks' has a wrong offset!");

// ScriptStruct Engine.BakedAnimationState
// 0x0038 (0x0038 - 0x0000)
struct FBakedAnimationState final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBakedStateExitTransition>      Transitions;                                       // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StateRootNodeIndex;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullyBlendedNotify;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAConduit;                                       // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EntryRuleNodeIndex;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PlayerNodeIndices;                                 // 0x002C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedAnimationState) == 0x000004, "Wrong alignment on FBakedAnimationState");
static_assert(sizeof(FBakedAnimationState) == 0x000038, "Wrong size on FBakedAnimationState");
static_assert(offsetof(FBakedAnimationState, StateName) == 0x000000, "Member 'FBakedAnimationState::StateName' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, Transitions) == 0x000008, "Member 'FBakedAnimationState::Transitions' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, StateRootNodeIndex) == 0x000014, "Member 'FBakedAnimationState::StateRootNodeIndex' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, StartNotify) == 0x000018, "Member 'FBakedAnimationState::StartNotify' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, EndNotify) == 0x00001C, "Member 'FBakedAnimationState::EndNotify' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, FullyBlendedNotify) == 0x000020, "Member 'FBakedAnimationState::FullyBlendedNotify' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, bIsAConduit) == 0x000024, "Member 'FBakedAnimationState::bIsAConduit' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, EntryRuleNodeIndex) == 0x000028, "Member 'FBakedAnimationState::EntryRuleNodeIndex' has a wrong offset!");
static_assert(offsetof(FBakedAnimationState, PlayerNodeIndices) == 0x00002C, "Member 'FBakedAnimationState::PlayerNodeIndices' has a wrong offset!");

// ScriptStruct Engine.AnimationTransitionBetweenStates
// 0x0028 (0x0030 - 0x0008)
struct FAnimationTransitionBetweenStates final : public FAnimationStateBase
{
public:
	int32                                         PreviousState;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextState;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossfadeDuration;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterruptNotify;                                   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendMode;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CustomCurve;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendProfile*                          BlendProfile;                                      // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionLogicType                          LogicType;                                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationTransitionBetweenStates) == 0x000004, "Wrong alignment on FAnimationTransitionBetweenStates");
static_assert(sizeof(FAnimationTransitionBetweenStates) == 0x000030, "Wrong size on FAnimationTransitionBetweenStates");
static_assert(offsetof(FAnimationTransitionBetweenStates, PreviousState) == 0x000008, "Member 'FAnimationTransitionBetweenStates::PreviousState' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, NextState) == 0x00000C, "Member 'FAnimationTransitionBetweenStates::NextState' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, CrossfadeDuration) == 0x000010, "Member 'FAnimationTransitionBetweenStates::CrossfadeDuration' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, StartNotify) == 0x000014, "Member 'FAnimationTransitionBetweenStates::StartNotify' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, EndNotify) == 0x000018, "Member 'FAnimationTransitionBetweenStates::EndNotify' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, InterruptNotify) == 0x00001C, "Member 'FAnimationTransitionBetweenStates::InterruptNotify' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, BlendMode) == 0x000020, "Member 'FAnimationTransitionBetweenStates::BlendMode' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, CustomCurve) == 0x000024, "Member 'FAnimationTransitionBetweenStates::CustomCurve' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, BlendProfile) == 0x000028, "Member 'FAnimationTransitionBetweenStates::BlendProfile' has a wrong offset!");
static_assert(offsetof(FAnimationTransitionBetweenStates, LogicType) == 0x00002C, "Member 'FAnimationTransitionBetweenStates::LogicType' has a wrong offset!");

// ScriptStruct Engine.BakedAnimationStateMachine
// 0x0024 (0x0024 - 0x0000)
struct FBakedAnimationStateMachine final
{
public:
	class FName                                   MachineName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialState;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBakedAnimationState>           States;                                            // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimationTransitionBetweenStates> Transitions;                                       // 0x0018(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakedAnimationStateMachine) == 0x000004, "Wrong alignment on FBakedAnimationStateMachine");
static_assert(sizeof(FBakedAnimationStateMachine) == 0x000024, "Wrong size on FBakedAnimationStateMachine");
static_assert(offsetof(FBakedAnimationStateMachine, MachineName) == 0x000000, "Member 'FBakedAnimationStateMachine::MachineName' has a wrong offset!");
static_assert(offsetof(FBakedAnimationStateMachine, InitialState) == 0x000008, "Member 'FBakedAnimationStateMachine::InitialState' has a wrong offset!");
static_assert(offsetof(FBakedAnimationStateMachine, States) == 0x00000C, "Member 'FBakedAnimationStateMachine::States' has a wrong offset!");
static_assert(offsetof(FBakedAnimationStateMachine, Transitions) == 0x000018, "Member 'FBakedAnimationStateMachine::Transitions' has a wrong offset!");

// ScriptStruct Engine.TTEventTrack
// 0x0004 (0x0010 - 0x000C)
struct FTTEventTrack final : public FTTTrackBase
{
public:
	class UCurveFloat*                            CurveKeys;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTTEventTrack) == 0x000004, "Wrong alignment on FTTEventTrack");
static_assert(sizeof(FTTEventTrack) == 0x000010, "Wrong size on FTTEventTrack");
static_assert(offsetof(FTTEventTrack, CurveKeys) == 0x00000C, "Member 'FTTEventTrack::CurveKeys' has a wrong offset!");

// ScriptStruct Engine.AnimationState
// 0x001C (0x0024 - 0x0008)
struct FAnimationState final : public FAnimationStateBase
{
public:
	TArray<struct FAnimationTransitionRule>       Transitions;                                       // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StateRootNodeIndex;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartNotify;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNotify;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FullyBlendedNotify;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationState) == 0x000004, "Wrong alignment on FAnimationState");
static_assert(sizeof(FAnimationState) == 0x000024, "Wrong size on FAnimationState");
static_assert(offsetof(FAnimationState, Transitions) == 0x000008, "Member 'FAnimationState::Transitions' has a wrong offset!");
static_assert(offsetof(FAnimationState, StateRootNodeIndex) == 0x000014, "Member 'FAnimationState::StateRootNodeIndex' has a wrong offset!");
static_assert(offsetof(FAnimationState, StartNotify) == 0x000018, "Member 'FAnimationState::StartNotify' has a wrong offset!");
static_assert(offsetof(FAnimationState, EndNotify) == 0x00001C, "Member 'FAnimationState::EndNotify' has a wrong offset!");
static_assert(offsetof(FAnimationState, FullyBlendedNotify) == 0x000020, "Member 'FAnimationState::FullyBlendedNotify' has a wrong offset!");

// ScriptStruct Engine.SlotEvaluationPose
// 0x002C (0x002C - 0x0000)
struct FSlotEvaluationPose final
{
public:
	EAdditiveAnimationType                        AdditiveType;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x24];                                       // 0x0008(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSlotEvaluationPose) == 0x000004, "Wrong alignment on FSlotEvaluationPose");
static_assert(sizeof(FSlotEvaluationPose) == 0x00002C, "Wrong size on FSlotEvaluationPose");
static_assert(offsetof(FSlotEvaluationPose, AdditiveType) == 0x000000, "Member 'FSlotEvaluationPose::AdditiveType' has a wrong offset!");
static_assert(offsetof(FSlotEvaluationPose, Weight) == 0x000004, "Member 'FSlotEvaluationPose::Weight' has a wrong offset!");

// ScriptStruct Engine.TransformBase
// 0x0020 (0x0020 - 0x0000)
struct FTransformBase final
{
public:
	class FName                                   Node;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformBaseConstraint               Constraints[0x2];                                  // 0x0008(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformBase) == 0x000004, "Wrong alignment on FTransformBase");
static_assert(sizeof(FTransformBase) == 0x000020, "Wrong size on FTransformBase");
static_assert(offsetof(FTransformBase, Node) == 0x000000, "Member 'FTransformBase::Node' has a wrong offset!");
static_assert(offsetof(FTransformBase, Constraints) == 0x000008, "Member 'FTransformBase::Constraints' has a wrong offset!");

// ScriptStruct Engine.PerBoneBlendWeights
// 0x000C (0x000C - 0x0000)
struct FPerBoneBlendWeights final
{
public:
	TArray<struct FPerBoneBlendWeight>            BoneBlendWeights;                                  // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerBoneBlendWeights) == 0x000004, "Wrong alignment on FPerBoneBlendWeights");
static_assert(sizeof(FPerBoneBlendWeights) == 0x00000C, "Wrong size on FPerBoneBlendWeights");
static_assert(offsetof(FPerBoneBlendWeights, BoneBlendWeights) == 0x000000, "Member 'FPerBoneBlendWeights::BoneBlendWeights' has a wrong offset!");

// ScriptStruct Engine.AnimMontageInstance
// 0x00C4 (0x00C4 - 0x0000)
struct FAnimMontageInstance final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x10];                                       // 0x0004(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlaying;                                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBlendTimeMultiplier;                        // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x1C];                                      // 0x001C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NextSections;                                      // 0x0038(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PrevSections;                                      // 0x0044(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimNotifyEvent>               ActiveStateBranchingPoints;                        // 0x0058(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         Position;                                          // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAlphaBlend                            Blend;                                             // 0x006C(0x002C)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x2C];                                      // 0x0098(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMontageInstance) == 0x000004, "Wrong alignment on FAnimMontageInstance");
static_assert(sizeof(FAnimMontageInstance) == 0x0000C4, "Wrong size on FAnimMontageInstance");
static_assert(offsetof(FAnimMontageInstance, Montage) == 0x000000, "Member 'FAnimMontageInstance::Montage' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, bPlaying) == 0x000014, "Member 'FAnimMontageInstance::bPlaying' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, DefaultBlendTimeMultiplier) == 0x000018, "Member 'FAnimMontageInstance::DefaultBlendTimeMultiplier' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, NextSections) == 0x000038, "Member 'FAnimMontageInstance::NextSections' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, PrevSections) == 0x000044, "Member 'FAnimMontageInstance::PrevSections' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, ActiveStateBranchingPoints) == 0x000058, "Member 'FAnimMontageInstance::ActiveStateBranchingPoints' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, Position) == 0x000064, "Member 'FAnimMontageInstance::Position' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, PlayRate) == 0x000068, "Member 'FAnimMontageInstance::PlayRate' has a wrong offset!");
static_assert(offsetof(FAnimMontageInstance, Blend) == 0x00006C, "Member 'FAnimMontageInstance::Blend' has a wrong offset!");

// ScriptStruct Engine.BranchingPoint
// 0x0010 (0x0034 - 0x0024)
struct FBranchingPoint final : public FAnimLinkableElement
{
public:
	class FName                                   EventName;                                         // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x002C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerTimeOffset;                                 // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchingPoint) == 0x000004, "Wrong alignment on FBranchingPoint");
static_assert(sizeof(FBranchingPoint) == 0x000034, "Wrong size on FBranchingPoint");
static_assert(offsetof(FBranchingPoint, EventName) == 0x000024, "Member 'FBranchingPoint::EventName' has a wrong offset!");
static_assert(offsetof(FBranchingPoint, DisplayTime) == 0x00002C, "Member 'FBranchingPoint::DisplayTime' has a wrong offset!");
static_assert(offsetof(FBranchingPoint, TriggerTimeOffset) == 0x000030, "Member 'FBranchingPoint::TriggerTimeOffset' has a wrong offset!");

// ScriptStruct Engine.CompositeSection
// 0x0020 (0x0044 - 0x0024)
struct FCompositeSection final : public FAnimLinkableElement
{
public:
	class FName                                   SectionName;                                       // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x002C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSectionName;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMetaData*>                  MetaData;                                          // 0x0038(0x000C)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCompositeSection) == 0x000004, "Wrong alignment on FCompositeSection");
static_assert(sizeof(FCompositeSection) == 0x000044, "Wrong size on FCompositeSection");
static_assert(offsetof(FCompositeSection, SectionName) == 0x000024, "Member 'FCompositeSection::SectionName' has a wrong offset!");
static_assert(offsetof(FCompositeSection, StartTime) == 0x00002C, "Member 'FCompositeSection::StartTime' has a wrong offset!");
static_assert(offsetof(FCompositeSection, NextSectionName) == 0x000030, "Member 'FCompositeSection::NextSectionName' has a wrong offset!");
static_assert(offsetof(FCompositeSection, MetaData) == 0x000038, "Member 'FCompositeSection::MetaData' has a wrong offset!");

// ScriptStruct Engine.CompressedOffsetData
// 0x0010 (0x0010 - 0x0000)
struct FCompressedOffsetData final
{
public:
	TArray<int32>                                 OffsetData;                                        // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StripSize;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompressedOffsetData) == 0x000004, "Wrong alignment on FCompressedOffsetData");
static_assert(sizeof(FCompressedOffsetData) == 0x000010, "Wrong size on FCompressedOffsetData");
static_assert(offsetof(FCompressedOffsetData, OffsetData) == 0x000000, "Member 'FCompressedOffsetData::OffsetData' has a wrong offset!");
static_assert(offsetof(FCompressedOffsetData, StripSize) == 0x00000C, "Member 'FCompressedOffsetData::StripSize' has a wrong offset!");

// ScriptStruct Engine.CompressedTrack
// 0x0030 (0x0030 - 0x0000)
struct FCompressedTrack final
{
public:
	TArray<uint8>                                 ByteStream;                                        // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Mins[0x3];                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ranges[0x3];                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompressedTrack) == 0x000004, "Wrong alignment on FCompressedTrack");
static_assert(sizeof(FCompressedTrack) == 0x000030, "Wrong size on FCompressedTrack");
static_assert(offsetof(FCompressedTrack, ByteStream) == 0x000000, "Member 'FCompressedTrack::ByteStream' has a wrong offset!");
static_assert(offsetof(FCompressedTrack, Times) == 0x00000C, "Member 'FCompressedTrack::Times' has a wrong offset!");
static_assert(offsetof(FCompressedTrack, Mins) == 0x000018, "Member 'FCompressedTrack::Mins' has a wrong offset!");
static_assert(offsetof(FCompressedTrack, Ranges) == 0x000024, "Member 'FCompressedTrack::Ranges' has a wrong offset!");

// ScriptStruct Engine.CurveTrack
// 0x0014 (0x0014 - 0x0000)
struct FCurveTrack final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CurveWeights;                                      // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurveTrack) == 0x000004, "Wrong alignment on FCurveTrack");
static_assert(sizeof(FCurveTrack) == 0x000014, "Wrong size on FCurveTrack");
static_assert(offsetof(FCurveTrack, CurveName) == 0x000000, "Member 'FCurveTrack::CurveName' has a wrong offset!");
static_assert(offsetof(FCurveTrack, CurveWeights) == 0x000008, "Member 'FCurveTrack::CurveWeights' has a wrong offset!");

// ScriptStruct Engine.ScaleTrack
// 0x0018 (0x0018 - 0x0000)
struct FScaleTrack final
{
public:
	TArray<struct FVector>                        ScaleKeys;                                         // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScaleTrack) == 0x000004, "Wrong alignment on FScaleTrack");
static_assert(sizeof(FScaleTrack) == 0x000018, "Wrong size on FScaleTrack");
static_assert(offsetof(FScaleTrack, ScaleKeys) == 0x000000, "Member 'FScaleTrack::ScaleKeys' has a wrong offset!");
static_assert(offsetof(FScaleTrack, Times) == 0x00000C, "Member 'FScaleTrack::Times' has a wrong offset!");

// ScriptStruct Engine.TrackToSkeletonMap
// 0x0004 (0x0004 - 0x0000)
struct FTrackToSkeletonMap final
{
public:
	int32                                         BoneTreeIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrackToSkeletonMap) == 0x000004, "Wrong alignment on FTrackToSkeletonMap");
static_assert(sizeof(FTrackToSkeletonMap) == 0x000004, "Wrong size on FTrackToSkeletonMap");
static_assert(offsetof(FTrackToSkeletonMap, BoneTreeIndex) == 0x000000, "Member 'FTrackToSkeletonMap::BoneTreeIndex' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionOpenAssetSettings
// 0x0048 (0x0048 - 0x0000)
struct FBuildPromotionOpenAssetSettings final
{
public:
	struct FFilePath                              BlueprintAsset;                                    // 0x0000(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              MaterialAsset;                                     // 0x000C(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              ParticleSystemAsset;                               // 0x0018(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              SkeletalMeshAsset;                                 // 0x0024(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              StaticMeshAsset;                                   // 0x0030(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              TextureAsset;                                      // 0x003C(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildPromotionOpenAssetSettings) == 0x000004, "Wrong alignment on FBuildPromotionOpenAssetSettings");
static_assert(sizeof(FBuildPromotionOpenAssetSettings) == 0x000048, "Wrong size on FBuildPromotionOpenAssetSettings");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, BlueprintAsset) == 0x000000, "Member 'FBuildPromotionOpenAssetSettings::BlueprintAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, MaterialAsset) == 0x00000C, "Member 'FBuildPromotionOpenAssetSettings::MaterialAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, ParticleSystemAsset) == 0x000018, "Member 'FBuildPromotionOpenAssetSettings::ParticleSystemAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, SkeletalMeshAsset) == 0x000024, "Member 'FBuildPromotionOpenAssetSettings::SkeletalMeshAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, StaticMeshAsset) == 0x000030, "Member 'FBuildPromotionOpenAssetSettings::StaticMeshAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionOpenAssetSettings, TextureAsset) == 0x00003C, "Member 'FBuildPromotionOpenAssetSettings::TextureAsset' has a wrong offset!");

// ScriptStruct Engine.PerBoneInterpolation
// 0x0010 (0x0010 - 0x0000)
struct FPerBoneInterpolation final
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeedPerSec;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerBoneInterpolation) == 0x000004, "Wrong alignment on FPerBoneInterpolation");
static_assert(sizeof(FPerBoneInterpolation) == 0x000010, "Wrong size on FPerBoneInterpolation");
static_assert(offsetof(FPerBoneInterpolation, BoneReference) == 0x000000, "Member 'FPerBoneInterpolation::BoneReference' has a wrong offset!");
static_assert(offsetof(FPerBoneInterpolation, InterpolationSpeedPerSec) == 0x00000C, "Member 'FPerBoneInterpolation::InterpolationSpeedPerSec' has a wrong offset!");

// ScriptStruct Engine.EditorElement
// 0x0018 (0x0018 - 0x0000)
struct FEditorElement final
{
public:
	int32                                         Indices[0x3];                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weights[0x3];                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorElement) == 0x000004, "Wrong alignment on FEditorElement");
static_assert(sizeof(FEditorElement) == 0x000018, "Wrong size on FEditorElement");
static_assert(offsetof(FEditorElement, Indices) == 0x000000, "Member 'FEditorElement::Indices' has a wrong offset!");
static_assert(offsetof(FEditorElement, Weights) == 0x00000C, "Member 'FEditorElement::Weights' has a wrong offset!");

// ScriptStruct Engine.GridBlendSample
// 0x001C (0x001C - 0x0000)
struct FGridBlendSample final
{
public:
	struct FEditorElement                         GridElement;                                       // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridBlendSample) == 0x000004, "Wrong alignment on FGridBlendSample");
static_assert(sizeof(FGridBlendSample) == 0x00001C, "Wrong size on FGridBlendSample");
static_assert(offsetof(FGridBlendSample, GridElement) == 0x000000, "Member 'FGridBlendSample::GridElement' has a wrong offset!");
static_assert(offsetof(FGridBlendSample, BlendWeight) == 0x000018, "Member 'FGridBlendSample::BlendWeight' has a wrong offset!");

// ScriptStruct Engine.GPUSpriteLocalVectorFieldInfo
// 0x0070 (0x0070 - 0x0000)
struct FGPUSpriteLocalVectorFieldInfo final
{
public:
	class UVectorField*                           Field;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MinInitialRotation;                                // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxInitialRotation;                                // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationRate;                                      // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tightness;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreComponentTransform : 1;                     // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTileX : 1;                                        // 0x006C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTileY : 1;                                        // 0x006C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTileZ : 1;                                        // 0x006C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGPUSpriteLocalVectorFieldInfo) == 0x000010, "Wrong alignment on FGPUSpriteLocalVectorFieldInfo");
static_assert(sizeof(FGPUSpriteLocalVectorFieldInfo) == 0x000070, "Wrong size on FGPUSpriteLocalVectorFieldInfo");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, Field) == 0x000000, "Member 'FGPUSpriteLocalVectorFieldInfo::Field' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, Transform) == 0x000010, "Member 'FGPUSpriteLocalVectorFieldInfo::Transform' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, MinInitialRotation) == 0x000040, "Member 'FGPUSpriteLocalVectorFieldInfo::MinInitialRotation' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, MaxInitialRotation) == 0x00004C, "Member 'FGPUSpriteLocalVectorFieldInfo::MaxInitialRotation' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, RotationRate) == 0x000058, "Member 'FGPUSpriteLocalVectorFieldInfo::RotationRate' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, Intensity) == 0x000064, "Member 'FGPUSpriteLocalVectorFieldInfo::Intensity' has a wrong offset!");
static_assert(offsetof(FGPUSpriteLocalVectorFieldInfo, Tightness) == 0x000068, "Member 'FGPUSpriteLocalVectorFieldInfo::Tightness' has a wrong offset!");

// ScriptStruct Engine.AnimSetMeshLinkup
// 0x000C (0x000C - 0x0000)
struct FAnimSetMeshLinkup final
{
public:
	TArray<int32>                                 BoneToTrackTable;                                  // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSetMeshLinkup) == 0x000004, "Wrong alignment on FAnimSetMeshLinkup");
static_assert(sizeof(FAnimSetMeshLinkup) == 0x00000C, "Wrong size on FAnimSetMeshLinkup");
static_assert(offsetof(FAnimSetMeshLinkup, BoneToTrackTable) == 0x000000, "Member 'FAnimSetMeshLinkup::BoneToTrackTable' has a wrong offset!");

// ScriptStruct Engine.LaunchOnTestSettings
// 0x0018 (0x0018 - 0x0000)
struct FLaunchOnTestSettings final
{
public:
	struct FFilePath                              LaunchOnTestmap;                                   // 0x0000(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 DeviceID;                                          // 0x000C(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLaunchOnTestSettings) == 0x000004, "Wrong alignment on FLaunchOnTestSettings");
static_assert(sizeof(FLaunchOnTestSettings) == 0x000018, "Wrong size on FLaunchOnTestSettings");
static_assert(offsetof(FLaunchOnTestSettings, LaunchOnTestmap) == 0x000000, "Member 'FLaunchOnTestSettings::LaunchOnTestmap' has a wrong offset!");
static_assert(offsetof(FLaunchOnTestSettings, DeviceID) == 0x00000C, "Member 'FLaunchOnTestSettings::DeviceID' has a wrong offset!");

// ScriptStruct Engine.MeshSectionInfoMap
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FMeshSectionInfoMap final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMeshSectionInfoMap) == 0x000004, "Wrong alignment on FMeshSectionInfoMap");
static_assert(sizeof(FMeshSectionInfoMap) == 0x00003C, "Wrong size on FMeshSectionInfoMap");

// ScriptStruct Engine.FullyLoadedPackagesInfo
// 0x0028 (0x0028 - 0x0000)
struct FFullyLoadedPackagesInfo final
{
public:
	EFullyLoadPackageType                         FullyLoadType;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Tag;                                               // 0x0004(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PackagesToLoad;                                    // 0x0010(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LoadedObjects;                                     // 0x001C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFullyLoadedPackagesInfo) == 0x000004, "Wrong alignment on FFullyLoadedPackagesInfo");
static_assert(sizeof(FFullyLoadedPackagesInfo) == 0x000028, "Wrong size on FFullyLoadedPackagesInfo");
static_assert(offsetof(FFullyLoadedPackagesInfo, FullyLoadType) == 0x000000, "Member 'FFullyLoadedPackagesInfo::FullyLoadType' has a wrong offset!");
static_assert(offsetof(FFullyLoadedPackagesInfo, Tag) == 0x000004, "Member 'FFullyLoadedPackagesInfo::Tag' has a wrong offset!");
static_assert(offsetof(FFullyLoadedPackagesInfo, PackagesToLoad) == 0x000010, "Member 'FFullyLoadedPackagesInfo::PackagesToLoad' has a wrong offset!");
static_assert(offsetof(FFullyLoadedPackagesInfo, LoadedObjects) == 0x00001C, "Member 'FFullyLoadedPackagesInfo::LoadedObjects' has a wrong offset!");

// ScriptStruct Engine.LevelStreamingStatus
// 0x0010 (0x0010 - 0x0000)
struct FLevelStreamingStatus final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShouldBeLoaded : 1;                               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShouldBeVisible : 1;                              // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        LODIndex;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelStreamingStatus) == 0x000004, "Wrong alignment on FLevelStreamingStatus");
static_assert(sizeof(FLevelStreamingStatus) == 0x000010, "Wrong size on FLevelStreamingStatus");
static_assert(offsetof(FLevelStreamingStatus, PackageName) == 0x000000, "Member 'FLevelStreamingStatus::PackageName' has a wrong offset!");
static_assert(offsetof(FLevelStreamingStatus, LODIndex) == 0x00000C, "Member 'FLevelStreamingStatus::LODIndex' has a wrong offset!");

// ScriptStruct Engine.NamedNetDriver
// 0x0008 (0x0008 - 0x0000)
struct FNamedNetDriver final
{
public:
	class UNetDriver*                             NetDriver;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNamedNetDriver) == 0x000004, "Wrong alignment on FNamedNetDriver");
static_assert(sizeof(FNamedNetDriver) == 0x000008, "Wrong size on FNamedNetDriver");
static_assert(offsetof(FNamedNetDriver, NetDriver) == 0x000000, "Member 'FNamedNetDriver::NetDriver' has a wrong offset!");

// ScriptStruct Engine.WorldContext
// 0x01D4 (0x01D4 - 0x0000)
struct FWorldContext final
{
public:
	uint8                                         Pad_0[0x9C];                                       // 0x0000(0x009C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FURL                                   LastURL;                                           // 0x009C(0x0050)(NativeAccessSpecifierPublic)
	struct FURL                                   LastRemoteURL;                                     // 0x00EC(0x0050)(NativeAccessSpecifierPublic)
	class UPendingNetGame*                        PendingNetGame;                                    // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFullyLoadedPackagesInfo>       PackagesToFullyLoad;                               // 0x0140(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0xC];                                      // 0x014C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevel*>                         LoadedLevelsForPendingMapChange;                   // 0x0158(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x10];                                     // 0x0164(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObjectReferencer*>              ObjectReferencers;                                 // 0x0174(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLevelStreamingStatus>          PendingLevelStreamingStatusUpdates;                // 0x0180(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGameViewportClient*                    GameViewport;                                      // 0x018C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameInstance*                          OwningGameInstance;                                // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNamedNetDriver>                ActiveNetDrivers;                                  // 0x0194(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x34];                                     // 0x01A0(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldContext) == 0x000004, "Wrong alignment on FWorldContext");
static_assert(sizeof(FWorldContext) == 0x0001D4, "Wrong size on FWorldContext");
static_assert(offsetof(FWorldContext, LastURL) == 0x00009C, "Member 'FWorldContext::LastURL' has a wrong offset!");
static_assert(offsetof(FWorldContext, LastRemoteURL) == 0x0000EC, "Member 'FWorldContext::LastRemoteURL' has a wrong offset!");
static_assert(offsetof(FWorldContext, PendingNetGame) == 0x00013C, "Member 'FWorldContext::PendingNetGame' has a wrong offset!");
static_assert(offsetof(FWorldContext, PackagesToFullyLoad) == 0x000140, "Member 'FWorldContext::PackagesToFullyLoad' has a wrong offset!");
static_assert(offsetof(FWorldContext, LoadedLevelsForPendingMapChange) == 0x000158, "Member 'FWorldContext::LoadedLevelsForPendingMapChange' has a wrong offset!");
static_assert(offsetof(FWorldContext, ObjectReferencers) == 0x000174, "Member 'FWorldContext::ObjectReferencers' has a wrong offset!");
static_assert(offsetof(FWorldContext, PendingLevelStreamingStatusUpdates) == 0x000180, "Member 'FWorldContext::PendingLevelStreamingStatusUpdates' has a wrong offset!");
static_assert(offsetof(FWorldContext, GameViewport) == 0x00018C, "Member 'FWorldContext::GameViewport' has a wrong offset!");
static_assert(offsetof(FWorldContext, OwningGameInstance) == 0x000190, "Member 'FWorldContext::OwningGameInstance' has a wrong offset!");
static_assert(offsetof(FWorldContext, ActiveNetDrivers) == 0x000194, "Member 'FWorldContext::ActiveNetDrivers' has a wrong offset!");

// ScriptStruct Engine.EditorMapPerformanceTestDefinition
// 0x0010 (0x0010 - 0x0000)
struct FEditorMapPerformanceTestDefinition final
{
public:
	struct FFilePath                              PerformanceTestmap;                                // 0x0000(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	int32                                         TestTimer;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorMapPerformanceTestDefinition) == 0x000004, "Wrong alignment on FEditorMapPerformanceTestDefinition");
static_assert(sizeof(FEditorMapPerformanceTestDefinition) == 0x000010, "Wrong size on FEditorMapPerformanceTestDefinition");
static_assert(offsetof(FEditorMapPerformanceTestDefinition, PerformanceTestmap) == 0x000000, "Member 'FEditorMapPerformanceTestDefinition::PerformanceTestmap' has a wrong offset!");
static_assert(offsetof(FEditorMapPerformanceTestDefinition, TestTimer) == 0x00000C, "Member 'FEditorMapPerformanceTestDefinition::TestTimer' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionImportWorkflowSettings
// 0x00FC (0x00FC - 0x0000)
struct FBuildPromotionImportWorkflowSettings final
{
public:
	struct FEditorImportWorkflowDefinition        Diffuse;                                           // 0x0000(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Normal;                                            // 0x0018(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        StaticMesh;                                        // 0x0030(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        ReimportStaticMesh;                                // 0x0048(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        BlendShapeMesh;                                    // 0x0060(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        MorphMesh;                                         // 0x0078(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        SkeletalMesh;                                      // 0x0090(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Animation;                                         // 0x00A8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        Sound;                                             // 0x00C0(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	struct FEditorImportWorkflowDefinition        SurroundSound;                                     // 0x00D8(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FEditorImportWorkflowDefinition> OtherAssetsToImport;                               // 0x00F0(0x000C)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildPromotionImportWorkflowSettings) == 0x000004, "Wrong alignment on FBuildPromotionImportWorkflowSettings");
static_assert(sizeof(FBuildPromotionImportWorkflowSettings) == 0x0000FC, "Wrong size on FBuildPromotionImportWorkflowSettings");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, Diffuse) == 0x000000, "Member 'FBuildPromotionImportWorkflowSettings::Diffuse' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, Normal) == 0x000018, "Member 'FBuildPromotionImportWorkflowSettings::Normal' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, StaticMesh) == 0x000030, "Member 'FBuildPromotionImportWorkflowSettings::StaticMesh' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, ReimportStaticMesh) == 0x000048, "Member 'FBuildPromotionImportWorkflowSettings::ReimportStaticMesh' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, BlendShapeMesh) == 0x000060, "Member 'FBuildPromotionImportWorkflowSettings::BlendShapeMesh' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, MorphMesh) == 0x000078, "Member 'FBuildPromotionImportWorkflowSettings::MorphMesh' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, SkeletalMesh) == 0x000090, "Member 'FBuildPromotionImportWorkflowSettings::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, Animation) == 0x0000A8, "Member 'FBuildPromotionImportWorkflowSettings::Animation' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, Sound) == 0x0000C0, "Member 'FBuildPromotionImportWorkflowSettings::Sound' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, SurroundSound) == 0x0000D8, "Member 'FBuildPromotionImportWorkflowSettings::SurroundSound' has a wrong offset!");
static_assert(offsetof(FBuildPromotionImportWorkflowSettings, OtherAssetsToImport) == 0x0000F0, "Member 'FBuildPromotionImportWorkflowSettings::OtherAssetsToImport' has a wrong offset!");

// ScriptStruct Engine.BuildPromotionTestSettings
// 0x0174 (0x0174 - 0x0000)
struct FBuildPromotionTestSettings final
{
public:
	struct FFilePath                              DefaultStaticMeshAsset;                            // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FBuildPromotionImportWorkflowSettings  ImportWorkflow;                                    // 0x000C(0x00FC)(Edit, NativeAccessSpecifierPublic)
	struct FBuildPromotionOpenAssetSettings       OpenAssets;                                        // 0x0108(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FBuildPromotionNewProjectSettings      NewProjectSettings;                                // 0x0150(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              SourceControlMaterial;                             // 0x0168(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildPromotionTestSettings) == 0x000004, "Wrong alignment on FBuildPromotionTestSettings");
static_assert(sizeof(FBuildPromotionTestSettings) == 0x000174, "Wrong size on FBuildPromotionTestSettings");
static_assert(offsetof(FBuildPromotionTestSettings, DefaultStaticMeshAsset) == 0x000000, "Member 'FBuildPromotionTestSettings::DefaultStaticMeshAsset' has a wrong offset!");
static_assert(offsetof(FBuildPromotionTestSettings, ImportWorkflow) == 0x00000C, "Member 'FBuildPromotionTestSettings::ImportWorkflow' has a wrong offset!");
static_assert(offsetof(FBuildPromotionTestSettings, OpenAssets) == 0x000108, "Member 'FBuildPromotionTestSettings::OpenAssets' has a wrong offset!");
static_assert(offsetof(FBuildPromotionTestSettings, NewProjectSettings) == 0x000150, "Member 'FBuildPromotionTestSettings::NewProjectSettings' has a wrong offset!");
static_assert(offsetof(FBuildPromotionTestSettings, SourceControlMaterial) == 0x000168, "Member 'FBuildPromotionTestSettings::SourceControlMaterial' has a wrong offset!");

// ScriptStruct Engine.ParticleSystemReplayFrame
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FParticleSystemReplayFrame final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleSystemReplayFrame) == 0x000004, "Wrong alignment on FParticleSystemReplayFrame");
static_assert(sizeof(FParticleSystemReplayFrame) == 0x00000C, "Wrong size on FParticleSystemReplayFrame");

// ScriptStruct Engine.BlueprintEditorPromotionSettings
// 0x0024 (0x0024 - 0x0000)
struct FBlueprintEditorPromotionSettings final
{
public:
	struct FFilePath                              FirstMeshPath;                                     // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              SecondMeshPath;                                    // 0x000C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultParticleAsset;                              // 0x0018(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintEditorPromotionSettings) == 0x000004, "Wrong alignment on FBlueprintEditorPromotionSettings");
static_assert(sizeof(FBlueprintEditorPromotionSettings) == 0x000024, "Wrong size on FBlueprintEditorPromotionSettings");
static_assert(offsetof(FBlueprintEditorPromotionSettings, FirstMeshPath) == 0x000000, "Member 'FBlueprintEditorPromotionSettings::FirstMeshPath' has a wrong offset!");
static_assert(offsetof(FBlueprintEditorPromotionSettings, SecondMeshPath) == 0x00000C, "Member 'FBlueprintEditorPromotionSettings::SecondMeshPath' has a wrong offset!");
static_assert(offsetof(FBlueprintEditorPromotionSettings, DefaultParticleAsset) == 0x000018, "Member 'FBlueprintEditorPromotionSettings::DefaultParticleAsset' has a wrong offset!");

// ScriptStruct Engine.SubsurfaceProfileStruct
// 0x0024 (0x0024 - 0x0000)
struct FSubsurfaceProfileStruct final
{
public:
	float                                         ScatterRadius;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SubsurfaceColor;                                   // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FalloffColor;                                      // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubsurfaceProfileStruct) == 0x000004, "Wrong alignment on FSubsurfaceProfileStruct");
static_assert(sizeof(FSubsurfaceProfileStruct) == 0x000024, "Wrong size on FSubsurfaceProfileStruct");
static_assert(offsetof(FSubsurfaceProfileStruct, ScatterRadius) == 0x000000, "Member 'FSubsurfaceProfileStruct::ScatterRadius' has a wrong offset!");
static_assert(offsetof(FSubsurfaceProfileStruct, SubsurfaceColor) == 0x000004, "Member 'FSubsurfaceProfileStruct::SubsurfaceColor' has a wrong offset!");
static_assert(offsetof(FSubsurfaceProfileStruct, FalloffColor) == 0x000014, "Member 'FSubsurfaceProfileStruct::FalloffColor' has a wrong offset!");

// ScriptStruct Engine.ParticleEditorPromotionSettings
// 0x000C (0x000C - 0x0000)
struct FParticleEditorPromotionSettings final
{
public:
	struct FFilePath                              DefaultParticleAsset;                              // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleEditorPromotionSettings) == 0x000004, "Wrong alignment on FParticleEditorPromotionSettings");
static_assert(sizeof(FParticleEditorPromotionSettings) == 0x00000C, "Wrong size on FParticleEditorPromotionSettings");
static_assert(offsetof(FParticleEditorPromotionSettings, DefaultParticleAsset) == 0x000000, "Member 'FParticleEditorPromotionSettings::DefaultParticleAsset' has a wrong offset!");

// ScriptStruct Engine.MaterialEditorPromotionSettings
// 0x0024 (0x0024 - 0x0000)
struct FMaterialEditorPromotionSettings final
{
public:
	struct FFilePath                              DefaultMaterialAsset;                              // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultDiffuseTexture;                             // 0x000C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FFilePath                              DefaultNormalTexture;                              // 0x0018(0x000C)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialEditorPromotionSettings) == 0x000004, "Wrong alignment on FMaterialEditorPromotionSettings");
static_assert(sizeof(FMaterialEditorPromotionSettings) == 0x000024, "Wrong size on FMaterialEditorPromotionSettings");
static_assert(offsetof(FMaterialEditorPromotionSettings, DefaultMaterialAsset) == 0x000000, "Member 'FMaterialEditorPromotionSettings::DefaultMaterialAsset' has a wrong offset!");
static_assert(offsetof(FMaterialEditorPromotionSettings, DefaultDiffuseTexture) == 0x00000C, "Member 'FMaterialEditorPromotionSettings::DefaultDiffuseTexture' has a wrong offset!");
static_assert(offsetof(FMaterialEditorPromotionSettings, DefaultNormalTexture) == 0x000018, "Member 'FMaterialEditorPromotionSettings::DefaultNormalTexture' has a wrong offset!");

// ScriptStruct Engine.ComponentOverrideRecord
// 0x0020 (0x0020 - 0x0000)
struct FComponentOverrideRecord final
{
public:
	class UActorComponent*                        ComponentTemplate;                                 // 0x0000(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FComponentKey                          ComponentKey;                                      // 0x0004(0x001C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FComponentOverrideRecord) == 0x000004, "Wrong alignment on FComponentOverrideRecord");
static_assert(sizeof(FComponentOverrideRecord) == 0x000020, "Wrong size on FComponentOverrideRecord");
static_assert(offsetof(FComponentOverrideRecord, ComponentTemplate) == 0x000000, "Member 'FComponentOverrideRecord::ComponentTemplate' has a wrong offset!");
static_assert(offsetof(FComponentOverrideRecord, ComponentKey) == 0x000004, "Member 'FComponentOverrideRecord::ComponentKey' has a wrong offset!");

// ScriptStruct Engine.ExternalToolDefinition
// 0x0048 (0x0048 - 0x0000)
struct FExternalToolDefinition final
{
public:
	class FString                                 ToolName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              ExecutablePath;                                    // 0x000C(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 CommandLineOptions;                                // 0x0018(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         WorkingDirectory;                                  // 0x0024(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
	class FString                                 ScriptExtension;                                   // 0x0030(0x000C)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         ScriptDirectory;                                   // 0x003C(0x000C)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExternalToolDefinition) == 0x000004, "Wrong alignment on FExternalToolDefinition");
static_assert(sizeof(FExternalToolDefinition) == 0x000048, "Wrong size on FExternalToolDefinition");
static_assert(offsetof(FExternalToolDefinition, ToolName) == 0x000000, "Member 'FExternalToolDefinition::ToolName' has a wrong offset!");
static_assert(offsetof(FExternalToolDefinition, ExecutablePath) == 0x00000C, "Member 'FExternalToolDefinition::ExecutablePath' has a wrong offset!");
static_assert(offsetof(FExternalToolDefinition, CommandLineOptions) == 0x000018, "Member 'FExternalToolDefinition::CommandLineOptions' has a wrong offset!");
static_assert(offsetof(FExternalToolDefinition, WorkingDirectory) == 0x000024, "Member 'FExternalToolDefinition::WorkingDirectory' has a wrong offset!");
static_assert(offsetof(FExternalToolDefinition, ScriptExtension) == 0x000030, "Member 'FExternalToolDefinition::ScriptExtension' has a wrong offset!");
static_assert(offsetof(FExternalToolDefinition, ScriptDirectory) == 0x00003C, "Member 'FExternalToolDefinition::ScriptDirectory' has a wrong offset!");

// ScriptStruct Engine.OpenTestAsset
// 0x0010 (0x0010 - 0x0000)
struct FOpenTestAsset final
{
public:
	struct FFilePath                              AssetToOpen;                                       // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	bool                                          bSkipTestWhenUnAttended;                           // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOpenTestAsset) == 0x000004, "Wrong alignment on FOpenTestAsset");
static_assert(sizeof(FOpenTestAsset) == 0x000010, "Wrong size on FOpenTestAsset");
static_assert(offsetof(FOpenTestAsset, AssetToOpen) == 0x000000, "Member 'FOpenTestAsset::AssetToOpen' has a wrong offset!");
static_assert(offsetof(FOpenTestAsset, bSkipTestWhenUnAttended) == 0x00000C, "Member 'FOpenTestAsset::bSkipTestWhenUnAttended' has a wrong offset!");

// ScriptStruct Engine.ParticleRandomSeedInfo
// 0x0018 (0x0018 - 0x0000)
struct FParticleRandomSeedInfo final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGetSeedFromInstance : 1;                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bInstanceSeedIsIndex : 1;                          // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bResetSeedOnEmitterLooping : 1;                    // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRandomlySelectSeedArray : 1;                      // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 RandomSeeds;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleRandomSeedInfo) == 0x000004, "Wrong alignment on FParticleRandomSeedInfo");
static_assert(sizeof(FParticleRandomSeedInfo) == 0x000018, "Wrong size on FParticleRandomSeedInfo");
static_assert(offsetof(FParticleRandomSeedInfo, ParameterName) == 0x000000, "Member 'FParticleRandomSeedInfo::ParameterName' has a wrong offset!");
static_assert(offsetof(FParticleRandomSeedInfo, RandomSeeds) == 0x00000C, "Member 'FParticleRandomSeedInfo::RandomSeeds' has a wrong offset!");

// ScriptStruct Engine.InputAxisProperties
// 0x0010 (0x0010 - 0x0000)
struct FInputAxisProperties final
{
public:
	float                                         DeadZone;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sensitivity;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInvert : 1;                                       // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputAxisProperties) == 0x000004, "Wrong alignment on FInputAxisProperties");
static_assert(sizeof(FInputAxisProperties) == 0x000010, "Wrong size on FInputAxisProperties");
static_assert(offsetof(FInputAxisProperties, DeadZone) == 0x000000, "Member 'FInputAxisProperties::DeadZone' has a wrong offset!");
static_assert(offsetof(FInputAxisProperties, Sensitivity) == 0x000004, "Member 'FInputAxisProperties::Sensitivity' has a wrong offset!");
static_assert(offsetof(FInputAxisProperties, Exponent) == 0x000008, "Member 'FInputAxisProperties::Exponent' has a wrong offset!");

// ScriptStruct Engine.InputAxisConfigEntry
// 0x0018 (0x0018 - 0x0000)
struct FInputAxisConfigEntry final
{
public:
	class FName                                   AxisKeyName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputAxisProperties                   AxisProperties;                                    // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputAxisConfigEntry) == 0x000004, "Wrong alignment on FInputAxisConfigEntry");
static_assert(sizeof(FInputAxisConfigEntry) == 0x000018, "Wrong size on FInputAxisConfigEntry");
static_assert(offsetof(FInputAxisConfigEntry, AxisKeyName) == 0x000000, "Member 'FInputAxisConfigEntry::AxisKeyName' has a wrong offset!");
static_assert(offsetof(FInputAxisConfigEntry, AxisProperties) == 0x000008, "Member 'FInputAxisConfigEntry::AxisProperties' has a wrong offset!");

// ScriptStruct Engine.NavAvoidanceData
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FNavAvoidanceData final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavAvoidanceData) == 0x000004, "Wrong alignment on FNavAvoidanceData");
static_assert(sizeof(FNavAvoidanceData) == 0x00003C, "Wrong size on FNavAvoidanceData");

// ScriptStruct Engine.BlendProfileBoneEntry
// 0x0010 (0x0010 - 0x0000)
struct FBlendProfileBoneEntry final
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0000(0x000C)(Edit, NativeAccessSpecifierPublic)
	float                                         BlendScale;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendProfileBoneEntry) == 0x000004, "Wrong alignment on FBlendProfileBoneEntry");
static_assert(sizeof(FBlendProfileBoneEntry) == 0x000010, "Wrong size on FBlendProfileBoneEntry");
static_assert(offsetof(FBlendProfileBoneEntry, BoneReference) == 0x000000, "Member 'FBlendProfileBoneEntry::BoneReference' has a wrong offset!");
static_assert(offsetof(FBlendProfileBoneEntry, BlendScale) == 0x00000C, "Member 'FBlendProfileBoneEntry::BlendScale' has a wrong offset!");

// ScriptStruct Engine.AnimParentNodeAssetOverride
// 0x0014 (0x0014 - 0x0000)
struct FAnimParentNodeAssetOverride final
{
public:
	class UAnimationAsset*                        NewAsset;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ParentNodeGuid;                                    // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimParentNodeAssetOverride) == 0x000004, "Wrong alignment on FAnimParentNodeAssetOverride");
static_assert(sizeof(FAnimParentNodeAssetOverride) == 0x000014, "Wrong size on FAnimParentNodeAssetOverride");
static_assert(offsetof(FAnimParentNodeAssetOverride, NewAsset) == 0x000000, "Member 'FAnimParentNodeAssetOverride::NewAsset' has a wrong offset!");
static_assert(offsetof(FAnimParentNodeAssetOverride, ParentNodeGuid) == 0x000004, "Member 'FAnimParentNodeAssetOverride::ParentNodeGuid' has a wrong offset!");

// ScriptStruct Engine.AnimGroupInfo
// 0x0018 (0x0018 - 0x0000)
struct FAnimGroupInfo final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimGroupInfo) == 0x000004, "Wrong alignment on FAnimGroupInfo");
static_assert(sizeof(FAnimGroupInfo) == 0x000018, "Wrong size on FAnimGroupInfo");
static_assert(offsetof(FAnimGroupInfo, Name) == 0x000000, "Member 'FAnimGroupInfo::Name' has a wrong offset!");
static_assert(offsetof(FAnimGroupInfo, Color) == 0x000008, "Member 'FAnimGroupInfo::Color' has a wrong offset!");

// ScriptStruct Engine.DialogueWaveParameter
// 0x0014 (0x0014 - 0x0000)
struct FDialogueWaveParameter final
{
public:
	class UDialogueWave*                          DialogueWave;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0004(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueWaveParameter) == 0x000004, "Wrong alignment on FDialogueWaveParameter");
static_assert(sizeof(FDialogueWaveParameter) == 0x000014, "Wrong size on FDialogueWaveParameter");
static_assert(offsetof(FDialogueWaveParameter, DialogueWave) == 0x000000, "Member 'FDialogueWaveParameter::DialogueWave' has a wrong offset!");
static_assert(offsetof(FDialogueWaveParameter, Context) == 0x000004, "Member 'FDialogueWaveParameter::Context' has a wrong offset!");

// ScriptStruct Engine.CustomProfile
// 0x0014 (0x0014 - 0x0000)
struct FCustomProfile final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FResponseChannel>               CustomResponses;                                   // 0x0008(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomProfile) == 0x000004, "Wrong alignment on FCustomProfile");
static_assert(sizeof(FCustomProfile) == 0x000014, "Wrong size on FCustomProfile");
static_assert(offsetof(FCustomProfile, Name) == 0x000000, "Member 'FCustomProfile::Name' has a wrong offset!");
static_assert(offsetof(FCustomProfile, CustomResponses) == 0x000008, "Member 'FCustomProfile::CustomResponses' has a wrong offset!");

// ScriptStruct Engine.CustomChannelSetup
// 0x0010 (0x0010 - 0x0000)
struct FCustomChannelSetup final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            DefaultResponse;                                   // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceType;                                        // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStaticObject;                                     // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomChannelSetup) == 0x000004, "Wrong alignment on FCustomChannelSetup");
static_assert(sizeof(FCustomChannelSetup) == 0x000010, "Wrong size on FCustomChannelSetup");
static_assert(offsetof(FCustomChannelSetup, Channel) == 0x000000, "Member 'FCustomChannelSetup::Channel' has a wrong offset!");
static_assert(offsetof(FCustomChannelSetup, Name) == 0x000004, "Member 'FCustomChannelSetup::Name' has a wrong offset!");
static_assert(offsetof(FCustomChannelSetup, DefaultResponse) == 0x00000C, "Member 'FCustomChannelSetup::DefaultResponse' has a wrong offset!");
static_assert(offsetof(FCustomChannelSetup, bTraceType) == 0x00000D, "Member 'FCustomChannelSetup::bTraceType' has a wrong offset!");
static_assert(offsetof(FCustomChannelSetup, bStaticObject) == 0x00000E, "Member 'FCustomChannelSetup::bStaticObject' has a wrong offset!");

// ScriptStruct Engine.EventGraphFastCallPair
// 0x0008 (0x0008 - 0x0000)
struct FEventGraphFastCallPair final
{
public:
	class UFunction*                              FunctionToPatch;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventGraphCallOffset;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventGraphFastCallPair) == 0x000004, "Wrong alignment on FEventGraphFastCallPair");
static_assert(sizeof(FEventGraphFastCallPair) == 0x000008, "Wrong size on FEventGraphFastCallPair");
static_assert(offsetof(FEventGraphFastCallPair, FunctionToPatch) == 0x000000, "Member 'FEventGraphFastCallPair::FunctionToPatch' has a wrong offset!");
static_assert(offsetof(FEventGraphFastCallPair, EventGraphCallOffset) == 0x000004, "Member 'FEventGraphFastCallPair::EventGraphCallOffset' has a wrong offset!");

// ScriptStruct Engine.BlueprintDebugData
// 0x0001 (0x0001 - 0x0000)
struct FBlueprintDebugData final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlueprintDebugData) == 0x000001, "Wrong alignment on FBlueprintDebugData");
static_assert(sizeof(FBlueprintDebugData) == 0x000001, "Wrong size on FBlueprintDebugData");

// ScriptStruct Engine.PointerToUberGraphFrame
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FPointerToUberGraphFrame final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPointerToUberGraphFrame) == 0x000004, "Wrong alignment on FPointerToUberGraphFrame");
static_assert(sizeof(FPointerToUberGraphFrame) == 0x000004, "Wrong size on FPointerToUberGraphFrame");

// ScriptStruct Engine.DebuggingInfoForSingleFunction
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x04) FDebuggingInfoForSingleFunction final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebuggingInfoForSingleFunction) == 0x000004, "Wrong alignment on FDebuggingInfoForSingleFunction");
static_assert(sizeof(FDebuggingInfoForSingleFunction) == 0x0000F0, "Wrong size on FDebuggingInfoForSingleFunction");

// ScriptStruct Engine.AnimationFrameSnapshot
// 0x0001 (0x0001 - 0x0000)
struct FAnimationFrameSnapshot final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationFrameSnapshot) == 0x000001, "Wrong alignment on FAnimationFrameSnapshot");
static_assert(sizeof(FAnimationFrameSnapshot) == 0x000001, "Wrong size on FAnimationFrameSnapshot");

// ScriptStruct Engine.SubTrackGroup
// 0x001C (0x001C - 0x0000)
struct FSubTrackGroup final
{
public:
	class FString                                 GroupName;                                         // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TrackIndices;                                      // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bIsCollapsed : 1;                                  // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsSelected : 1;                                   // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubTrackGroup) == 0x000004, "Wrong alignment on FSubTrackGroup");
static_assert(sizeof(FSubTrackGroup) == 0x00001C, "Wrong size on FSubTrackGroup");
static_assert(offsetof(FSubTrackGroup, GroupName) == 0x000000, "Member 'FSubTrackGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FSubTrackGroup, TrackIndices) == 0x00000C, "Member 'FSubTrackGroup::TrackIndices' has a wrong offset!");

// ScriptStruct Engine.StateMachineDebugData
// 0x0084 (0x0084 - 0x0000)
struct alignas(0x04) FStateMachineDebugData final
{
public:
	uint8                                         Pad_0[0x84];                                       // 0x0000(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateMachineDebugData) == 0x000004, "Wrong alignment on FStateMachineDebugData");
static_assert(sizeof(FStateMachineDebugData) == 0x000084, "Wrong size on FStateMachineDebugData");

// ScriptStruct Engine.SupportedSubTrackInfo
// 0x0014 (0x0014 - 0x0000)
struct FSupportedSubTrackInfo final
{
public:
	TSubclassOf<class UInterpTrack>               SupportedClass;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubTrackName;                                      // 0x0004(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportedSubTrackInfo) == 0x000004, "Wrong alignment on FSupportedSubTrackInfo");
static_assert(sizeof(FSupportedSubTrackInfo) == 0x000014, "Wrong size on FSupportedSubTrackInfo");
static_assert(offsetof(FSupportedSubTrackInfo, SupportedClass) == 0x000000, "Member 'FSupportedSubTrackInfo::SupportedClass' has a wrong offset!");
static_assert(offsetof(FSupportedSubTrackInfo, SubTrackName) == 0x000004, "Member 'FSupportedSubTrackInfo::SubTrackName' has a wrong offset!");
static_assert(offsetof(FSupportedSubTrackInfo, GroupIndex) == 0x000010, "Member 'FSupportedSubTrackInfo::GroupIndex' has a wrong offset!");

// ScriptStruct Engine.DialogueContextMapping
// 0x0018 (0x0018 - 0x0000)
struct FDialogueContextMapping final
{
public:
	struct FDialogueContext                       Context;                                           // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	class USoundWave*                             SoundWave;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueSoundWaveProxy*                Proxy;                                             // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueContextMapping) == 0x000004, "Wrong alignment on FDialogueContextMapping");
static_assert(sizeof(FDialogueContextMapping) == 0x000018, "Wrong size on FDialogueContextMapping");
static_assert(offsetof(FDialogueContextMapping, Context) == 0x000000, "Member 'FDialogueContextMapping::Context' has a wrong offset!");
static_assert(offsetof(FDialogueContextMapping, SoundWave) == 0x000010, "Member 'FDialogueContextMapping::SoundWave' has a wrong offset!");
static_assert(offsetof(FDialogueContextMapping, Proxy) == 0x000014, "Member 'FDialogueContextMapping::Proxy' has a wrong offset!");

// ScriptStruct Engine.AggregateGeometry2D
// 0x0024 (0x0024 - 0x0000)
struct FAggregateGeometry2D final
{
public:
	TArray<struct FCircleElement2D>               CircleElements;                                    // 0x0000(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoxElement2D>                  BoxElements;                                       // 0x000C(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FConvexElement2D>               ConvexElements;                                    // 0x0018(0x000C)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAggregateGeometry2D) == 0x000004, "Wrong alignment on FAggregateGeometry2D");
static_assert(sizeof(FAggregateGeometry2D) == 0x000024, "Wrong size on FAggregateGeometry2D");
static_assert(offsetof(FAggregateGeometry2D, CircleElements) == 0x000000, "Member 'FAggregateGeometry2D::CircleElements' has a wrong offset!");
static_assert(offsetof(FAggregateGeometry2D, BoxElements) == 0x00000C, "Member 'FAggregateGeometry2D::BoxElements' has a wrong offset!");
static_assert(offsetof(FAggregateGeometry2D, ConvexElements) == 0x000018, "Member 'FAggregateGeometry2D::ConvexElements' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputAxisDelegateBinding
// 0x0010 (0x0014 - 0x0004)
struct FBlueprintInputAxisDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	class FName                                   InputAxisName;                                     // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintInputAxisDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputAxisDelegateBinding");
static_assert(sizeof(FBlueprintInputAxisDelegateBinding) == 0x000014, "Wrong size on FBlueprintInputAxisDelegateBinding");
static_assert(offsetof(FBlueprintInputAxisDelegateBinding, InputAxisName) == 0x000004, "Member 'FBlueprintInputAxisDelegateBinding::InputAxisName' has a wrong offset!");
static_assert(offsetof(FBlueprintInputAxisDelegateBinding, FunctionNameToBind) == 0x00000C, "Member 'FBlueprintInputAxisDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.PluginRedirect
// 0x0018 (0x0018 - 0x0000)
struct FPluginRedirect final
{
public:
	class FString                                 OldPluginName;                                     // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewPluginName;                                     // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPluginRedirect) == 0x000004, "Wrong alignment on FPluginRedirect");
static_assert(sizeof(FPluginRedirect) == 0x000018, "Wrong size on FPluginRedirect");
static_assert(offsetof(FPluginRedirect, OldPluginName) == 0x000000, "Member 'FPluginRedirect::OldPluginName' has a wrong offset!");
static_assert(offsetof(FPluginRedirect, NewPluginName) == 0x00000C, "Member 'FPluginRedirect::NewPluginName' has a wrong offset!");

// ScriptStruct Engine.ClassRedirect
// 0x003C (0x003C - 0x0000)
struct FClassRedirect final
{
public:
	class FName                                   ObjectName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldClassName;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassName;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OldSubobjName;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewSubobjName;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassClass;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewClassPackage;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstanceOnly;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClassRedirect) == 0x000004, "Wrong alignment on FClassRedirect");
static_assert(sizeof(FClassRedirect) == 0x00003C, "Wrong size on FClassRedirect");
static_assert(offsetof(FClassRedirect, ObjectName) == 0x000000, "Member 'FClassRedirect::ObjectName' has a wrong offset!");
static_assert(offsetof(FClassRedirect, OldClassName) == 0x000008, "Member 'FClassRedirect::OldClassName' has a wrong offset!");
static_assert(offsetof(FClassRedirect, NewClassName) == 0x000010, "Member 'FClassRedirect::NewClassName' has a wrong offset!");
static_assert(offsetof(FClassRedirect, OldSubobjName) == 0x000018, "Member 'FClassRedirect::OldSubobjName' has a wrong offset!");
static_assert(offsetof(FClassRedirect, NewSubobjName) == 0x000020, "Member 'FClassRedirect::NewSubobjName' has a wrong offset!");
static_assert(offsetof(FClassRedirect, NewClassClass) == 0x000028, "Member 'FClassRedirect::NewClassClass' has a wrong offset!");
static_assert(offsetof(FClassRedirect, NewClassPackage) == 0x000030, "Member 'FClassRedirect::NewClassPackage' has a wrong offset!");
static_assert(offsetof(FClassRedirect, InstanceOnly) == 0x000038, "Member 'FClassRedirect::InstanceOnly' has a wrong offset!");

// ScriptStruct Engine.ScreenMessageString
// 0x0028 (0x0028 - 0x0000)
struct FScreenMessageString final
{
public:
	uint64                                        Key;                                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScreenMessage;                                     // 0x0008(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DisplayColor;                                      // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeToDisplay;                                     // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTimeDisplayed;                              // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextScale;                                         // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenMessageString) == 0x000004, "Wrong alignment on FScreenMessageString");
static_assert(sizeof(FScreenMessageString) == 0x000028, "Wrong size on FScreenMessageString");
static_assert(offsetof(FScreenMessageString, Key) == 0x000000, "Member 'FScreenMessageString::Key' has a wrong offset!");
static_assert(offsetof(FScreenMessageString, ScreenMessage) == 0x000008, "Member 'FScreenMessageString::ScreenMessage' has a wrong offset!");
static_assert(offsetof(FScreenMessageString, DisplayColor) == 0x000014, "Member 'FScreenMessageString::DisplayColor' has a wrong offset!");
static_assert(offsetof(FScreenMessageString, TimeToDisplay) == 0x000018, "Member 'FScreenMessageString::TimeToDisplay' has a wrong offset!");
static_assert(offsetof(FScreenMessageString, CurrentTimeDisplayed) == 0x00001C, "Member 'FScreenMessageString::CurrentTimeDisplayed' has a wrong offset!");
static_assert(offsetof(FScreenMessageString, TextScale) == 0x000020, "Member 'FScreenMessageString::TextScale' has a wrong offset!");

// ScriptStruct Engine.DropNoteInfo
// 0x0024 (0x0024 - 0x0000)
struct FDropNoteInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropNoteInfo) == 0x000004, "Wrong alignment on FDropNoteInfo");
static_assert(sizeof(FDropNoteInfo) == 0x000024, "Wrong size on FDropNoteInfo");
static_assert(offsetof(FDropNoteInfo, Location) == 0x000000, "Member 'FDropNoteInfo::Location' has a wrong offset!");
static_assert(offsetof(FDropNoteInfo, Rotation) == 0x00000C, "Member 'FDropNoteInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FDropNoteInfo, Comment) == 0x000018, "Member 'FDropNoteInfo::Comment' has a wrong offset!");

// ScriptStruct Engine.AnimNode_StateMachine
// 0x0074 (0x0094 - 0x0020)
struct FAnimNode_StateMachine final : public FAnimNode_Base
{
public:
	int32                                         StateMachineIndexInClass;                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTransitionsPerFrame;                            // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentState;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x60];                                      // 0x0034(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_StateMachine) == 0x000004, "Wrong alignment on FAnimNode_StateMachine");
static_assert(sizeof(FAnimNode_StateMachine) == 0x000094, "Wrong size on FAnimNode_StateMachine");
static_assert(offsetof(FAnimNode_StateMachine, StateMachineIndexInClass) == 0x000020, "Member 'FAnimNode_StateMachine::StateMachineIndexInClass' has a wrong offset!");
static_assert(offsetof(FAnimNode_StateMachine, MaxTransitionsPerFrame) == 0x000024, "Member 'FAnimNode_StateMachine::MaxTransitionsPerFrame' has a wrong offset!");
static_assert(offsetof(FAnimNode_StateMachine, CurrentState) == 0x00002C, "Member 'FAnimNode_StateMachine::CurrentState' has a wrong offset!");
static_assert(offsetof(FAnimNode_StateMachine, ElapsedTime) == 0x000030, "Member 'FAnimNode_StateMachine::ElapsedTime' has a wrong offset!");

// ScriptStruct Engine.NetDriverDefinition
// 0x0018 (0x0018 - 0x0000)
struct FNetDriverDefinition final
{
public:
	class FName                                   DefName;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriverClassName;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriverClassNameFallback;                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetDriverDefinition) == 0x000004, "Wrong alignment on FNetDriverDefinition");
static_assert(sizeof(FNetDriverDefinition) == 0x000018, "Wrong size on FNetDriverDefinition");
static_assert(offsetof(FNetDriverDefinition, DefName) == 0x000000, "Member 'FNetDriverDefinition::DefName' has a wrong offset!");
static_assert(offsetof(FNetDriverDefinition, DriverClassName) == 0x000008, "Member 'FNetDriverDefinition::DriverClassName' has a wrong offset!");
static_assert(offsetof(FNetDriverDefinition, DriverClassNameFallback) == 0x000010, "Member 'FNetDriverDefinition::DriverClassNameFallback' has a wrong offset!");

// ScriptStruct Engine.FontParameterValue
// 0x0020 (0x0020 - 0x0000)
struct FFontParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  FontValue;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontPage;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontParameterValue) == 0x000004, "Wrong alignment on FFontParameterValue");
static_assert(sizeof(FFontParameterValue) == 0x000020, "Wrong size on FFontParameterValue");
static_assert(offsetof(FFontParameterValue, ParameterName) == 0x000000, "Member 'FFontParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FFontParameterValue, FontValue) == 0x000008, "Member 'FFontParameterValue::FontValue' has a wrong offset!");
static_assert(offsetof(FFontParameterValue, FontPage) == 0x00000C, "Member 'FFontParameterValue::FontPage' has a wrong offset!");
static_assert(offsetof(FFontParameterValue, ExpressionGUID) == 0x000010, "Member 'FFontParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.TextSizingParameters
// 0x0024 (0x0024 - 0x0000)
struct FTextSizingParameters final
{
public:
	float                                         DrawX;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawY;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawXL;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawYL;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scaling;                                           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFont*                                  DrawFont;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpacingAdjust;                                     // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextSizingParameters) == 0x000004, "Wrong alignment on FTextSizingParameters");
static_assert(sizeof(FTextSizingParameters) == 0x000024, "Wrong size on FTextSizingParameters");
static_assert(offsetof(FTextSizingParameters, DrawX) == 0x000000, "Member 'FTextSizingParameters::DrawX' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, DrawY) == 0x000004, "Member 'FTextSizingParameters::DrawY' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, DrawXL) == 0x000008, "Member 'FTextSizingParameters::DrawXL' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, DrawYL) == 0x00000C, "Member 'FTextSizingParameters::DrawYL' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, Scaling) == 0x000010, "Member 'FTextSizingParameters::Scaling' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, DrawFont) == 0x000018, "Member 'FTextSizingParameters::DrawFont' has a wrong offset!");
static_assert(offsetof(FTextSizingParameters, SpacingAdjust) == 0x00001C, "Member 'FTextSizingParameters::SpacingAdjust' has a wrong offset!");

// ScriptStruct Engine.CanvasIcon
// 0x0014 (0x0014 - 0x0000)
struct FCanvasIcon final
{
public:
	class UTexture*                               Texture;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         U;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UL;                                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VL;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCanvasIcon) == 0x000004, "Wrong alignment on FCanvasIcon");
static_assert(sizeof(FCanvasIcon) == 0x000014, "Wrong size on FCanvasIcon");
static_assert(offsetof(FCanvasIcon, Texture) == 0x000000, "Member 'FCanvasIcon::Texture' has a wrong offset!");
static_assert(offsetof(FCanvasIcon, U) == 0x000004, "Member 'FCanvasIcon::U' has a wrong offset!");
static_assert(offsetof(FCanvasIcon, V) == 0x000008, "Member 'FCanvasIcon::V' has a wrong offset!");
static_assert(offsetof(FCanvasIcon, UL) == 0x00000C, "Member 'FCanvasIcon::UL' has a wrong offset!");
static_assert(offsetof(FCanvasIcon, VL) == 0x000010, "Member 'FCanvasIcon::VL' has a wrong offset!");

// ScriptStruct Engine.RuntimeCurveLinearColor
// 0x0154 (0x0154 - 0x0000)
struct FRuntimeCurveLinearColor final
{
public:
	struct FRichCurve                             ColorCurves[0x4];                                  // 0x0000(0x0054)(NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      ExternalCurve;                                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeCurveLinearColor) == 0x000004, "Wrong alignment on FRuntimeCurveLinearColor");
static_assert(sizeof(FRuntimeCurveLinearColor) == 0x000154, "Wrong size on FRuntimeCurveLinearColor");
static_assert(offsetof(FRuntimeCurveLinearColor, ColorCurves) == 0x000000, "Member 'FRuntimeCurveLinearColor::ColorCurves' has a wrong offset!");
static_assert(offsetof(FRuntimeCurveLinearColor, ExternalCurve) == 0x000150, "Member 'FRuntimeCurveLinearColor::ExternalCurve' has a wrong offset!");

// ScriptStruct Engine.AnimationPotentialTransition
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FAnimationPotentialTransition final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationPotentialTransition) == 0x000004, "Wrong alignment on FAnimationPotentialTransition");
static_assert(sizeof(FAnimationPotentialTransition) == 0x000008, "Wrong size on FAnimationPotentialTransition");

// ScriptStruct Engine.DestructibleChunkParameters
// 0x0004 (0x0004 - 0x0000)
struct FDestructibleChunkParameters final
{
public:
	bool                                          bIsSupportChunk;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDoNotFracture;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDoNotDamage;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDoNotCrumble;                                     // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleChunkParameters) == 0x000001, "Wrong alignment on FDestructibleChunkParameters");
static_assert(sizeof(FDestructibleChunkParameters) == 0x000004, "Wrong size on FDestructibleChunkParameters");
static_assert(offsetof(FDestructibleChunkParameters, bIsSupportChunk) == 0x000000, "Member 'FDestructibleChunkParameters::bIsSupportChunk' has a wrong offset!");
static_assert(offsetof(FDestructibleChunkParameters, bDoNotFracture) == 0x000001, "Member 'FDestructibleChunkParameters::bDoNotFracture' has a wrong offset!");
static_assert(offsetof(FDestructibleChunkParameters, bDoNotDamage) == 0x000002, "Member 'FDestructibleChunkParameters::bDoNotDamage' has a wrong offset!");
static_assert(offsetof(FDestructibleChunkParameters, bDoNotCrumble) == 0x000003, "Member 'FDestructibleChunkParameters::bDoNotCrumble' has a wrong offset!");

// ScriptStruct Engine.FractureMaterial
// 0x0024 (0x0024 - 0x0000)
struct FFractureMaterial final
{
public:
	struct FVector2D                              UVScale;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              UVOffset;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         UAngle;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteriorElementIndex;                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFractureMaterial) == 0x000004, "Wrong alignment on FFractureMaterial");
static_assert(sizeof(FFractureMaterial) == 0x000024, "Wrong size on FFractureMaterial");
static_assert(offsetof(FFractureMaterial, UVScale) == 0x000000, "Member 'FFractureMaterial::UVScale' has a wrong offset!");
static_assert(offsetof(FFractureMaterial, UVOffset) == 0x000008, "Member 'FFractureMaterial::UVOffset' has a wrong offset!");
static_assert(offsetof(FFractureMaterial, Tangent) == 0x000010, "Member 'FFractureMaterial::Tangent' has a wrong offset!");
static_assert(offsetof(FFractureMaterial, UAngle) == 0x00001C, "Member 'FFractureMaterial::UAngle' has a wrong offset!");
static_assert(offsetof(FFractureMaterial, InteriorElementIndex) == 0x000020, "Member 'FFractureMaterial::InteriorElementIndex' has a wrong offset!");

// ScriptStruct Engine.PhysicalSurfaceName
// 0x000C (0x000C - 0x0000)
struct FPhysicalSurfaceName final
{
public:
	EPhysicalSurface                              Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalSurfaceName) == 0x000004, "Wrong alignment on FPhysicalSurfaceName");
static_assert(sizeof(FPhysicalSurfaceName) == 0x00000C, "Wrong size on FPhysicalSurfaceName");
static_assert(offsetof(FPhysicalSurfaceName, Type) == 0x000000, "Member 'FPhysicalSurfaceName::Type' has a wrong offset!");
static_assert(offsetof(FPhysicalSurfaceName, Name) == 0x000004, "Member 'FPhysicalSurfaceName::Name' has a wrong offset!");

// ScriptStruct Engine.BlueprintInputActionDelegateBinding
// 0x0014 (0x0018 - 0x0004)
struct FBlueprintInputActionDelegateBinding final : public FBlueprintInputDelegateBinding
{
public:
	class FName                                   InputActionName;                                   // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   InputKeyEvent;                                     // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FunctionNameToBind;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintInputActionDelegateBinding) == 0x000004, "Wrong alignment on FBlueprintInputActionDelegateBinding");
static_assert(sizeof(FBlueprintInputActionDelegateBinding) == 0x000018, "Wrong size on FBlueprintInputActionDelegateBinding");
static_assert(offsetof(FBlueprintInputActionDelegateBinding, InputActionName) == 0x000004, "Member 'FBlueprintInputActionDelegateBinding::InputActionName' has a wrong offset!");
static_assert(offsetof(FBlueprintInputActionDelegateBinding, InputKeyEvent) == 0x00000C, "Member 'FBlueprintInputActionDelegateBinding::InputKeyEvent' has a wrong offset!");
static_assert(offsetof(FBlueprintInputActionDelegateBinding, FunctionNameToBind) == 0x000010, "Member 'FBlueprintInputActionDelegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct Engine.GPUSpriteEmitterInfo
// 0x0200 (0x0200 - 0x0000)
struct FGPUSpriteEmitterInfo final
{
public:
	class UParticleModuleRequired*                RequiredModule;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleSpawn*                   SpawnModule;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleModuleSpawnPerUnit*            SpawnPerUnitModule;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleModule*>                SpawnModules;                                      // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGPUSpriteLocalVectorFieldInfo         LocalVectorField;                                  // 0x0020(0x0070)(NativeAccessSpecifierPublic)
	struct FFloatDistribution                     VectorFieldScale;                                  // 0x0090(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     DragCoefficient;                                   // 0x00AC(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     PointAttractorStrength;                            // 0x00C8(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFloatDistribution                     Resilience;                                        // 0x00E4(0x001C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAcceleration;                              // 0x0100(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PointAttractorPosition;                            // 0x010C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PointAttractorRadiusSq;                            // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetBase;                                   // 0x011C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetRange;                                  // 0x0128(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InvMaxSize;                                        // 0x0134(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InvRotationRateScale;                              // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLifetime;                                       // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxParticleCount;                                  // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleScreenAlignment                      ScreenAlignment;                                   // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleAxisLock                             LockAxisFlag;                                      // 0x0149(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x2];                                      // 0x014A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableCollision : 1;                              // 0x014C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EParticleCollisionMode                        CollisionMode;                                     // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionVector                 DynamicColor;                                      // 0x0154(0x0028)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DynamicAlpha;                                      // 0x017C(0x0028)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionVector                 DynamicColorScale;                                 // 0x01A4(0x0028)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRawDistributionFloat                  DynamicAlphaScale;                                 // 0x01CC(0x0028)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0xC];                                      // 0x01F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGPUSpriteEmitterInfo) == 0x000010, "Wrong alignment on FGPUSpriteEmitterInfo");
static_assert(sizeof(FGPUSpriteEmitterInfo) == 0x000200, "Wrong size on FGPUSpriteEmitterInfo");
static_assert(offsetof(FGPUSpriteEmitterInfo, RequiredModule) == 0x000000, "Member 'FGPUSpriteEmitterInfo::RequiredModule' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, SpawnModule) == 0x000004, "Member 'FGPUSpriteEmitterInfo::SpawnModule' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, SpawnPerUnitModule) == 0x000008, "Member 'FGPUSpriteEmitterInfo::SpawnPerUnitModule' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, SpawnModules) == 0x00000C, "Member 'FGPUSpriteEmitterInfo::SpawnModules' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, LocalVectorField) == 0x000020, "Member 'FGPUSpriteEmitterInfo::LocalVectorField' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, VectorFieldScale) == 0x000090, "Member 'FGPUSpriteEmitterInfo::VectorFieldScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, DragCoefficient) == 0x0000AC, "Member 'FGPUSpriteEmitterInfo::DragCoefficient' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, PointAttractorStrength) == 0x0000C8, "Member 'FGPUSpriteEmitterInfo::PointAttractorStrength' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, Resilience) == 0x0000E4, "Member 'FGPUSpriteEmitterInfo::Resilience' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, ConstantAcceleration) == 0x000100, "Member 'FGPUSpriteEmitterInfo::ConstantAcceleration' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, PointAttractorPosition) == 0x00010C, "Member 'FGPUSpriteEmitterInfo::PointAttractorPosition' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, PointAttractorRadiusSq) == 0x000118, "Member 'FGPUSpriteEmitterInfo::PointAttractorRadiusSq' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, OrbitOffsetBase) == 0x00011C, "Member 'FGPUSpriteEmitterInfo::OrbitOffsetBase' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, OrbitOffsetRange) == 0x000128, "Member 'FGPUSpriteEmitterInfo::OrbitOffsetRange' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, InvMaxSize) == 0x000134, "Member 'FGPUSpriteEmitterInfo::InvMaxSize' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, InvRotationRateScale) == 0x00013C, "Member 'FGPUSpriteEmitterInfo::InvRotationRateScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, MaxLifetime) == 0x000140, "Member 'FGPUSpriteEmitterInfo::MaxLifetime' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, MaxParticleCount) == 0x000144, "Member 'FGPUSpriteEmitterInfo::MaxParticleCount' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, ScreenAlignment) == 0x000148, "Member 'FGPUSpriteEmitterInfo::ScreenAlignment' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, LockAxisFlag) == 0x000149, "Member 'FGPUSpriteEmitterInfo::LockAxisFlag' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, CollisionMode) == 0x000150, "Member 'FGPUSpriteEmitterInfo::CollisionMode' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, DynamicColor) == 0x000154, "Member 'FGPUSpriteEmitterInfo::DynamicColor' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, DynamicAlpha) == 0x00017C, "Member 'FGPUSpriteEmitterInfo::DynamicAlpha' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, DynamicColorScale) == 0x0001A4, "Member 'FGPUSpriteEmitterInfo::DynamicColorScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteEmitterInfo, DynamicAlphaScale) == 0x0001CC, "Member 'FGPUSpriteEmitterInfo::DynamicAlphaScale' has a wrong offset!");

// ScriptStruct Engine.FontImportOptionsData
// 0x0094 (0x0094 - 0x0000)
struct FFontImportOptionsData final
{
public:
	class FString                                 FontName;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableAntialiasing : 1;                           // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableBold : 1;                                   // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableItalic : 1;                                 // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableUnderline : 1;                              // 0x0010(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAlphaOnly : 1;                                    // 0x0010(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFontImportCharacterSet                       CharacterSet;                                      // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Chars;                                             // 0x0018(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UnicodeRange;                                      // 0x0024(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharsFilePath;                                     // 0x0030(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharsFileWildcard;                                 // 0x003C(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCreatePrintableOnly : 1;                          // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIncludeASCIIRange : 1;                            // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ForegroundColor;                                   // 0x004C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bEnableDropShadow : 1;                             // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TexturePageWidth;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TexturePageMaxHeight;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPadding;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YPadding;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxTop;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxBottom;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxRight;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendBoxLeft;                                     // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableLegacyMode : 1;                             // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kerning;                                           // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseDistanceFieldAlpha : 1;                        // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DistanceFieldScaleFactor;                          // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldScanRadiusScale;                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontImportOptionsData) == 0x000004, "Wrong alignment on FFontImportOptionsData");
static_assert(sizeof(FFontImportOptionsData) == 0x000094, "Wrong size on FFontImportOptionsData");
static_assert(offsetof(FFontImportOptionsData, FontName) == 0x000000, "Member 'FFontImportOptionsData::FontName' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, Height) == 0x00000C, "Member 'FFontImportOptionsData::Height' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, CharacterSet) == 0x000014, "Member 'FFontImportOptionsData::CharacterSet' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, Chars) == 0x000018, "Member 'FFontImportOptionsData::Chars' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, UnicodeRange) == 0x000024, "Member 'FFontImportOptionsData::UnicodeRange' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, CharsFilePath) == 0x000030, "Member 'FFontImportOptionsData::CharsFilePath' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, CharsFileWildcard) == 0x00003C, "Member 'FFontImportOptionsData::CharsFileWildcard' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, ForegroundColor) == 0x00004C, "Member 'FFontImportOptionsData::ForegroundColor' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, TexturePageWidth) == 0x000060, "Member 'FFontImportOptionsData::TexturePageWidth' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, TexturePageMaxHeight) == 0x000064, "Member 'FFontImportOptionsData::TexturePageMaxHeight' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, XPadding) == 0x000068, "Member 'FFontImportOptionsData::XPadding' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, YPadding) == 0x00006C, "Member 'FFontImportOptionsData::YPadding' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, ExtendBoxTop) == 0x000070, "Member 'FFontImportOptionsData::ExtendBoxTop' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, ExtendBoxBottom) == 0x000074, "Member 'FFontImportOptionsData::ExtendBoxBottom' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, ExtendBoxRight) == 0x000078, "Member 'FFontImportOptionsData::ExtendBoxRight' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, ExtendBoxLeft) == 0x00007C, "Member 'FFontImportOptionsData::ExtendBoxLeft' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, Kerning) == 0x000084, "Member 'FFontImportOptionsData::Kerning' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, DistanceFieldScaleFactor) == 0x00008C, "Member 'FFontImportOptionsData::DistanceFieldScaleFactor' has a wrong offset!");
static_assert(offsetof(FFontImportOptionsData, DistanceFieldScanRadiusScale) == 0x000090, "Member 'FFontImportOptionsData::DistanceFieldScanRadiusScale' has a wrong offset!");

// ScriptStruct Engine.FontCharacter
// 0x0018 (0x0018 - 0x0000)
struct FFontCharacter final
{
public:
	int32                                         StartU;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartV;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         USize;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VSize;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TextureIndex;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VerticalOffset;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontCharacter) == 0x000004, "Wrong alignment on FFontCharacter");
static_assert(sizeof(FFontCharacter) == 0x000018, "Wrong size on FFontCharacter");
static_assert(offsetof(FFontCharacter, StartU) == 0x000000, "Member 'FFontCharacter::StartU' has a wrong offset!");
static_assert(offsetof(FFontCharacter, StartV) == 0x000004, "Member 'FFontCharacter::StartV' has a wrong offset!");
static_assert(offsetof(FFontCharacter, USize) == 0x000008, "Member 'FFontCharacter::USize' has a wrong offset!");
static_assert(offsetof(FFontCharacter, VSize) == 0x00000C, "Member 'FFontCharacter::VSize' has a wrong offset!");
static_assert(offsetof(FFontCharacter, TextureIndex) == 0x000010, "Member 'FFontCharacter::TextureIndex' has a wrong offset!");
static_assert(offsetof(FFontCharacter, VerticalOffset) == 0x000014, "Member 'FFontCharacter::VerticalOffset' has a wrong offset!");

// ScriptStruct Engine.StaticMeshSourceModel
// 0x0058 (0x0058 - 0x0000)
struct FStaticMeshSourceModel final
{
public:
	struct FMeshBuildSettings                     BuildSettings;                                     // 0x0000(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FMeshReductionSettings                 ReductionSettings;                                 // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         LODDistance;                                       // 0x0050(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenSize;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshSourceModel) == 0x000004, "Wrong alignment on FStaticMeshSourceModel");
static_assert(sizeof(FStaticMeshSourceModel) == 0x000058, "Wrong size on FStaticMeshSourceModel");
static_assert(offsetof(FStaticMeshSourceModel, BuildSettings) == 0x000000, "Member 'FStaticMeshSourceModel::BuildSettings' has a wrong offset!");
static_assert(offsetof(FStaticMeshSourceModel, ReductionSettings) == 0x000030, "Member 'FStaticMeshSourceModel::ReductionSettings' has a wrong offset!");
static_assert(offsetof(FStaticMeshSourceModel, LODDistance) == 0x000050, "Member 'FStaticMeshSourceModel::LODDistance' has a wrong offset!");
static_assert(offsetof(FStaticMeshSourceModel, ScreenSize) == 0x000054, "Member 'FStaticMeshSourceModel::ScreenSize' has a wrong offset!");

// ScriptStruct Engine.GameplayDebuggerReplicatedBlob
// 0x0018 (0x0018 - 0x0000)
struct FGameplayDebuggerReplicatedBlob final
{
public:
	TArray<uint8>                                 RepData;                                           // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VersionNum;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepDataOffset;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepDataSize;                                       // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayDebuggerReplicatedBlob) == 0x000004, "Wrong alignment on FGameplayDebuggerReplicatedBlob");
static_assert(sizeof(FGameplayDebuggerReplicatedBlob) == 0x000018, "Wrong size on FGameplayDebuggerReplicatedBlob");
static_assert(offsetof(FGameplayDebuggerReplicatedBlob, RepData) == 0x000000, "Member 'FGameplayDebuggerReplicatedBlob::RepData' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerReplicatedBlob, VersionNum) == 0x00000C, "Member 'FGameplayDebuggerReplicatedBlob::VersionNum' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerReplicatedBlob, RepDataOffset) == 0x000010, "Member 'FGameplayDebuggerReplicatedBlob::RepDataOffset' has a wrong offset!");
static_assert(offsetof(FGameplayDebuggerReplicatedBlob, RepDataSize) == 0x000014, "Member 'FGameplayDebuggerReplicatedBlob::RepDataSize' has a wrong offset!");

// ScriptStruct Engine.ActiveHapticFeedbackEffect
// 0x000C (0x000C - 0x0000)
struct FActiveHapticFeedbackEffect final
{
public:
	class UHapticFeedbackEffect*                  HapticEffect;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveHapticFeedbackEffect) == 0x000004, "Wrong alignment on FActiveHapticFeedbackEffect");
static_assert(sizeof(FActiveHapticFeedbackEffect) == 0x00000C, "Wrong size on FActiveHapticFeedbackEffect");
static_assert(offsetof(FActiveHapticFeedbackEffect, HapticEffect) == 0x000000, "Member 'FActiveHapticFeedbackEffect::HapticEffect' has a wrong offset!");

// ScriptStruct Engine.DirectorTrackCut
// 0x0014 (0x0014 - 0x0000)
struct FDirectorTrackCut final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetCamGroup;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotNumber;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectorTrackCut) == 0x000004, "Wrong alignment on FDirectorTrackCut");
static_assert(sizeof(FDirectorTrackCut) == 0x000014, "Wrong size on FDirectorTrackCut");
static_assert(offsetof(FDirectorTrackCut, Time) == 0x000000, "Member 'FDirectorTrackCut::Time' has a wrong offset!");
static_assert(offsetof(FDirectorTrackCut, TransitionTime) == 0x000004, "Member 'FDirectorTrackCut::TransitionTime' has a wrong offset!");
static_assert(offsetof(FDirectorTrackCut, TargetCamGroup) == 0x000008, "Member 'FDirectorTrackCut::TargetCamGroup' has a wrong offset!");
static_assert(offsetof(FDirectorTrackCut, ShotNumber) == 0x000010, "Member 'FDirectorTrackCut::ShotNumber' has a wrong offset!");

// ScriptStruct Engine.ParticleReplayTrackKey
// 0x000C (0x000C - 0x0000)
struct FParticleReplayTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClipIDNumber;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleReplayTrackKey) == 0x000004, "Wrong alignment on FParticleReplayTrackKey");
static_assert(sizeof(FParticleReplayTrackKey) == 0x00000C, "Wrong size on FParticleReplayTrackKey");
static_assert(offsetof(FParticleReplayTrackKey, Time) == 0x000000, "Member 'FParticleReplayTrackKey::Time' has a wrong offset!");
static_assert(offsetof(FParticleReplayTrackKey, Duration) == 0x000004, "Member 'FParticleReplayTrackKey::Duration' has a wrong offset!");
static_assert(offsetof(FParticleReplayTrackKey, ClipIDNumber) == 0x000008, "Member 'FParticleReplayTrackKey::ClipIDNumber' has a wrong offset!");

// ScriptStruct Engine.ToggleTrackKey
// 0x0008 (0x0008 - 0x0000)
struct FToggleTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrackToggleAction                            ToggleAction;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FToggleTrackKey) == 0x000004, "Wrong alignment on FToggleTrackKey");
static_assert(sizeof(FToggleTrackKey) == 0x000008, "Wrong size on FToggleTrackKey");
static_assert(offsetof(FToggleTrackKey, Time) == 0x000000, "Member 'FToggleTrackKey::Time' has a wrong offset!");
static_assert(offsetof(FToggleTrackKey, ToggleAction) == 0x000004, "Member 'FToggleTrackKey::ToggleAction' has a wrong offset!");

// ScriptStruct Engine.SoundTrackKey
// 0x0010 (0x0010 - 0x0000)
struct FSoundTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundTrackKey) == 0x000004, "Wrong alignment on FSoundTrackKey");
static_assert(sizeof(FSoundTrackKey) == 0x000010, "Wrong size on FSoundTrackKey");
static_assert(offsetof(FSoundTrackKey, Time) == 0x000000, "Member 'FSoundTrackKey::Time' has a wrong offset!");
static_assert(offsetof(FSoundTrackKey, Volume) == 0x000004, "Member 'FSoundTrackKey::Volume' has a wrong offset!");
static_assert(offsetof(FSoundTrackKey, Pitch) == 0x000008, "Member 'FSoundTrackKey::Pitch' has a wrong offset!");
static_assert(offsetof(FSoundTrackKey, Sound) == 0x00000C, "Member 'FSoundTrackKey::Sound' has a wrong offset!");

// ScriptStruct Engine.VisibilityTrackKey
// 0x0008 (0x0008 - 0x0000)
struct FVisibilityTrackKey final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityTrackAction                        Action;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibilityTrackCondition                     ActiveCondition;                                   // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisibilityTrackKey) == 0x000004, "Wrong alignment on FVisibilityTrackKey");
static_assert(sizeof(FVisibilityTrackKey) == 0x000008, "Wrong size on FVisibilityTrackKey");
static_assert(offsetof(FVisibilityTrackKey, Time) == 0x000000, "Member 'FVisibilityTrackKey::Time' has a wrong offset!");
static_assert(offsetof(FVisibilityTrackKey, Action) == 0x000004, "Member 'FVisibilityTrackKey::Action' has a wrong offset!");
static_assert(offsetof(FVisibilityTrackKey, ActiveCondition) == 0x000005, "Member 'FVisibilityTrackKey::ActiveCondition' has a wrong offset!");

// ScriptStruct Engine.LayerActorStats
// 0x0008 (0x0008 - 0x0000)
struct FLayerActorStats final
{
public:
	class UClass*                                 Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Total;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLayerActorStats) == 0x000004, "Wrong alignment on FLayerActorStats");
static_assert(sizeof(FLayerActorStats) == 0x000008, "Wrong size on FLayerActorStats");
static_assert(offsetof(FLayerActorStats, Type) == 0x000000, "Member 'FLayerActorStats::Type' has a wrong offset!");
static_assert(offsetof(FLayerActorStats, Total) == 0x000004, "Member 'FLayerActorStats::Total' has a wrong offset!");

// ScriptStruct Engine.ClientReceiveData
// 0x0028 (0x0028 - 0x0000)
struct FClientReceiveData final
{
public:
	class APlayerController*                      LocalPC;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageType;                                       // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MessageIndex;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageString;                                     // 0x0010(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           RelatedPlayerState_1;                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           RelatedPlayerState_2;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClientReceiveData) == 0x000004, "Wrong alignment on FClientReceiveData");
static_assert(sizeof(FClientReceiveData) == 0x000028, "Wrong size on FClientReceiveData");
static_assert(offsetof(FClientReceiveData, LocalPC) == 0x000000, "Member 'FClientReceiveData::LocalPC' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, MessageType) == 0x000004, "Member 'FClientReceiveData::MessageType' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, MessageIndex) == 0x00000C, "Member 'FClientReceiveData::MessageIndex' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, MessageString) == 0x000010, "Member 'FClientReceiveData::MessageString' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, RelatedPlayerState_1) == 0x00001C, "Member 'FClientReceiveData::RelatedPlayerState_1' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, RelatedPlayerState_2) == 0x000020, "Member 'FClientReceiveData::RelatedPlayerState_2' has a wrong offset!");
static_assert(offsetof(FClientReceiveData, OptionalObject) == 0x000024, "Member 'FClientReceiveData::OptionalObject' has a wrong offset!");

// ScriptStruct Engine.FunctionExpressionInput
// 0x0040 (0x0040 - 0x0000)
struct FFunctionExpressionInput final
{
public:
	class UMaterialExpressionFunctionInput*       ExpressionInput;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionInputId;                                 // 0x0004(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Input;                                             // 0x0014(0x002C)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFunctionExpressionInput) == 0x000004, "Wrong alignment on FFunctionExpressionInput");
static_assert(sizeof(FFunctionExpressionInput) == 0x000040, "Wrong size on FFunctionExpressionInput");
static_assert(offsetof(FFunctionExpressionInput, ExpressionInput) == 0x000000, "Member 'FFunctionExpressionInput::ExpressionInput' has a wrong offset!");
static_assert(offsetof(FFunctionExpressionInput, ExpressionInputId) == 0x000004, "Member 'FFunctionExpressionInput::ExpressionInputId' has a wrong offset!");
static_assert(offsetof(FFunctionExpressionInput, Input) == 0x000014, "Member 'FFunctionExpressionInput::Input' has a wrong offset!");

// ScriptStruct Engine.MaterialParameterCollectionInfo
// 0x0014 (0x0014 - 0x0000)
struct FMaterialParameterCollectionInfo final
{
public:
	struct FGuid                                  StateId;                                           // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           ParameterCollection;                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParameterCollectionInfo) == 0x000004, "Wrong alignment on FMaterialParameterCollectionInfo");
static_assert(sizeof(FMaterialParameterCollectionInfo) == 0x000014, "Wrong size on FMaterialParameterCollectionInfo");
static_assert(offsetof(FMaterialParameterCollectionInfo, StateId) == 0x000000, "Member 'FMaterialParameterCollectionInfo::StateId' has a wrong offset!");
static_assert(offsetof(FMaterialParameterCollectionInfo, ParameterCollection) == 0x000010, "Member 'FMaterialParameterCollectionInfo::ParameterCollection' has a wrong offset!");

// ScriptStruct Engine.MaterialInstanceBasePropertyOverrides
// 0x0014 (0x0014 - 0x0000)
struct FMaterialInstanceBasePropertyOverrides final
{
public:
	bool                                          bOverride_OpacityMaskClipValue;                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_BlendMode;                               // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_ShadingModel;                            // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_DitheredLODTransition;                   // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_TwoSided;                                // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpacityMaskClipValue;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialShadingModel                         ShadingModel;                                      // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TwoSided : 1;                                      // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         DitheredLODTransition : 1;                         // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialInstanceBasePropertyOverrides) == 0x000004, "Wrong alignment on FMaterialInstanceBasePropertyOverrides");
static_assert(sizeof(FMaterialInstanceBasePropertyOverrides) == 0x000014, "Wrong size on FMaterialInstanceBasePropertyOverrides");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, bOverride_OpacityMaskClipValue) == 0x000000, "Member 'FMaterialInstanceBasePropertyOverrides::bOverride_OpacityMaskClipValue' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, bOverride_BlendMode) == 0x000001, "Member 'FMaterialInstanceBasePropertyOverrides::bOverride_BlendMode' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, bOverride_ShadingModel) == 0x000002, "Member 'FMaterialInstanceBasePropertyOverrides::bOverride_ShadingModel' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, bOverride_DitheredLODTransition) == 0x000003, "Member 'FMaterialInstanceBasePropertyOverrides::bOverride_DitheredLODTransition' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, bOverride_TwoSided) == 0x000004, "Member 'FMaterialInstanceBasePropertyOverrides::bOverride_TwoSided' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, OpacityMaskClipValue) == 0x000008, "Member 'FMaterialInstanceBasePropertyOverrides::OpacityMaskClipValue' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, BlendMode) == 0x00000C, "Member 'FMaterialInstanceBasePropertyOverrides::BlendMode' has a wrong offset!");
static_assert(offsetof(FMaterialInstanceBasePropertyOverrides, ShadingModel) == 0x00000D, "Member 'FMaterialInstanceBasePropertyOverrides::ShadingModel' has a wrong offset!");

// ScriptStruct Engine.VectorParameterValue
// 0x0028 (0x0028 - 0x0000)
struct FVectorParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValue;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorParameterValue) == 0x000004, "Wrong alignment on FVectorParameterValue");
static_assert(sizeof(FVectorParameterValue) == 0x000028, "Wrong size on FVectorParameterValue");
static_assert(offsetof(FVectorParameterValue, ParameterName) == 0x000000, "Member 'FVectorParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FVectorParameterValue, ParameterValue) == 0x000008, "Member 'FVectorParameterValue::ParameterValue' has a wrong offset!");
static_assert(offsetof(FVectorParameterValue, ExpressionGUID) == 0x000018, "Member 'FVectorParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.ScalarParameterValue
// 0x001C (0x001C - 0x0000)
struct FScalarParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ExpressionGUID;                                    // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScalarParameterValue) == 0x000004, "Wrong alignment on FScalarParameterValue");
static_assert(sizeof(FScalarParameterValue) == 0x00001C, "Wrong size on FScalarParameterValue");
static_assert(offsetof(FScalarParameterValue, ParameterName) == 0x000000, "Member 'FScalarParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(FScalarParameterValue, ParameterValue) == 0x000008, "Member 'FScalarParameterValue::ParameterValue' has a wrong offset!");
static_assert(offsetof(FScalarParameterValue, ExpressionGUID) == 0x00000C, "Member 'FScalarParameterValue::ExpressionGUID' has a wrong offset!");

// ScriptStruct Engine.NavCollisionBox
// 0x0018 (0x0018 - 0x0000)
struct FNavCollisionBox final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavCollisionBox) == 0x000004, "Wrong alignment on FNavCollisionBox");
static_assert(sizeof(FNavCollisionBox) == 0x000018, "Wrong size on FNavCollisionBox");
static_assert(offsetof(FNavCollisionBox, Offset) == 0x000000, "Member 'FNavCollisionBox::Offset' has a wrong offset!");
static_assert(offsetof(FNavCollisionBox, Extent) == 0x00000C, "Member 'FNavCollisionBox::Extent' has a wrong offset!");

// ScriptStruct Engine.PacketSimulationSettings
// 0x0014 (0x0014 - 0x0000)
struct FPacketSimulationSettings final
{
public:
	int32                                         PktLoss;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktOrder;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktDup;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLag;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PktLagVariance;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPacketSimulationSettings) == 0x000004, "Wrong alignment on FPacketSimulationSettings");
static_assert(sizeof(FPacketSimulationSettings) == 0x000014, "Wrong size on FPacketSimulationSettings");
static_assert(offsetof(FPacketSimulationSettings, PktLoss) == 0x000000, "Member 'FPacketSimulationSettings::PktLoss' has a wrong offset!");
static_assert(offsetof(FPacketSimulationSettings, PktOrder) == 0x000004, "Member 'FPacketSimulationSettings::PktOrder' has a wrong offset!");
static_assert(offsetof(FPacketSimulationSettings, PktDup) == 0x000008, "Member 'FPacketSimulationSettings::PktDup' has a wrong offset!");
static_assert(offsetof(FPacketSimulationSettings, PktLag) == 0x00000C, "Member 'FPacketSimulationSettings::PktLag' has a wrong offset!");
static_assert(offsetof(FPacketSimulationSettings, PktLagVariance) == 0x000010, "Member 'FPacketSimulationSettings::PktLagVariance' has a wrong offset!");

// ScriptStruct Engine.ParticleBurst
// 0x000C (0x000C - 0x0000)
struct FParticleBurst final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountLow;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleBurst) == 0x000004, "Wrong alignment on FParticleBurst");
static_assert(sizeof(FParticleBurst) == 0x00000C, "Wrong size on FParticleBurst");
static_assert(offsetof(FParticleBurst, Count) == 0x000000, "Member 'FParticleBurst::Count' has a wrong offset!");
static_assert(offsetof(FParticleBurst, CountLow) == 0x000004, "Member 'FParticleBurst::CountLow' has a wrong offset!");
static_assert(offsetof(FParticleBurst, Time) == 0x000008, "Member 'FParticleBurst::Time' has a wrong offset!");

// ScriptStruct Engine.BeamModifierOptions
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FBeamModifierOptions final
{
public:
	uint8                                         bModify : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bScale : 1;                                        // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bLock : 1;                                         // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBeamModifierOptions) == 0x000004, "Wrong alignment on FBeamModifierOptions");
static_assert(sizeof(FBeamModifierOptions) == 0x000004, "Wrong size on FBeamModifierOptions");

// ScriptStruct Engine.LocationBoneSocketInfo
// 0x0014 (0x0014 - 0x0000)
struct FLocationBoneSocketInfo final
{
public:
	class FName                                   BoneSocketName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocationBoneSocketInfo) == 0x000004, "Wrong alignment on FLocationBoneSocketInfo");
static_assert(sizeof(FLocationBoneSocketInfo) == 0x000014, "Wrong size on FLocationBoneSocketInfo");
static_assert(offsetof(FLocationBoneSocketInfo, BoneSocketName) == 0x000000, "Member 'FLocationBoneSocketInfo::BoneSocketName' has a wrong offset!");
static_assert(offsetof(FLocationBoneSocketInfo, Offset) == 0x000008, "Member 'FLocationBoneSocketInfo::Offset' has a wrong offset!");

// ScriptStruct Engine.EmitterDynamicParameter
// 0x003C (0x003C - 0x0000)
struct FEmitterDynamicParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseEmitterTime : 1;                               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSpawnTimeOnly : 1;                                // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EEmitterDynamicParameterValue                 ValueMethod;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bScaleVelocityByParamValue : 1;                    // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRawDistributionFloat                  ParamValue;                                        // 0x0014(0x0028)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmitterDynamicParameter) == 0x000004, "Wrong alignment on FEmitterDynamicParameter");
static_assert(sizeof(FEmitterDynamicParameter) == 0x00003C, "Wrong size on FEmitterDynamicParameter");
static_assert(offsetof(FEmitterDynamicParameter, ParamName) == 0x000000, "Member 'FEmitterDynamicParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FEmitterDynamicParameter, ValueMethod) == 0x00000C, "Member 'FEmitterDynamicParameter::ValueMethod' has a wrong offset!");
static_assert(offsetof(FEmitterDynamicParameter, ParamValue) == 0x000014, "Member 'FEmitterDynamicParameter::ParamValue' has a wrong offset!");

// ScriptStruct Engine.SoundNodeEditorData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FSoundNodeEditorData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundNodeEditorData) == 0x000004, "Wrong alignment on FSoundNodeEditorData");
static_assert(sizeof(FSoundNodeEditorData) == 0x000008, "Wrong size on FSoundNodeEditorData");

// ScriptStruct Engine.GPUSpriteResourceData
// 0x0150 (0x0150 - 0x0000)
struct FGPUSpriteResourceData final
{
public:
	TArray<struct FColor>                         QuantizedColorSamples;                             // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         QuantizedMiscSamples;                              // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         QuantizedSimulationAttrSamples;                    // 0x0018(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ColorScale;                                        // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               ColorBias;                                         // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               MiscScale;                                         // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               MiscBias;                                          // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               SimulationAttrCurveScale;                          // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               SimulationAttrCurveBias;                           // 0x0080(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               SubImageSize;                                      // 0x0090(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector4                               SizeBySpeed;                                       // 0x00A0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAcceleration;                              // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetBase;                                   // 0x00BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitOffsetRange;                                  // 0x00C8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitFrequencyBase;                                // 0x00D4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitFrequencyRange;                               // 0x00E0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitPhaseBase;                                    // 0x00EC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OrbitPhaseRange;                                   // 0x00F8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GlobalVectorFieldScale;                            // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVectorFieldTightness;                        // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerParticleVectorFieldScale;                       // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerParticleVectorFieldBias;                        // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragCoefficientScale;                              // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragCoefficientBias;                               // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResilienceScale;                                   // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResilienceBias;                                    // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusScale;                              // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadiusBias;                               // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionTimeBias;                                 // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneMinusFriction;                                  // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRateScale;                                 // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraMotionBlurAmount;                            // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleScreenAlignment                      ScreenAlignment;                                   // 0x013C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleAxisLock                             LockAxisFlag;                                      // 0x013D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PivotOffset;                                       // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGPUSpriteResourceData) == 0x000010, "Wrong alignment on FGPUSpriteResourceData");
static_assert(sizeof(FGPUSpriteResourceData) == 0x000150, "Wrong size on FGPUSpriteResourceData");
static_assert(offsetof(FGPUSpriteResourceData, QuantizedColorSamples) == 0x000000, "Member 'FGPUSpriteResourceData::QuantizedColorSamples' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, QuantizedMiscSamples) == 0x00000C, "Member 'FGPUSpriteResourceData::QuantizedMiscSamples' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, QuantizedSimulationAttrSamples) == 0x000018, "Member 'FGPUSpriteResourceData::QuantizedSimulationAttrSamples' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ColorScale) == 0x000030, "Member 'FGPUSpriteResourceData::ColorScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ColorBias) == 0x000040, "Member 'FGPUSpriteResourceData::ColorBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, MiscScale) == 0x000050, "Member 'FGPUSpriteResourceData::MiscScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, MiscBias) == 0x000060, "Member 'FGPUSpriteResourceData::MiscBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, SimulationAttrCurveScale) == 0x000070, "Member 'FGPUSpriteResourceData::SimulationAttrCurveScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, SimulationAttrCurveBias) == 0x000080, "Member 'FGPUSpriteResourceData::SimulationAttrCurveBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, SubImageSize) == 0x000090, "Member 'FGPUSpriteResourceData::SubImageSize' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, SizeBySpeed) == 0x0000A0, "Member 'FGPUSpriteResourceData::SizeBySpeed' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ConstantAcceleration) == 0x0000B0, "Member 'FGPUSpriteResourceData::ConstantAcceleration' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitOffsetBase) == 0x0000BC, "Member 'FGPUSpriteResourceData::OrbitOffsetBase' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitOffsetRange) == 0x0000C8, "Member 'FGPUSpriteResourceData::OrbitOffsetRange' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitFrequencyBase) == 0x0000D4, "Member 'FGPUSpriteResourceData::OrbitFrequencyBase' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitFrequencyRange) == 0x0000E0, "Member 'FGPUSpriteResourceData::OrbitFrequencyRange' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitPhaseBase) == 0x0000EC, "Member 'FGPUSpriteResourceData::OrbitPhaseBase' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OrbitPhaseRange) == 0x0000F8, "Member 'FGPUSpriteResourceData::OrbitPhaseRange' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, GlobalVectorFieldScale) == 0x000104, "Member 'FGPUSpriteResourceData::GlobalVectorFieldScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, GlobalVectorFieldTightness) == 0x000108, "Member 'FGPUSpriteResourceData::GlobalVectorFieldTightness' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, PerParticleVectorFieldScale) == 0x00010C, "Member 'FGPUSpriteResourceData::PerParticleVectorFieldScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, PerParticleVectorFieldBias) == 0x000110, "Member 'FGPUSpriteResourceData::PerParticleVectorFieldBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, DragCoefficientScale) == 0x000114, "Member 'FGPUSpriteResourceData::DragCoefficientScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, DragCoefficientBias) == 0x000118, "Member 'FGPUSpriteResourceData::DragCoefficientBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ResilienceScale) == 0x00011C, "Member 'FGPUSpriteResourceData::ResilienceScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ResilienceBias) == 0x000120, "Member 'FGPUSpriteResourceData::ResilienceBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, CollisionRadiusScale) == 0x000124, "Member 'FGPUSpriteResourceData::CollisionRadiusScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, CollisionRadiusBias) == 0x000128, "Member 'FGPUSpriteResourceData::CollisionRadiusBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, CollisionTimeBias) == 0x00012C, "Member 'FGPUSpriteResourceData::CollisionTimeBias' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, OneMinusFriction) == 0x000130, "Member 'FGPUSpriteResourceData::OneMinusFriction' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, RotationRateScale) == 0x000134, "Member 'FGPUSpriteResourceData::RotationRateScale' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, CameraMotionBlurAmount) == 0x000138, "Member 'FGPUSpriteResourceData::CameraMotionBlurAmount' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, ScreenAlignment) == 0x00013C, "Member 'FGPUSpriteResourceData::ScreenAlignment' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, LockAxisFlag) == 0x00013D, "Member 'FGPUSpriteResourceData::LockAxisFlag' has a wrong offset!");
static_assert(offsetof(FGPUSpriteResourceData, PivotOffset) == 0x000140, "Member 'FGPUSpriteResourceData::PivotOffset' has a wrong offset!");

// ScriptStruct Engine.ParticleEmitterReplayFrame
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FParticleEmitterReplayFrame final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleEmitterReplayFrame) == 0x000004, "Wrong alignment on FParticleEmitterReplayFrame");
static_assert(sizeof(FParticleEmitterReplayFrame) == 0x00000C, "Wrong size on FParticleEmitterReplayFrame");

// ScriptStruct Engine.TireFrictionScalePair
// 0x0008 (0x0008 - 0x0000)
struct FTireFrictionScalePair final
{
public:
	class UTireType*                              TireType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionScale;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTireFrictionScalePair) == 0x000004, "Wrong alignment on FTireFrictionScalePair");
static_assert(sizeof(FTireFrictionScalePair) == 0x000008, "Wrong size on FTireFrictionScalePair");
static_assert(offsetof(FTireFrictionScalePair, TireType) == 0x000000, "Member 'FTireFrictionScalePair::TireType' has a wrong offset!");
static_assert(offsetof(FTireFrictionScalePair, FrictionScale) == 0x000004, "Member 'FTireFrictionScalePair::FrictionScale' has a wrong offset!");

// ScriptStruct Engine.DelegateArray
// 0x000C (0x000C - 0x0000)
struct FDelegateArray final
{
public:
	TArray<TDelegate<void(const struct FPlatformInterfaceDelegateResult& Result)>> Delegates;                                         // 0x0000(0x000C)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDelegateArray) == 0x000004, "Wrong alignment on FDelegateArray");
static_assert(sizeof(FDelegateArray) == 0x00000C, "Wrong size on FDelegateArray");
static_assert(offsetof(FDelegateArray, Delegates) == 0x000000, "Member 'FDelegateArray::Delegates' has a wrong offset!");

// ScriptStruct Engine.PurchaseInfo
// 0x0030 (0x0030 - 0x0000)
struct FPurchaseInfo final
{
public:
	class FString                                 Identifier;                                        // 0x0000(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayDescription;                                // 0x0018(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayPrice;                                      // 0x0024(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPurchaseInfo) == 0x000004, "Wrong alignment on FPurchaseInfo");
static_assert(sizeof(FPurchaseInfo) == 0x000030, "Wrong size on FPurchaseInfo");
static_assert(offsetof(FPurchaseInfo, Identifier) == 0x000000, "Member 'FPurchaseInfo::Identifier' has a wrong offset!");
static_assert(offsetof(FPurchaseInfo, DisplayName) == 0x00000C, "Member 'FPurchaseInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FPurchaseInfo, DisplayDescription) == 0x000018, "Member 'FPurchaseInfo::DisplayDescription' has a wrong offset!");
static_assert(offsetof(FPurchaseInfo, DisplayPrice) == 0x000024, "Member 'FPurchaseInfo::DisplayPrice' has a wrong offset!");

// ScriptStruct Engine.SoundConcurrencySettings
// 0x0010 (0x0010 - 0x0000)
struct FSoundConcurrencySettings final
{
public:
	int32                                         MaxCount;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitToOwner : 1;                                 // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMaxConcurrentResolutionRule                  ResolutionRule;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeScale;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundConcurrencySettings) == 0x000004, "Wrong alignment on FSoundConcurrencySettings");
static_assert(sizeof(FSoundConcurrencySettings) == 0x000010, "Wrong size on FSoundConcurrencySettings");
static_assert(offsetof(FSoundConcurrencySettings, MaxCount) == 0x000000, "Member 'FSoundConcurrencySettings::MaxCount' has a wrong offset!");
static_assert(offsetof(FSoundConcurrencySettings, ResolutionRule) == 0x000008, "Member 'FSoundConcurrencySettings::ResolutionRule' has a wrong offset!");
static_assert(offsetof(FSoundConcurrencySettings, VolumeScale) == 0x00000C, "Member 'FSoundConcurrencySettings::VolumeScale' has a wrong offset!");

// ScriptStruct Engine.StreamedAudioPlatformData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FStreamedAudioPlatformData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamedAudioPlatformData) == 0x000004, "Wrong alignment on FStreamedAudioPlatformData");
static_assert(sizeof(FStreamedAudioPlatformData) == 0x000018, "Wrong size on FStreamedAudioPlatformData");

// ScriptStruct Engine.SoundClassProperties
// 0x0024 (0x0024 - 0x0000)
struct FSoundClassProperties final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StereoBleed;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LFEBleed;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceCenterChannelVolume;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadioFilterVolume;                                 // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadioFilterVolumeThreshold;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyEffects : 1;                                 // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysPlay : 1;                                   // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsUISound : 1;                                    // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsMusic : 1;                                      // 0x001C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bReverb : 1;                                       // 0x001C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCenterChannelOnly : 1;                            // 0x001C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bApplyAmbientVolumes : 1;                          // 0x001C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAudioOutputTarget                            OutputTarget;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundClassProperties) == 0x000004, "Wrong alignment on FSoundClassProperties");
static_assert(sizeof(FSoundClassProperties) == 0x000024, "Wrong size on FSoundClassProperties");
static_assert(offsetof(FSoundClassProperties, Volume) == 0x000000, "Member 'FSoundClassProperties::Volume' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, Pitch) == 0x000004, "Member 'FSoundClassProperties::Pitch' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, StereoBleed) == 0x000008, "Member 'FSoundClassProperties::StereoBleed' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, LFEBleed) == 0x00000C, "Member 'FSoundClassProperties::LFEBleed' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, VoiceCenterChannelVolume) == 0x000010, "Member 'FSoundClassProperties::VoiceCenterChannelVolume' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, RadioFilterVolume) == 0x000014, "Member 'FSoundClassProperties::RadioFilterVolume' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, RadioFilterVolumeThreshold) == 0x000018, "Member 'FSoundClassProperties::RadioFilterVolumeThreshold' has a wrong offset!");
static_assert(offsetof(FSoundClassProperties, OutputTarget) == 0x000020, "Member 'FSoundClassProperties::OutputTarget' has a wrong offset!");

// ScriptStruct Engine.AudioEQEffect
// 0x0024 (0x0024 - 0x0000)
struct FAudioEQEffect final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HFFrequency;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HFGain;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFCutoffFrequency;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFBandwidth;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFGain;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LFFrequency;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LFGain;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioEQEffect) == 0x000004, "Wrong alignment on FAudioEQEffect");
static_assert(sizeof(FAudioEQEffect) == 0x000024, "Wrong size on FAudioEQEffect");
static_assert(offsetof(FAudioEQEffect, HFFrequency) == 0x000008, "Member 'FAudioEQEffect::HFFrequency' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, HFGain) == 0x00000C, "Member 'FAudioEQEffect::HFGain' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, MFCutoffFrequency) == 0x000010, "Member 'FAudioEQEffect::MFCutoffFrequency' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, MFBandwidth) == 0x000014, "Member 'FAudioEQEffect::MFBandwidth' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, MFGain) == 0x000018, "Member 'FAudioEQEffect::MFGain' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, LFFrequency) == 0x00001C, "Member 'FAudioEQEffect::LFFrequency' has a wrong offset!");
static_assert(offsetof(FAudioEQEffect, LFGain) == 0x000020, "Member 'FAudioEQEffect::LFGain' has a wrong offset!");

// ScriptStruct Engine.TexturePlatformData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FTexturePlatformData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTexturePlatformData) == 0x000004, "Wrong alignment on FTexturePlatformData");
static_assert(sizeof(FTexturePlatformData) == 0x00001C, "Wrong size on FTexturePlatformData");

// ScriptStruct Engine.TTLinearColorTrack
// 0x0004 (0x0010 - 0x000C)
struct FTTLinearColorTrack final : public FTTTrackBase
{
public:
	class UCurveLinearColor*                      CurveLinearColor;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTTLinearColorTrack) == 0x000004, "Wrong alignment on FTTLinearColorTrack");
static_assert(sizeof(FTTLinearColorTrack) == 0x000010, "Wrong size on FTTLinearColorTrack");
static_assert(offsetof(FTTLinearColorTrack, CurveLinearColor) == 0x00000C, "Member 'FTTLinearColorTrack::CurveLinearColor' has a wrong offset!");

// ScriptStruct Engine.TTVectorTrack
// 0x0004 (0x0010 - 0x000C)
struct FTTVectorTrack final : public FTTTrackBase
{
public:
	class UCurveVector*                           CurveVector;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTTVectorTrack) == 0x000004, "Wrong alignment on FTTVectorTrack");
static_assert(sizeof(FTTVectorTrack) == 0x000010, "Wrong size on FTTVectorTrack");
static_assert(offsetof(FTTVectorTrack, CurveVector) == 0x00000C, "Member 'FTTVectorTrack::CurveVector' has a wrong offset!");

// ScriptStruct Engine.AnimNode_SequencePlayer
// 0x0010 (0x0058 - 0x0048)
struct FAnimNode_SequencePlayer final : public FAnimNode_AssetPlayerBase
{
public:
	class UAnimSequenceBase*                      Sequence;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnimation;                                    // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_SequencePlayer) == 0x000004, "Wrong alignment on FAnimNode_SequencePlayer");
static_assert(sizeof(FAnimNode_SequencePlayer) == 0x000058, "Wrong size on FAnimNode_SequencePlayer");
static_assert(offsetof(FAnimNode_SequencePlayer, Sequence) == 0x000048, "Member 'FAnimNode_SequencePlayer::Sequence' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequencePlayer, bLoopAnimation) == 0x00004C, "Member 'FAnimNode_SequencePlayer::bLoopAnimation' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequencePlayer, PlayRate) == 0x000050, "Member 'FAnimNode_SequencePlayer::PlayRate' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequencePlayer, StartPosition) == 0x000054, "Member 'FAnimNode_SequencePlayer::StartPosition' has a wrong offset!");

// ScriptStruct Engine.AnimationActiveTransitionEntry
// 0x0088 (0x0088 - 0x0000)
struct FAnimationActiveTransitionEntry final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendProfile*                          BlendProfile;                                      // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x2C];                                      // 0x005C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationActiveTransitionEntry) == 0x000004, "Wrong alignment on FAnimationActiveTransitionEntry");
static_assert(sizeof(FAnimationActiveTransitionEntry) == 0x000088, "Wrong size on FAnimationActiveTransitionEntry");
static_assert(offsetof(FAnimationActiveTransitionEntry, BlendProfile) == 0x000058, "Member 'FAnimationActiveTransitionEntry::BlendProfile' has a wrong offset!");

// ScriptStruct Engine.AnimNode_TransitionPoseEvaluator
// 0x0030 (0x0050 - 0x0020)
struct FAnimNode_TransitionPoseEvaluator final : public FAnimNode_Base
{
public:
	EEvaluatorDataSource                          DataSource;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvaluatorMode                                EvaluatorMode;                                     // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FramesToCachePose;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x24];                                      // 0x0028(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CacheFramesRemaining;                              // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_TransitionPoseEvaluator) == 0x000004, "Wrong alignment on FAnimNode_TransitionPoseEvaluator");
static_assert(sizeof(FAnimNode_TransitionPoseEvaluator) == 0x000050, "Wrong size on FAnimNode_TransitionPoseEvaluator");
static_assert(offsetof(FAnimNode_TransitionPoseEvaluator, DataSource) == 0x000020, "Member 'FAnimNode_TransitionPoseEvaluator::DataSource' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionPoseEvaluator, EvaluatorMode) == 0x000021, "Member 'FAnimNode_TransitionPoseEvaluator::EvaluatorMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionPoseEvaluator, FramesToCachePose) == 0x000024, "Member 'FAnimNode_TransitionPoseEvaluator::FramesToCachePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionPoseEvaluator, CacheFramesRemaining) == 0x00004C, "Member 'FAnimNode_TransitionPoseEvaluator::CacheFramesRemaining' has a wrong offset!");

// ScriptStruct Engine.AnimNode_TransitionResult
// 0x000C (0x002C - 0x0020)
struct FAnimNode_TransitionResult final : public FAnimNode_Base
{
public:
	bool                                          bCanEnterTransition;                               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xB];                                       // 0x0021(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TransitionResult) == 0x000004, "Wrong alignment on FAnimNode_TransitionResult");
static_assert(sizeof(FAnimNode_TransitionResult) == 0x00002C, "Wrong size on FAnimNode_TransitionResult");
static_assert(offsetof(FAnimNode_TransitionResult, bCanEnterTransition) == 0x000020, "Member 'FAnimNode_TransitionResult::bCanEnterTransition' has a wrong offset!");

// ScriptStruct Engine.DummySpacerCameraTypes
// 0x0001 (0x0001 - 0x0000)
struct FDummySpacerCameraTypes final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDummySpacerCameraTypes) == 0x000001, "Wrong alignment on FDummySpacerCameraTypes");
static_assert(sizeof(FDummySpacerCameraTypes) == 0x000001, "Wrong size on FDummySpacerCameraTypes");

// ScriptStruct Engine.StreamableManager
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x04) FStreamableManager final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStreamableManager) == 0x000004, "Wrong alignment on FStreamableManager");
static_assert(sizeof(FStreamableManager) == 0x000078, "Wrong size on FStreamableManager");

}

#pragma pack(pop)
