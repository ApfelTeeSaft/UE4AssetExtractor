#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FortniteGame

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "OnlineSubsystemUtils_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Party_structs.hpp"
#include "Party_classes.hpp"
#include "McpProfileSys_structs.hpp"
#include "McpProfileSys_classes.hpp"
#include "Lobby_classes.hpp"


#pragma pack(push, 0x4)
namespace SDK
{

// Class FortniteGame.FortMissionEventParams
// 0x0000 (0x001C - 0x001C)
class UFortMissionEventParams : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionEventParams">();
	}
	static class UFortMissionEventParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionEventParams>();
	}
};
static_assert(alignof(UFortMissionEventParams) == 0x000004, "Wrong alignment on UFortMissionEventParams");
static_assert(sizeof(UFortMissionEventParams) == 0x00001C, "Wrong size on UFortMissionEventParams");

// Class FortniteGame.AIHotSpot
// 0x00D8 (0x0318 - 0x0240)
class AAIHotSpot : public AActor
{
public:
	TArray<class UAIHotSpotSlot*>                 UserSlots;                                         // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAIHotSpotSlot*>                 Slots;                                             // 0x0250(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 FocusActor;                                        // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CustomNavmeshSearchExtent;                         // 0x0264(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bAllowSlotlessAssignment : 1;                      // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bAllowClaimingMultipleSlots : 1;                   // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bTrackOverlappingSlots : 1;                        // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bProjectSlotsOnNavmesh : 1;                        // 0x0270(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCustomNavmeshSearchExtent : 1;                    // 0x0270(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x0270(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAIController*>                  NoSlotAssignees;                                   // 0x0274(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x94];                                     // 0x0280(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	class UBillboardComponent*                    SpriteComponent;                                   // 0x0314(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AssignFromWaitingList();
	int32 AssignGroupToHotspot(const TArray<class AAIController*>& GroupOfAI);
	bool AssignToHotspot(class AAIController* AI);
	bool AssignToSlotByIndex(class AAIController* AI, int32 INDEX);
	bool AssignToSlotByUserId(class AAIController* AI, int32 UserId);
	bool OccupySlotByIndex(int32 INDEX);
	bool OccupySlotByOwner(const class AAIController* AIOwner);
	bool OccupySlotByUserId(int32 UserId);
	bool OnAssignedClaimedBehavior(class AAIController* AI, int32 INDEX, int32 UserId, bool bWasOnWaitingList);
	bool OnAssignedOccupiedBehavior(class AAIController* AI, int32 INDEX, int32 UserId);
	bool OnAssignedSlotlessBehavior(class AAIController* AI);
	void OnHotSpotDisabled();
	void OnHotSpotEnabled();
	void OnMoveToSlotFinished(class AAIController* AI, int32 INDEX, int32 UserId, bool bResult);
	void OnRemovedBehavior(class AAIController* AI, int32 INDEX, int32 UserId, EAIHotSpotSlot PrevState, bool bWasOnWaitingList);
	void OnRemovedSlotlessBehavior(class AAIController* AI, bool bIsClamingSlot);
	void OnSlotBlocked(class AAIController* AI, int32 INDEX, int32 UserId);
	void OnSlotClaimed(class AAIController* AI, int32 INDEX, int32 UserId);
	void OnSlotDisabled(int32 INDEX, int32 UserId);
	void OnSlotEnabled(int32 INDEX, int32 UserId);
	void OnSlotFreed(class AAIController* AI, int32 INDEX, int32 UserId);
	void OnSlotOccupied(class AAIController* AI, int32 INDEX, int32 UserId);
	bool RemoveFromHotspot(class AAIController* AI, bool bAssignFromWaitingList);
	int32 RemoveGroupFromHotspot(const TArray<class AAIController*>& GroupOfAI);
	void SetEnabled(bool bEnabled);

	bool CanUseSlotByIndex(const class AAIController* AI, int32 INDEX) const;
	bool CanUseSlotByUserId(const class AAIController* AI, int32 UserId) const;
	int32 FindBestSlotIndex(class AAIController* AI) const;
	TArray<int32> FindBestSlotIndices(const TArray<class AAIController*>& AI) const;
	TArray<class AAIController*> GetAssignedAI(EAIHotSpotAssignmentFilter Filter) const;
	int32 GetAssignedAICount(EAIHotSpotAssignmentFilter Filter) const;
	class UAIHotSpotSlot* GetSlotByIndex(int32 INDEX) const;
	class UAIHotSpotSlot* GetSlotByOwner(const class AAIController* AIOwner) const;
	class UAIHotSpotSlot* GetSlotByUserId(int32 UserId) const;
	int32 GetSlotCount(EAIHotSpotSlotFilter Filter) const;
	int32 GetSlotIndexByOwner(const class AAIController* AIOwner) const;
	int32 GetSlotIndexByUserId(int32 UserId) const;
	struct FVector GetSlotLocationByIndex(int32 INDEX) const;
	struct FVector GetSlotLocationByOwner(const class AAIController* AIOwner) const;
	struct FVector GetSlotLocationByUserId(int32 UserId) const;
	class AAIController* GetSlotOwnerByIndex(int32 INDEX) const;
	class AAIController* GetSlotOwnerByUserId(int32 UserId) const;
	struct FRotator GetSlotRotationByIndex(int32 INDEX) const;
	struct FRotator GetSlotRotationByOwner(const class AAIController* AIOwner) const;
	struct FRotator GetSlotRotationByUserId(int32 UserId) const;
	EAIHotSpotSlot GetSlotStateByIndex(int32 INDEX) const;
	EAIHotSpotSlot GetSlotStateByOwner(const class AAIController* AIOwner) const;
	EAIHotSpotSlot GetSlotStateByUserId(int32 UserId) const;
	int32 GetSlotUserIdByIndex(int32 INDEX) const;
	int32 GetSlotUserIdByOwner(const class AAIController* AIOwner) const;
	bool HasAssignedAI(const class AAIController* AI, EAIHotSpotAssignmentFilter Filter) const;
	bool HasEnabledSlots() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;
	bool IsSlotlessAssignmentAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpot">();
	}
	static class AAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIHotSpot>();
	}
};
static_assert(alignof(AAIHotSpot) == 0x000004, "Wrong alignment on AAIHotSpot");
static_assert(sizeof(AAIHotSpot) == 0x000318, "Wrong size on AAIHotSpot");
static_assert(offsetof(AAIHotSpot, UserSlots) == 0x000240, "Member 'AAIHotSpot::UserSlots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SlotGenerator) == 0x00024C, "Member 'AAIHotSpot::SlotGenerator' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, Slots) == 0x000250, "Member 'AAIHotSpot::Slots' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FocusActor) == 0x00025C, "Member 'AAIHotSpot::FocusActor' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, FilterClass) == 0x000260, "Member 'AAIHotSpot::FilterClass' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, CustomNavmeshSearchExtent) == 0x000264, "Member 'AAIHotSpot::CustomNavmeshSearchExtent' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, NoSlotAssignees) == 0x000274, "Member 'AAIHotSpot::NoSlotAssignees' has a wrong offset!");
static_assert(offsetof(AAIHotSpot, SpriteComponent) == 0x000314, "Member 'AAIHotSpot::SpriteComponent' has a wrong offset!");

// Class FortniteGame.FortAIHotSpot
// 0x000C (0x0324 - 0x0318)
class AFortAIHotSpot : public AAIHotSpot
{
public:
	uint8                                         Pad_318[0xC];                                      // 0x0318(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot">();
	}
	static class AFortAIHotSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot>();
	}
};
static_assert(alignof(AFortAIHotSpot) == 0x000004, "Wrong alignment on AFortAIHotSpot");
static_assert(sizeof(AFortAIHotSpot) == 0x000324, "Wrong size on AFortAIHotSpot");

// Class FortniteGame.FortAIHotSpot_FakeBuilding
// 0x0000 (0x0324 - 0x0324)
class AFortAIHotSpot_FakeBuilding final : public AFortAIHotSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_FakeBuilding">();
	}
	static class AFortAIHotSpot_FakeBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_FakeBuilding>();
	}
};
static_assert(alignof(AFortAIHotSpot_FakeBuilding) == 0x000004, "Wrong alignment on AFortAIHotSpot_FakeBuilding");
static_assert(sizeof(AFortAIHotSpot_FakeBuilding) == 0x000324, "Wrong size on AFortAIHotSpot_FakeBuilding");

// Class FortniteGame.FortQuickBars
// 0x0094 (0x02D4 - 0x0240)
class AFortQuickBars final : public AActor
{
public:
	struct FQuickBar                              PrimaryQuickBar;                                   // 0x0240(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FQuickBar                              SecondaryQuickBar;                                 // 0x0260(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x54];                                     // 0x0280(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Empty(EFortQuickBars InQuickBar);
	void OnRep_PrimaryQuickBar();
	void OnRep_SecondaryQuickBar();
	void ServerActivateSlotInternal(EFortQuickBars InQuickBar, int32 Slot, float AcivateDelay);
	void ServerAddItemInternal(const struct FGuid& Item, EFortQuickBars InQuickBar, int32 Slot);
	void ServerRemoveItemInternal(const struct FGuid& Item, bool bFindReplacement, bool bForce);
	void ServerSwapItemsInternal(EFortQuickBars QuickBarA, int32 SlotIndexA, EFortQuickBars QuickBarB, int32 SlotIndexB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuickBars">();
	}
	static class AFortQuickBars* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortQuickBars>();
	}
};
static_assert(alignof(AFortQuickBars) == 0x000004, "Wrong alignment on AFortQuickBars");
static_assert(sizeof(AFortQuickBars) == 0x0002D4, "Wrong size on AFortQuickBars");
static_assert(offsetof(AFortQuickBars, PrimaryQuickBar) == 0x000240, "Member 'AFortQuickBars::PrimaryQuickBar' has a wrong offset!");
static_assert(offsetof(AFortQuickBars, SecondaryQuickBar) == 0x000260, "Member 'AFortQuickBars::SecondaryQuickBar' has a wrong offset!");

// Class FortniteGame.BuildingLevelGameplayEffectInfo
// 0x0054 (0x0070 - 0x001C)
class UBuildingLevelGameplayEffectInfo final : public UObject
{
public:
	class FText                                   NumericDescription;                                // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortAttributeInfo                     AttributeInfo;                                     // 0x0028(0x0024)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x004C(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RequiredTagsDescription;                           // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingLevelGameplayEffectInfo">();
	}
	static class UBuildingLevelGameplayEffectInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingLevelGameplayEffectInfo>();
	}
};
static_assert(alignof(UBuildingLevelGameplayEffectInfo) == 0x000004, "Wrong alignment on UBuildingLevelGameplayEffectInfo");
static_assert(sizeof(UBuildingLevelGameplayEffectInfo) == 0x000070, "Wrong size on UBuildingLevelGameplayEffectInfo");
static_assert(offsetof(UBuildingLevelGameplayEffectInfo, NumericDescription) == 0x00001C, "Member 'UBuildingLevelGameplayEffectInfo::NumericDescription' has a wrong offset!");
static_assert(offsetof(UBuildingLevelGameplayEffectInfo, AttributeInfo) == 0x000028, "Member 'UBuildingLevelGameplayEffectInfo::AttributeInfo' has a wrong offset!");
static_assert(offsetof(UBuildingLevelGameplayEffectInfo, RequiredTags) == 0x00004C, "Member 'UBuildingLevelGameplayEffectInfo::RequiredTags' has a wrong offset!");
static_assert(offsetof(UBuildingLevelGameplayEffectInfo, RequiredTagsDescription) == 0x000064, "Member 'UBuildingLevelGameplayEffectInfo::RequiredTagsDescription' has a wrong offset!");

// Class FortniteGame.FortRegionInfo
// 0x0080 (0x009C - 0x001C)
class UFortRegionInfo final : public UDataAsset
{
public:
	class FText                                   RegionName;                                        // 0x001C(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RegionTags;                                        // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortRequirementsInfo                  Requirements;                                      // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortTheaterMapMissionData             MissionData;                                       // 0x0060(0x0024)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USlateBrushAsset>        RegionThemeIcon;                                   // 0x0084(0x0018)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegionInfo">();
	}
	static class UFortRegionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegionInfo>();
	}
};
static_assert(alignof(UFortRegionInfo) == 0x000004, "Wrong alignment on UFortRegionInfo");
static_assert(sizeof(UFortRegionInfo) == 0x00009C, "Wrong size on UFortRegionInfo");
static_assert(offsetof(UFortRegionInfo, RegionName) == 0x00001C, "Member 'UFortRegionInfo::RegionName' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, RegionTags) == 0x000028, "Member 'UFortRegionInfo::RegionTags' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, Requirements) == 0x000040, "Member 'UFortRegionInfo::Requirements' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, MissionData) == 0x000060, "Member 'UFortRegionInfo::MissionData' has a wrong offset!");
static_assert(offsetof(UFortRegionInfo, RegionThemeIcon) == 0x000084, "Member 'UFortRegionInfo::RegionThemeIcon' has a wrong offset!");

// Class FortniteGame.AccumulatedGameplayEffectInfo
// 0x0080 (0x009C - 0x001C)
class UAccumulatedGameplayEffectInfo final : public UObject
{
public:
	struct FGameplayEffectInfo                    AccumulatedEffect;                                 // 0x001C(0x0024)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NextUpgradeRating;                                 // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AccumulatedEffectCount;                            // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAttributeInfo                     AttributeInfo;                                     // 0x0048(0x0024)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectInfo>            AllEffects;                                        // 0x006C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RequiredTagsDescription;                           // 0x0090(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	struct FGameplayEffectInfo GetRelativeEffectAtRating(const int32 NewRating) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccumulatedGameplayEffectInfo">();
	}
	static class UAccumulatedGameplayEffectInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccumulatedGameplayEffectInfo>();
	}
};
static_assert(alignof(UAccumulatedGameplayEffectInfo) == 0x000004, "Wrong alignment on UAccumulatedGameplayEffectInfo");
static_assert(sizeof(UAccumulatedGameplayEffectInfo) == 0x00009C, "Wrong size on UAccumulatedGameplayEffectInfo");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, AccumulatedEffect) == 0x00001C, "Member 'UAccumulatedGameplayEffectInfo::AccumulatedEffect' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, NextUpgradeRating) == 0x000040, "Member 'UAccumulatedGameplayEffectInfo::NextUpgradeRating' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, AccumulatedEffectCount) == 0x000044, "Member 'UAccumulatedGameplayEffectInfo::AccumulatedEffectCount' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, AttributeInfo) == 0x000048, "Member 'UAccumulatedGameplayEffectInfo::AttributeInfo' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, AllEffects) == 0x00006C, "Member 'UAccumulatedGameplayEffectInfo::AllEffects' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, RequiredTags) == 0x000078, "Member 'UAccumulatedGameplayEffectInfo::RequiredTags' has a wrong offset!");
static_assert(offsetof(UAccumulatedGameplayEffectInfo, RequiredTagsDescription) == 0x000090, "Member 'UAccumulatedGameplayEffectInfo::RequiredTagsDescription' has a wrong offset!");

// Class FortniteGame.FortGameMode
// 0x0104 (0x03D4 - 0x02D0)
class AFortGameMode : public AGameMode
{
public:
	uint8                                         bBuildAnimCheat : 1;                               // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableCloudStorage : 1;                          // 0x02D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTravelInitiated : 1;                              // 0x02D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTeamGame : 1;                                     // 0x02D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheatBuildAnimHeight;                              // 0x02D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheatBuildAnimInterpSpeedMultiplier;               // 0x02D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheatBuildMaxDelay;                                // 0x02DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildingConstructionTimeModifier;                  // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentWUID;                                       // 0x02E4(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlaylistId;                                 // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentZoneInstanceId;                             // 0x02F4(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x4];                                      // 0x0300(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ForceWorldName;                                    // 0x0304(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneIndex;                                         // 0x0310(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayersInvincible : 1;                            // 0x0314(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bKickIdlers;                                       // 0x0318(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxIdleTime;                                       // 0x031C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortGameDeathPenalty>   DeathPenaltyData;                                  // 0x0320(0x0018)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  StartingObjectiveObject;                           // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x4];                                      // 0x0340(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGameSession*                       FortGameSession;                                   // 0x0344(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameModeSessionString;                             // 0x0348(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultPawnClassName;                              // 0x0354(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortMissionManager>        MissionManagerClass;                               // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x10];                                     // 0x0364(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EFortGameplayState                            PendingTimerState;                                 // 0x0374(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_375[0x7];                                      // 0x0375(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWorldIsReady : 1;                                 // 0x037C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bTheaterDataIsReady : 1;                           // 0x037C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TheaterSlot;                                       // 0x0380(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameContextTags;                                   // 0x0384(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          FakePlayerClass;                                   // 0x039C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortRegisteredPlayer>          RegisteredPlayers;                                 // 0x03A0(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AFortTeamInfo>              TeamInfoClass;                                     // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortMissionGenerationManager*          MissionGenerationManager;                          // 0x03D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleScoreToXPUpdate();

	void DumpReservations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameMode">();
	}
	static class AFortGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameMode>();
	}
};
static_assert(alignof(AFortGameMode) == 0x000004, "Wrong alignment on AFortGameMode");
static_assert(sizeof(AFortGameMode) == 0x0003D4, "Wrong size on AFortGameMode");
static_assert(offsetof(AFortGameMode, CheatBuildAnimHeight) == 0x0002D4, "Member 'AFortGameMode::CheatBuildAnimHeight' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CheatBuildAnimInterpSpeedMultiplier) == 0x0002D8, "Member 'AFortGameMode::CheatBuildAnimInterpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CheatBuildMaxDelay) == 0x0002DC, "Member 'AFortGameMode::CheatBuildMaxDelay' has a wrong offset!");
static_assert(offsetof(AFortGameMode, BuildingConstructionTimeModifier) == 0x0002E0, "Member 'AFortGameMode::BuildingConstructionTimeModifier' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CurrentWUID) == 0x0002E4, "Member 'AFortGameMode::CurrentWUID' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CurrentPlaylistId) == 0x0002F0, "Member 'AFortGameMode::CurrentPlaylistId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, CurrentZoneInstanceId) == 0x0002F4, "Member 'AFortGameMode::CurrentZoneInstanceId' has a wrong offset!");
static_assert(offsetof(AFortGameMode, ForceWorldName) == 0x000304, "Member 'AFortGameMode::ForceWorldName' has a wrong offset!");
static_assert(offsetof(AFortGameMode, ZoneIndex) == 0x000310, "Member 'AFortGameMode::ZoneIndex' has a wrong offset!");
static_assert(offsetof(AFortGameMode, bKickIdlers) == 0x000318, "Member 'AFortGameMode::bKickIdlers' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MaxIdleTime) == 0x00031C, "Member 'AFortGameMode::MaxIdleTime' has a wrong offset!");
static_assert(offsetof(AFortGameMode, DeathPenaltyData) == 0x000320, "Member 'AFortGameMode::DeathPenaltyData' has a wrong offset!");
static_assert(offsetof(AFortGameMode, StartingObjectiveObject) == 0x000338, "Member 'AFortGameMode::StartingObjectiveObject' has a wrong offset!");
static_assert(offsetof(AFortGameMode, FortGameSession) == 0x000344, "Member 'AFortGameMode::FortGameSession' has a wrong offset!");
static_assert(offsetof(AFortGameMode, GameModeSessionString) == 0x000348, "Member 'AFortGameMode::GameModeSessionString' has a wrong offset!");
static_assert(offsetof(AFortGameMode, DefaultPawnClassName) == 0x000354, "Member 'AFortGameMode::DefaultPawnClassName' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MissionManagerClass) == 0x000360, "Member 'AFortGameMode::MissionManagerClass' has a wrong offset!");
static_assert(offsetof(AFortGameMode, PendingTimerState) == 0x000374, "Member 'AFortGameMode::PendingTimerState' has a wrong offset!");
static_assert(offsetof(AFortGameMode, TheaterSlot) == 0x000380, "Member 'AFortGameMode::TheaterSlot' has a wrong offset!");
static_assert(offsetof(AFortGameMode, GameContextTags) == 0x000384, "Member 'AFortGameMode::GameContextTags' has a wrong offset!");
static_assert(offsetof(AFortGameMode, FakePlayerClass) == 0x00039C, "Member 'AFortGameMode::FakePlayerClass' has a wrong offset!");
static_assert(offsetof(AFortGameMode, RegisteredPlayers) == 0x0003A0, "Member 'AFortGameMode::RegisteredPlayers' has a wrong offset!");
static_assert(offsetof(AFortGameMode, TeamInfoClass) == 0x0003AC, "Member 'AFortGameMode::TeamInfoClass' has a wrong offset!");
static_assert(offsetof(AFortGameMode, MissionGenerationManager) == 0x0003D0, "Member 'AFortGameMode::MissionGenerationManager' has a wrong offset!");

// Class FortniteGame.FortGameModeEmptyDedicated
// 0x0004 (0x03D8 - 0x03D4)
class AFortGameModeEmptyDedicated final : public AFortGameMode
{
public:
	class AFortGameSessionDedicated*              FortGameSessionDedicated;                          // 0x03D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeEmptyDedicated">();
	}
	static class AFortGameModeEmptyDedicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeEmptyDedicated>();
	}
};
static_assert(alignof(AFortGameModeEmptyDedicated) == 0x000004, "Wrong alignment on AFortGameModeEmptyDedicated");
static_assert(sizeof(AFortGameModeEmptyDedicated) == 0x0003D8, "Wrong size on AFortGameModeEmptyDedicated");
static_assert(offsetof(AFortGameModeEmptyDedicated, FortGameSessionDedicated) == 0x0003D4, "Member 'AFortGameModeEmptyDedicated::FortGameSessionDedicated' has a wrong offset!");

// Class FortniteGame.FortItemCollectedParams
// 0x000C (0x0028 - 0x001C)
class UFortItemCollectedParams final : public UFortMissionEventParams
{
public:
	class UFortWorldItemDefinition*               CollectedItemDefinition;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  CollectedBy;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountCollected;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class UFortWorldItemDefinition** _CollectedItemDefinition, class AFortPlayerController** _CollectedBy, int32* _AmountCollected);
	void MakeData(const class UFortWorldItemDefinition* _CollectedItemDefinition, class AFortPlayerController* _CollectedBy, int32 _AmountCollected, class UFortItemCollectedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCollectedParams">();
	}
	static class UFortItemCollectedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCollectedParams>();
	}
};
static_assert(alignof(UFortItemCollectedParams) == 0x000004, "Wrong alignment on UFortItemCollectedParams");
static_assert(sizeof(UFortItemCollectedParams) == 0x000028, "Wrong size on UFortItemCollectedParams");
static_assert(offsetof(UFortItemCollectedParams, CollectedItemDefinition) == 0x00001C, "Member 'UFortItemCollectedParams::CollectedItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemCollectedParams, CollectedBy) == 0x000020, "Member 'UFortItemCollectedParams::CollectedBy' has a wrong offset!");
static_assert(offsetof(UFortItemCollectedParams, AmountCollected) == 0x000024, "Member 'UFortItemCollectedParams::AmountCollected' has a wrong offset!");

// Class FortniteGame.AIHotSpotConfig
// 0x0014 (0x0030 - 0x001C)
class UAIHotSpotConfig final : public UDataAsset
{
public:
	TArray<struct FAIHotSpotSlotConfig>           Slots;                                             // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDetectUnreachableSlots : 1;                       // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIHotSpotSlotGenerator*                SlotGenerator;                                     // 0x002C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotConfig">();
	}
	static class UAIHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotConfig>();
	}
};
static_assert(alignof(UAIHotSpotConfig) == 0x000004, "Wrong alignment on UAIHotSpotConfig");
static_assert(sizeof(UAIHotSpotConfig) == 0x000030, "Wrong size on UAIHotSpotConfig");
static_assert(offsetof(UAIHotSpotConfig, Slots) == 0x00001C, "Member 'UAIHotSpotConfig::Slots' has a wrong offset!");
static_assert(offsetof(UAIHotSpotConfig, SlotGenerator) == 0x00002C, "Member 'UAIHotSpotConfig::SlotGenerator' has a wrong offset!");

// Class FortniteGame.WorldMapPin
// 0x000C (0x024C - 0x0240)
class AWorldMapPin final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       WidgetComponent;                                   // 0x0244(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TheaterIndex;                                      // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTheaterIndexSet();
	void SetTheaterIndex(int32 NewIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapPin">();
	}
	static class AWorldMapPin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldMapPin>();
	}
};
static_assert(alignof(AWorldMapPin) == 0x000004, "Wrong alignment on AWorldMapPin");
static_assert(sizeof(AWorldMapPin) == 0x00024C, "Wrong size on AWorldMapPin");
static_assert(offsetof(AWorldMapPin, SceneComponent) == 0x000240, "Member 'AWorldMapPin::SceneComponent' has a wrong offset!");
static_assert(offsetof(AWorldMapPin, WidgetComponent) == 0x000244, "Member 'AWorldMapPin::WidgetComponent' has a wrong offset!");
static_assert(offsetof(AWorldMapPin, TheaterIndex) == 0x000248, "Member 'AWorldMapPin::TheaterIndex' has a wrong offset!");

// Class FortniteGame.AIHotSpotSlot
// 0x0084 (0x00A0 - 0x001C)
class UAIHotSpotSlot : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UserId;                                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStartEnabled : 1;                                 // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasCachedAgentData : 1;                           // 0x005C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasOverlappingSlots : 1;                          // 0x005C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsBlockingOthers : 1;                             // 0x005C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsEnabled : 1;                                    // 0x005C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          Owner;                                             // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotIndex;                                         // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIHotSpotSlot                                SlotState;                                         // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x37];                                      // 0x0069(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSlot();
	void OnStateChanged(class AAIController* SlotOwner, EAIHotSpotSlot NewState);
	void SetSlotEnabled(bool bNewEnabled);
	void SetSlotOwnerAndState(class AAIController* NewOwner, EAIHotSpotSlot NewState);
	void SetSlotState(EAIHotSpotSlot NewState);

	class AAIHotSpot* GetHotSpot() const;
	struct FBox GetSlotBounds() const;
	float GetSlotHeight() const;
	int32 GetSlotIndex() const;
	struct FVector GetSlotLocation() const;
	class AAIController* GetSlotOwner() const;
	float GetSlotRadius() const;
	struct FRotator GetSlotRotation() const;
	EAIHotSpotSlot GetSlotState() const;
	int32 GetSlotUserId() const;
	bool HasUserId() const;
	bool IsAIAllowed(const class AAIController* AI) const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlot">();
	}
	static class UAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlot>();
	}
};
static_assert(alignof(UAIHotSpotSlot) == 0x000010, "Wrong alignment on UAIHotSpotSlot");
static_assert(sizeof(UAIHotSpotSlot) == 0x0000A0, "Wrong size on UAIHotSpotSlot");
static_assert(offsetof(UAIHotSpotSlot, LocalTransform) == 0x000020, "Member 'UAIHotSpotSlot::LocalTransform' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Height) == 0x000050, "Member 'UAIHotSpotSlot::Height' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Radius) == 0x000054, "Member 'UAIHotSpotSlot::Radius' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, UserId) == 0x000058, "Member 'UAIHotSpotSlot::UserId' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, Owner) == 0x000060, "Member 'UAIHotSpotSlot::Owner' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotIndex) == 0x000064, "Member 'UAIHotSpotSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlot, SlotState) == 0x000068, "Member 'UAIHotSpotSlot::SlotState' has a wrong offset!");

// Class FortniteGame.FortDifficultyOption
// 0x0010 (0x002C - 0x001C)
class UFortDifficultyOption : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CostAndAvailability;                               // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOption">();
	}
	static class UFortDifficultyOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOption>();
	}
};
static_assert(alignof(UFortDifficultyOption) == 0x000004, "Wrong alignment on UFortDifficultyOption");
static_assert(sizeof(UFortDifficultyOption) == 0x00002C, "Wrong size on UFortDifficultyOption");
static_assert(offsetof(UFortDifficultyOption, CostAndAvailability) == 0x000020, "Member 'UFortDifficultyOption::CostAndAvailability' has a wrong offset!");

// Class FortniteGame.FortGameplayCueNotify_Simple
// 0x0014 (0x0044 - 0x0030)
class UFortGameplayCueNotify_Simple : public UGameplayCueNotify_Static
{
public:
	class USoundBase*                             StartSound;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StartParticleSystem;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPoint;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayAttached;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseHitResult;                                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeapon;                                        // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotation;                                   // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueNotify_Simple">();
	}
	static class UFortGameplayCueNotify_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayCueNotify_Simple>();
	}
};
static_assert(alignof(UFortGameplayCueNotify_Simple) == 0x000004, "Wrong alignment on UFortGameplayCueNotify_Simple");
static_assert(sizeof(UFortGameplayCueNotify_Simple) == 0x000044, "Wrong size on UFortGameplayCueNotify_Simple");
static_assert(offsetof(UFortGameplayCueNotify_Simple, StartSound) == 0x000030, "Member 'UFortGameplayCueNotify_Simple::StartSound' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, StartParticleSystem) == 0x000034, "Member 'UFortGameplayCueNotify_Simple::StartParticleSystem' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, AttachPoint) == 0x000038, "Member 'UFortGameplayCueNotify_Simple::AttachPoint' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bStayAttached) == 0x000040, "Member 'UFortGameplayCueNotify_Simple::bStayAttached' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bUseHitResult) == 0x000041, "Member 'UFortGameplayCueNotify_Simple::bUseHitResult' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bUseWeapon) == 0x000042, "Member 'UFortGameplayCueNotify_Simple::bUseWeapon' has a wrong offset!");
static_assert(offsetof(UFortGameplayCueNotify_Simple, bIgnoreRotation) == 0x000043, "Member 'UFortGameplayCueNotify_Simple::bIgnoreRotation' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategory
// 0x0004 (0x0020 - 0x001C)
class UFortDifficultyOptionCategory : public UDataAsset
{
public:
	bool                                          bIsRequired;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsStatic;                                         // 0x001D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasValueRange;                                    // 0x001E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategory">();
	}
	static class UFortDifficultyOptionCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategory>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategory) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategory");
static_assert(sizeof(UFortDifficultyOptionCategory) == 0x000020, "Wrong size on UFortDifficultyOptionCategory");
static_assert(offsetof(UFortDifficultyOptionCategory, bIsRequired) == 0x00001C, "Member 'UFortDifficultyOptionCategory::bIsRequired' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionCategory, bIsStatic) == 0x00001D, "Member 'UFortDifficultyOptionCategory::bIsStatic' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionCategory, bHasValueRange) == 0x00001E, "Member 'UFortDifficultyOptionCategory::bHasValueRange' has a wrong offset!");

// Class FortniteGame.FortMissionConfigData
// 0x0000 (0x001C - 0x001C)
class UFortMissionConfigData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionConfigData">();
	}
	static class UFortMissionConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionConfigData>();
	}
};
static_assert(alignof(UFortMissionConfigData) == 0x000004, "Wrong alignment on UFortMissionConfigData");
static_assert(sizeof(UFortMissionConfigData) == 0x00001C, "Wrong size on UFortMissionConfigData");

// Class FortniteGame.FortAIHotSpot_Building
// 0x0024 (0x0348 - 0x0324)
class AFortAIHotSpot_Building final : public AFortAIHotSpot
{
public:
	EFortHotSpotDirection                         DirectionType;                                     // 0x0324(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_325[0x23];                                     // 0x0325(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpot_Building">();
	}
	static class AFortAIHotSpot_Building* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIHotSpot_Building>();
	}
};
static_assert(alignof(AFortAIHotSpot_Building) == 0x000004, "Wrong alignment on AFortAIHotSpot_Building");
static_assert(sizeof(AFortAIHotSpot_Building) == 0x000348, "Wrong size on AFortAIHotSpot_Building");
static_assert(offsetof(AFortAIHotSpot_Building, DirectionType) == 0x000324, "Member 'AFortAIHotSpot_Building::DirectionType' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility
// 0x03D0 (0x06DC - 0x030C)
class UFortGameplayAbility : public UGameplayAbility
{
public:
	uint8                                         Pad_30C[0x8];                                      // 0x030C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EFortGameplayAbilityActivation                ActivationType;                                    // 0x0314(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainer           EffectContainers[0x5];                             // 0x0318(0x006C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortGameplayEffectContainer>   GameplayEffectContainers;                          // 0x0534(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortProjectileBase>        ProjectileClass;                                   // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x0544(0x000C)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FFortAbilityCost>               AbilityCosts;                                      // 0x0550(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bShowWidgetForCosts : 1;                           // 0x055C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartWithCooldown;                                // 0x0560(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPersistOnDeath;                                   // 0x0561(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_562[0x2];                                      // 0x0562(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ProhibitedTargetTags;                              // 0x0564(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bStopsAIBehaviorLogic;                             // 0x057C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bStopsAIMovement;                                  // 0x057D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRelevantForAIDespawning;                          // 0x057E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAIFireLocationAndRotation;                     // 0x057F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FireOffset;                                        // 0x0580(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bVerifyFireOffsetIsNotObstructedByWorldGeometry;   // 0x058C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanHitBallisticTestsOnlyTestIndesructiblesWhileFalling; // 0x058D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58E[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivationNoiseRange;                              // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactNoiseRange;                                  // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationNoiseLoudness;                           // 0x0598(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactNoiseLoudness;                               // 0x059C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeadPawnTargets;                                  // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredThrowAngle;                                 // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawAngleToFire;                                 // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMaxYawAngleToFire;                           // 0x05AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseTargetActorLocation;                           // 0x05AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AE[0x2];                                      // 0x05AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialAccuracyMax;                                // 0x05B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAccuracyMin;                                // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAccuracyMax;                                 // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetAccuracyMin;                                 // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAccuracyDistance;                               // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccuracyDistance;                               // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccuracyDistanceMultiplier;                        // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumUsesToReachTargetAccuracy;                      // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortGameplayAbilityBehaviorDistanceData> GameplayAbilityBehaviorDistanceData;               // 0x05D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x14];                                     // 0x05E0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayAbilityMontageInfo        MontageInfo;                                       // 0x05F4(0x0044)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0638(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0644(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0x4];                                      // 0x0650(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconOverride;                                      // 0x0654(0x0074)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x10];                                     // 0x06C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortTooltip>               Tooltip;                                           // 0x06D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const TArray<struct FActiveGameplayEffectHandle> ApplyGameplayEffectContainer(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel);
	void ClearAIFocalPoint();
	void EquipAbilityWeapon(class UFortWeaponItemDefinition* WeaponDefinition, int32 ItemLevel);
	struct FVector GetAimLocationNearestPawn(class AFortPawn* Instigator);
	void K2_AbilityCompleted();
	void K2_TriggerFromAnimation(const struct FGameplayTag& ApplicationTag);
	struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpec(const struct FGameplayTag& ApplicationTag, int32 GameplayEffectLevel);
	void OnAbilityInputReleased();
	void RemoveAbilityWeapon();
	void SetAIFocalPoint(class AActor* FocusTarget, const struct FVector& FocalPoint);
	bool SetupIconOverride();

	struct FVector ApplyAccuracyToTargetLocation(const struct FVector& SourceLocation, const struct FVector& TargetLocation, float inDesiredThrowAngle) const;
	bool DoesTargetHaveProhibitedTagsForAI(const class AActor* Target) const;
	bool DoesTargetHaveTags(const class AActor* Target, const struct FGameplayTagContainer& Tags) const;
	class UFortAbilitySystemComponent* GetActivatingAbilityComponent() const;
	class AFortPawn* GetActivatingPawn() const;
	class AActor* GetAIAbilityTarget() const;
	void GetCurrentAbilitySource(EFortAbilitySourceType* OutSourceType, int32* OutSourceLevel) const;
	class UFortWorldItemDefinition* GetCurrentSourceItemDefinition() const;
	class AFortWeapon* GetCurrentSourceWeapon() const;
	struct FTransform GetCustomAbilitySourceTransform() const;
	struct FVector GetFireLocation() const;
	struct FRotator GetFireRotation(bool bApplyLeading, bool bApplyInaccuracy, bool bApplyClampedMaxYawAngleToFire) const;
	const struct FFortGameplayEffectContainer GetGameplayEffectContainer(const struct FGameplayTag& ApplicationTag) const;
	void GetProjectileInitialValues(float* outProjectileSpeed, struct FRotator* outSpawnDirection, float* outProjectileGravity, class AActor** HomingTarget, bool bApplyInaccuracy, bool bApplyClampedMaxYawAngleToFire, bool bApplyLeading) const;
	struct FFortAbilityTargetSelectionList GetTargetSelectionList(const struct FGameplayTag& ApplicationTag) const;
	TSubclassOf<class UFortTooltip> GetTooltip() const;
	bool IsTargetOutsideOfMaxYawRotation() const;
	bool K2_ShouldUseDecoTool(const struct FGameplayAbilityActorInfo& ActorInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility">();
	}
	static class UFortGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility>();
	}
};
static_assert(alignof(UFortGameplayAbility) == 0x000004, "Wrong alignment on UFortGameplayAbility");
static_assert(sizeof(UFortGameplayAbility) == 0x0006DC, "Wrong size on UFortGameplayAbility");
static_assert(offsetof(UFortGameplayAbility, ActivationType) == 0x000314, "Member 'UFortGameplayAbility::ActivationType' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, EffectContainers) == 0x000318, "Member 'UFortGameplayAbility::EffectContainers' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, GameplayEffectContainers) == 0x000534, "Member 'UFortGameplayAbility::GameplayEffectContainers' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ProjectileClass) == 0x000540, "Member 'UFortGameplayAbility::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DamageStatHandle) == 0x000544, "Member 'UFortGameplayAbility::DamageStatHandle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, AbilityCosts) == 0x000550, "Member 'UFortGameplayAbility::AbilityCosts' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bStartWithCooldown) == 0x000560, "Member 'UFortGameplayAbility::bStartWithCooldown' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bPersistOnDeath) == 0x000561, "Member 'UFortGameplayAbility::bPersistOnDeath' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ProhibitedTargetTags) == 0x000564, "Member 'UFortGameplayAbility::ProhibitedTargetTags' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bStopsAIBehaviorLogic) == 0x00057C, "Member 'UFortGameplayAbility::bStopsAIBehaviorLogic' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bStopsAIMovement) == 0x00057D, "Member 'UFortGameplayAbility::bStopsAIMovement' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bRelevantForAIDespawning) == 0x00057E, "Member 'UFortGameplayAbility::bRelevantForAIDespawning' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bUseAIFireLocationAndRotation) == 0x00057F, "Member 'UFortGameplayAbility::bUseAIFireLocationAndRotation' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, FireOffset) == 0x000580, "Member 'UFortGameplayAbility::FireOffset' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bVerifyFireOffsetIsNotObstructedByWorldGeometry) == 0x00058C, "Member 'UFortGameplayAbility::bVerifyFireOffsetIsNotObstructedByWorldGeometry' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bCanHitBallisticTestsOnlyTestIndesructiblesWhileFalling) == 0x00058D, "Member 'UFortGameplayAbility::bCanHitBallisticTestsOnlyTestIndesructiblesWhileFalling' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ActivationNoiseRange) == 0x000590, "Member 'UFortGameplayAbility::ActivationNoiseRange' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ImpactNoiseRange) == 0x000594, "Member 'UFortGameplayAbility::ImpactNoiseRange' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ActivationNoiseLoudness) == 0x000598, "Member 'UFortGameplayAbility::ActivationNoiseLoudness' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, ImpactNoiseLoudness) == 0x00059C, "Member 'UFortGameplayAbility::ImpactNoiseLoudness' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bLeadPawnTargets) == 0x0005A0, "Member 'UFortGameplayAbility::bLeadPawnTargets' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DesiredThrowAngle) == 0x0005A4, "Member 'UFortGameplayAbility::DesiredThrowAngle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MaxYawAngleToFire) == 0x0005A8, "Member 'UFortGameplayAbility::MaxYawAngleToFire' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bClampMaxYawAngleToFire) == 0x0005AC, "Member 'UFortGameplayAbility::bClampMaxYawAngleToFire' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, bUseTargetActorLocation) == 0x0005AD, "Member 'UFortGameplayAbility::bUseTargetActorLocation' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, InitialAccuracyMax) == 0x0005B0, "Member 'UFortGameplayAbility::InitialAccuracyMax' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, InitialAccuracyMin) == 0x0005B4, "Member 'UFortGameplayAbility::InitialAccuracyMin' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, TargetAccuracyMax) == 0x0005B8, "Member 'UFortGameplayAbility::TargetAccuracyMax' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, TargetAccuracyMin) == 0x0005BC, "Member 'UFortGameplayAbility::TargetAccuracyMin' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MinAccuracyDistance) == 0x0005C0, "Member 'UFortGameplayAbility::MinAccuracyDistance' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MaxAccuracyDistance) == 0x0005C4, "Member 'UFortGameplayAbility::MaxAccuracyDistance' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, AccuracyDistanceMultiplier) == 0x0005C8, "Member 'UFortGameplayAbility::AccuracyDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, NumUsesToReachTargetAccuracy) == 0x0005CC, "Member 'UFortGameplayAbility::NumUsesToReachTargetAccuracy' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, UseCount) == 0x0005D0, "Member 'UFortGameplayAbility::UseCount' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, GameplayAbilityBehaviorDistanceData) == 0x0005D4, "Member 'UFortGameplayAbility::GameplayAbilityBehaviorDistanceData' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, MontageInfo) == 0x0005F4, "Member 'UFortGameplayAbility::MontageInfo' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, DisplayName) == 0x000638, "Member 'UFortGameplayAbility::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, Description) == 0x000644, "Member 'UFortGameplayAbility::Description' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, IconOverride) == 0x000654, "Member 'UFortGameplayAbility::IconOverride' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility, Tooltip) == 0x0006D8, "Member 'UFortGameplayAbility::Tooltip' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Reload
// 0x000C (0x06E8 - 0x06DC)
class UFortGameplayAbility_Reload final : public UFortGameplayAbility
{
public:
	int32                                         NumTimesReloaded;                                  // 0x06DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x8];                                      // 0x06E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Reload">();
	}
	static class UFortGameplayAbility_Reload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Reload>();
	}
};
static_assert(alignof(UFortGameplayAbility_Reload) == 0x000004, "Wrong alignment on UFortGameplayAbility_Reload");
static_assert(sizeof(UFortGameplayAbility_Reload) == 0x0006E8, "Wrong size on UFortGameplayAbility_Reload");
static_assert(offsetof(UFortGameplayAbility_Reload, NumTimesReloaded) == 0x0006DC, "Member 'UFortGameplayAbility_Reload::NumTimesReloaded' has a wrong offset!");

// Class FortniteGame.AIHotSpotManagerProxy
// 0x0040 (0x005C - 0x001C)
class UAIHotSpotManagerProxy : public UAIHotSpotManager
{
public:
	uint8                                         Pad_1C[0x40];                                      // 0x001C(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotManagerProxy">();
	}
	static class UAIHotSpotManagerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotManagerProxy>();
	}
};
static_assert(alignof(UAIHotSpotManagerProxy) == 0x000004, "Wrong alignment on UAIHotSpotManagerProxy");
static_assert(sizeof(UAIHotSpotManagerProxy) == 0x00005C, "Wrong size on UAIHotSpotManagerProxy");

// Class FortniteGame.BuildingActorHotSpotConfig
// 0x00AC (0x00C8 - 0x001C)
class UBuildingActorHotSpotConfig final : public UDataAsset
{
public:
	struct FBuildingActorHotSpotDirection         HotSpotPerDirection[0x6];                          // 0x001C(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBuildingActorHotSpotDirection         FallBackConfig;                                    // 0x00AC(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHasDirectionalSetup : 1;                          // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotConfig">();
	}
	static class UBuildingActorHotSpotConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotConfig>();
	}
};
static_assert(alignof(UBuildingActorHotSpotConfig) == 0x000004, "Wrong alignment on UBuildingActorHotSpotConfig");
static_assert(sizeof(UBuildingActorHotSpotConfig) == 0x0000C8, "Wrong size on UBuildingActorHotSpotConfig");
static_assert(offsetof(UBuildingActorHotSpotConfig, HotSpotPerDirection) == 0x00001C, "Member 'UBuildingActorHotSpotConfig::HotSpotPerDirection' has a wrong offset!");
static_assert(offsetof(UBuildingActorHotSpotConfig, FallBackConfig) == 0x0000AC, "Member 'UBuildingActorHotSpotConfig::FallBackConfig' has a wrong offset!");

// Class FortniteGame.FortCameraMode
// 0x0020 (0x003C - 0x001C)
class UFortCameraMode : public UObject
{
public:
	class AFortPlayerCameraBase*                  PlayerCamera;                                      // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionOutTime;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bResetInterpolation : 1;                           // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode">();
	}
	static class UFortCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode>();
	}
};
static_assert(alignof(UFortCameraMode) == 0x000004, "Wrong alignment on UFortCameraMode");
static_assert(sizeof(UFortCameraMode) == 0x00003C, "Wrong size on UFortCameraMode");
static_assert(offsetof(UFortCameraMode, PlayerCamera) == 0x00001C, "Member 'UFortCameraMode::PlayerCamera' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionTime) == 0x000020, "Member 'UFortCameraMode::TransitionTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionOutTime) == 0x000024, "Member 'UFortCameraMode::TransitionOutTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode, TransitionParams) == 0x000028, "Member 'UFortCameraMode::TransitionParams' has a wrong offset!");

// Class FortniteGame.Fort3PCameraMode
// 0x00D4 (0x0110 - 0x003C)
class UFort3PCameraMode : public UFortCameraMode
{
public:
	struct FViewOffsetData                        ViewOffsets;                                       // 0x003C(0x0024)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         FOV;                                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SafeLocationOffset;                                // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bValidateSafeLoc : 1;                              // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDoPredictiveAvoidance : 1;                        // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bPreventPenetration : 1;                           // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPenetrationAvoidanceFeeler>    PenetrationAvoidanceFeelers;                       // 0x0074(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendInTime;                            // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PenetrationBlendOutTime;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PivotLocInterpSpeed;                               // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PivotRotInterpSpeed;                               // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FOVInterpSpeed;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewOffsetInterpSpeed;                             // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SafeLocationInterpSpeed;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastActualViewOffset;                              // 0x00A4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LastIdealViewOffset;                               // 0x00B0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         LastFOV;                                           // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastSafeLocationLocal;                             // 0x00C0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LastSafeLocation;                                  // 0x00CC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         LastSafeLocBlockedPct;                             // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastPenetrationBlockedPct;                         // 0x00DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LastActualPivotLoc;                                // 0x00E0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               LastActualPivotRot;                                // 0x00EC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LastIdealPivotLoc;                                 // 0x00F8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               LastIdealPivotRot;                                 // 0x0104(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCameraMode">();
	}
	static class UFort3PCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCameraMode>();
	}
};
static_assert(alignof(UFort3PCameraMode) == 0x000004, "Wrong alignment on UFort3PCameraMode");
static_assert(sizeof(UFort3PCameraMode) == 0x000110, "Wrong size on UFort3PCameraMode");
static_assert(offsetof(UFort3PCameraMode, ViewOffsets) == 0x00003C, "Member 'UFort3PCameraMode::ViewOffsets' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, FOV) == 0x000060, "Member 'UFort3PCameraMode::FOV' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, SafeLocationOffset) == 0x000064, "Member 'UFort3PCameraMode::SafeLocationOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationAvoidanceFeelers) == 0x000074, "Member 'UFort3PCameraMode::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationBlendInTime) == 0x000080, "Member 'UFort3PCameraMode::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PenetrationBlendOutTime) == 0x000084, "Member 'UFort3PCameraMode::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PivotLocInterpSpeed) == 0x000088, "Member 'UFort3PCameraMode::PivotLocInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, PivotRotInterpSpeed) == 0x000094, "Member 'UFort3PCameraMode::PivotRotInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, FOVInterpSpeed) == 0x000098, "Member 'UFort3PCameraMode::FOVInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, ViewOffsetInterpSpeed) == 0x00009C, "Member 'UFort3PCameraMode::ViewOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, SafeLocationInterpSpeed) == 0x0000A0, "Member 'UFort3PCameraMode::SafeLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualViewOffset) == 0x0000A4, "Member 'UFort3PCameraMode::LastActualViewOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealViewOffset) == 0x0000B0, "Member 'UFort3PCameraMode::LastIdealViewOffset' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastFOV) == 0x0000BC, "Member 'UFort3PCameraMode::LastFOV' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocationLocal) == 0x0000C0, "Member 'UFort3PCameraMode::LastSafeLocationLocal' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocation) == 0x0000CC, "Member 'UFort3PCameraMode::LastSafeLocation' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastSafeLocBlockedPct) == 0x0000D8, "Member 'UFort3PCameraMode::LastSafeLocBlockedPct' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastPenetrationBlockedPct) == 0x0000DC, "Member 'UFort3PCameraMode::LastPenetrationBlockedPct' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualPivotLoc) == 0x0000E0, "Member 'UFort3PCameraMode::LastActualPivotLoc' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastActualPivotRot) == 0x0000EC, "Member 'UFort3PCameraMode::LastActualPivotRot' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealPivotLoc) == 0x0000F8, "Member 'UFort3PCameraMode::LastIdealPivotLoc' has a wrong offset!");
static_assert(offsetof(UFort3PCameraMode, LastIdealPivotRot) == 0x000104, "Member 'UFort3PCameraMode::LastIdealPivotRot' has a wrong offset!");

// Class FortniteGame.Fort3PCam_Default
// 0x0000 (0x0110 - 0x0110)
class UFort3PCam_Default : public UFort3PCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCam_Default">();
	}
	static class UFort3PCam_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCam_Default>();
	}
};
static_assert(alignof(UFort3PCam_Default) == 0x000004, "Wrong alignment on UFort3PCam_Default");
static_assert(sizeof(UFort3PCam_Default) == 0x000110, "Wrong size on UFort3PCam_Default");

// Class FortniteGame.FortAIHotSpotManager
// 0x0090 (0x00EC - 0x005C)
class UFortAIHotSpotManager final : public UAIHotSpotManagerProxy
{
public:
	TSoftObjectPtr<class UBuildingActorHotSpotConfig> FallbackHotspotConfig;                             // 0x005C(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x78];                                      // 0x0074(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotManager">();
	}
	static class UFortAIHotSpotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotManager>();
	}
};
static_assert(alignof(UFortAIHotSpotManager) == 0x000004, "Wrong alignment on UFortAIHotSpotManager");
static_assert(sizeof(UFortAIHotSpotManager) == 0x0000EC, "Wrong size on UFortAIHotSpotManager");
static_assert(offsetof(UFortAIHotSpotManager, FallbackHotspotConfig) == 0x00005C, "Member 'UFortAIHotSpotManager::FallbackHotspotConfig' has a wrong offset!");

// Class FortniteGame.AIHotSpotRenderingComponent
// 0x0004 (0x0430 - 0x042C)
class UAIHotSpotRenderingComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotRenderingComponent">();
	}
	static class UAIHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UAIHotSpotRenderingComponent) == 0x000004, "Wrong alignment on UAIHotSpotRenderingComponent");
static_assert(sizeof(UAIHotSpotRenderingComponent) == 0x000430, "Wrong size on UAIHotSpotRenderingComponent");

// Class FortniteGame.FortAIHotSpotSlot
// 0x0010 (0x00B0 - 0x00A0)
class UFortAIHotSpotSlot final : public UAIHotSpotSlot
{
public:
	EFortHotSpotSlot                              SlotType;                                          // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlot">();
	}
	static class UFortAIHotSpotSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlot>();
	}
};
static_assert(alignof(UFortAIHotSpotSlot) == 0x000010, "Wrong alignment on UFortAIHotSpotSlot");
static_assert(sizeof(UFortAIHotSpotSlot) == 0x0000B0, "Wrong size on UFortAIHotSpotSlot");
static_assert(offsetof(UFortAIHotSpotSlot, SlotType) == 0x0000A0, "Member 'UFortAIHotSpotSlot::SlotType' has a wrong offset!");

// Class FortniteGame.AIHotSpotSlotGenerator
// 0x0000 (0x001C - 0x001C)
class UAIHotSpotSlotGenerator : public UObject
{
public:
	void GenerateSlots();

	class UAIHotSpotSlot* AddSlot(const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, TSubclassOf<class UAIHotSpotSlot> CustomSlotClass, bool bEnabled) const;
	class AAIHotSpot* GetHotSpot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator">();
	}
	static class UAIHotSpotSlotGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator) == 0x000004, "Wrong alignment on UAIHotSpotSlotGenerator");
static_assert(sizeof(UAIHotSpotSlotGenerator) == 0x00001C, "Wrong size on UAIHotSpotSlotGenerator");

// Class FortniteGame.AIHotSpotSlotGenerator_OnBoundingBox
// 0x0040 (0x005C - 0x001C)
class UAIHotSpotSlotGenerator_OnBoundingBox : public UAIHotSpotSlotGenerator
{
public:
	TSubclassOf<class UAIHotSpotSlot>             SlotClass;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxExtent;                                         // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExpandBy;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetFromEdge;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spacing;                                           // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLimitMaxExtent : 1;                               // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBoundingBoxSlotDirectionCalculation          SlotDirectionCalculation;                          // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x1F];                                      // 0x003D(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x000004, "Wrong alignment on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UAIHotSpotSlotGenerator_OnBoundingBox) == 0x00005C, "Wrong size on UAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotClass) == 0x00001C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotClass' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, MaxExtent) == 0x000020, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::MaxExtent' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, ExpandBy) == 0x00002C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::ExpandBy' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, OffsetFromEdge) == 0x000030, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::OffsetFromEdge' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, Spacing) == 0x000034, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::Spacing' has a wrong offset!");
static_assert(offsetof(UAIHotSpotSlotGenerator_OnBoundingBox, SlotDirectionCalculation) == 0x00003C, "Member 'UAIHotSpotSlotGenerator_OnBoundingBox::SlotDirectionCalculation' has a wrong offset!");

// Class FortniteGame.FortCarriedObject
// 0x0120 (0x0360 - 0x0240)
class AFortCarriedObject : public AActor
{
public:
	uint8                                         Pad_240[0xC];                                      // 0x0240(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileComp;                                    // 0x024C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCarriedObjectAttachmentInfo           HolderInfo;                                        // 0x0258(0x0024)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x24];                                     // 0x027C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IndicatorRelativeOffset;                           // 0x02A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            Indicator;                                         // 0x02AC(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            DefaultIndicatorColor;                             // 0x0320(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RelativeTranslation;                               // 0x033C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeRotation;                                  // 0x0348(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPickupOnTouch;                                    // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x0355(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_356[0x2];                                      // 0x0356(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingFlagSpawn*                     SpawnPointActor;                                   // 0x0358(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HolderInfo(struct FCarriedObjectAttachmentInfo* PreviousInfo);
	void ReturnToSpawnPoint();

	class AActor* GetHoldingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObject">();
	}
	static class AFortCarriedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCarriedObject>();
	}
};
static_assert(alignof(AFortCarriedObject) == 0x000004, "Wrong alignment on AFortCarriedObject");
static_assert(sizeof(AFortCarriedObject) == 0x000360, "Wrong size on AFortCarriedObject");
static_assert(offsetof(AFortCarriedObject, ProjectileComp) == 0x00024C, "Member 'AFortCarriedObject::ProjectileComp' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, HolderInfo) == 0x000258, "Member 'AFortCarriedObject::HolderInfo' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, IndicatorRelativeOffset) == 0x0002A0, "Member 'AFortCarriedObject::IndicatorRelativeOffset' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, Indicator) == 0x0002AC, "Member 'AFortCarriedObject::Indicator' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, DefaultIndicatorColor) == 0x000320, "Member 'AFortCarriedObject::DefaultIndicatorColor' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, RelativeTranslation) == 0x00033C, "Member 'AFortCarriedObject::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, RelativeRotation) == 0x000348, "Member 'AFortCarriedObject::RelativeRotation' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, bPickupOnTouch) == 0x000354, "Member 'AFortCarriedObject::bPickupOnTouch' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, Team) == 0x000355, "Member 'AFortCarriedObject::Team' has a wrong offset!");
static_assert(offsetof(AFortCarriedObject, SpawnPointActor) == 0x000358, "Member 'AFortCarriedObject::SpawnPointActor' has a wrong offset!");

// Class FortniteGame.FortWeatherAugment
// 0x0018 (0x0378 - 0x0360)
class AFortWeatherAugment final : public AFortCarriedObject
{
public:
	struct FGameplayTagContainer                  WeatherTags;                                       // 0x0360(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	const struct FGameplayTagContainer GetWeatherTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeatherAugment">();
	}
	static class AFortWeatherAugment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeatherAugment>();
	}
};
static_assert(alignof(AFortWeatherAugment) == 0x000004, "Wrong alignment on AFortWeatherAugment");
static_assert(sizeof(AFortWeatherAugment) == 0x000378, "Wrong size on AFortWeatherAugment");
static_assert(offsetof(AFortWeatherAugment, WeatherTags) == 0x000360, "Member 'AFortWeatherAugment::WeatherTags' has a wrong offset!");

// Class FortniteGame.FortAIHotSpotSlotGenerator_OnBoundingBox
// 0x0008 (0x0064 - 0x005C)
class UFortAIHotSpotSlotGenerator_OnBoundingBox final : public UAIHotSpotSlotGenerator_OnBoundingBox
{
public:
	float                                         DistanceForRangedSlots;                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForHugeSlots;                              // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_OnBoundingBox">();
	}
	static class UFortAIHotSpotSlotGenerator_OnBoundingBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_OnBoundingBox>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x000004, "Wrong alignment on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_OnBoundingBox) == 0x000064, "Wrong size on UFortAIHotSpotSlotGenerator_OnBoundingBox");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForRangedSlots) == 0x00005C, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForRangedSlots' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_OnBoundingBox, DistanceForHugeSlots) == 0x000060, "Member 'UFortAIHotSpotSlotGenerator_OnBoundingBox::DistanceForHugeSlots' has a wrong offset!");

// Class FortniteGame.FortAIHotSpotSlotGenerator_FromConfig
// 0x0014 (0x0030 - 0x001C)
class UFortAIHotSpotSlotGenerator_FromConfig final : public UAIHotSpotSlotGenerator
{
public:
	class UAIHotSpotConfig*                       BuildingConfig;                                    // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bMirrorX : 1;                                      // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bMirrorY : 1;                                      // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIHotSpotSlotGenerator_FromConfig">();
	}
	static class UFortAIHotSpotSlotGenerator_FromConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIHotSpotSlotGenerator_FromConfig>();
	}
};
static_assert(alignof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000004, "Wrong alignment on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(sizeof(UFortAIHotSpotSlotGenerator_FromConfig) == 0x000030, "Wrong size on UFortAIHotSpotSlotGenerator_FromConfig");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, BuildingConfig) == 0x00001C, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::BuildingConfig' has a wrong offset!");
static_assert(offsetof(UFortAIHotSpotSlotGenerator_FromConfig, Offset) == 0x000020, "Member 'UFortAIHotSpotSlotGenerator_FromConfig::Offset' has a wrong offset!");

// Class FortniteGame.FortCameraMode_ThirdPerson
// 0x0078 (0x00B4 - 0x003C)
class UFortCameraMode_ThirdPerson : public UFortCameraMode
{
public:
	float                                         FOV;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraSpaceForwardDistance;                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraOrigin                                 CameraOrigin;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraOriginSocketName;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CameraOriginInterpSpeed;                           // 0x0050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FInterpOffset                          ViewTargetSpaceViewOffset;                         // 0x005C(0x000C)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FInterpOffset                          CameraSpaceViewOffset;                             // 0x0068(0x000C)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LastCameraOrigin;                                  // 0x0074(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                CameraOriginLocalOffset;                           // 0x0080(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         PenetrationBlendInTime;                            // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationBlendOutTime;                           // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventPenetration;                               // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDoPredictiveAvoidance;                            // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionPushOutDistance;                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPenetrationAvoidanceFeeler>    PenetrationAvoidanceFeelers;                       // 0x009C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         SafeLocToAimLineBlockedPct;                        // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AimLineToDesiredPosBlockedPct;                     // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastDrawDebugTime;                                 // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraMode_ThirdPerson">();
	}
	static class UFortCameraMode_ThirdPerson* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCameraMode_ThirdPerson>();
	}
};
static_assert(alignof(UFortCameraMode_ThirdPerson) == 0x000004, "Wrong alignment on UFortCameraMode_ThirdPerson");
static_assert(sizeof(UFortCameraMode_ThirdPerson) == 0x0000B4, "Wrong size on UFortCameraMode_ThirdPerson");
static_assert(offsetof(UFortCameraMode_ThirdPerson, FOV) == 0x00003C, "Member 'UFortCameraMode_ThirdPerson::FOV' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraSpaceForwardDistance) == 0x000040, "Member 'UFortCameraMode_ThirdPerson::CameraSpaceForwardDistance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOrigin) == 0x000044, "Member 'UFortCameraMode_ThirdPerson::CameraOrigin' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginSocketName) == 0x000048, "Member 'UFortCameraMode_ThirdPerson::CameraOriginSocketName' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginInterpSpeed) == 0x000050, "Member 'UFortCameraMode_ThirdPerson::CameraOriginInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, ViewTargetSpaceViewOffset) == 0x00005C, "Member 'UFortCameraMode_ThirdPerson::ViewTargetSpaceViewOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraSpaceViewOffset) == 0x000068, "Member 'UFortCameraMode_ThirdPerson::CameraSpaceViewOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, LastCameraOrigin) == 0x000074, "Member 'UFortCameraMode_ThirdPerson::LastCameraOrigin' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CameraOriginLocalOffset) == 0x000080, "Member 'UFortCameraMode_ThirdPerson::CameraOriginLocalOffset' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationBlendInTime) == 0x00008C, "Member 'UFortCameraMode_ThirdPerson::PenetrationBlendInTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationBlendOutTime) == 0x000090, "Member 'UFortCameraMode_ThirdPerson::PenetrationBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, bPreventPenetration) == 0x000094, "Member 'UFortCameraMode_ThirdPerson::bPreventPenetration' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, bDoPredictiveAvoidance) == 0x000095, "Member 'UFortCameraMode_ThirdPerson::bDoPredictiveAvoidance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, CollisionPushOutDistance) == 0x000098, "Member 'UFortCameraMode_ThirdPerson::CollisionPushOutDistance' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, PenetrationAvoidanceFeelers) == 0x00009C, "Member 'UFortCameraMode_ThirdPerson::PenetrationAvoidanceFeelers' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, SafeLocToAimLineBlockedPct) == 0x0000A8, "Member 'UFortCameraMode_ThirdPerson::SafeLocToAimLineBlockedPct' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, AimLineToDesiredPosBlockedPct) == 0x0000AC, "Member 'UFortCameraMode_ThirdPerson::AimLineToDesiredPosBlockedPct' has a wrong offset!");
static_assert(offsetof(UFortCameraMode_ThirdPerson, LastDrawDebugTime) == 0x0000B0, "Member 'UFortCameraMode_ThirdPerson::LastDrawDebugTime' has a wrong offset!");

// Class FortniteGame.BlueprintContextBase
// 0x0000 (0x001C - 0x001C)
class UBlueprintContextBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintContextBase">();
	}
	static class UBlueprintContextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintContextBase>();
	}
};
static_assert(alignof(UBlueprintContextBase) == 0x000004, "Wrong alignment on UBlueprintContextBase");
static_assert(sizeof(UBlueprintContextBase) == 0x00001C, "Wrong size on UBlueprintContextBase");

// Class FortniteGame.FortSessionHelper
// 0x00C0 (0x00DC - 0x001C)
class UFortSessionHelper final : public UObject
{
public:
	class UClass*                                 BeaconClientClass;                                 // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPartyBeaconClient*                 PartyBeaconClient;                                 // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x94];                                      // 0x0024(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentSessionName;                                // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPartyReservationResult                       LastBeaconResponse;                                // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortSessionHelperJoinState                   CurrentJoinState;                                  // 0x00C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortSessionHelperJoinResult                  CurrentJoinResult;                                 // 0x00C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C3[0x19];                                      // 0x00C3(0x0019)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSessionHelper">();
	}
	static class UFortSessionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSessionHelper>();
	}
};
static_assert(alignof(UFortSessionHelper) == 0x000004, "Wrong alignment on UFortSessionHelper");
static_assert(sizeof(UFortSessionHelper) == 0x0000DC, "Wrong size on UFortSessionHelper");
static_assert(offsetof(UFortSessionHelper, BeaconClientClass) == 0x00001C, "Member 'UFortSessionHelper::BeaconClientClass' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, PartyBeaconClient) == 0x000020, "Member 'UFortSessionHelper::PartyBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentSessionName) == 0x0000B8, "Member 'UFortSessionHelper::CurrentSessionName' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, LastBeaconResponse) == 0x0000C0, "Member 'UFortSessionHelper::LastBeaconResponse' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentJoinState) == 0x0000C1, "Member 'UFortSessionHelper::CurrentJoinState' has a wrong offset!");
static_assert(offsetof(UFortSessionHelper, CurrentJoinResult) == 0x0000C2, "Member 'UFortSessionHelper::CurrentJoinResult' has a wrong offset!");

// Class FortniteGame.FortCameraBase
// 0x0030 (0x0608 - 0x05D8)
class AFortCameraBase : public ACameraActor
{
public:
	float                                         MinDistanceToDrag;                                 // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFieldOfView;                                // 0x05DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DefaultRotation;                                   // 0x05E0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DefaultLocation;                                   // 0x05EC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFortExhibitActor*                      ExhibitActor;                                      // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExhibitActorChanged;                              // 0x05FC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FD[0x3];                                      // 0x05FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DownPosition;                                      // 0x0600(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void Exhibit(class AFortExhibitActor* TargetActor);
	void OnActivated();
	void OnDeactivated();
	void OnDragBegin();
	void OnDragEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCameraBase">();
	}
	static class AFortCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCameraBase>();
	}
};
static_assert(alignof(AFortCameraBase) == 0x000004, "Wrong alignment on AFortCameraBase");
static_assert(sizeof(AFortCameraBase) == 0x000608, "Wrong size on AFortCameraBase");
static_assert(offsetof(AFortCameraBase, MinDistanceToDrag) == 0x0005D8, "Member 'AFortCameraBase::MinDistanceToDrag' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultFieldOfView) == 0x0005DC, "Member 'AFortCameraBase::DefaultFieldOfView' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultRotation) == 0x0005E0, "Member 'AFortCameraBase::DefaultRotation' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DefaultLocation) == 0x0005EC, "Member 'AFortCameraBase::DefaultLocation' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, ExhibitActor) == 0x0005F8, "Member 'AFortCameraBase::ExhibitActor' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, bExhibitActorChanged) == 0x0005FC, "Member 'AFortCameraBase::bExhibitActorChanged' has a wrong offset!");
static_assert(offsetof(AFortCameraBase, DownPosition) == 0x000600, "Member 'AFortCameraBase::DownPosition' has a wrong offset!");

// Class FortniteGame.FortHomeBaseCamera
// 0x0000 (0x0608 - 0x0608)
class AFortHomeBaseCamera : public AFortCameraBase
{
public:
	void ClearBuildingFocus();
	void SetBuildingFocus(class UCameraComponent* BuildingCameraComponent);

	struct FVector LimitTo(const struct FVector& DesiredPosition, class APostProcessVolume* Volume) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomeBaseCamera">();
	}
	static class AFortHomeBaseCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHomeBaseCamera>();
	}
};
static_assert(alignof(AFortHomeBaseCamera) == 0x000004, "Wrong alignment on AFortHomeBaseCamera");
static_assert(sizeof(AFortHomeBaseCamera) == 0x000608, "Wrong size on AFortHomeBaseCamera");

// Class FortniteGame.FortSearchPass
// 0x00B4 (0x00D0 - 0x001C)
class UFortSearchPass final : public UObject
{
public:
	uint8                                         Pad_1C[0x28];                                      // 0x001C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortSessionHelper*                     SessionHelper;                                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortSearchPassParams                  CurrentSearchParams;                               // 0x0050(0x001C)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortSearchPassState                   CurrentSearchPassState;                            // 0x006C(0x001C)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x48];                                      // 0x0088(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSearchPass">();
	}
	static class UFortSearchPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSearchPass>();
	}
};
static_assert(alignof(UFortSearchPass) == 0x000004, "Wrong alignment on UFortSearchPass");
static_assert(sizeof(UFortSearchPass) == 0x0000D0, "Wrong size on UFortSearchPass");
static_assert(offsetof(UFortSearchPass, SessionHelper) == 0x000044, "Member 'UFortSearchPass::SessionHelper' has a wrong offset!");
static_assert(offsetof(UFortSearchPass, CurrentSearchParams) == 0x000050, "Member 'UFortSearchPass::CurrentSearchParams' has a wrong offset!");
static_assert(offsetof(UFortSearchPass, CurrentSearchPassState) == 0x00006C, "Member 'UFortSearchPass::CurrentSearchPassState' has a wrong offset!");

// Class FortniteGame.FortMatchmakingPolicy
// 0x008C (0x00A8 - 0x001C)
class UFortMatchmakingPolicy : public UObject
{
public:
	uint8                                         Pad_1C[0x10];                                      // 0x001C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMatchmakingInProgress;                            // 0x002C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SessionName;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMatchmakingParams                     CurrentParams;                                     // 0x0038(0x0064)(Transient, Protected, NativeAccessSpecifierProtected)
	class UFortSearchPass*                        MMPass;                                            // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingPolicy">();
	}
	static class UFortMatchmakingPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingPolicy>();
	}
};
static_assert(alignof(UFortMatchmakingPolicy) == 0x000004, "Wrong alignment on UFortMatchmakingPolicy");
static_assert(sizeof(UFortMatchmakingPolicy) == 0x0000A8, "Wrong size on UFortMatchmakingPolicy");
static_assert(offsetof(UFortMatchmakingPolicy, bMatchmakingInProgress) == 0x00002C, "Member 'UFortMatchmakingPolicy::bMatchmakingInProgress' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, SessionName) == 0x000030, "Member 'UFortMatchmakingPolicy::SessionName' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, CurrentParams) == 0x000038, "Member 'UFortMatchmakingPolicy::CurrentParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingPolicy, MMPass) == 0x00009C, "Member 'UFortMatchmakingPolicy::MMPass' has a wrong offset!");

// Class FortniteGame.MyTownLibrary
// 0x0000 (0x001C - 0x001C)
class UMyTownLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FLinearColor GetBannerColor(class UObject* WorldContextObject);
	static int32 GetBannerPattern(class UObject* WorldContextObject);
	static class AMyTownBuildingActor* GetBuildingActor(class UObject* WorldContextObject, const class FString& BuildingTemplateId);
	static class UMyTownBuildingDefinitionData* GetBuildingDefinition(class UObject* WorldContextObject, const class FString& BuildingTemplateId);
	static int32 GetBuildingLevel(class UObject* WorldContextObject, const class FString& BuildingTemplateId);
	static EMyTownBuildingState GetBuildingState(class UObject* WorldContextObject, const class FString& BuildingTemplateId);
	static class UMyTownData* GetMyTownData(class UObject* WorldContextObject);
	static class FString GetMyTownName(class UObject* WorldContextObject);
	static TArray<struct FMyTownRoadData3D> GetRoadsInfo(class UObject* WorldContextObject);
	static bool IsKeepAvailable(class UObject* WorldContextObject);
	static bool IsManorAvailable(class UObject* WorldContextObject);
	static bool IsShowingFriendsHomeBase(class UObject* WorldContextObject);
	static void RegisterSlotCamera(class UObject* WorldContextObject, int32 MapSlotId, class UCameraComponent* InCameraComponent);
	static void ReinitializeManagerData(class UObject* WorldContextObject);
	static void SetInputEnabled(class UObject* WorldContextObject, bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownLibrary">();
	}
	static class UMyTownLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownLibrary>();
	}
};
static_assert(alignof(UMyTownLibrary) == 0x000004, "Wrong alignment on UMyTownLibrary");
static_assert(sizeof(UMyTownLibrary) == 0x00001C, "Wrong size on UMyTownLibrary");

// Class FortniteGame.FortMatchmakingCommon
// 0x000C (0x00B4 - 0x00A8)
class UFortMatchmakingCommon : public UFortMatchmakingPolicy
{
public:
	uint8                                         Pad_A8[0xC];                                       // 0x00A8(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingCommon">();
	}
	static class UFortMatchmakingCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingCommon>();
	}
};
static_assert(alignof(UFortMatchmakingCommon) == 0x000004, "Wrong alignment on UFortMatchmakingCommon");
static_assert(sizeof(UFortMatchmakingCommon) == 0x0000B4, "Wrong size on UFortMatchmakingCommon");

// Class FortniteGame.FortMatchmakingPvE
// 0x0000 (0x00B4 - 0x00B4)
class UFortMatchmakingPvE final : public UFortMatchmakingCommon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingPvE">();
	}
	static class UFortMatchmakingPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingPvE>();
	}
};
static_assert(alignof(UFortMatchmakingPvE) == 0x000004, "Wrong alignment on UFortMatchmakingPvE");
static_assert(sizeof(UFortMatchmakingPvE) == 0x0000B4, "Wrong size on UFortMatchmakingPvE");

// Class FortniteGame.FortClientNotification
// 0x01DC (0x041C - 0x0240)
class AFortClientNotification : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientNotificationData            NotificationData;                                  // 0x0244(0x0114)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  PlayerController;                                  // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x8];                                      // 0x035C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            StartingDisplayBrush;                              // 0x0364(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   StartingText;                                      // 0x03D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   NotificationTitle;                                 // 0x03E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         DefaultDisplayTime;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CurrentDisplayText;                                // 0x03F4(0x000C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x4];                                      // 0x0400(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  NotificationID;                                    // 0x0404(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_414[0x8];                                      // 0x0414(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotificationIsFinished();
	void OnNotificationStart();
	void PlayFeedbackLine(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Audio, float OverrideDelay);
	void SetDisplayText(const class FText& DisplayText, bool bForce);
	void SetupDelayedStop(float KillTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientNotification">();
	}
	static class AFortClientNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientNotification>();
	}
};
static_assert(alignof(AFortClientNotification) == 0x000004, "Wrong alignment on AFortClientNotification");
static_assert(sizeof(AFortClientNotification) == 0x00041C, "Wrong size on AFortClientNotification");
static_assert(offsetof(AFortClientNotification, NotificationData) == 0x000244, "Member 'AFortClientNotification::NotificationData' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, PlayerController) == 0x000358, "Member 'AFortClientNotification::PlayerController' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, StartingDisplayBrush) == 0x000364, "Member 'AFortClientNotification::StartingDisplayBrush' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, StartingText) == 0x0003D8, "Member 'AFortClientNotification::StartingText' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, NotificationTitle) == 0x0003E4, "Member 'AFortClientNotification::NotificationTitle' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, DefaultDisplayTime) == 0x0003F0, "Member 'AFortClientNotification::DefaultDisplayTime' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, CurrentDisplayText) == 0x0003F4, "Member 'AFortClientNotification::CurrentDisplayText' has a wrong offset!");
static_assert(offsetof(AFortClientNotification, NotificationID) == 0x000404, "Member 'AFortClientNotification::NotificationID' has a wrong offset!");

// Class FortniteGame.FortMatchmakingContext
// 0x00C4 (0x00E0 - 0x001C)
class UFortMatchmakingContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnMatchmakingStarted;                              // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchmakingComplete;                             // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchmakingStateChange;                          // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectionAttemptStarted;                   // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyConnectionAttemptFailed;                    // 0x004C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyWaitingForPlayers;                          // 0x0058(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyWaitingForPlayersTimeUpdate;                // 0x0064(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyStarted;                                    // 0x0070(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyDisconnected;                               // 0x007C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyTimeUpdated;                                // 0x0088(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLobbyTimeExpired;                                // 0x0094(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalReadyUpStatusChange;                        // 0x00A0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBasicError;                                      // 0x00AC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWorldRecordLoadedChanged;                        // 0x00B8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMatchmakingPvE*                    StandaloneZoneMatchmaking;                         // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnOutpostDiscoveryFailure;                         // 0x00D4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CancelMatchmaking();
	void DisconnectFromLobby();
	bool EnterOutpost();
	float GetLobbyWaitForPlayersTimeRemaining();
	bool IsConnectedToGame();
	bool IsWorldRecordLoaded();
	void JoinFromLobby();
	void ReadyUp();
	void StartCriticalMission(int32 MinMissionPower, int32 MaxMissionPower);
	void StartMatchmaking();
	void StartOnboardingMission();

	bool IsInLobby() const;
	bool IsOutpostPermitted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingContext">();
	}
	static class UFortMatchmakingContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingContext>();
	}
};
static_assert(alignof(UFortMatchmakingContext) == 0x000004, "Wrong alignment on UFortMatchmakingContext");
static_assert(sizeof(UFortMatchmakingContext) == 0x0000E0, "Wrong size on UFortMatchmakingContext");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingStarted) == 0x00001C, "Member 'UFortMatchmakingContext::OnMatchmakingStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingComplete) == 0x000028, "Member 'UFortMatchmakingContext::OnMatchmakingComplete' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnMatchmakingStateChange) == 0x000034, "Member 'UFortMatchmakingContext::OnMatchmakingStateChange' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectionAttemptStarted) == 0x000040, "Member 'UFortMatchmakingContext::OnLobbyConnectionAttemptStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyConnectionAttemptFailed) == 0x00004C, "Member 'UFortMatchmakingContext::OnLobbyConnectionAttemptFailed' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyWaitingForPlayers) == 0x000058, "Member 'UFortMatchmakingContext::OnLobbyWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyWaitingForPlayersTimeUpdate) == 0x000064, "Member 'UFortMatchmakingContext::OnLobbyWaitingForPlayersTimeUpdate' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyStarted) == 0x000070, "Member 'UFortMatchmakingContext::OnLobbyStarted' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyDisconnected) == 0x00007C, "Member 'UFortMatchmakingContext::OnLobbyDisconnected' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyTimeUpdated) == 0x000088, "Member 'UFortMatchmakingContext::OnLobbyTimeUpdated' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLobbyTimeExpired) == 0x000094, "Member 'UFortMatchmakingContext::OnLobbyTimeExpired' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnLocalReadyUpStatusChange) == 0x0000A0, "Member 'UFortMatchmakingContext::OnLocalReadyUpStatusChange' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnBasicError) == 0x0000AC, "Member 'UFortMatchmakingContext::OnBasicError' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnWorldRecordLoadedChanged) == 0x0000B8, "Member 'UFortMatchmakingContext::OnWorldRecordLoadedChanged' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, StandaloneZoneMatchmaking) == 0x0000D0, "Member 'UFortMatchmakingContext::StandaloneZoneMatchmaking' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingContext, OnOutpostDiscoveryFailure) == 0x0000D4, "Member 'UFortMatchmakingContext::OnOutpostDiscoveryFailure' has a wrong offset!");

// Class FortniteGame.FortAbilitySet
// 0x001C (0x0038 - 0x001C)
class UFortAbilitySet : public UDataAsset
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UFortGameplayAbility>> GameplayAbilities;                                 // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGameplayEffectApplicationInfo> PassiveGameplayEffects;                            // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySet">();
	}
	static class UFortAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySet>();
	}
};
static_assert(alignof(UFortAbilitySet) == 0x000004, "Wrong alignment on UFortAbilitySet");
static_assert(sizeof(UFortAbilitySet) == 0x000038, "Wrong size on UFortAbilitySet");
static_assert(offsetof(UFortAbilitySet, GameplayAbilities) == 0x000020, "Member 'UFortAbilitySet::GameplayAbilities' has a wrong offset!");
static_assert(offsetof(UFortAbilitySet, PassiveGameplayEffects) == 0x00002C, "Member 'UFortAbilitySet::PassiveGameplayEffects' has a wrong offset!");

// Class FortniteGame.FortPlayerController
// 0x0780 (0x0C20 - 0x04A0)
class AFortPlayerController : public APlayerController
{
public:
	uint8                                         Pad_4A0[0x4];                                      // 0x04A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFailedToRespawn : 1;                              // 0x04A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsDisconnecting : 1;                              // 0x04A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsLateJoining : 1;                                // 0x04A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bHasInitiallySpawned : 1;                          // 0x04A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAssignedStartSpawn : 1;                           // 0x04A4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bReadyToStartMatch : 1;                            // 0x04A4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bClientPawnIsLoaded : 1;                           // 0x04A4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLoc;                                          // 0x04A8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumPreviousSpawns;                                 // 0x04B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBlueprintReadyCheckCompleted;                    // 0x04B8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0x48];                                     // 0x04C4(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerPawn*                        MyFortPawn;                                        // 0x050C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasClientFinishedLoading;                         // 0x0510(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasServerFinishedLoading;                         // 0x0511(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_512[0x2];                                      // 0x0512(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeStartedWaiting;                                // 0x0514(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeFinishedNavigationBuild;                       // 0x0518(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PendingSpectatorLocation;                          // 0x051C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ActorUnderReticle;                                 // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         LastActiveTime;                                    // 0x0530(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x60];                                     // 0x0534(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractDistance;                                  // 0x0594(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractHighlightDistance;                         // 0x0598(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractTraceExtent;                               // 0x059C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastInteractTraceTime;                             // 0x05A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractMultiplierForActiveInteraction;            // 0x05A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A8[0xD];                                      // 0x05A8(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsToSprint;                                    // 0x05B5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHoldingSprint;                                    // 0x05B6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSprintToggleable;                                 // 0x05B7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bMovementDisabledDueToCancellableAction;           // 0x05B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPlayerActivelyMoving;                           // 0x05B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BA[0x2];                                      // 0x05BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InMovementCancellableAction;                       // 0x05BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastMoveForwardTime;                               // 0x05C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnSetFirstPersonCamera;                            // 0x05C4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x20];                                     // 0x05D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortIndicatorManager*                  IndicatorManager;                                  // 0x05F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUiChoiceCompleted;                               // 0x05F4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_600[0x74];                                     // 0x0600(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInQuickToggleCursorMode;                        // 0x0674(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bDragDropPending;                                  // 0x0675(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bSuppressEventNotifications;                       // 0x0676(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_677[0x5];                                      // 0x0677(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastSpotTime;                                      // 0x067C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AFortMarkActor>>  CurrentMarks;                                      // 0x0680(0x000C)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_68C[0x44];                                     // 0x068C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGameplayAbility*                   PreviewAbility;                                    // 0x06D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDirectorDebugInfo                   IntensityGraphInfo;                                // 0x06D4(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FAIDirectorDebugInfo                   PIDValuesGraphInfo;                                // 0x06F4(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FAIDirectorDebugInfo                   PIDContributionsGraphInfo;                         // 0x0714(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	class AFortCombatManager*                     CombatManager;                                     // 0x0734(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIDirectorDataManager*             AIDirectorDataManager;                             // 0x0738(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMusicManager*                      MusicManager;                                      // 0x073C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_740[0x88];                                     // 0x0740(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        BuildPreviewModeInputComponent;                    // 0x07C8(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingPlayerPrimitivePreview*        BuildPreviewMarker;                                // 0x07CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D0[0x80];                                     // 0x07D0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingActor*                         TargetedBuilding;                                  // 0x0850(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingSMActor>           ContextualConversionClass;                         // 0x0854(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StartRepairSound;                                  // 0x0858(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StartUpgradeSound;                                 // 0x0870(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 HighlightedPrimaryBuildings;                       // 0x0888(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABuildingActor*>                 HighlightedInteractionBuildings;                   // 0x0894(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABuildingActor>          HighlightedPrimaryBuilding;                        // 0x08A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABuildingActor>          HighlightedInteractBuilding;                       // 0x08A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      BuildPreviewMarkerParentMaterial;                  // 0x08B0(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BuildPreviewMarkerMID;                             // 0x08C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BuildPreviewRotationIterations;                    // 0x08CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8CD[0x3];                                      // 0x08CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBuildPreviewMirrored : 1;                         // 0x08D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bBuildFree : 1;                                    // 0x08D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_8D1[0x3];                                      // 0x08D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortCostInfoTypes                            CurrentCostInfoType;                               // 0x08D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABuildingSMActor>           CurrentBuildableClass;                             // 0x08D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingSMActor>           PreviousBuildableClass;                            // 0x08DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortResourceLevel                            CurrentResourceLevel;                              // 0x08E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortResourceType                             CurrentResourceType;                               // 0x08E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E2[0x2];                                      // 0x08E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLastBuildableState                    LastBuildableStateData[0xC];                       // 0x08E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRecentDamagedBuildingInfo             LastRecentlyDamagedBuilding;                       // 0x0974(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortDamageNumberInfo>          QueuedDamageNumbers;                               // 0x0984(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AFortDamageNumbersActor*                DamageNumbersActor;                                // 0x0990(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputComponent*                        EditModeInputComponent;                            // 0x0994(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       EditBuildingActor;                                 // 0x0998(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeDistance;                                  // 0x099C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastBuildPreviewGridSnapLoc;                       // 0x09A0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               LastBuildPreviewGridSnapRot;                       // 0x09AC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFortQuickBars*                         QuickBars;                                         // 0x09B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9BC[0x38];                                     // 0x09BC(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PinnedSchematics;                                  // 0x09F4(0x000C)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_A00[0x20];                                     // 0x0A00(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoEquipBetterItems : 1;                         // 0x0A20(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_A21[0x3];                                      // 0x0A21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         WorldInventory;                                    // 0x0A24(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortCombinedInventoryProxy*            CombinedWorldAndSharedInventory;                   // 0x0A28(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2C[0x38];                                     // 0x0A2C(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasInitializedWorldInventory;                     // 0x0A64(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasInitializedHeroInventory;                      // 0x0A65(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAccountInventoryWasUpdated;                       // 0x0A66(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsSavingGadgetLoadout;                            // 0x0A67(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A68[0x3C];                                     // 0x0A68(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortClientBotManager*                  BotManager;                                        // 0x0AA4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA8[0x3C];                                     // 0x0AA8(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortRewardReport                      LatestRewardReport;                                // 0x0AE4(0x0030)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UFortQuestManager*                      QuestManager;                                      // 0x0B14(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortUpdatedObjectiveStat>      UpdatedObjectiveStats;                             // 0x0B18(0x000C)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B24[0x18];                                     // 0x0B24(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WorldFavorites;                                    // 0x0B3C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UStatManager*                           StatManager;                                       // 0x0B48(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHeartbeatManager*                      HeartbeatManager;                                  // 0x0B4C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortStatEventManager*                  StatEventManager;                                  // 0x0B50(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortPersistentGameplayStatContainer   CachedPersistentGameplayStats;                     // 0x0B54(0x000C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B60[0x8];                                      // 0x0B60(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMcpProfileGroup*                       McpProfileGroup;                                   // 0x0B68(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortMcpProfileAccount*                 MainMcpProfile;                                    // 0x0B6C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTutorialCompleted : 1;                            // 0x0B70(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_B71[0x3];                                      // 0x0B71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldReceiveCriticalMatchBonus;                  // 0x0B74(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B75[0x3];                                      // 0x0B75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SynchronizingWithMcpCount;                         // 0x0B78(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationUnderReticle;                              // 0x0B7C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bInfiniteAmmo : 1;                                 // 0x0B88(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoCoolDown : 1;                                   // 0x0B88(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteDurability : 1;                           // 0x0B88(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCheatGhost : 1;                                   // 0x0B88(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCheatFly : 1;                                     // 0x0B88(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableShotLogging : 1;                            // 0x0B88(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bForceNakedOutfits : 1;                            // 0x0B88(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_B89[0x7];                                      // 0x0B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverriddenBackpackSize;                            // 0x0B90(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        AimHelpMode;                                       // 0x0B94(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortJumpStaminaCost                          JumpStaminaCost;                                   // 0x0B98(0x0001)(Net, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B99[0x3];                                      // 0x0B99(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CameraPrototypeName;                               // 0x0B9C(0x0008)(Net, ZeroConstructor, Transient, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA4[0x7C];                                     // 0x0BA4(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSlot(EFortQuickBars InQuickBar, int32 Slot, float AcivateDelay);
	void Cheat(const class FString& Msg);
	void CheatAll(const class FString& Msg);
	void ClientAddHeroSpecialization(class UFortHeroSpecialization* NewSpecialization);
	void ClientCancelCrafting();
	void ClientClearDisabledActionMappings();
	void ClientDrawAttentionToUI(const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle);
	void ClientExecuteInventoryItem(const struct FGuid& ItemGuid, float Delay);
	void ClientForceCancelBuildingTool();
	void ClientForceProfileQuery();
	void ClientGivePlayerLocalAccountItem(class UFortAccountItemDefinition* ItemDefinition, int32 Count);
	void ClientHandleNotification(const class FString& TypeStr, const class FString& PayloadStr);
	void ClientHideTutorialWidget(class FName WidgetName);
	void ClientOnGenericPlayerInitialization();
	void ClientOpenChoiceUI(const struct FChoiceData& ChoiceItems);
	void ClientPingMinimap(const struct FVector& WorldLocation, const struct FLinearColor& PingColor);
	void ClientReadyCheckComplete(bool bPassed);
	void ClientRegisterWithParty();
	void ClientRequestReadyCheck(const class FText& QueryText, const class FText& YesText, const class FText& NoText);
	void ClientSendClientNotification(const struct FFortClientNotificationData& NewClientNotification);
	void ClientSendEventNotification(const class FName NotificationName, const class UObject* NotificationParameter, bool bRemoveIfActive);
	void ClientSendTutorialNotification(const struct FFortTutorialNotificationData& NewTutorialNotification);
	void ClientSetActionMappingEnabled(class FName ActionName, bool bEnabled);
	void ClientSetInviteFlags(const struct FJoinabilitySettings& Settings);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientStayWithParty(bool bStayWithParty);
	void ClientStopUIFeedbackEvent(class FName EventName);
	void ClientTriggerUIFeedbackEvent(class FName EventName);
	void ClientUnableToPlaceGenerator();
	void ClientUnhideTutorialWidget(class FName WidgetName);
	void ClientUpdateRichPresence(ERichPresenceStateChange RichPresenceChange, bool bImportant);
	void ClientZoneSay(const class FString& PlayerName, const class FString& Message);
	void Emote(const class FString& Msg);
	void ForceUpdateQuickbar(EFortQuickBars QuickbarToRefresh);
	class AFortAIDirectorDataManager* GetAIDirectorDataManager();
	void GivePlayerAmmo(int32 AmmoCount);
	void HandleWorldInventoryLocalUpdate();
	void LocalOnBlueprintEdit(class ABuildingSMActor* EditedActor);
	void OnRep_bHasServerFinishedLoading();
	void OnRep_CheatMovement();
	void OnRep_CombatManager();
	void OnRep_IntensityGraphInfo();
	void OnRep_LatestRewardReport();
	void OnRep_PIDContributionsGraphInfo();
	void OnRep_PIDValuesGraphInfo();
	void OnRep_PinnedSchematics();
	void OnRep_QuickBar();
	void OnRep_UpdatedObjectiveStats();
	void OpenChoiceUI(const struct FChoiceData& ChoiceData);
	void PlaySpatialSound(class USoundBase* Sound, const struct FVector& Location);
	void PrintDebugInfo();
	void RemoveItemFromQuickBars(class UFortItemDefinition* ItemDefinition);
	void ResetInputRotationScale();
	void Say(const class FString& Msg);
	void SayTeam(const class FString& Msg);
	void SendMessage(const class FString& Message, class FName Type, class AActor* Source);
	void SendTextNotification(const class FText& NotificationText, float DisplayTime);
	void ServerAttemptInteract(class AActor* ReceivingActor, class UPrimitiveComponent* InteractComponent, ETInteractionType InteractType);
	void ServerAttemptPinSchematic(const class FString& ItemId, bool bSave);
	void ServerAttemptUnpinSchematic(const class FString& ItemId, bool bSave);
	void ServerBanPlayer(const struct FUniqueNetIdRepl& PlayerToBan);
	void ServerBeginEditingBuildingActor(class ABuildingSMActor* BuildingActorToEdit);
	void ServerBroadcastUIFeedbackEvent(class FName EventName);
	void ServerCheat(const class FString& Msg);
	void ServerCheatAll(const class FString& Msg);
	void ServerClientPawnLoaded(bool bIsPawnLoaded);
	void ServerCraftSchematic(const class FString& ItemId);
	void ServerCreateAIDirectorDataManager();
	void ServerCreateBuildingActor(const struct FBuildingClassData& BuildingClassData, const struct FVector_NetQuantize10& BuildLoc, const struct FRotator& BuildRot, bool bMirrored);
	void ServerCreateCombatManager();
	void ServerDisassembleInventoryItem(const struct FGuid& ItemGuid);
	void ServerDropCarriedObject();
	void ServerEditBuildingActor(class ABuildingSMActor* BuildingActorToEdit, TSubclassOf<class ABuildingSMActor> NewBuildingClass, int32 RotationIterations, bool bMirrored);
	void ServerEmote(const class FString& Msg);
	void ServerEndEditingBuildingActor(class ABuildingSMActor* BuildingActorToStopEditing);
	void ServerExecuteInventoryItem(const struct FGuid& ItemGuid);
	void ServerForceProfileQuery();
	void ServerGiftInventoryItemToOtherPlayer(const struct FGuid& ItemGuid, const struct FUniqueNetIdRepl& PlayerID, int32 Quantity);
	void ServerGrantAdminPlayer(const struct FUniqueNetIdRepl& PlayerToAdmin);
	void ServerHandleMissionEvent_ToggledCursorMode(class AFortPlayerController* PlayerThatToggledCursorMode, bool bOpened);
	void ServerHandleMissionEvent_ToggledEditMode(class AFortPlayerController* PlayerThatToggledEditMode, bool bOpened);
	void ServerHandleMissionEvent_ToggledOptionsMenu(class AFortPlayerController* PlayerThatToggledOptionsMenu, bool bOpened);
	void ServerItemWillBeDestroyed(const struct FGuid& DestroyedItemGuid, int32 Count);
	void ServerKickPlayer(const struct FUniqueNetIdRepl& PlayerToKick, const class FText& Reason);
	void ServerKillAllAIPawnsAroundPlayer();
	void ServerModDurability(const struct FGuid& ItemGuid, float DurabilityMod, bool bForceSet);
	void ServerModifyStat(class FName StatName, int32 Amount, EStatMod ModType, bool bForceStatSave);
	void ServerNotificationIsFinished(const struct FGuid& NotificationID);
	void ServerOnBannerUpdate();
	void ServerPingMinimap(const struct FVector& WorldLocation, const struct FLinearColor& PingColor);
	void ServerReadyToStartMatch();
	void ServerReconcileGiftsFromPlayer(const class FString& PlayerName, bool bAccept);
	void ServerReleaseInventoryItemKey(EFortQuickBars InQuickBar, int32 Slot);
	void ServerRemoveAdminPlayer(const struct FUniqueNetIdRepl& PlayerToAdmin);
	void ServerRemoveInventoryItem(const struct FGuid& ItemGuid, int32 Count, bool bForceRemoveFromQuickBars);
	void ServerRemoveInventoryStateValue(const struct FGuid& ItemGuid, EFortItemEntryState StateValueType);
	void ServerRepairBuildingActor(class ABuildingSMActor* BuildingActorToRepair);
	void ServerReplyToReadyCheck(bool bReady);
	void ServerRequestGameplayAction(EFortRequestedGameplayAction RequestedAction);
	void ServerReturnToLobby();
	void ServerReturnToMainMenu();
	void ServerSaveLoadoutData(const class FString& NewHeroID, const struct FSelectedClassAbilityKits& ForceSelectedAbilities);
	void ServerSay(const class FString& Msg);
	void ServerSayTeam(const class FString& Msg);
	void ServerSetAnalyticsIds(const class FString& SessionId, const class FString& UserId);
	void ServerSetAutoEquipBetterItems(bool bAutoEquip);
	void ServerSetClientHasFinishedLoading(bool bInHasFinishedLoading);
	void ServerSetHero(const class FString& NewHeroID);
	void ServerSetInventoryStateValue(const struct FGuid& ItemGuid, const struct FFortItemEntryStateValue& StateValue);
	void ServerSetInvincibleDueToUI(bool bInvincible);
	void ServerSetMarkText(class AFortMarkActor* MarkActor, const class FString& MarkText);
	void ServerSetPartyOwner(const struct FUniqueNetIdRepl& PartyOwnerUniqueId);
	void ServerSetPlayerStatus(uint32 PlayerStatus);
	void ServerSetReadyToContinue(bool bReady, EFortGameplayState RequestedState, bool bTryStartTimer);
	void ServerSetTimeOfDay(float TimeOfDay);
	void ServerSetupWeakSpotsOnBuildingActor(class ABuildingSMActor* BuildingActor, const struct FFortCrackEffectData& CrackData);
	void ServerSpawnInventoryDrop(const struct FGuid& ItemGuid, int32 Count);
	void ServerSpawnMark(class AActor* ActorToAttachTo, const struct FVector& AttachOffset);
	void ServerSpotActor(class AActor* NewlySpottedActor);
	void ServerStartIntensityGraphing();
	void ServerStartPIDContributionsGraphing();
	void ServerStartPIDValueGraphing();
	void ServerSuicide();
	void ServerTeleportToReticle(const struct FVector& TeleportLocation);
	void ServerTouchActiveTime();
	void ServerTriggerCombatEvent(EFortCombatEvents TriggeredEvent, float HeatMultiplier);
	void ServerUIChoiceCompleted(int32 ChosenItem, int32 MenuIdentifier);
	void ServerUpgradeBuildingActor(class ABuildingActor* BuildingActorToUpgrade, int32 NewUpgradeLevel);
	void SetCinematicOverrideClass(TSubclassOf<class UFortCinematicCamera> OverrideCameraClass);
	void SetInputPitchScale(float InInputPitchScale);
	void SetInputYawScale(float InInputYawScale);
	void SetShowHUD(bool bNewShowHUD);
	class AFortEmitterCameraLensEffectDirectional* SpawnCameraLensEffectDirectional(TSubclassOf<class AFortEmitterCameraLensEffectDirectional> LensEffectEmitterClass, class AFortPawn* DamageDealer, const struct FHitResult& HitInfo);
	bool StartReadyCheck(const class FText& QueryText, const class FText& YesText, const class FText& NoText, float PercentageToPass);
	void Suicide();
	void SuppressEventNotifications(bool bSuppress);
	void ToggleFullScreenMap();
	void ToggleInventory();
	void ToggleMirrorBuildPreview();
	void ToggleStats();

	void DumpHomebaseRatingInfo() const;
	int32 GetAccountLevel() const;
	float GetAccountLevelProgression() const;
	class AActor* GetActorUnderReticle() const;
	class UFortQuestManager* GetQuestManager() const;
	bool IsClientBot() const;
	bool IsRequirementsMet(const struct FFortRequirementsInfo& InRequirements) const;
	bool IsUsingFirstPersonCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerController">();
	}
	static class AFortPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerController>();
	}
};
static_assert(alignof(AFortPlayerController) == 0x000004, "Wrong alignment on AFortPlayerController");
static_assert(sizeof(AFortPlayerController) == 0x000C20, "Wrong size on AFortPlayerController");
static_assert(offsetof(AFortPlayerController, SpawnLoc) == 0x0004A8, "Member 'AFortPlayerController::SpawnLoc' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, NumPreviousSpawns) == 0x0004B4, "Member 'AFortPlayerController::NumPreviousSpawns' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnBlueprintReadyCheckCompleted) == 0x0004B8, "Member 'AFortPlayerController::OnBlueprintReadyCheckCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MyFortPawn) == 0x00050C, "Member 'AFortPlayerController::MyFortPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasClientFinishedLoading) == 0x000510, "Member 'AFortPlayerController::bHasClientFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasServerFinishedLoading) == 0x000511, "Member 'AFortPlayerController::bHasServerFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TimeStartedWaiting) == 0x000514, "Member 'AFortPlayerController::TimeStartedWaiting' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TimeFinishedNavigationBuild) == 0x000518, "Member 'AFortPlayerController::TimeFinishedNavigationBuild' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PendingSpectatorLocation) == 0x00051C, "Member 'AFortPlayerController::PendingSpectatorLocation' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ActorUnderReticle) == 0x000528, "Member 'AFortPlayerController::ActorUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastActiveTime) == 0x000530, "Member 'AFortPlayerController::LastActiveTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractDistance) == 0x000594, "Member 'AFortPlayerController::InteractDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractHighlightDistance) == 0x000598, "Member 'AFortPlayerController::InteractHighlightDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractTraceExtent) == 0x00059C, "Member 'AFortPlayerController::InteractTraceExtent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastInteractTraceTime) == 0x0005A0, "Member 'AFortPlayerController::LastInteractTraceTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InteractMultiplierForActiveInteraction) == 0x0005A4, "Member 'AFortPlayerController::InteractMultiplierForActiveInteraction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bWantsToSprint) == 0x0005B5, "Member 'AFortPlayerController::bWantsToSprint' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHoldingSprint) == 0x0005B6, "Member 'AFortPlayerController::bHoldingSprint' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bSprintToggleable) == 0x0005B7, "Member 'AFortPlayerController::bSprintToggleable' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bMovementDisabledDueToCancellableAction) == 0x0005B8, "Member 'AFortPlayerController::bMovementDisabledDueToCancellableAction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsPlayerActivelyMoving) == 0x0005B9, "Member 'AFortPlayerController::bIsPlayerActivelyMoving' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, InMovementCancellableAction) == 0x0005BC, "Member 'AFortPlayerController::InMovementCancellableAction' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastMoveForwardTime) == 0x0005C0, "Member 'AFortPlayerController::LastMoveForwardTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnSetFirstPersonCamera) == 0x0005C4, "Member 'AFortPlayerController::OnSetFirstPersonCamera' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, IndicatorManager) == 0x0005F0, "Member 'AFortPlayerController::IndicatorManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OnUiChoiceCompleted) == 0x0005F4, "Member 'AFortPlayerController::OnUiChoiceCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsInQuickToggleCursorMode) == 0x000674, "Member 'AFortPlayerController::bIsInQuickToggleCursorMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bDragDropPending) == 0x000675, "Member 'AFortPlayerController::bDragDropPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bSuppressEventNotifications) == 0x000676, "Member 'AFortPlayerController::bSuppressEventNotifications' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastSpotTime) == 0x00067C, "Member 'AFortPlayerController::LastSpotTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentMarks) == 0x000680, "Member 'AFortPlayerController::CurrentMarks' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PreviewAbility) == 0x0006D0, "Member 'AFortPlayerController::PreviewAbility' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, IntensityGraphInfo) == 0x0006D4, "Member 'AFortPlayerController::IntensityGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PIDValuesGraphInfo) == 0x0006F4, "Member 'AFortPlayerController::PIDValuesGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PIDContributionsGraphInfo) == 0x000714, "Member 'AFortPlayerController::PIDContributionsGraphInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CombatManager) == 0x000734, "Member 'AFortPlayerController::CombatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, AIDirectorDataManager) == 0x000738, "Member 'AFortPlayerController::AIDirectorDataManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MusicManager) == 0x00073C, "Member 'AFortPlayerController::MusicManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewModeInputComponent) == 0x0007C8, "Member 'AFortPlayerController::BuildPreviewModeInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarker) == 0x0007CC, "Member 'AFortPlayerController::BuildPreviewMarker' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, TargetedBuilding) == 0x000850, "Member 'AFortPlayerController::TargetedBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, ContextualConversionClass) == 0x000854, "Member 'AFortPlayerController::ContextualConversionClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StartRepairSound) == 0x000858, "Member 'AFortPlayerController::StartRepairSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StartUpgradeSound) == 0x000870, "Member 'AFortPlayerController::StartUpgradeSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedPrimaryBuildings) == 0x000888, "Member 'AFortPlayerController::HighlightedPrimaryBuildings' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedInteractionBuildings) == 0x000894, "Member 'AFortPlayerController::HighlightedInteractionBuildings' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedPrimaryBuilding) == 0x0008A0, "Member 'AFortPlayerController::HighlightedPrimaryBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HighlightedInteractBuilding) == 0x0008A8, "Member 'AFortPlayerController::HighlightedInteractBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarkerParentMaterial) == 0x0008B0, "Member 'AFortPlayerController::BuildPreviewMarkerParentMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewMarkerMID) == 0x0008C8, "Member 'AFortPlayerController::BuildPreviewMarkerMID' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BuildPreviewRotationIterations) == 0x0008CC, "Member 'AFortPlayerController::BuildPreviewRotationIterations' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentCostInfoType) == 0x0008D4, "Member 'AFortPlayerController::CurrentCostInfoType' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentBuildableClass) == 0x0008D8, "Member 'AFortPlayerController::CurrentBuildableClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PreviousBuildableClass) == 0x0008DC, "Member 'AFortPlayerController::PreviousBuildableClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentResourceLevel) == 0x0008E0, "Member 'AFortPlayerController::CurrentResourceLevel' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CurrentResourceType) == 0x0008E1, "Member 'AFortPlayerController::CurrentResourceType' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildableStateData) == 0x0008E4, "Member 'AFortPlayerController::LastBuildableStateData' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastRecentlyDamagedBuilding) == 0x000974, "Member 'AFortPlayerController::LastRecentlyDamagedBuilding' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, QueuedDamageNumbers) == 0x000984, "Member 'AFortPlayerController::QueuedDamageNumbers' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, DamageNumbersActor) == 0x000990, "Member 'AFortPlayerController::DamageNumbersActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditModeInputComponent) == 0x000994, "Member 'AFortPlayerController::EditModeInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditBuildingActor) == 0x000998, "Member 'AFortPlayerController::EditBuildingActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, EditModeDistance) == 0x00099C, "Member 'AFortPlayerController::EditModeDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildPreviewGridSnapLoc) == 0x0009A0, "Member 'AFortPlayerController::LastBuildPreviewGridSnapLoc' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LastBuildPreviewGridSnapRot) == 0x0009AC, "Member 'AFortPlayerController::LastBuildPreviewGridSnapRot' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, QuickBars) == 0x0009B8, "Member 'AFortPlayerController::QuickBars' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, PinnedSchematics) == 0x0009F4, "Member 'AFortPlayerController::PinnedSchematics' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, WorldInventory) == 0x000A24, "Member 'AFortPlayerController::WorldInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CombinedWorldAndSharedInventory) == 0x000A28, "Member 'AFortPlayerController::CombinedWorldAndSharedInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasInitializedWorldInventory) == 0x000A64, "Member 'AFortPlayerController::bHasInitializedWorldInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bHasInitializedHeroInventory) == 0x000A65, "Member 'AFortPlayerController::bHasInitializedHeroInventory' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bAccountInventoryWasUpdated) == 0x000A66, "Member 'AFortPlayerController::bAccountInventoryWasUpdated' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bIsSavingGadgetLoadout) == 0x000A67, "Member 'AFortPlayerController::bIsSavingGadgetLoadout' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, BotManager) == 0x000AA4, "Member 'AFortPlayerController::BotManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LatestRewardReport) == 0x000AE4, "Member 'AFortPlayerController::LatestRewardReport' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, QuestManager) == 0x000B14, "Member 'AFortPlayerController::QuestManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, UpdatedObjectiveStats) == 0x000B18, "Member 'AFortPlayerController::UpdatedObjectiveStats' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, WorldFavorites) == 0x000B3C, "Member 'AFortPlayerController::WorldFavorites' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StatManager) == 0x000B48, "Member 'AFortPlayerController::StatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, HeartbeatManager) == 0x000B4C, "Member 'AFortPlayerController::HeartbeatManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, StatEventManager) == 0x000B50, "Member 'AFortPlayerController::StatEventManager' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CachedPersistentGameplayStats) == 0x000B54, "Member 'AFortPlayerController::CachedPersistentGameplayStats' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, McpProfileGroup) == 0x000B68, "Member 'AFortPlayerController::McpProfileGroup' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, MainMcpProfile) == 0x000B6C, "Member 'AFortPlayerController::MainMcpProfile' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, bShouldReceiveCriticalMatchBonus) == 0x000B74, "Member 'AFortPlayerController::bShouldReceiveCriticalMatchBonus' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, SynchronizingWithMcpCount) == 0x000B78, "Member 'AFortPlayerController::SynchronizingWithMcpCount' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, LocationUnderReticle) == 0x000B7C, "Member 'AFortPlayerController::LocationUnderReticle' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, OverriddenBackpackSize) == 0x000B90, "Member 'AFortPlayerController::OverriddenBackpackSize' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, AimHelpMode) == 0x000B94, "Member 'AFortPlayerController::AimHelpMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, JumpStaminaCost) == 0x000B98, "Member 'AFortPlayerController::JumpStaminaCost' has a wrong offset!");
static_assert(offsetof(AFortPlayerController, CameraPrototypeName) == 0x000B9C, "Member 'AFortPlayerController::CameraPrototypeName' has a wrong offset!");

// Class FortniteGame.FortTooltipInterface
// 0x0000 (0x001C - 0x001C)
class IFortTooltipInterface final : public IInterface
{
public:
	TSubclassOf<class UFortTooltip> GetTooltip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipInterface">();
	}
	static class IFortTooltipInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTooltipInterface>();
	}
};
static_assert(alignof(IFortTooltipInterface) == 0x000004, "Wrong alignment on IFortTooltipInterface");
static_assert(sizeof(IFortTooltipInterface) == 0x00001C, "Wrong size on IFortTooltipInterface");

// Class FortniteGame.FortDeathCameraMode
// 0x001C (0x0058 - 0x003C)
class UFortDeathCameraMode final : public UFortCameraMode
{
public:
	float                                         FOV;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToTrackTarget;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrackToTargetSpeed;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDeathCameraMode">();
	}
	static class UFortDeathCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDeathCameraMode>();
	}
};
static_assert(alignof(UFortDeathCameraMode) == 0x000004, "Wrong alignment on UFortDeathCameraMode");
static_assert(sizeof(UFortDeathCameraMode) == 0x000058, "Wrong size on UFortDeathCameraMode");
static_assert(offsetof(UFortDeathCameraMode, FOV) == 0x00003C, "Member 'UFortDeathCameraMode::FOV' has a wrong offset!");
static_assert(offsetof(UFortDeathCameraMode, TimeToTrackTarget) == 0x000040, "Member 'UFortDeathCameraMode::TimeToTrackTarget' has a wrong offset!");
static_assert(offsetof(UFortDeathCameraMode, TrackToTargetSpeed) == 0x000044, "Member 'UFortDeathCameraMode::TrackToTargetSpeed' has a wrong offset!");

// Class FortniteGame.FortTooltipContext
// 0x0008 (0x0024 - 0x001C)
class UFortTooltipContext final : public UObject
{
public:
	class UAbilitySystemComponent*                SourceAbilitySystem;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                DestAbilitySystem;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UFortTooltipContext* SpawnTooltipContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipContext">();
	}
	static class UFortTooltipContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipContext>();
	}
};
static_assert(alignof(UFortTooltipContext) == 0x000004, "Wrong alignment on UFortTooltipContext");
static_assert(sizeof(UFortTooltipContext) == 0x000024, "Wrong size on UFortTooltipContext");
static_assert(offsetof(UFortTooltipContext, SourceAbilitySystem) == 0x00001C, "Member 'UFortTooltipContext::SourceAbilitySystem' has a wrong offset!");
static_assert(offsetof(UFortTooltipContext, DestAbilitySystem) == 0x000020, "Member 'UFortTooltipContext::DestAbilitySystem' has a wrong offset!");

// Class FortniteGame.FortTooltipMap
// 0x0048 (0x0064 - 0x001C)
class UFortTooltipMap final : public UDataAsset
{
public:
	uint8                                         Pad_1C[0x3C];                                      // 0x001C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortTooltipMapEntry>           Mapping;                                           // 0x0058(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipMap">();
	}
	static class UFortTooltipMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipMap>();
	}
};
static_assert(alignof(UFortTooltipMap) == 0x000004, "Wrong alignment on UFortTooltipMap");
static_assert(sizeof(UFortTooltipMap) == 0x000064, "Wrong size on UFortTooltipMap");
static_assert(offsetof(UFortTooltipMap, Mapping) == 0x000058, "Member 'UFortTooltipMap::Mapping' has a wrong offset!");

// Class FortniteGame.FortClientEventData
// 0x000C (0x0028 - 0x001C)
class UFortClientEventData final : public UDataAsset
{
public:
	TArray<struct FFortClientEventName>           ClientEventNames;                                  // 0x001C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientEventData">();
	}
	static class UFortClientEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientEventData>();
	}
};
static_assert(alignof(UFortClientEventData) == 0x000004, "Wrong alignment on UFortClientEventData");
static_assert(sizeof(UFortClientEventData) == 0x000028, "Wrong size on UFortClientEventData");
static_assert(offsetof(UFortClientEventData, ClientEventNames) == 0x00001C, "Member 'UFortClientEventData::ClientEventNames' has a wrong offset!");

// Class FortniteGame.WorldTheme
// 0x014C (0x0168 - 0x001C)
class UWorldTheme final : public UDataAsset
{
public:
	TArray<struct FTileGroupSelection>            TileGroups;                                        // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWorldTileGroup*                        FillerTileGroup;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCircuitSize;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  BorderWorld_I;                                     // 0x0030(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_IO;                                    // 0x0048(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_O;                                     // 0x0060(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OO;                                    // 0x0078(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OOO;                                   // 0x0090(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OOOO;                                  // 0x00A8(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_S;                                     // 0x00C0(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SS;                                    // 0x00D8(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_OS;                                    // 0x00F0(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SO;                                    // 0x0108(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_SOO;                                   // 0x0120(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_U;                                     // 0x0138(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  BorderWorld_R;                                     // 0x0150(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTheme">();
	}
	static class UWorldTheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTheme>();
	}
};
static_assert(alignof(UWorldTheme) == 0x000004, "Wrong alignment on UWorldTheme");
static_assert(sizeof(UWorldTheme) == 0x000168, "Wrong size on UWorldTheme");
static_assert(offsetof(UWorldTheme, TileGroups) == 0x00001C, "Member 'UWorldTheme::TileGroups' has a wrong offset!");
static_assert(offsetof(UWorldTheme, FillerTileGroup) == 0x000028, "Member 'UWorldTheme::FillerTileGroup' has a wrong offset!");
static_assert(offsetof(UWorldTheme, MaxCircuitSize) == 0x00002C, "Member 'UWorldTheme::MaxCircuitSize' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_I) == 0x000030, "Member 'UWorldTheme::BorderWorld_I' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_IO) == 0x000048, "Member 'UWorldTheme::BorderWorld_IO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_O) == 0x000060, "Member 'UWorldTheme::BorderWorld_O' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OO) == 0x000078, "Member 'UWorldTheme::BorderWorld_OO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OOO) == 0x000090, "Member 'UWorldTheme::BorderWorld_OOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OOOO) == 0x0000A8, "Member 'UWorldTheme::BorderWorld_OOOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_S) == 0x0000C0, "Member 'UWorldTheme::BorderWorld_S' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SS) == 0x0000D8, "Member 'UWorldTheme::BorderWorld_SS' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_OS) == 0x0000F0, "Member 'UWorldTheme::BorderWorld_OS' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SO) == 0x000108, "Member 'UWorldTheme::BorderWorld_SO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_SOO) == 0x000120, "Member 'UWorldTheme::BorderWorld_SOO' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_U) == 0x000138, "Member 'UWorldTheme::BorderWorld_U' has a wrong offset!");
static_assert(offsetof(UWorldTheme, BorderWorld_R) == 0x000150, "Member 'UWorldTheme::BorderWorld_R' has a wrong offset!");

// Class FortniteGame.FortTooltipManager
// 0x003C (0x0058 - 0x001C)
class UFortTooltipManager final : public UObject
{
public:
	TMap<class UClass*, class UFortTooltip*>      Tooltips;                                          // 0x001C(0x003C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltipManager">();
	}
	static class UFortTooltipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltipManager>();
	}
};
static_assert(alignof(UFortTooltipManager) == 0x000004, "Wrong alignment on UFortTooltipManager");
static_assert(sizeof(UFortTooltipManager) == 0x000058, "Wrong size on UFortTooltipManager");
static_assert(offsetof(UFortTooltipManager, Tooltips) == 0x00001C, "Member 'UFortTooltipManager::Tooltips' has a wrong offset!");

// Class FortniteGame.FortItemDefinition
// 0x03FC (0x0418 - 0x001C)
class UFortItemDefinition : public UDataAsset
{
public:
	uint8                                         Pad_1C[0x8];                                       // 0x001C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemCountChanged;                                // 0x0024(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFortItemType                                 ItemType;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinLevel;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLevel;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayNamePrefix;                                 // 0x0054(0x000C)(Protected, NativeAccessSpecifierProtected)
	class FText                                   SearchTags;                                        // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x006C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortAttributeTemplate>  AttributeTemplate;                                 // 0x0084(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortInventoryFilter                          FilterOverride;                                    // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconBrush;                                         // 0x00A0(0x0074)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FFortMultiSizeBrush                    MultiSizeIconBrush;                                // 0x0114(0x02B8)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsAccountItem : 1;                                // 0x03CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bNeverPersisted : 1;                               // 0x03CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SecondaryCategoryOverrideTags;                     // 0x03D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TertiaryCategoryOverrideTags;                      // 0x03E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowMultipleStacks : 1;                          // 0x0400(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_401[0x3];                                      // 0x0401(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStackSize;                                      // 0x0404(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPrivateTemplate;                                  // 0x0408(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFortTemplateAccess                           Access;                                            // 0x0409(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateRarityFromQualityAndTier;                // 0x040A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFortQuality                                  Quality;                                           // 0x040B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortItemTier                                 Tier;                                              // 0x040C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortTooltip>               Tooltip;                                           // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortRarity                                   Rarity;                                            // 0x0414(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortItem* CreateTemporaryItemInstanceBP() const;
	TArray<class FText> GetDescription() const;
	class FText GetDisplayName(bool bBaseName) const;
	void GetIconBrush(struct FSlateBrush* IconBrush_0, EFortBrushSize BrushSize) const;
	class FText GetSingleLineDescription() const;
	TSubclassOf<class UFortTooltip> GetTooltip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDefinition">();
	}
	static class UFortItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDefinition>();
	}
};
static_assert(alignof(UFortItemDefinition) == 0x000004, "Wrong alignment on UFortItemDefinition");
static_assert(sizeof(UFortItemDefinition) == 0x000418, "Wrong size on UFortItemDefinition");
static_assert(offsetof(UFortItemDefinition, OnItemCountChanged) == 0x000024, "Member 'UFortItemDefinition::OnItemCountChanged' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, ItemType) == 0x000030, "Member 'UFortItemDefinition::ItemType' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MinLevel) == 0x000034, "Member 'UFortItemDefinition::MinLevel' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MaxLevel) == 0x000038, "Member 'UFortItemDefinition::MaxLevel' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, DisplayName) == 0x00003C, "Member 'UFortItemDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Description) == 0x000048, "Member 'UFortItemDefinition::Description' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, DisplayNamePrefix) == 0x000054, "Member 'UFortItemDefinition::DisplayNamePrefix' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, SearchTags) == 0x000060, "Member 'UFortItemDefinition::SearchTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, GameplayTags) == 0x00006C, "Member 'UFortItemDefinition::GameplayTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, AttributeTemplate) == 0x000084, "Member 'UFortItemDefinition::AttributeTemplate' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, FilterOverride) == 0x00009C, "Member 'UFortItemDefinition::FilterOverride' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, IconBrush) == 0x0000A0, "Member 'UFortItemDefinition::IconBrush' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MultiSizeIconBrush) == 0x000114, "Member 'UFortItemDefinition::MultiSizeIconBrush' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, SecondaryCategoryOverrideTags) == 0x0003D0, "Member 'UFortItemDefinition::SecondaryCategoryOverrideTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, TertiaryCategoryOverrideTags) == 0x0003E8, "Member 'UFortItemDefinition::TertiaryCategoryOverrideTags' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, MaxStackSize) == 0x000404, "Member 'UFortItemDefinition::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, bPrivateTemplate) == 0x000408, "Member 'UFortItemDefinition::bPrivateTemplate' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Access) == 0x000409, "Member 'UFortItemDefinition::Access' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, bCalculateRarityFromQualityAndTier) == 0x00040A, "Member 'UFortItemDefinition::bCalculateRarityFromQualityAndTier' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Quality) == 0x00040B, "Member 'UFortItemDefinition::Quality' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Tier) == 0x00040C, "Member 'UFortItemDefinition::Tier' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Tooltip) == 0x000410, "Member 'UFortItemDefinition::Tooltip' has a wrong offset!");
static_assert(offsetof(UFortItemDefinition, Rarity) == 0x000414, "Member 'UFortItemDefinition::Rarity' has a wrong offset!");

// Class FortniteGame.FortClientOnlyActor
// 0x0000 (0x0240 - 0x0240)
class AFortClientOnlyActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientOnlyActor">();
	}
	static class AFortClientOnlyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientOnlyActor>();
	}
};
static_assert(alignof(AFortClientOnlyActor) == 0x000004, "Wrong alignment on AFortClientOnlyActor");
static_assert(sizeof(AFortClientOnlyActor) == 0x000240, "Wrong size on AFortClientOnlyActor");

// Class FortniteGame.FortDamageNumbersActor
// 0x0064 (0x02A4 - 0x0240)
class AFortDamageNumbersActor : public AFortClientOnlyActor
{
public:
	float                                         ComponentLifespan;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MeshesByElement[0x4];                              // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CritBuildingImpactMesh;                            // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPooledDamageNumberComponents          PooledComponentsByElement[0x4];                    // 0x0258(0x000C)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FPooledDamageNumberComponents          PooledComponentsCritBuildingImpact;                // 0x0288(0x000C)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLiveDamageNumberComponent>     LiveComponents;                                    // 0x0294(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x4];                                      // 0x02A0(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewDamageNumber(const struct FFortDamageNumberInfo& NewDamageNumberInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageNumbersActor">();
	}
	static class AFortDamageNumbersActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDamageNumbersActor>();
	}
};
static_assert(alignof(AFortDamageNumbersActor) == 0x000004, "Wrong alignment on AFortDamageNumbersActor");
static_assert(sizeof(AFortDamageNumbersActor) == 0x0002A4, "Wrong size on AFortDamageNumbersActor");
static_assert(offsetof(AFortDamageNumbersActor, ComponentLifespan) == 0x000240, "Member 'AFortDamageNumbersActor::ComponentLifespan' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, MeshesByElement) == 0x000244, "Member 'AFortDamageNumbersActor::MeshesByElement' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, CritBuildingImpactMesh) == 0x000254, "Member 'AFortDamageNumbersActor::CritBuildingImpactMesh' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PooledComponentsByElement) == 0x000258, "Member 'AFortDamageNumbersActor::PooledComponentsByElement' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, PooledComponentsCritBuildingImpact) == 0x000288, "Member 'AFortDamageNumbersActor::PooledComponentsCritBuildingImpact' has a wrong offset!");
static_assert(offsetof(AFortDamageNumbersActor, LiveComponents) == 0x000294, "Member 'AFortDamageNumbersActor::LiveComponents' has a wrong offset!");

// Class FortniteGame.FortAccountItemDefinition
// 0x0018 (0x0430 - 0x0418)
class UFortAccountItemDefinition : public UFortItemDefinition
{
public:
	struct FCurveTableRowHandle                   LevelToXpHandle;                                   // 0x0418(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   LevelToSacrificeXpHandle;                          // 0x0424(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountItemDefinition">();
	}
	static class UFortAccountItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountItemDefinition>();
	}
};
static_assert(alignof(UFortAccountItemDefinition) == 0x000004, "Wrong alignment on UFortAccountItemDefinition");
static_assert(sizeof(UFortAccountItemDefinition) == 0x000430, "Wrong size on UFortAccountItemDefinition");
static_assert(offsetof(UFortAccountItemDefinition, LevelToXpHandle) == 0x000418, "Member 'UFortAccountItemDefinition::LevelToXpHandle' has a wrong offset!");
static_assert(offsetof(UFortAccountItemDefinition, LevelToSacrificeXpHandle) == 0x000424, "Member 'UFortAccountItemDefinition::LevelToSacrificeXpHandle' has a wrong offset!");

// Class FortniteGame.FortWorkerType
// 0x0314 (0x0744 - 0x0430)
class UFortWorkerType : public UFortAccountItemDefinition
{
public:
	class UGameplayEffect*                        ManagerEffect;                                     // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               WorkerWorldItem;                                   // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsManager;                                        // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BuildingSynergyTag;                                // 0x043C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FixedPersonalityTag;                               // 0x0454(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FixedSetBonusTag;                                  // 0x046C(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MatchingPersonalityBonus;                          // 0x0484(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MismatchingPersonalityPenalty;                     // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            CardIconBrush[0x3];                                // 0x048C(0x0074)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            AvatarIconBrush[0x3];                              // 0x05E8(0x0074)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorkerType">();
	}
	static class UFortWorkerType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorkerType>();
	}
};
static_assert(alignof(UFortWorkerType) == 0x000004, "Wrong alignment on UFortWorkerType");
static_assert(sizeof(UFortWorkerType) == 0x000744, "Wrong size on UFortWorkerType");
static_assert(offsetof(UFortWorkerType, ManagerEffect) == 0x000430, "Member 'UFortWorkerType::ManagerEffect' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, WorkerWorldItem) == 0x000434, "Member 'UFortWorkerType::WorkerWorldItem' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, bIsManager) == 0x000438, "Member 'UFortWorkerType::bIsManager' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, BuildingSynergyTag) == 0x00043C, "Member 'UFortWorkerType::BuildingSynergyTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, FixedPersonalityTag) == 0x000454, "Member 'UFortWorkerType::FixedPersonalityTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, FixedSetBonusTag) == 0x00046C, "Member 'UFortWorkerType::FixedSetBonusTag' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, MatchingPersonalityBonus) == 0x000484, "Member 'UFortWorkerType::MatchingPersonalityBonus' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, MismatchingPersonalityPenalty) == 0x000488, "Member 'UFortWorkerType::MismatchingPersonalityPenalty' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, CardIconBrush) == 0x00048C, "Member 'UFortWorkerType::CardIconBrush' has a wrong offset!");
static_assert(offsetof(UFortWorkerType, AvatarIconBrush) == 0x0005E8, "Member 'UFortWorkerType::AvatarIconBrush' has a wrong offset!");

// Class FortniteGame.FortMissionRewardNotification
// 0x0000 (0x041C - 0x041C)
class AFortMissionRewardNotification final : public AFortClientNotification
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionRewardNotification">();
	}
	static class AFortMissionRewardNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionRewardNotification>();
	}
};
static_assert(alignof(AFortMissionRewardNotification) == 0x000004, "Wrong alignment on AFortMissionRewardNotification");
static_assert(sizeof(AFortMissionRewardNotification) == 0x00041C, "Wrong size on AFortMissionRewardNotification");

// Class FortniteGame.FortHeroType
// 0x0118 (0x085C - 0x0744)
class UFortHeroType final : public UFortWorkerType
{
public:
	TArray<class FString>                         Outfits_Naked;                                     // 0x0744(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         Outfits_Male;                                      // 0x0750(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         Outfits_Female;                                    // 0x075C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           IdleAnimation_Male;                                // 0x0768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           IdleAnimation_Female;                              // 0x076C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTrait*                             PrimaryTrait;                                      // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTrait*                             SecondaryTraits[0x4];                              // 0x0774(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHeroSpecialization*                DefaultSpecialization;                             // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHeroAbilityKit>                AbilityKits;                                       // 0x0788(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectApplicationInfo> CombinedStatGEs;                                   // 0x0794(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            CombinedStatSourceGE;                              // 0x07A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHeroItem>                      HeroItems;                                         // 0x07A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredGPTags;                                    // 0x07B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFortFeedbackBank*                      MaleOverrideFeedback;                              // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortFeedbackBank*                      FemaleOverrideFeedback;                            // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OverridePawnClass;                                 // 0x07D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrushSmall;                                    // 0x07E8(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroType">();
	}
	static class UFortHeroType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHeroType>();
	}
};
static_assert(alignof(UFortHeroType) == 0x000004, "Wrong alignment on UFortHeroType");
static_assert(sizeof(UFortHeroType) == 0x00085C, "Wrong size on UFortHeroType");
static_assert(offsetof(UFortHeroType, Outfits_Naked) == 0x000744, "Member 'UFortHeroType::Outfits_Naked' has a wrong offset!");
static_assert(offsetof(UFortHeroType, Outfits_Male) == 0x000750, "Member 'UFortHeroType::Outfits_Male' has a wrong offset!");
static_assert(offsetof(UFortHeroType, Outfits_Female) == 0x00075C, "Member 'UFortHeroType::Outfits_Female' has a wrong offset!");
static_assert(offsetof(UFortHeroType, IdleAnimation_Male) == 0x000768, "Member 'UFortHeroType::IdleAnimation_Male' has a wrong offset!");
static_assert(offsetof(UFortHeroType, IdleAnimation_Female) == 0x00076C, "Member 'UFortHeroType::IdleAnimation_Female' has a wrong offset!");
static_assert(offsetof(UFortHeroType, PrimaryTrait) == 0x000770, "Member 'UFortHeroType::PrimaryTrait' has a wrong offset!");
static_assert(offsetof(UFortHeroType, SecondaryTraits) == 0x000774, "Member 'UFortHeroType::SecondaryTraits' has a wrong offset!");
static_assert(offsetof(UFortHeroType, DefaultSpecialization) == 0x000784, "Member 'UFortHeroType::DefaultSpecialization' has a wrong offset!");
static_assert(offsetof(UFortHeroType, AbilityKits) == 0x000788, "Member 'UFortHeroType::AbilityKits' has a wrong offset!");
static_assert(offsetof(UFortHeroType, CombinedStatGEs) == 0x000794, "Member 'UFortHeroType::CombinedStatGEs' has a wrong offset!");
static_assert(offsetof(UFortHeroType, CombinedStatSourceGE) == 0x0007A0, "Member 'UFortHeroType::CombinedStatSourceGE' has a wrong offset!");
static_assert(offsetof(UFortHeroType, HeroItems) == 0x0007A4, "Member 'UFortHeroType::HeroItems' has a wrong offset!");
static_assert(offsetof(UFortHeroType, RequiredGPTags) == 0x0007B0, "Member 'UFortHeroType::RequiredGPTags' has a wrong offset!");
static_assert(offsetof(UFortHeroType, MaleOverrideFeedback) == 0x0007C8, "Member 'UFortHeroType::MaleOverrideFeedback' has a wrong offset!");
static_assert(offsetof(UFortHeroType, FemaleOverrideFeedback) == 0x0007CC, "Member 'UFortHeroType::FemaleOverrideFeedback' has a wrong offset!");
static_assert(offsetof(UFortHeroType, OverridePawnClass) == 0x0007D0, "Member 'UFortHeroType::OverridePawnClass' has a wrong offset!");
static_assert(offsetof(UFortHeroType, IconBrushSmall) == 0x0007E8, "Member 'UFortHeroType::IconBrushSmall' has a wrong offset!");

// Class FortniteGame.FortTrait
// 0x0044 (0x045C - 0x0418)
class UFortTrait final : public UFortItemDefinition
{
public:
	struct FFortAbilityKitSlot                    AbilityKitSlots[0x5];                              // 0x0418(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   TraitCostEntryName;                                // 0x0454(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<struct FFortAbilityKitSlot> GetAbilityKitSlots();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrait">();
	}
	static class UFortTrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrait>();
	}
};
static_assert(alignof(UFortTrait) == 0x000004, "Wrong alignment on UFortTrait");
static_assert(sizeof(UFortTrait) == 0x00045C, "Wrong size on UFortTrait");
static_assert(offsetof(UFortTrait, AbilityKitSlots) == 0x000418, "Member 'UFortTrait::AbilityKitSlots' has a wrong offset!");
static_assert(offsetof(UFortTrait, TraitCostEntryName) == 0x000454, "Member 'UFortTrait::TraitCostEntryName' has a wrong offset!");

// Class FortniteGame.FortCheatManager
// 0x004C (0x00A8 - 0x005C)
class UFortCheatManager final : public UCheatManager
{
public:
	TArray<struct FSpawnPickupEntry>              SpawnablePickups;                                  // 0x005C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDebugInteractTrace : 1;                           // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugPickupSpline : 1;                            // 0x0070(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugFloorsOnMiniMap : 1;                         // 0x0070(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bEnableScoreboard : 1;                             // 0x0070(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugBounceCurve : 1;                             // 0x0070(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugBeautyMode : 1;                              // 0x0070(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDebugStructuralSupportSystem : 1;                 // 0x0070(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bInfiniteStamina : 1;                              // 0x0070(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowGameDifficultyHUD : 1;                        // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowIntensityHUD : 1;                             // 0x0071(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowSpawnPointsHUD : 1;                           // 0x0071(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowMaxAIHUD : 1;                                 // 0x0071(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUnlimitedHealth : 1;                              // 0x0071(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bFreezeAILOD : 1;                                  // 0x0071(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bForceAILOD : 1;                                   // 0x0071(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EFortAILODLevel                               ForcedAILODValue;                                  // 0x0074(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBuildingTextureData>    TransparentTextureData;                            // 0x0078(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowRespawn();
	void ApplyWeaponAlteration(const class FString& AlterationName);
	void BackpackSetSize(int32 Size);
	void Badass();
	void BanPlayer(const class FString& PlayerName);
	void BeautyMode();
	void BounceContainer();
	void BuildFree();
	void BuildWith(const class FString& ResourceTypeAndOrLevel);
	void CheatScript(const class FString& ScriptName);
	void ClearBannedPlayers();
	void ClearEncounterSimulatedNumberOfPlayers();
	void ClearEncounterSpawnPointsCap();
	void ClearEncounterSpawnPointsCurve();
	void ClearKeepSave();
	void ClearRespawnTimer();
	void ConstructTileWorld(int32 MaxTiles, int32 X, int32 Y);
	void CoverMap();
	void CycleCurrentEncounterToDebug();
	void CycleEncounterEQSQueryToDebug();
	void CycleTheaterDisplayed();
	void DebugAbilityTags();
	void DebugAttribute(class FString* Attribute);
	void DebugAttributeClear();
	void DebugAttributeModifiers();
	void DebugBuildingDetection();
	void DebugForceEnsure();
	void DebugHideLoadingScreen();
	void DebugHotSpots();
	void DebugKickPlayerDueToInactivity();
	void DebugLoadingScreen(const class FString& MissionGen);
	void DebugRifts();
	void DebugStructuralSupport();
	void DebugThisAI();
	void DebugUseDedicatedServer(bool bUse);
	void DeleteWorld(const class FString& WorldName);
	void DisableAI();
	void DumpActiveGameplayEffects();
	void DumpActorsWithAssetTags(const class FString& TagList);
	void DumpAllActorsWithAssetTags();
	void DumpGameStats(const class FString& FilterName);
	void EnableAltKeybinds(bool bEnable);
	void EnableNewCustomizationPanel(bool bEnable);
	void EncounterCurrentUtilities();
	void EncounterInitialUtilities();
	void EncounterSetDifficultyLevel(float NewDifficulty);
	void EncounterSpawnProbabilities();
	void EncounterTopUtilityPercentages();
	void ExecuteNewMissionGeneration(float DifficultyLevel, const class FString& GeneratorName);
	void FakeZoneScoreboard();
	void ForceAILODs(EFortAILODLevel inForcedAILODValue);
	void ForceHeroType(const class FString& HeroPersistentName);
	void ForceNakedOutfit();
	void ForceSaveMissionStateAndWorld(const class FString& SaveFilename);
	void ForceSaveWorld(const class FString& SaveFilename);
	void ForceSetHeroRemoteCharacter(int32 PartyMemberIndex, bool bEnabled);
	void ForceShowScoreboard();
	void GeneratePolysInPathingRange(float MaxDistance, float MinDistance);
	void GetAllReplStats();
	void GetFocusedMissionInfo();
	void GetGameStat(const class FString& StatName);
	void GetReplStat(EFortReplicatedStat Stat);
	void GetWorldDifficulty();
	void GetWorldLevel();
	void GetWorldLockStatus(const class FString& WUID);
	void GetWTFRotations();
	void GiveAllConsumables(int32 NumItems);
	void GiveAllDecorations();
	void GiveAllIngredients(int32 NumIngredients);
	void GiveAllMelee();
	void GiveAllPistols();
	void GiveAllRifles();
	void GiveAllShotguns();
	void GiveAllTraps(int32 NumItems);
	void GiveAllWeapons();
	void GiveAmmo(const class FString& AmmoNameAndAmmount);
	void GiveBluGlo(int32 Amount);
	void GiveCheatInventory();
	void GiveFakeBuildingGameplayEffect(const class FString& BuildingTemplateId, int32 Level);
	void GiveGadget(const class FString& GadgetName, int32 ItemLevel);
	void GiveGadgets(const class FString& GadgetName, int32 Quantity, int32 ItemLevel);
	void GiveGoodWeapons();
	void GiveHeroSpecialization(const class FString& SpecializationName);
	void GiveMetal(int32 Amount);
	void GiveResources(int32 Amount);
	void GiveSBA(const class FString& StrategicBuildingName);
	void GiveSpecificItem(const class FString& ItemPath, int32 ItemLevel);
	void GiveStone(int32 Amount);
	void GiveTrap(const class FString& TrapName, int32 RequestedLevel);
	void GiveUsefulThings(int32 NumOfUsefulThings);
	void GiveWeapon(const class FString& WeaponName, int32 RequestedLevel);
	void GiveWeapons(class FName Tag);
	void GiveWood(int32 Amount);
	void KillPawns(TSubclassOf<class AFortPawn> aClass);
	void ListActiveEncounters();
	void ListAIUtilities();
	void ListAmmo();
	void ListBannedPlayers();
	void ListCheats();
	void ListDecorations();
	void ListEmotes();
	void ListEnemyMutators();
	void ListMissionGenerators();
	void ListMissions();
	void ListSpawnGroups();
	void LoadMission(const class FString& MissionName);
	void LoadMissionGenerator(const class FString& GeneratorName);
	void McpApplyAlteration(const class FString& Schematic, const class FString& Alteration);
	void McpCheat();
	void McpCompleteCurrentPrimaryMission(int32 NumMissionPoints);
	void McpCompleteHexMission();
	void McpEarnScore(int32 ScoreAmount);
	void McpEquipCharCosmetic(const class FString& CharacterId, const class FString& CosmeticId, int32 CosmeticType);
	void McpGetCachedPersistence();
	void McpGetCurrencyAmount();
	void McpGetHexMission();
	void McpGetPersonnelXP();
	void McpGetSchematicXP();
	void McpGetVersion();
	void McpGrantAllSchematics();
	void McpGrantCurrency(int32 Amount);
	void McpGrantItem(const class FString& ItemId);
	void McpGrantPersonnelXP(int32 Amount);
	void McpGrantSchematicXP(int32 Amount);
	void McpHeroAssignToBuilding(const class FString& HeroName, const class FString& BuildingType, int32 SlotIdx);
	void McpHeroCreate(const class FString& HeroType, const class FString& Name_0);
	void McpHeroDelete(const class FString& HeroName);
	void McpHeroRename(const class FString& OldHeroName, const class FString& NewHeroName);
	void McpHostGetAllPlayerCachedPersistence();
	void McpHostGetPlayers();
	void McpHostGrantAllPlayersSchematic(const class FString& SchematicId);
	void McpLogout();
	void McpOpenCardPack(const class FString& CardPackItemId, int32 SelectionIdx);
	void McpRecycleItem(const class FString& ItemToRecycle);
	void McpRedeemPurchases();
	void McpRefreshCatalog();
	void McpRefreshProfile();
	void McpResetPersistence();
	void McpUpgradeItem(const class FString& ItemToUpgrade);
	void MissionForceFailure(const class FString& MissionName);
	void MissionForcePrimarySuccess();
	void MissionForceSuccess(const class FString& MissionName);
	void ModItemDurability(float InValue);
	void MyFortAddHeroSlot();
	void MyFortAddWorker();
	void MyFortCollectAccumulatedResources(EFortPersistentResources ResourceType);
	void MyFortConsumeAllResources(int32 Amount);
	void MyFortConsumeResources(int32 Amount, EFortPersistentResources ResourceType);
	void MyFortFillWarehouse(EFortPersistentResources ResourceType);
	void MyFortGrantAllResources(int32 Amount);
	void MyFortRequestUpdate();
	void MyFortSetChecksDisabled(bool bSet);
	void MyFortTestDefaultHeroId();
	void MyFortTestLastRatings(const class FString& BuildingId, int32 LastMaxLevel, int32 LastMaxRating);
	void MyFortUpgradeBuilding(const class FString& BuildingId);
	void MyTownToggleBetweenKeepAndManor(bool bNowShowKeep);
	void MyTownToggleFriendsHomeBase(const class FString& FriendsAccountId, const class FString& FriendsName);
	void OpenClassSelectScreen();
	void PrintShotReport();
	void PrintTileWorld();
	void RefreshTheaters();
	void RegenerateZoneMissions(bool bUseNewMissionGeneration);
	void RegenerateZoneMissionsWithDifficultyLevel(bool bUseNewMissionGeneration, float DifficultyLevelOverride);
	void ReInitHUD();
	void ReloadUI();
	void ReloadUMG();
	void ReRandomizeTiles();
	void ResetEncounterWave();
	void ResetMaxAITracking();
	void RunMonteCarlo(int32 X, int32 Y, const class FString& TileGroup, int32 NumIterations);
	void SendCheatNotifications(int32 NumOfNotifications);
	void SendMissionEvent(const class FString& MissionEventName);
	void SendQuestEvent(class FName Type, class FName TargetTag, class FName SourceTag, class FName ContextTag);
	void SetActionMappingEnabled(class FName Action, bool bEnabled);
	void SetAimMode(uint32 Mode);
	void SetBaseScaleLevelOverride(float BaseScaleLevelOverrideValue);
	void SetBTProbability(float Propability);
	void SetBuildAnimCheatHeight(float NewHeight);
	void SetBuildAnimCheatSpeedMultiplier(float NewMultiplier);
	void SetBuildAnimCheatStartDelay(float MaxRandDelay);
	void SetCameraDistanceMultiplier(float XMultiplier, float YMultiplier, float ZMultiplier);
	void SetCameraFOVMultiplier(float Multiplier);
	void SetCameraPrototype(class FName ProtoName);
	void SetCapturePercentage(float NewCapturePercentage);
	void SetCombatGraphHistoryLength(int32 Seconds);
	void SetCullValues(float DefaultCullObjectSize, float DefaultCullDistance, float MinCullObjectSize, float MinCullDistance, float MaxCullObjectSize, float MaxCullDistance);
	void SetCurrentEncounterToDebug(int32 EncounterIndex);
	void SetEncounterDirections(const TArray<EFortEncounterDirection>& Directions);
	void SetEncounterGraphsHistoryLength(int32 Seconds);
	void SetEncounterSimulatedNumberOfPlayers(int32 NumPlayers);
	void SetEncounterSpawnPointsCap(int32 SpawnPointsCap);
	void SetEncounterSpawnPointsCurve(const class FString& CurveName);
	void SetEncounterTopUtilityPercentages(const class FString& UtilitiesAndPercentages);
	void SetGameDifficultyOverride(float GameDifficultyOverrideValue);
	void SetGameStat(const class FString& StatName, int32 Amount);
	void SetHealthPercent(float Percent);
	void SetInteractExtent(float Extent);
	void SetInteractionDistances(float InteractionDistance, float InteractionHighlightDistance);
	void SetJumpStaminaCost(class FName ModeName);
	void SetMaxClouds(int32 MaxClouds);
	void SetPvPRoundTime(int32 NumSeconds, int32 CriticalThreshold);
	void SetPvPStalemateTime(int32 NumSeconds);
	void SetReplStat(EFortReplicatedStat Stat, int32 Amount);
	void SetRespawnTimerOverride(float TimeUntilRespawn);
	void SetWorldDaysElapsed(float days);
	void SetWorldLevel(float Level);
	void SimulateLoot(const class FName TierGroup, int32 LootTier);
	void SimulateLootDrops();
	void SpawnAIGroup(const class FString& SpawnGroupName);
	void SpawnAIGroupFromExternalSpawner(const class FString& SpawnGroupName);
	void SpawnAIGroupWithMutator(const class FString& SpawnGroupName, const class FString& MutatorName, int32 DummyInt);
	void SpawnGuardians();
	class AFortPawn* SpawnPawn(const class FString& PawnType);
	void StopDummyDebugEncounter();
	void SwitchHeroToClass(const class FString& NewHeroID);
	void SwitchTeam();
	void TeleportToActor(const class FString& ClassOrInstanceName);
	void TeleportToLocation(float X, float Y, float Z);
	void TeleportToMissionActor();
	void TestCancelLobby();
	void TestChangePartyPrivacy(bool bPrivate, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);
	void TestChangePartySize(int32 NewSize);
	void TestDisconnect();
	void TestFogLoad();
	void TestFogReplicate();
	void TestFogSave();
	void TestJoin();
	void TestKnockback(float KnockbackMagnitude, float KnockbackZAngle);
	void TestLeaveGame();
	void TestLockWorld(const class FString& WUID, bool bLock);
	void TestOutpostUI();
	void TestSetOutpostDefenseActive(bool bActive);
	void TestStun(float StunStime);
	void TestUpgradeOutpostItem(const class FString& ItemTemplateId);
	void ToggleAIAnim();
	void ToggleAIDespawning();
	void ToggleAIDirectorLogging();
	void ToggleAISpawnCap();
	void ToggleAISpawning();
	void ToggleBuildAnimCheat();
	void ToggleBuildingActorsTransparency();
	void ToggleCombatGraph();
	void ToggleDrawRunVariationDebug();
	void ToggleDrawTargetSelectionDebug();
	void ToggleDrawTargetSelectionDebugByClass(TSubclassOf<class AActor> TargetSelectionDebugSourceClass);
	void ToggleDrawTurnTransitionDebug();
	void ToggleEncounterEQSDebug();
	void ToggleFactorGraph();
	void ToggleFloorsOnMiniMap();
	void ToggleFreezeAILOD();
	void ToggleGameDifficultyHUD();
	void ToggleIndestructibleKeep();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteDurability();
	void ToggleInfiniteStamina();
	void ToggleIntensityGraph();
	void ToggleIntensityHUD();
	void ToggleInteractTrace();
	void ToggleInvincibleCornerstones();
	void ToggleLogCharacterCustomization();
	void ToggleMaxAIHUD();
	void ToggleNoCoolDown();
	void TogglePickupSpline();
	void TogglePIDContributionsGraph();
	void TogglePIDValuesGraph();
	void TogglePlayerNames();
	void ToggleShotLogging();
	void ToggleSpawnPATrolls();
	void ToggleSpawnPointsHUD();
	void ToggleTreeVisibility();
	void ToggleUnlimitedHealth();
	void ToggleUtilitiesGraph();
	void ToggleVoiceDebug();
	void ToggleWalkOnWalls();
	void TriggerOutOfStaminaFeedback();
	void TutorialAddHidden(class FName Hidden);
	void TutorialAddHighlight(class FName Highlight);
	void TutorialListAll();
	void TutorialListHidden();
	void TutorialListHighlights();
	void TutorialRemoveHidden(class FName Hidden);
	void TutorialRemoveHighlight(class FName Highlight);
	void UnbanPlayer(const class FString& PlayerName);
	void UncoverMap();
	void UnforceAILODs();
	void UnlockAllZones();
	void UpdateHomebaseGameplayEffects();
	void ViewStuck();
	void WannaGun();
	void WriteLootReport();

	void ListGadgets() const;
	void ListTraps() const;
	void ListWeapons() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCheatManager">();
	}
	static class UFortCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCheatManager>();
	}
};
static_assert(alignof(UFortCheatManager) == 0x000004, "Wrong alignment on UFortCheatManager");
static_assert(sizeof(UFortCheatManager) == 0x0000A8, "Wrong size on UFortCheatManager");
static_assert(offsetof(UFortCheatManager, SpawnablePickups) == 0x00005C, "Member 'UFortCheatManager::SpawnablePickups' has a wrong offset!");
static_assert(offsetof(UFortCheatManager, ForcedAILODValue) == 0x000074, "Member 'UFortCheatManager::ForcedAILODValue' has a wrong offset!");
static_assert(offsetof(UFortCheatManager, TransparentTextureData) == 0x000078, "Member 'UFortCheatManager::TransparentTextureData' has a wrong offset!");

// Class FortniteGame.FortAbilityKit
// 0x0144 (0x017C - 0x0038)
class UFortAbilityKit final : public UFortAbilitySet
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TArray<class FText>                           Description;                                       // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   TooltipDescription;                                // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	struct FSlateBrush                            IconBrush;                                         // 0x0060(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PrimaryTraitIconBrushOverride;                     // 0x00D4(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UFortGadgetItemDefinition*>      Gadgets;                                           // 0x0148(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FAbilityKitItem>                Items;                                             // 0x0154(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UFortSchematicItemDefinition*>   AddedSchematics;                                   // 0x0160(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UFortSchematicItemDefinition*>   RemovedSchematics;                                 // 0x016C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortTooltip>               Tooltip;                                           // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FText> GetDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityKit">();
	}
	static class UFortAbilityKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityKit>();
	}
};
static_assert(alignof(UFortAbilityKit) == 0x000004, "Wrong alignment on UFortAbilityKit");
static_assert(sizeof(UFortAbilityKit) == 0x00017C, "Wrong size on UFortAbilityKit");
static_assert(offsetof(UFortAbilityKit, DisplayName) == 0x00003C, "Member 'UFortAbilityKit::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Description) == 0x000048, "Member 'UFortAbilityKit::Description' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, TooltipDescription) == 0x000054, "Member 'UFortAbilityKit::TooltipDescription' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, IconBrush) == 0x000060, "Member 'UFortAbilityKit::IconBrush' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, PrimaryTraitIconBrushOverride) == 0x0000D4, "Member 'UFortAbilityKit::PrimaryTraitIconBrushOverride' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Gadgets) == 0x000148, "Member 'UFortAbilityKit::Gadgets' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Items) == 0x000154, "Member 'UFortAbilityKit::Items' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, AddedSchematics) == 0x000160, "Member 'UFortAbilityKit::AddedSchematics' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, RemovedSchematics) == 0x00016C, "Member 'UFortAbilityKit::RemovedSchematics' has a wrong offset!");
static_assert(offsetof(UFortAbilityKit, Tooltip) == 0x000178, "Member 'UFortAbilityKit::Tooltip' has a wrong offset!");

// Class FortniteGame.FortItem
// 0x0024 (0x0040 - 0x001C)
class UFortItem : public UObject
{
public:
	UMulticastDelegateProperty_                   OnItemChanged;                                     // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemDestroyed;                                   // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x8];                                       // 0x0034(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadedFromSave;                                   // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanBeDropped() const;
	bool CanBeUnslotted() const;
	bool CanBeUpgraded() const;
	bool DoesMatchSearchString(const class FString& SearchString) const;
	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	class FText GetAlterationSlotActivationRequirement(int32 SlotIndex) const;
	float GetCoolDownPercentageRemaining(class AFortPlayerController* FortPC) const;
	float GetCoolDownTimeRemaining(class AFortPlayerController* FortPC, float* CooldownDuration) const;
	class FText GetDescription() const;
	class FText GetDisplayName() const;
	float GetDurability() const;
	EFortInventoryFilter GetFilterCategory() const;
	void GetIconBrush(struct FSlateBrush* IconBrush, EFortBrushSize BrushSize) const;
	class UFortItemDefinition* GetItemDefinitionBP() const;
	struct FGuid GetItemGuid() const;
	int32 GetLevel() const;
	int32 GetLoadedAmmo() const;
	int32 GetMaxLevel() const;
	float GetNormalizedDurability() const;
	int32 GetNumInStack() const;
	bool GetPrimaryCategory(class FText* ItemCategoryText) const;
	EFortRarity GetRarity() const;
	struct FLinearColor GetRarityColor() const;
	struct FLinearColor GetRaritySecondaryColor() const;
	struct FLinearColor GetRarityTextShadowColor() const;
	int32 GetRecycleValue() const;
	int32 GetRemainingAmmo() const;
	class UFortItemDefinition* GetSchematicCraftingResultBP() const;
	EFortItemType GetSchematicResultType() const;
	class FText GetSearchTags() const;
	bool GetSecondaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	bool GetTertiaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	EFortItemTier GetTier() const;
	EFortItemType GetType() const;
	int32 GetUpgradeCost() const;
	bool HasDurability() const;
	bool IsActivatable(class AFortPlayerController* FortPC) const;
	bool IsAlterationSlotActive(int32 SlotIndex) const;
	bool IsEquipable(const class AFortPlayerController* EquippingPC) const;
	bool IsEquipped() const;
	bool IsInBackpackOverflow() const;
	bool IsInStorageVault() const;
	bool IsSchematic() const;
	bool IsSlotted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItem">();
	}
	static class UFortItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItem>();
	}
};
static_assert(alignof(UFortItem) == 0x000004, "Wrong alignment on UFortItem");
static_assert(sizeof(UFortItem) == 0x000040, "Wrong size on UFortItem");
static_assert(offsetof(UFortItem, OnItemChanged) == 0x00001C, "Member 'UFortItem::OnItemChanged' has a wrong offset!");
static_assert(offsetof(UFortItem, OnItemDestroyed) == 0x000028, "Member 'UFortItem::OnItemDestroyed' has a wrong offset!");
static_assert(offsetof(UFortItem, bLoadedFromSave) == 0x00003C, "Member 'UFortItem::bLoadedFromSave' has a wrong offset!");

// Class FortniteGame.FortUIBypassNotification
// 0x0000 (0x041C - 0x041C)
class AFortUIBypassNotification : public AFortClientNotification
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIBypassNotification">();
	}
	static class AFortUIBypassNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIBypassNotification>();
	}
};
static_assert(alignof(AFortUIBypassNotification) == 0x000004, "Wrong alignment on AFortUIBypassNotification");
static_assert(sizeof(AFortUIBypassNotification) == 0x00041C, "Wrong size on AFortUIBypassNotification");

// Class FortniteGame.FortDialogNotification
// 0x0000 (0x041C - 0x041C)
class AFortDialogNotification final : public AFortUIBypassNotification
{
public:
	void CloseTalkingHead();
	void OnDialogInterrupted();
	void OpenTalkingHead(class UTexture2D* Image, const class FText& Title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDialogNotification">();
	}
	static class AFortDialogNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDialogNotification>();
	}
};
static_assert(alignof(AFortDialogNotification) == 0x000004, "Wrong alignment on AFortDialogNotification");
static_assert(sizeof(AFortDialogNotification) == 0x00041C, "Wrong size on AFortDialogNotification");

// Class FortniteGame.FortAccountItem
// 0x0040 (0x0080 - 0x0040)
class UFortAccountItem : public UFortItem
{
public:
	uint8                                         Pad_40[0x4];                                       // 0x0040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         XP;                                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         bItemSeen;                                         // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxLevelBonus;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAccountItemDefinition*             ItemDefinition;                                    // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InstanceId;                                        // 0x0058(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TemplateId;                                        // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Quantity;                                          // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLocalOnlyItem;                                  // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldBeMarkedAsSeen;                             // 0x0075(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_76[0xA];                                       // 0x0076(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasBeenSeenLocally() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAccountItem">();
	}
	static class UFortAccountItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAccountItem>();
	}
};
static_assert(alignof(UFortAccountItem) == 0x000004, "Wrong alignment on UFortAccountItem");
static_assert(sizeof(UFortAccountItem) == 0x000080, "Wrong size on UFortAccountItem");
static_assert(offsetof(UFortAccountItem, Level) == 0x000044, "Member 'UFortAccountItem::Level' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, XP) == 0x000048, "Member 'UFortAccountItem::XP' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, bItemSeen) == 0x00004C, "Member 'UFortAccountItem::bItemSeen' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, MaxLevelBonus) == 0x000050, "Member 'UFortAccountItem::MaxLevelBonus' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, ItemDefinition) == 0x000054, "Member 'UFortAccountItem::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, InstanceId) == 0x000058, "Member 'UFortAccountItem::InstanceId' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, TemplateId) == 0x000064, "Member 'UFortAccountItem::TemplateId' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, Quantity) == 0x000070, "Member 'UFortAccountItem::Quantity' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, bIsLocalOnlyItem) == 0x000074, "Member 'UFortAccountItem::bIsLocalOnlyItem' has a wrong offset!");
static_assert(offsetof(UFortAccountItem, bShouldBeMarkedAsSeen) == 0x000075, "Member 'UFortAccountItem::bShouldBeMarkedAsSeen' has a wrong offset!");

// Class FortniteGame.FortWorker
// 0x005C (0x00DC - 0x0080)
class UFortWorker : public UFortAccountItem
{
public:
	class FString                                 Slotted_Building_Id;                               // 0x0080(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Building_Slot_Used;                                // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 personality;                                       // 0x0094(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 set_bonus;                                         // 0x00A0(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PersonalityTag;                                    // 0x00AC(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SetBonusTag;                                       // 0x00C4(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool GetSecondaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	bool GetTertiaryCategory(class FText* ItemCategoryText, struct FSlateBrush* ItemCategoryBrush, EFortBrushSize BrushSize) const;
	class UFortWorkerType* GetWorkerTypeBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorker">();
	}
	static class UFortWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorker>();
	}
};
static_assert(alignof(UFortWorker) == 0x000004, "Wrong alignment on UFortWorker");
static_assert(sizeof(UFortWorker) == 0x0000DC, "Wrong size on UFortWorker");
static_assert(offsetof(UFortWorker, Slotted_Building_Id) == 0x000080, "Member 'UFortWorker::Slotted_Building_Id' has a wrong offset!");
static_assert(offsetof(UFortWorker, Building_Slot_Used) == 0x00008C, "Member 'UFortWorker::Building_Slot_Used' has a wrong offset!");
static_assert(offsetof(UFortWorker, Gender) == 0x000090, "Member 'UFortWorker::Gender' has a wrong offset!");
static_assert(offsetof(UFortWorker, personality) == 0x000094, "Member 'UFortWorker::personality' has a wrong offset!");
static_assert(offsetof(UFortWorker, set_bonus) == 0x0000A0, "Member 'UFortWorker::set_bonus' has a wrong offset!");
static_assert(offsetof(UFortWorker, PersonalityTag) == 0x0000AC, "Member 'UFortWorker::PersonalityTag' has a wrong offset!");
static_assert(offsetof(UFortWorker, SetBonusTag) == 0x0000C4, "Member 'UFortWorker::SetBonusTag' has a wrong offset!");

// Class FortniteGame.FortHero
// 0x00C0 (0x019C - 0x00DC)
class UFortHero final : public UFortWorker
{
public:
	class FString                                 Hero_Name;                                         // 0x00DC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Primary_Trait_Abilities;                           // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Secondary_Trait_Alpha_Abilities;                   // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Secondary_Trait_Beta_Abilities;                    // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Secondary_Trait_Gamma_Abilities;                   // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Secondary_Trait_Delta_Abilities;                   // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Equipped_Cosmetics;                                // 0x00FC(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortSavedModeLoadout>          Mode_Loadouts;                                     // 0x0108(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSelectedClassAbilityKits              SelectedAbilityKits;                               // 0x0114(0x0064)(NativeAccessSpecifierPublic)
	int64                                         AbilitiesChanged;                                  // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortHeroSpecialization*>        Specializations;                                   // 0x0180(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFortAbilityKit*>                SpecializationAbilityKits;                         // 0x018C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortCharacterCosmeticItem*             CosmeticItem;                                      // 0x0198(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UFortHeroType* GetHeroTypeBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHero">();
	}
	static class UFortHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHero>();
	}
};
static_assert(alignof(UFortHero) == 0x000004, "Wrong alignment on UFortHero");
static_assert(sizeof(UFortHero) == 0x00019C, "Wrong size on UFortHero");
static_assert(offsetof(UFortHero, Hero_Name) == 0x0000DC, "Member 'UFortHero::Hero_Name' has a wrong offset!");
static_assert(offsetof(UFortHero, Primary_Trait_Abilities) == 0x0000E8, "Member 'UFortHero::Primary_Trait_Abilities' has a wrong offset!");
static_assert(offsetof(UFortHero, Secondary_Trait_Alpha_Abilities) == 0x0000EC, "Member 'UFortHero::Secondary_Trait_Alpha_Abilities' has a wrong offset!");
static_assert(offsetof(UFortHero, Secondary_Trait_Beta_Abilities) == 0x0000F0, "Member 'UFortHero::Secondary_Trait_Beta_Abilities' has a wrong offset!");
static_assert(offsetof(UFortHero, Secondary_Trait_Gamma_Abilities) == 0x0000F4, "Member 'UFortHero::Secondary_Trait_Gamma_Abilities' has a wrong offset!");
static_assert(offsetof(UFortHero, Secondary_Trait_Delta_Abilities) == 0x0000F8, "Member 'UFortHero::Secondary_Trait_Delta_Abilities' has a wrong offset!");
static_assert(offsetof(UFortHero, Equipped_Cosmetics) == 0x0000FC, "Member 'UFortHero::Equipped_Cosmetics' has a wrong offset!");
static_assert(offsetof(UFortHero, Mode_Loadouts) == 0x000108, "Member 'UFortHero::Mode_Loadouts' has a wrong offset!");
static_assert(offsetof(UFortHero, SelectedAbilityKits) == 0x000114, "Member 'UFortHero::SelectedAbilityKits' has a wrong offset!");
static_assert(offsetof(UFortHero, AbilitiesChanged) == 0x000178, "Member 'UFortHero::AbilitiesChanged' has a wrong offset!");
static_assert(offsetof(UFortHero, Specializations) == 0x000180, "Member 'UFortHero::Specializations' has a wrong offset!");
static_assert(offsetof(UFortHero, SpecializationAbilityKits) == 0x00018C, "Member 'UFortHero::SpecializationAbilityKits' has a wrong offset!");
static_assert(offsetof(UFortHero, CosmeticItem) == 0x000198, "Member 'UFortHero::CosmeticItem' has a wrong offset!");

// Class FortniteGame.MyTownBuildingDefinitionData
// 0x00F4 (0x0524 - 0x0430)
class UMyTownBuildingDefinitionData final : public UFortAccountItemDefinition
{
public:
	EMyFortBuildingCategory                       BuildingCategory;                                  // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHomebaseBuildingDataTable*         BuildingBonusTable;                                // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BuildingTag;                                       // 0x0438(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     LevelAttribute;                                    // 0x0450(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     RatingAttribute;                                   // 0x0454(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     WorkerSlotsAttribute;                              // 0x0458(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     ManagerSlotsAttribute;                             // 0x045C(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    StaticGameplayEffectsByLevel;                      // 0x0460(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            WorkerGameplayEffect;                              // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortAbilityKit*>                AbilityKitsByLevel;                                // 0x0470(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  ProducedResource;                                  // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMyTownSubBuildingData>         SubBuildingsWithIcons;                             // 0x0480(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BuildingSymbolNormal;                              // 0x048C(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMediaTexture*                          BuildingVideo;                                     // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMyTownBuildingActor>       BuildingActor;                                     // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BuyCue;                                            // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             UpgradeCue;                                        // 0x050C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SelectCue;                                         // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           MultilineDescription;                              // 0x0514(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHideInUI;                                         // 0x0520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetBuildingTemplateId() const;
	TArray<class FText> GetDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownBuildingDefinitionData">();
	}
	static class UMyTownBuildingDefinitionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownBuildingDefinitionData>();
	}
};
static_assert(alignof(UMyTownBuildingDefinitionData) == 0x000004, "Wrong alignment on UMyTownBuildingDefinitionData");
static_assert(sizeof(UMyTownBuildingDefinitionData) == 0x000524, "Wrong size on UMyTownBuildingDefinitionData");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingCategory) == 0x000430, "Member 'UMyTownBuildingDefinitionData::BuildingCategory' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingBonusTable) == 0x000434, "Member 'UMyTownBuildingDefinitionData::BuildingBonusTable' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingTag) == 0x000438, "Member 'UMyTownBuildingDefinitionData::BuildingTag' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, LevelAttribute) == 0x000450, "Member 'UMyTownBuildingDefinitionData::LevelAttribute' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, RatingAttribute) == 0x000454, "Member 'UMyTownBuildingDefinitionData::RatingAttribute' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, WorkerSlotsAttribute) == 0x000458, "Member 'UMyTownBuildingDefinitionData::WorkerSlotsAttribute' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, ManagerSlotsAttribute) == 0x00045C, "Member 'UMyTownBuildingDefinitionData::ManagerSlotsAttribute' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, StaticGameplayEffectsByLevel) == 0x000460, "Member 'UMyTownBuildingDefinitionData::StaticGameplayEffectsByLevel' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, WorkerGameplayEffect) == 0x00046C, "Member 'UMyTownBuildingDefinitionData::WorkerGameplayEffect' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, AbilityKitsByLevel) == 0x000470, "Member 'UMyTownBuildingDefinitionData::AbilityKitsByLevel' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, ProducedResource) == 0x00047C, "Member 'UMyTownBuildingDefinitionData::ProducedResource' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, SubBuildingsWithIcons) == 0x000480, "Member 'UMyTownBuildingDefinitionData::SubBuildingsWithIcons' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingSymbolNormal) == 0x00048C, "Member 'UMyTownBuildingDefinitionData::BuildingSymbolNormal' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingVideo) == 0x000500, "Member 'UMyTownBuildingDefinitionData::BuildingVideo' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuildingActor) == 0x000504, "Member 'UMyTownBuildingDefinitionData::BuildingActor' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, BuyCue) == 0x000508, "Member 'UMyTownBuildingDefinitionData::BuyCue' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, UpgradeCue) == 0x00050C, "Member 'UMyTownBuildingDefinitionData::UpgradeCue' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, SelectCue) == 0x000510, "Member 'UMyTownBuildingDefinitionData::SelectCue' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, MultilineDescription) == 0x000514, "Member 'UMyTownBuildingDefinitionData::MultilineDescription' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingDefinitionData, bHideInUI) == 0x000520, "Member 'UMyTownBuildingDefinitionData::bHideInUI' has a wrong offset!");

// Class FortniteGame.FortCombinedInventoryProxy
// 0x000C (0x0028 - 0x001C)
class UFortCombinedInventoryProxy final : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         WorldInventory;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortInventory*                         SharedInventory;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCombinedInventoryProxy">();
	}
	static class UFortCombinedInventoryProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCombinedInventoryProxy>();
	}
};
static_assert(alignof(UFortCombinedInventoryProxy) == 0x000004, "Wrong alignment on UFortCombinedInventoryProxy");
static_assert(sizeof(UFortCombinedInventoryProxy) == 0x000028, "Wrong size on UFortCombinedInventoryProxy");
static_assert(offsetof(UFortCombinedInventoryProxy, WorldInventory) == 0x000020, "Member 'UFortCombinedInventoryProxy::WorldInventory' has a wrong offset!");
static_assert(offsetof(UFortCombinedInventoryProxy, SharedInventory) == 0x000024, "Member 'UFortCombinedInventoryProxy::SharedInventory' has a wrong offset!");

// Class FortniteGame.MyTownData
// 0x007C (0x0098 - 0x001C)
class UMyTownData final : public UDataAsset
{
public:
	TArray<struct FMyTownBuildingData>            MyTownBuildings;                                   // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMyTownRoadData>                MyTownRoads;                                       // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMyTownBuildingDefinitionData*          CollectBuilding;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMyTownBuildingDefinitionData*          CommandCenterBuilding;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMyTownBuildingDefinitionData*          KeepBuilding;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMyTownBuildingDefinitionData*          ManorBuilding;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMyTownBannerData>              Banners;                                           // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMyTownColorBannerData>         BannerColors;                                      // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             BuildingUpgradesData;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            RatingPerLevelGrowthTable;                         // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMyTownWorkerPersonalityData>   WorkerPersonalities;                               // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMyTownWorkerSetBonusData>      WorkerSetBonuses;                                  // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UFortPersistentResourceItemDefinition*> PersistentResourceDefinitions;                     // 0x007C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  PersonnelXpItemDefinition;                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortPersistentResourceItemDefinition*  SchematicXpItemDefinition;                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortCurrencyItemDefinition*            CurrencyItemDefinition;                            // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            TotalRatingGameplayEffect;                         // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownData">();
	}
	static class UMyTownData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownData>();
	}
};
static_assert(alignof(UMyTownData) == 0x000004, "Wrong alignment on UMyTownData");
static_assert(sizeof(UMyTownData) == 0x000098, "Wrong size on UMyTownData");
static_assert(offsetof(UMyTownData, MyTownBuildings) == 0x00001C, "Member 'UMyTownData::MyTownBuildings' has a wrong offset!");
static_assert(offsetof(UMyTownData, MyTownRoads) == 0x000028, "Member 'UMyTownData::MyTownRoads' has a wrong offset!");
static_assert(offsetof(UMyTownData, CollectBuilding) == 0x000034, "Member 'UMyTownData::CollectBuilding' has a wrong offset!");
static_assert(offsetof(UMyTownData, CommandCenterBuilding) == 0x000038, "Member 'UMyTownData::CommandCenterBuilding' has a wrong offset!");
static_assert(offsetof(UMyTownData, KeepBuilding) == 0x00003C, "Member 'UMyTownData::KeepBuilding' has a wrong offset!");
static_assert(offsetof(UMyTownData, ManorBuilding) == 0x000040, "Member 'UMyTownData::ManorBuilding' has a wrong offset!");
static_assert(offsetof(UMyTownData, Banners) == 0x000044, "Member 'UMyTownData::Banners' has a wrong offset!");
static_assert(offsetof(UMyTownData, BannerColors) == 0x000050, "Member 'UMyTownData::BannerColors' has a wrong offset!");
static_assert(offsetof(UMyTownData, BuildingUpgradesData) == 0x00005C, "Member 'UMyTownData::BuildingUpgradesData' has a wrong offset!");
static_assert(offsetof(UMyTownData, RatingPerLevelGrowthTable) == 0x000060, "Member 'UMyTownData::RatingPerLevelGrowthTable' has a wrong offset!");
static_assert(offsetof(UMyTownData, WorkerPersonalities) == 0x000064, "Member 'UMyTownData::WorkerPersonalities' has a wrong offset!");
static_assert(offsetof(UMyTownData, WorkerSetBonuses) == 0x000070, "Member 'UMyTownData::WorkerSetBonuses' has a wrong offset!");
static_assert(offsetof(UMyTownData, PersistentResourceDefinitions) == 0x00007C, "Member 'UMyTownData::PersistentResourceDefinitions' has a wrong offset!");
static_assert(offsetof(UMyTownData, PersonnelXpItemDefinition) == 0x000088, "Member 'UMyTownData::PersonnelXpItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, SchematicXpItemDefinition) == 0x00008C, "Member 'UMyTownData::SchematicXpItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, CurrencyItemDefinition) == 0x000090, "Member 'UMyTownData::CurrencyItemDefinition' has a wrong offset!");
static_assert(offsetof(UMyTownData, TotalRatingGameplayEffect) == 0x000094, "Member 'UMyTownData::TotalRatingGameplayEffect' has a wrong offset!");

// Class FortniteGame.FortMcpContext
// 0x007C (0x0098 - 0x001C)
class UFortMcpContext final : public UBlueprintContextBase
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHeroesChanged;                                   // 0x0020(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBuildingInfoUpdated;                             // 0x002C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalAccountInfoChanged;                         // 0x0038(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCurrentlyViewedAccountInfoChanged;               // 0x0044(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)> DisplayPurchaseWidget;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             DismissPurchaseWidget;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ApplyAlteration(class UFortAlterableItem* Item, class UFortAlterationItem* AlterationToApply);
	void CancelEpicPurchasingDisplay();
	void ListMtxPackages(const TDelegate<void(const TArray<struct FMtxPackage>& Offers)>& Callback);
	void MarkItemSeen(const class UFortAccountItem* ItemToMarkSeen);
	void PurchaseRealMoneyCatalogEntry(const class FString& OfferId, const TDelegate<void(bool bSuccess)>& Callback);
	void RecycleItem(const class UFortItem* ItemToRecycle);
	void RegisterForEpicPurchasingDisplay(const TDelegate<void(class UWidget* WebWidget, const class FString& OfferId)>& DisplayCallback, const TDelegate<void()>& DismissCallback);
	void UpgradeItem(const class UFortItem* ItemToUpgrade);

	class UFortAccountItem* GetAccountItemWithDefinition(const class UFortAccountItemDefinition* AccountItemDefinition) const;
	void GetAllAlterations(TArray<class UFortAlterationItem*>* OutAlterations, EFortAlteration InAlterationType) const;
	void GetAllHeroes(TArray<class UFortHero*>* Result) const;
	void GetCurrentlyViewedAccountInfo(struct FFortPublicAccountInfo* Result) const;
	class UFortHero* GetDefaultHero() const;
	void GetHomeBaseInfo(struct FFortHomeBaseInfo* Result) const;
	void GetHomeBaseInfoForPlayer(struct FFortHomeBaseInfo* Result, const struct FUniqueNetIdRepl& MemberUniqueId) const;
	void GetLocalAccountInfo(struct FFortPrivateAccountInfo* Result) const;
	int32 GetPersonnelXpBalance() const;
	int32 GetSchematicXpBalance() const;
	bool IsDailyRewardAvailable(float* OutSecondsUntilNextReward, bool* OutRewardAvailable) const;
	bool IsLocalPlayersUniqueID(const struct FUniqueNetIdRepl& PlayerID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpContext">();
	}
	static class UFortMcpContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpContext>();
	}
};
static_assert(alignof(UFortMcpContext) == 0x000004, "Wrong alignment on UFortMcpContext");
static_assert(sizeof(UFortMcpContext) == 0x000098, "Wrong size on UFortMcpContext");
static_assert(offsetof(UFortMcpContext, OnHeroesChanged) == 0x000020, "Member 'UFortMcpContext::OnHeroesChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnBuildingInfoUpdated) == 0x00002C, "Member 'UFortMcpContext::OnBuildingInfoUpdated' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnLocalAccountInfoChanged) == 0x000038, "Member 'UFortMcpContext::OnLocalAccountInfoChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, OnCurrentlyViewedAccountInfoChanged) == 0x000044, "Member 'UFortMcpContext::OnCurrentlyViewedAccountInfoChanged' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, DisplayPurchaseWidget) == 0x000078, "Member 'UFortMcpContext::DisplayPurchaseWidget' has a wrong offset!");
static_assert(offsetof(UFortMcpContext, DismissPurchaseWidget) == 0x000088, "Member 'UFortMcpContext::DismissPurchaseWidget' has a wrong offset!");

// Class FortniteGame.FortOutpostContext
// 0x0030 (0x004C - 0x001C)
class UFortOutpostContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnStructureLevelChanged;                           // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemsNeedRefresh;                                // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGooContentNeedRefresh;                           // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCraftingTableActivationBonusChanged;             // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DepositPOSTResource(const class UFortItemDefinition* ResourceItem, int32 Count);
	void IncreaseOutpostPrestigeLevel();
	void UpgradePOST();
	void UpgradeStructure(class UFortOutpostItemDefinition* StructureToUpgrade);

	bool CanUpgradePOST() const;
	bool CanUpgradeStructure(class UFortOutpostItemDefinition* OutpostStructure, bool bLog) const;
	class UFortWorldItemDefinition* GetHarvestingToolForLevel(int32 InHarvestingOptimizerLevel) const;
	TArray<class UOutpostPOSTRequirementData*> GetNextPOSTLevelRequirements() const;
	int32 GetOutpostPrestigeLevel() const;
	class AOutpostStructureBase* GetOutpostStructure(class UFortOutpostItemDefinition* OutpostStructure) const;
	float GetPOSTBuildingHealthMod(int32 POSTLevel) const;
	int32 GetStormShieldLevelDefended() const;
	int32 GetStructureLevel(class UFortOutpostItemDefinition* OutpostStructure) const;
	int32 GetStructureMaxLevel(class UFortOutpostItemDefinition* OutpostStructure) const;
	void GetUpgradeStructureCost(class UFortOutpostItemDefinition* OutpostStructure, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	bool IsPrestigeAllowed() const;
	void LeaveOutpostAsParty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostContext">();
	}
	static class UFortOutpostContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostContext>();
	}
};
static_assert(alignof(UFortOutpostContext) == 0x000004, "Wrong alignment on UFortOutpostContext");
static_assert(sizeof(UFortOutpostContext) == 0x00004C, "Wrong size on UFortOutpostContext");
static_assert(offsetof(UFortOutpostContext, OnStructureLevelChanged) == 0x00001C, "Member 'UFortOutpostContext::OnStructureLevelChanged' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnItemsNeedRefresh) == 0x000028, "Member 'UFortOutpostContext::OnItemsNeedRefresh' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnGooContentNeedRefresh) == 0x000034, "Member 'UFortOutpostContext::OnGooContentNeedRefresh' has a wrong offset!");
static_assert(offsetof(UFortOutpostContext, OnCraftingTableActivationBonusChanged) == 0x000040, "Member 'UFortOutpostContext::OnCraftingTableActivationBonusChanged' has a wrong offset!");

// Class FortniteGame.FortPartyGameState
// 0x0170 (0x03A0 - 0x0230)
class UFortPartyGameState final : public UPartyGameState
{
public:
	struct FFortPartyRepState                     PartyState;                                        // 0x0230(0x003C)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x134];                                    // 0x026C(0x0134)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyGameState">();
	}
	static class UFortPartyGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyGameState>();
	}
};
static_assert(alignof(UFortPartyGameState) == 0x000004, "Wrong alignment on UFortPartyGameState");
static_assert(sizeof(UFortPartyGameState) == 0x0003A0, "Wrong size on UFortPartyGameState");
static_assert(offsetof(UFortPartyGameState, PartyState) == 0x000230, "Member 'UFortPartyGameState::PartyState' has a wrong offset!");

// Class FortniteGame.FortUITeamInfo
// 0x00B4 (0x00D0 - 0x001C)
class UFortUITeamInfo final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnTeamMemberAdded;                                 // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberRemoved;                               // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberStateChanged;                          // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamMemberPromoted;                              // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x78];                                      // 0x004C(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPartyContext*                      TeamContext;                                       // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortTeam                                     TeamAssignment;                                    // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  FortTeamUEnum;                                     // 0x00CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetTeamHitPointFractions(TArray<float>* HealthFractions, TArray<float>* ShieldFractions);
	void GetTeamMemberIDs(TArray<struct FUniqueNetIdRepl>* TeamMemberIDs);
	void GetTeamMembers(TArray<struct FFortTeamMemberInfo>* TeamMembers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUITeamInfo">();
	}
	static class UFortUITeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUITeamInfo>();
	}
};
static_assert(alignof(UFortUITeamInfo) == 0x000004, "Wrong alignment on UFortUITeamInfo");
static_assert(sizeof(UFortUITeamInfo) == 0x0000D0, "Wrong size on UFortUITeamInfo");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberAdded) == 0x00001C, "Member 'UFortUITeamInfo::OnTeamMemberAdded' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberRemoved) == 0x000028, "Member 'UFortUITeamInfo::OnTeamMemberRemoved' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberStateChanged) == 0x000034, "Member 'UFortUITeamInfo::OnTeamMemberStateChanged' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, OnTeamMemberPromoted) == 0x000040, "Member 'UFortUITeamInfo::OnTeamMemberPromoted' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, TeamContext) == 0x0000C4, "Member 'UFortUITeamInfo::TeamContext' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, TeamAssignment) == 0x0000C8, "Member 'UFortUITeamInfo::TeamAssignment' has a wrong offset!");
static_assert(offsetof(UFortUITeamInfo, FortTeamUEnum) == 0x0000CC, "Member 'UFortUITeamInfo::FortTeamUEnum' has a wrong offset!");

// Class FortniteGame.FortPartyContext
// 0x024C (0x0268 - 0x001C)
class UFortPartyContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnPartyTransitionStarted;                          // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyTransitionCompleted;                        // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyJoined;                                     // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyLeft;                                       // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClientPartyStateChanged;                         // 0x004C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyTypeChanged;                                // 0x0058(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderFriendsOnlyChanged;                        // 0x0064(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeaderInvitesOnlyChanged;                        // 0x0070(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLocalPlayerStateChanged;                         // 0x007C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayerStateChanged;                              // 0x0088(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyDataChanged;                                // 0x0094(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActiveFriendsCountUpdated;                       // 0x00A0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActiveFriendsUpdated;                            // 0x00AC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyInvitesCountChanged;                        // 0x00B8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartyInvitesUpdated;                             // 0x00C4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   RejectInviteComplete;                              // 0x00D0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSocialListChanged;                               // 0x00DC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSentPartyInvite;                                 // 0x00E8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUnhandledErrorMessage;                           // 0x00F4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHandledErrorMessage;                             // 0x0100(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x14C];                                    // 0x010C(0x014C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortUITeamInfo*                        LocalPlayerTeam;                                   // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0xC];                                      // 0x025C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsValidNetID(const struct FUniqueNetIdRepl& UniqueNetID);

	void AcceptFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void CancelFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void ClearPendingInvites();
	void GetActiveFriendsList(TArray<class UFortSocialItem*>* OutActiveFriends);
	void GetPartyInvites(TArray<class UFortSocialItem*>* OutPartyInvites);
	bool GetPartyPrivacySetting(EPartyType* OutPartyType, bool* OutLeaderFriendsOnly, bool* OutLeaderInvitesOnly);
	void GetSocialItemList(TArray<class UFortSocialItem*>* OutSocialItems);
	class UFortUITeamInfo* GetTeamInfo(EFortTeam Team);
	void HandlePendingInvites();
	void JoinParty(class UFortSocialItem* PartyItem);
	void KickPartyMember(const struct FUniqueNetIdRepl& PartyMemberId);
	void LeaveParty();
	void PromotePartyMemberToLeader(const struct FUniqueNetIdRepl& PartyMemberId);
	void RejectFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void RejectPartyInvite(class UFortSocialItem* PartyInvite);
	void SendFriendRequest(const struct FUniqueNetIdRepl& PlayerID);
	void SendPartyInvite(class UFortSocialItem* SocialItem);
	void SetChatWhisperTarget(const struct FUniqueNetIdRepl& FriendID);
	void SetPartyPrivacySetting(EPartyType PartyType, bool bLeaderFriendsOnly, bool bLeaderInvitesOnly);

	bool CanBeInvited(class UFortSocialItem* SocialItem, EFortPartyRestriction* FailReason) const;
	bool CanBeJoined(class UFortSocialItem* SocialItem, EFortPartyRestriction* FailReason) const;
	EFortFriendRequestStatus GetFriendRequestStatusForPlayer(const struct FUniqueNetIdRepl& PlayerID) const;
	void GetLocalPartyMemberIDs(TArray<struct FUniqueNetIdRepl>* PartyMemberIDs, bool bIncludeLocalPlayerID) const;
	EFortPartyState GetLocalPartyProgression() const;
	class FString GetLocalPlayerDisplayName() const;
	class UFortUITeamInfo* GetLocalPlayerTeam() const;
	void GetLocalPlayerTeamMemberInfo(struct FFortTeamMemberInfo* LocalPlayerInfo) const;
	int32 GetMaxTeamSizeForSelectedTheater() const;
	int32 GetNumPlayersInLocalParty() const;
	bool HasPendingFriendRequest() const;
	bool IsActiveFriend(const struct FUniqueNetIdRepl& PlayerID) const;
	bool IsActiveFriendsListRetrieved() const;
	bool IsEntirePartyInFrontEnd() const;
	bool IsInLocalPlayersParty(const struct FUniqueNetIdRepl& PlayerID) const;
	bool IsLocalPlayerInParty(class UFortSocialItem* SocialItem) const;
	bool IsLocalPlayerPartyLeader() const;
	bool ShouldShowHeroPortraits() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyContext">();
	}
	static class UFortPartyContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyContext>();
	}
};
static_assert(alignof(UFortPartyContext) == 0x000004, "Wrong alignment on UFortPartyContext");
static_assert(sizeof(UFortPartyContext) == 0x000268, "Wrong size on UFortPartyContext");
static_assert(offsetof(UFortPartyContext, OnPartyTransitionStarted) == 0x00001C, "Member 'UFortPartyContext::OnPartyTransitionStarted' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyTransitionCompleted) == 0x000028, "Member 'UFortPartyContext::OnPartyTransitionCompleted' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyJoined) == 0x000034, "Member 'UFortPartyContext::OnPartyJoined' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyLeft) == 0x000040, "Member 'UFortPartyContext::OnPartyLeft' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnClientPartyStateChanged) == 0x00004C, "Member 'UFortPartyContext::OnClientPartyStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyTypeChanged) == 0x000058, "Member 'UFortPartyContext::OnPartyTypeChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLeaderFriendsOnlyChanged) == 0x000064, "Member 'UFortPartyContext::OnLeaderFriendsOnlyChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLeaderInvitesOnlyChanged) == 0x000070, "Member 'UFortPartyContext::OnLeaderInvitesOnlyChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnLocalPlayerStateChanged) == 0x00007C, "Member 'UFortPartyContext::OnLocalPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPlayerStateChanged) == 0x000088, "Member 'UFortPartyContext::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyDataChanged) == 0x000094, "Member 'UFortPartyContext::OnPartyDataChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnActiveFriendsCountUpdated) == 0x0000A0, "Member 'UFortPartyContext::OnActiveFriendsCountUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnActiveFriendsUpdated) == 0x0000AC, "Member 'UFortPartyContext::OnActiveFriendsUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyInvitesCountChanged) == 0x0000B8, "Member 'UFortPartyContext::OnPartyInvitesCountChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnPartyInvitesUpdated) == 0x0000C4, "Member 'UFortPartyContext::OnPartyInvitesUpdated' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, RejectInviteComplete) == 0x0000D0, "Member 'UFortPartyContext::RejectInviteComplete' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnSocialListChanged) == 0x0000DC, "Member 'UFortPartyContext::OnSocialListChanged' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnSentPartyInvite) == 0x0000E8, "Member 'UFortPartyContext::OnSentPartyInvite' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnUnhandledErrorMessage) == 0x0000F4, "Member 'UFortPartyContext::OnUnhandledErrorMessage' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, OnHandledErrorMessage) == 0x000100, "Member 'UFortPartyContext::OnHandledErrorMessage' has a wrong offset!");
static_assert(offsetof(UFortPartyContext, LocalPlayerTeam) == 0x000258, "Member 'UFortPartyContext::LocalPlayerTeam' has a wrong offset!");

// Class FortniteGame.FortTutorialContext
// 0x0030 (0x004C - 0x001C)
class UFortTutorialContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnShowTutorialScreen;                              // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHideTutorialScreen;                              // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowBannerSelectionScreen;                       // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShowTutorialNotification;                        // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ClearTutorialHighlights();
	void DisableTutorialHighlight(class FName WidgetName);
	void DisableTutorialHighlightForBang(EFortBangType BangType);
	void EnableTutorialHighlight(class FName WidgetName);
	void EnableTutorialHighlightForBang(EFortBangType BangType);
	void HideTutorialWidget(class FName WidgetName);
	void HideTutorialWidgetForBang(EFortBangType BangType);
	void SetTutorialNotificationActive(bool bActive);
	void SkipTutorial();
	void UnhideAllTutorialWidgets();
	void UnhideTutorialWidget(class FName WidgetName);
	void UnhideTutorialWidgetForBang(EFortBangType BangType);

	bool ShouldPromptToSkipTutorial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTutorialContext">();
	}
	static class UFortTutorialContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTutorialContext>();
	}
};
static_assert(alignof(UFortTutorialContext) == 0x000004, "Wrong alignment on UFortTutorialContext");
static_assert(sizeof(UFortTutorialContext) == 0x00004C, "Wrong size on UFortTutorialContext");
static_assert(offsetof(UFortTutorialContext, OnShowTutorialScreen) == 0x00001C, "Member 'UFortTutorialContext::OnShowTutorialScreen' has a wrong offset!");
static_assert(offsetof(UFortTutorialContext, OnHideTutorialScreen) == 0x000028, "Member 'UFortTutorialContext::OnHideTutorialScreen' has a wrong offset!");
static_assert(offsetof(UFortTutorialContext, OnShowBannerSelectionScreen) == 0x000034, "Member 'UFortTutorialContext::OnShowBannerSelectionScreen' has a wrong offset!");
static_assert(offsetof(UFortTutorialContext, OnShowTutorialNotification) == 0x000040, "Member 'UFortTutorialContext::OnShowTutorialNotification' has a wrong offset!");

// Class FortniteGame.FortMcpProfile
// 0x000C (0x0130 - 0x0124)
class UFortMcpProfile : public UMcpProfile
{
public:
	uint8                                         Pad_124[0xC];                                      // 0x0124(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfile">();
	}
	static class UFortMcpProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfile>();
	}
};
static_assert(alignof(UFortMcpProfile) == 0x000004, "Wrong alignment on UFortMcpProfile");
static_assert(sizeof(UFortMcpProfile) == 0x000130, "Wrong size on UFortMcpProfile");

// Class FortniteGame.FortQuestObjectiveInfo
// 0x0020 (0x003C - 0x001C)
class UFortQuestObjectiveInfo final : public UObject
{
public:
	class FName                                   ObjectiveStatName;                                 // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EFortQuestObjectiveType                       Type;                                              // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AchievedCount;                                     // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCount;                                     // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetObjectiveStatRow(struct FFortQuestObjectiveStatTableRow* OutRow) const;
	class UFortQuestItem* GetOwningQuest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestObjectiveInfo">();
	}
	static class UFortQuestObjectiveInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestObjectiveInfo>();
	}
};
static_assert(alignof(UFortQuestObjectiveInfo) == 0x000004, "Wrong alignment on UFortQuestObjectiveInfo");
static_assert(sizeof(UFortQuestObjectiveInfo) == 0x00003C, "Wrong size on UFortQuestObjectiveInfo");
static_assert(offsetof(UFortQuestObjectiveInfo, ObjectiveStatName) == 0x00001C, "Member 'UFortQuestObjectiveInfo::ObjectiveStatName' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, Description) == 0x000024, "Member 'UFortQuestObjectiveInfo::Description' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, Type) == 0x000030, "Member 'UFortQuestObjectiveInfo::Type' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, AchievedCount) == 0x000034, "Member 'UFortQuestObjectiveInfo::AchievedCount' has a wrong offset!");
static_assert(offsetof(UFortQuestObjectiveInfo, RequiredCount) == 0x000038, "Member 'UFortQuestObjectiveInfo::RequiredCount' has a wrong offset!");

// Class FortniteGame.FortQuestItem
// 0x0064 (0x00E4 - 0x0080)
class UFortQuestItem final : public UFortAccountItem
{
public:
	EFortQuestState                               State;                                             // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSentNewNotification;                              // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      CompletionCounts;                                  // 0x0084(0x003C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UFortQuestObjectiveInfo*>        Objectives;                                        // 0x00C0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FDateTime                              LastStateChangeTime;                               // 0x00CC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllObjectivesComplete;                            // 0x00D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSentCompleteNotification;                         // 0x00D5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortMissionInstancedConfigData        InstancedConfigData;                               // 0x00D8(0x000C)(Transient, NativeAccessSpecifierPrivate)

public:
	class UFortMissionConfigData* GetMissionConfigData(const struct FGameplayTag& InBucketTag);

	void GetAchievedCount(int32* OutTotalAchievedCount, int32* OutTotalRequiredCount) const;
	class UFortQuestObjectiveInfo* GetObjectiveInfo(const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	float GetPercentageComplete() const;
	TArray<struct FFortQuestReward> GetPreviewRewards() const;
	class UFortQuestItemDefinition* GetQuestDefinitionBP() const;
	bool HasCompletedObjective(const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool HasCompletedQuest() const;
	bool IsVisibleToUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestItem">();
	}
	static class UFortQuestItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestItem>();
	}
};
static_assert(alignof(UFortQuestItem) == 0x000004, "Wrong alignment on UFortQuestItem");
static_assert(sizeof(UFortQuestItem) == 0x0000E4, "Wrong size on UFortQuestItem");
static_assert(offsetof(UFortQuestItem, State) == 0x000080, "Member 'UFortQuestItem::State' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, bSentNewNotification) == 0x000081, "Member 'UFortQuestItem::bSentNewNotification' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, CompletionCounts) == 0x000084, "Member 'UFortQuestItem::CompletionCounts' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, Objectives) == 0x0000C0, "Member 'UFortQuestItem::Objectives' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, LastStateChangeTime) == 0x0000CC, "Member 'UFortQuestItem::LastStateChangeTime' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, bAllObjectivesComplete) == 0x0000D4, "Member 'UFortQuestItem::bAllObjectivesComplete' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, bSentCompleteNotification) == 0x0000D5, "Member 'UFortQuestItem::bSentCompleteNotification' has a wrong offset!");
static_assert(offsetof(UFortQuestItem, InstancedConfigData) == 0x0000D8, "Member 'UFortQuestItem::InstancedConfigData' has a wrong offset!");

// Class FortniteGame.FortMcpProfileAccount
// 0x0044 (0x0174 - 0x0130)
class UFortMcpProfileAccount final : public UFortMcpProfile
{
public:
	class FString                                 ListCatalogEntriesUrl;                             // 0x0130(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GetHomebaseViewUrl;                                // 0x013C(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GetOutpostViewUrl;                                 // 0x0148(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x20];                                     // 0x0154(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAlteration(const class FString& TargetItemId, const class FString& AlterationItemId, struct FClientUrlContext* Context);
	void AssignWorkerToBuilding(const class FString& WorkerId, const class FString& BuildingId, int32 SlotIndex, struct FClientUrlContext* Context);
	void AssignWorkerToBuildingBatch(const TArray<class FString>& WorkerIds, const TArray<class FString>& BuildingIds, const TArray<int32>& SlotIndices, struct FClientUrlContext* Context);
	void ClaimLoginReward(struct FClientUrlContext* Context);
	void ClaimQuestReward(const class FString& QuestId, struct FClientUrlContext* Context);
	void ConsumeItems(const TArray<class FString>& ItemsToConsumeIds, const TArray<int32>& ItemCountsToConsume, const class FString& ConsumeReason, struct FDedicatedServerUrlContext* Context);
	void CreateBuilding(const class FString& TemplateId, struct FClientUrlContext* Context);
	void CreateHero(const class FString& HeroName, int32 Gender, const class FString& HeroTemplateId, struct FClientUrlContext* Context);
	void DeleteHero(const class FString& HeroId, struct FClientUrlContext* Context);
	void EarnScore(int32 TotalScore, const class FString& MatchmakingSessionId, const class FString& HeroId, bool bCriticalMatchBonus, struct FDedicatedServerUrlContext* Context);
	void EndPrimaryMission(const class FString& MatchmakingSessionId, const class FString& MissionName, const class FString& MissionStatus, int32 NumMissionPoints, bool bCriticalMatchBonus, struct FDedicatedServerUrlContext* Context);
	void EquipCharCosmetic(const class FString& CharacterId, const class FString& CosmeticId, int32 TypeId, struct FClientUrlContext* Context);
	void FortRerollDailyQuest(const class FString& QuestId, struct FClientUrlContext* Context);
	void MarkItemSeen(const TArray<class FString>& ItemIds, struct FClientUrlContext* Context);
	void MarkNewQuestNotificationSent(const TArray<class FString>& ItemIds, struct FClientUrlContext* Context);
	void OpenCardPack(const class FString& CardPackItemId, int32 SelectionIdx, struct FClientUrlContext* Context);
	void QuestLogin(struct FClientUrlContext* Context);
	void RecycleItem(const class FString& TargetItemId, struct FClientUrlContext* Context);
	void RenameHero(const class FString& HeroId, const class FString& NewHeroName, struct FClientUrlContext* Context);
	void SetDefaultHero(const class FString& DefaultHeroId, struct FClientUrlContext* Context);
	void SetGameplayStats(const TArray<struct FFortPersistentGameplayStatValue>& GameplayStats, struct FClientUrlContext* Context);
	void SetHeroAbilities(const class FString& HeroId, int32 PrimaryTraitAbilities, int32 SecondaryTraitAbilities_Alpha, int32 SecondaryTraitAbilities_Beta, int32 SecondaryTraitAbilities_Gamma, int32 SecondaryTraitAbilities_Delta, struct FClientUrlContext* Context);
	void SetHeroModeLoadout(const class FString& HeroId, const struct FFortSavedModeLoadout& ModeLoadout, struct FClientUrlContext* Context);
	void SetHomebaseMeta(const class FString& TownName, int32 FlagPattern, float FlagColor, struct FClientUrlContext* Context);
	void SetModeLoadout(const struct FFortSavedModeLoadout& ModeLoadout, const class FString& HeroId, const struct FFortSavedModeLoadout& HeroModeLoadout, struct FClientUrlContext* Context);
	void SkipTutorial(struct FClientUrlContext* Context);
	void UnloadWarehouse(const TArray<class FString>& ResourceTypes, struct FClientUrlContext* Context);
	void UnslotAllWorkers(const TArray<class FString>& BuildingIds, struct FClientUrlContext* Context);
	void UpdateBuildingLevelAndRating(const class FString& BuildingId, int32 LastBuildingLevel, int32 LastBuildingRating, struct FClientUrlContext* Context);
	void UpdateQuestClientObjectives(const TArray<struct FFortQuestObjectiveCompletion>& Advance, struct FClientUrlContext* Context);
	void UpdateQuests(const TArray<struct FFortQuestObjectiveCompletion>& Advance, struct FDedicatedServerUrlContext* Context);
	void UpgradeBuilding(const class FString& BuildingId, struct FClientUrlContext* Context);
	void UpgradeItem(const class FString& TargetItemId, struct FClientUrlContext* Context);
	void UpgradeWorker(const class FString& TargetWorkerId, struct FClientUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileAccount">();
	}
	static class UFortMcpProfileAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileAccount>();
	}
};
static_assert(alignof(UFortMcpProfileAccount) == 0x000004, "Wrong alignment on UFortMcpProfileAccount");
static_assert(sizeof(UFortMcpProfileAccount) == 0x000174, "Wrong size on UFortMcpProfileAccount");
static_assert(offsetof(UFortMcpProfileAccount, ListCatalogEntriesUrl) == 0x000130, "Member 'UFortMcpProfileAccount::ListCatalogEntriesUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileAccount, GetHomebaseViewUrl) == 0x00013C, "Member 'UFortMcpProfileAccount::GetHomebaseViewUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileAccount, GetOutpostViewUrl) == 0x000148, "Member 'UFortMcpProfileAccount::GetOutpostViewUrl' has a wrong offset!");

// Class FortniteGame.MyTownBuildingItem
// 0x0034 (0x00B4 - 0x0080)
class UMyTownBuildingItem final : public UFortAccountItem
{
public:
	int32                                         LastMaxLevel;                                      // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastMaxRating;                                     // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ManagerInstanceId;                                 // 0x0088(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         WorkerInstanceIds;                                 // 0x0094(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bBuildingWasClicked;                               // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateLastMaxValues;                        // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasAvailableUpgrades;                             // 0x00A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EMyTownBuildingState                          BuildingState;                                     // 0x00A3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapSlotId;                                         // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentBuildingTemplateId;                          // 0x00A8(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownBuildingItem">();
	}
	static class UMyTownBuildingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownBuildingItem>();
	}
};
static_assert(alignof(UMyTownBuildingItem) == 0x000004, "Wrong alignment on UMyTownBuildingItem");
static_assert(sizeof(UMyTownBuildingItem) == 0x0000B4, "Wrong size on UMyTownBuildingItem");
static_assert(offsetof(UMyTownBuildingItem, LastMaxLevel) == 0x000080, "Member 'UMyTownBuildingItem::LastMaxLevel' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, LastMaxRating) == 0x000084, "Member 'UMyTownBuildingItem::LastMaxRating' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, ManagerInstanceId) == 0x000088, "Member 'UMyTownBuildingItem::ManagerInstanceId' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, WorkerInstanceIds) == 0x000094, "Member 'UMyTownBuildingItem::WorkerInstanceIds' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, bBuildingWasClicked) == 0x0000A0, "Member 'UMyTownBuildingItem::bBuildingWasClicked' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, bShouldUpdateLastMaxValues) == 0x0000A1, "Member 'UMyTownBuildingItem::bShouldUpdateLastMaxValues' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, bHasAvailableUpgrades) == 0x0000A2, "Member 'UMyTownBuildingItem::bHasAvailableUpgrades' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, BuildingState) == 0x0000A3, "Member 'UMyTownBuildingItem::BuildingState' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, MapSlotId) == 0x0000A4, "Member 'UMyTownBuildingItem::MapSlotId' has a wrong offset!");
static_assert(offsetof(UMyTownBuildingItem, ParentBuildingTemplateId) == 0x0000A8, "Member 'UMyTownBuildingItem::ParentBuildingTemplateId' has a wrong offset!");

// Class FortniteGame.FortTheaterInfo
// 0x0168 (0x0184 - 0x001C)
class UFortTheaterInfo final : public UDataAsset
{
public:
	class FString                                 UniqueId;                                          // 0x001C(0x000C)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortTheaterMapData                    TheaterData;                                       // 0x0028(0x00D0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortTheaterMapMissionData             Missions;                                          // 0x00F8(0x0024)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bForceIncludeInCookIfReferenced;                   // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortZoneTheme>             SelectedZoneTheme;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortRegionInfo*                        SelectedZoneRegion;                                // 0x0124(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTheaterMapTileType                       SelectedTileType;                                  // 0x0128(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortRequirementsInfo                  SelectedTileRequirements;                          // 0x012C(0x0020)(Edit, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterMissionWeight>      SelectedMissionWeightOverrides;                    // 0x014C(0x000C)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterDifficultyWeight>   SelectedDifficultyWeightOverrides;                 // 0x0158(0x000C)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortEditorTheaterMapRegionColor> RegionColors;                                      // 0x0164(0x000C)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterTileEditorData>     EditorTiles;                                       // 0x0170(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         TheaterWidth;                                      // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TheaterHeight;                                     // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterInfo">();
	}
	static class UFortTheaterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTheaterInfo>();
	}
};
static_assert(alignof(UFortTheaterInfo) == 0x000004, "Wrong alignment on UFortTheaterInfo");
static_assert(sizeof(UFortTheaterInfo) == 0x000184, "Wrong size on UFortTheaterInfo");
static_assert(offsetof(UFortTheaterInfo, UniqueId) == 0x00001C, "Member 'UFortTheaterInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterData) == 0x000028, "Member 'UFortTheaterInfo::TheaterData' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, Missions) == 0x0000F8, "Member 'UFortTheaterInfo::Missions' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, bForceIncludeInCookIfReferenced) == 0x00011C, "Member 'UFortTheaterInfo::bForceIncludeInCookIfReferenced' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedZoneTheme) == 0x000120, "Member 'UFortTheaterInfo::SelectedZoneTheme' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedZoneRegion) == 0x000124, "Member 'UFortTheaterInfo::SelectedZoneRegion' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedTileType) == 0x000128, "Member 'UFortTheaterInfo::SelectedTileType' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedTileRequirements) == 0x00012C, "Member 'UFortTheaterInfo::SelectedTileRequirements' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedMissionWeightOverrides) == 0x00014C, "Member 'UFortTheaterInfo::SelectedMissionWeightOverrides' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, SelectedDifficultyWeightOverrides) == 0x000158, "Member 'UFortTheaterInfo::SelectedDifficultyWeightOverrides' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, RegionColors) == 0x000164, "Member 'UFortTheaterInfo::RegionColors' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, EditorTiles) == 0x000170, "Member 'UFortTheaterInfo::EditorTiles' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterWidth) == 0x00017C, "Member 'UFortTheaterInfo::TheaterWidth' has a wrong offset!");
static_assert(offsetof(UFortTheaterInfo, TheaterHeight) == 0x000180, "Member 'UFortTheaterInfo::TheaterHeight' has a wrong offset!");

// Class FortniteGame.FortMissionPowerPointsInterface
// 0x0000 (0x001C - 0x001C)
class IFortMissionPowerPointsInterface final : public IInterface
{
public:
	float GetAvailabilityWeight(float DifficultyLevel) const;
	float GetInitialRangeLerpValue(float PointsAvailable) const;
	float GetMaxRangeLerpValue(float PointsAvailable, float PreviousLerpValue) const;
	float GetPowerPointsCost(float LerpValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionPowerPointsInterface">();
	}
	static class IFortMissionPowerPointsInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionPowerPointsInterface>();
	}
};
static_assert(alignof(IFortMissionPowerPointsInterface) == 0x000004, "Wrong alignment on IFortMissionPowerPointsInterface");
static_assert(sizeof(IFortMissionPowerPointsInterface) == 0x00001C, "Wrong size on IFortMissionPowerPointsInterface");

// Class FortniteGame.FortStartMissionParams
// 0x0000 (0x001C - 0x001C)
class UFortStartMissionParams final : public UFortMissionEventParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStartMissionParams">();
	}
	static class UFortStartMissionParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStartMissionParams>();
	}
};
static_assert(alignof(UFortStartMissionParams) == 0x000004, "Wrong alignment on UFortStartMissionParams");
static_assert(sizeof(UFortStartMissionParams) == 0x00001C, "Wrong size on UFortStartMissionParams");

// Class FortniteGame.FortItemDroppedParams
// 0x000C (0x0028 - 0x001C)
class UFortItemDroppedParams final : public UFortMissionEventParams
{
public:
	class UFortWorldItemDefinition*               DroppedItemDefinition;                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  DroppedBy;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountDropped;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class UFortWorldItemDefinition** _DroppedItemDefinition, class AFortPlayerController** _DroppedBy, int32* _AmountCollected);
	void MakeData(const class UFortWorldItemDefinition* _DroppedItemDefinition, class AFortPlayerController* _DroppedBy, int32 _AmountCollected, class UFortItemDroppedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDroppedParams">();
	}
	static class UFortItemDroppedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDroppedParams>();
	}
};
static_assert(alignof(UFortItemDroppedParams) == 0x000004, "Wrong alignment on UFortItemDroppedParams");
static_assert(sizeof(UFortItemDroppedParams) == 0x000028, "Wrong size on UFortItemDroppedParams");
static_assert(offsetof(UFortItemDroppedParams, DroppedItemDefinition) == 0x00001C, "Member 'UFortItemDroppedParams::DroppedItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemDroppedParams, DroppedBy) == 0x000020, "Member 'UFortItemDroppedParams::DroppedBy' has a wrong offset!");
static_assert(offsetof(UFortItemDroppedParams, AmountDropped) == 0x000024, "Member 'UFortItemDroppedParams::AmountDropped' has a wrong offset!");

// Class FortniteGame.FortItemCraftedParams
// 0x000C (0x0028 - 0x001C)
class UFortItemCraftedParams final : public UFortMissionEventParams
{
public:
	class UFortSchematicItemDefinition*           SchematicDefinition;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  CraftedBy;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountCrafted;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class UFortSchematicItemDefinition** _SchematicDefinition, class AFortPlayerController** _CraftedBy, int32* _AmountCrafted);
	void MakeData(const class UFortSchematicItemDefinition* _SchematicDefinition, class AFortPlayerController* _CraftedBy, int32 _AmountCrafted, class UFortItemCraftedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCraftedParams">();
	}
	static class UFortItemCraftedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCraftedParams>();
	}
};
static_assert(alignof(UFortItemCraftedParams) == 0x000004, "Wrong alignment on UFortItemCraftedParams");
static_assert(sizeof(UFortItemCraftedParams) == 0x000028, "Wrong size on UFortItemCraftedParams");
static_assert(offsetof(UFortItemCraftedParams, SchematicDefinition) == 0x00001C, "Member 'UFortItemCraftedParams::SchematicDefinition' has a wrong offset!");
static_assert(offsetof(UFortItemCraftedParams, CraftedBy) == 0x000020, "Member 'UFortItemCraftedParams::CraftedBy' has a wrong offset!");
static_assert(offsetof(UFortItemCraftedParams, AmountCrafted) == 0x000024, "Member 'UFortItemCraftedParams::AmountCrafted' has a wrong offset!");

// Class FortniteGame.FortEnemyKilledParams
// 0x0008 (0x0024 - 0x001C)
class UFortEnemyKilledParams final : public UFortMissionEventParams
{
public:
	class AFortPawn*                              KilledPawn;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  KilledBy;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortPawn** _KilledPawn, class AFortPlayerController** _KilledBy);
	void MakeData(class AFortPawn* _KilledPawn, class AFortPlayerController* _KilledBy, class UFortEnemyKilledParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemyKilledParams">();
	}
	static class UFortEnemyKilledParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnemyKilledParams>();
	}
};
static_assert(alignof(UFortEnemyKilledParams) == 0x000004, "Wrong alignment on UFortEnemyKilledParams");
static_assert(sizeof(UFortEnemyKilledParams) == 0x000024, "Wrong size on UFortEnemyKilledParams");
static_assert(offsetof(UFortEnemyKilledParams, KilledPawn) == 0x00001C, "Member 'UFortEnemyKilledParams::KilledPawn' has a wrong offset!");
static_assert(offsetof(UFortEnemyKilledParams, KilledBy) == 0x000020, "Member 'UFortEnemyKilledParams::KilledBy' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter
// 0x0000 (0x0020 - 0x0020)
class UFortDifficultyOptionCategoryEncounter : public UFortDifficultyOptionCategory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter">();
	}
	static class UFortDifficultyOptionCategoryEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter) == 0x000020, "Wrong size on UFortDifficultyOptionCategoryEncounter");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_IntensityCurveSequence
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_IntensityCurveSequence>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_IntensityCurveSequence">();
	}
	static class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence::Options' has a wrong offset!");

// Class FortniteGame.FortEnemyDamagedParams
// 0x000C (0x0028 - 0x001C)
class UFortEnemyDamagedParams final : public UFortMissionEventParams
{
public:
	class AFortPawn*                              DamagedPawn;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  DamagedBy;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortPawn** _DamagedPawn, class AFortPlayerController** _DamagedBy, float* _DamageAmount);
	void MakeData(class AFortPawn* _DamagedPawn, class AFortPlayerController* _DamagedBy, float _DamageAmount, class UFortEnemyDamagedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemyDamagedParams">();
	}
	static class UFortEnemyDamagedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEnemyDamagedParams>();
	}
};
static_assert(alignof(UFortEnemyDamagedParams) == 0x000004, "Wrong alignment on UFortEnemyDamagedParams");
static_assert(sizeof(UFortEnemyDamagedParams) == 0x000028, "Wrong size on UFortEnemyDamagedParams");
static_assert(offsetof(UFortEnemyDamagedParams, DamagedPawn) == 0x00001C, "Member 'UFortEnemyDamagedParams::DamagedPawn' has a wrong offset!");
static_assert(offsetof(UFortEnemyDamagedParams, DamagedBy) == 0x000020, "Member 'UFortEnemyDamagedParams::DamagedBy' has a wrong offset!");
static_assert(offsetof(UFortEnemyDamagedParams, DamageAmount) == 0x000024, "Member 'UFortEnemyDamagedParams::DamageAmount' has a wrong offset!");

// Class FortniteGame.FortNewPlayerParams
// 0x0004 (0x0020 - 0x001C)
class UFortNewPlayerParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  NewPlayerController;                               // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortPlayerController** _NewPlayerController);
	void MakeData(class AFortPlayerController* _NewPlayerController, class UFortNewPlayerParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNewPlayerParams">();
	}
	static class UFortNewPlayerParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNewPlayerParams>();
	}
};
static_assert(alignof(UFortNewPlayerParams) == 0x000004, "Wrong alignment on UFortNewPlayerParams");
static_assert(sizeof(UFortNewPlayerParams) == 0x000020, "Wrong size on UFortNewPlayerParams");
static_assert(offsetof(UFortNewPlayerParams, NewPlayerController) == 0x00001C, "Member 'UFortNewPlayerParams::NewPlayerController' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionMission
// 0x0000 (0x002C - 0x002C)
class UFortDifficultyOptionMission final : public UFortDifficultyOption
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionMission">();
	}
	static class UFortDifficultyOptionMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionMission) == 0x000004, "Wrong alignment on UFortDifficultyOptionMission");
static_assert(sizeof(UFortDifficultyOptionMission) == 0x00002C, "Wrong size on UFortDifficultyOptionMission");

// Class FortniteGame.FortPlayerSpawnedParams
// 0x0004 (0x0020 - 0x001C)
class UFortPlayerSpawnedParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  SpawnedPlayerController;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortPlayerController** _SpawnedPlayerController);
	void MakeData(class AFortPlayerController* _SpawnedPlayerController, class UFortPlayerSpawnedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerSpawnedParams">();
	}
	static class UFortPlayerSpawnedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerSpawnedParams>();
	}
};
static_assert(alignof(UFortPlayerSpawnedParams) == 0x000004, "Wrong alignment on UFortPlayerSpawnedParams");
static_assert(sizeof(UFortPlayerSpawnedParams) == 0x000020, "Wrong size on UFortPlayerSpawnedParams");
static_assert(offsetof(UFortPlayerSpawnedParams, SpawnedPlayerController) == 0x00001C, "Member 'UFortPlayerSpawnedParams::SpawnedPlayerController' has a wrong offset!");

// Class FortniteGame.FortPlayerDiedParams
// 0x0008 (0x0024 - 0x001C)
class UFortPlayerDiedParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerPawn*                        KilledPlayer;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            KilledBy;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortPlayerPawn** _KilledPlayer, class AController** _KilledBy);
	void MakeData(class AFortPlayerPawn* _KilledPlayer, class AController* _KilledBy, class UFortPlayerDiedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerDiedParams">();
	}
	static class UFortPlayerDiedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerDiedParams>();
	}
};
static_assert(alignof(UFortPlayerDiedParams) == 0x000004, "Wrong alignment on UFortPlayerDiedParams");
static_assert(sizeof(UFortPlayerDiedParams) == 0x000024, "Wrong size on UFortPlayerDiedParams");
static_assert(offsetof(UFortPlayerDiedParams, KilledPlayer) == 0x00001C, "Member 'UFortPlayerDiedParams::KilledPlayer' has a wrong offset!");
static_assert(offsetof(UFortPlayerDiedParams, KilledBy) == 0x000020, "Member 'UFortPlayerDiedParams::KilledBy' has a wrong offset!");

// Class FortniteGame.FortDayPhaseChangeParams
// 0x0008 (0x0024 - 0x001C)
class UFortDayPhaseChangeParams final : public UFortMissionEventParams
{
public:
	class AFortDayNightLightingAndFog*            LightingAndFogManager;                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortDayPhase                                 NewDayPhase;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakData(class AFortDayNightLightingAndFog** _LightingAndFogManager, EFortDayPhase* _NewDayPhase);
	void MakeData(class AFortDayNightLightingAndFog* _LightingAndFogManager, EFortDayPhase _NewDayPhase, class UFortDayPhaseChangeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDayPhaseChangeParams">();
	}
	static class UFortDayPhaseChangeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDayPhaseChangeParams>();
	}
};
static_assert(alignof(UFortDayPhaseChangeParams) == 0x000004, "Wrong alignment on UFortDayPhaseChangeParams");
static_assert(sizeof(UFortDayPhaseChangeParams) == 0x000024, "Wrong size on UFortDayPhaseChangeParams");
static_assert(offsetof(UFortDayPhaseChangeParams, LightingAndFogManager) == 0x00001C, "Member 'UFortDayPhaseChangeParams::LightingAndFogManager' has a wrong offset!");
static_assert(offsetof(UFortDayPhaseChangeParams, NewDayPhase) == 0x000020, "Member 'UFortDayPhaseChangeParams::NewDayPhase' has a wrong offset!");

// Class FortniteGame.FortPlayerBuiltParams
// 0x000C (0x0028 - 0x001C)
class UFortPlayerBuiltParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerController*                  Builder;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AFortPlayerController** _Builder);
	void MakeData(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AFortPlayerController* _Builder, class UFortPlayerBuiltParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerBuiltParams">();
	}
	static class UFortPlayerBuiltParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerBuiltParams>();
	}
};
static_assert(alignof(UFortPlayerBuiltParams) == 0x000004, "Wrong alignment on UFortPlayerBuiltParams");
static_assert(sizeof(UFortPlayerBuiltParams) == 0x000028, "Wrong size on UFortPlayerBuiltParams");
static_assert(offsetof(UFortPlayerBuiltParams, Building) == 0x00001C, "Member 'UFortPlayerBuiltParams::Building' has a wrong offset!");
static_assert(offsetof(UFortPlayerBuiltParams, BuildingType) == 0x000020, "Member 'UFortPlayerBuiltParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortPlayerBuiltParams, Builder) == 0x000024, "Member 'UFortPlayerBuiltParams::Builder' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_DirectionNumber
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_DirectionNumber final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_DirectionNumber>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_DirectionNumber">();
	}
	static class UFortDifficultyOptionCategoryEncounter_DirectionNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_DirectionNumber>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_DirectionNumber) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_DirectionNumber");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_DirectionNumber) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_DirectionNumber");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_DirectionNumber, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_DirectionNumber::Options' has a wrong offset!");

// Class FortniteGame.FortBuildingDestroyedParams
// 0x000C (0x0028 - 0x001C)
class UFortBuildingDestroyedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            Destroyer;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AController** _Destroyer);
	void MakeData(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AController* _Destroyer, class UFortBuildingDestroyedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingDestroyedParams">();
	}
	static class UFortBuildingDestroyedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingDestroyedParams>();
	}
};
static_assert(alignof(UFortBuildingDestroyedParams) == 0x000004, "Wrong alignment on UFortBuildingDestroyedParams");
static_assert(sizeof(UFortBuildingDestroyedParams) == 0x000028, "Wrong size on UFortBuildingDestroyedParams");
static_assert(offsetof(UFortBuildingDestroyedParams, Building) == 0x00001C, "Member 'UFortBuildingDestroyedParams::Building' has a wrong offset!");
static_assert(offsetof(UFortBuildingDestroyedParams, BuildingType) == 0x000020, "Member 'UFortBuildingDestroyedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingDestroyedParams, Destroyer) == 0x000024, "Member 'UFortBuildingDestroyedParams::Destroyer' has a wrong offset!");

// Class FortniteGame.FortBuildingEditedParams
// 0x0010 (0x002C - 0x001C)
class UFortBuildingEditedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         OriginalBuilding;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         NewBuilding;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerController*                  Editor;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class ABuildingActor** _OriginalBuilding, class ABuildingActor** _NewBuilding, EFortBuildingType* _BuildingType, class AFortPlayerController** _Editor);
	void MakeData(class ABuildingActor* _OriginalBuilding, class ABuildingActor* _NewBuilding, EFortBuildingType _BuildingType, class AFortPlayerController* _Editor, class UFortBuildingEditedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingEditedParams">();
	}
	static class UFortBuildingEditedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingEditedParams>();
	}
};
static_assert(alignof(UFortBuildingEditedParams) == 0x000004, "Wrong alignment on UFortBuildingEditedParams");
static_assert(sizeof(UFortBuildingEditedParams) == 0x00002C, "Wrong size on UFortBuildingEditedParams");
static_assert(offsetof(UFortBuildingEditedParams, OriginalBuilding) == 0x00001C, "Member 'UFortBuildingEditedParams::OriginalBuilding' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, NewBuilding) == 0x000020, "Member 'UFortBuildingEditedParams::NewBuilding' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, BuildingType) == 0x000024, "Member 'UFortBuildingEditedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingEditedParams, Editor) == 0x000028, "Member 'UFortBuildingEditedParams::Editor' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsMultiplier>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier::Options' has a wrong offset!");

// Class FortniteGame.FortBuildingDamagedParams
// 0x0010 (0x002C - 0x001C)
class UFortBuildingDamagedParams final : public UFortMissionEventParams
{
public:
	class ABuildingActor*                         Building;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBuildingType                             BuildingType;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            DamagedBy;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakData(class ABuildingActor** _Building, EFortBuildingType* _BuildingType, class AController** _DamagedBy, float* _DamageAmount);
	void MakeData(class ABuildingActor* _Building, EFortBuildingType _BuildingType, class AController* _DamagedBy, float _DamageAmount, class UFortBuildingDamagedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingDamagedParams">();
	}
	static class UFortBuildingDamagedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingDamagedParams>();
	}
};
static_assert(alignof(UFortBuildingDamagedParams) == 0x000004, "Wrong alignment on UFortBuildingDamagedParams");
static_assert(sizeof(UFortBuildingDamagedParams) == 0x00002C, "Wrong size on UFortBuildingDamagedParams");
static_assert(offsetof(UFortBuildingDamagedParams, Building) == 0x00001C, "Member 'UFortBuildingDamagedParams::Building' has a wrong offset!");
static_assert(offsetof(UFortBuildingDamagedParams, BuildingType) == 0x000020, "Member 'UFortBuildingDamagedParams::BuildingType' has a wrong offset!");
static_assert(offsetof(UFortBuildingDamagedParams, DamagedBy) == 0x000024, "Member 'UFortBuildingDamagedParams::DamagedBy' has a wrong offset!");

// Class FortniteGame.FortMissionSucceededParams
// 0x0004 (0x0020 - 0x001C)
class UFortMissionSucceededParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           SucceededMission;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortMission** _SucceededMission);
	void MakeData(class AFortMission* _SucceededMission, class UFortMissionSucceededParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionSucceededParams">();
	}
	static class UFortMissionSucceededParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionSucceededParams>();
	}
};
static_assert(alignof(UFortMissionSucceededParams) == 0x000004, "Wrong alignment on UFortMissionSucceededParams");
static_assert(sizeof(UFortMissionSucceededParams) == 0x000020, "Wrong size on UFortMissionSucceededParams");
static_assert(offsetof(UFortMissionSucceededParams, SucceededMission) == 0x00001C, "Member 'UFortMissionSucceededParams::SucceededMission' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_PawnNumberCap
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_PawnNumberCap final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_PawnNumberCap>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_PawnNumberCap">();
	}
	static class UFortDifficultyOptionCategoryEncounter_PawnNumberCap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_PawnNumberCap>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_PawnNumberCap");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_PawnNumberCap");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_PawnNumberCap, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_PawnNumberCap::Options' has a wrong offset!");

// Class FortniteGame.FortMissionFailedParams
// 0x0004 (0x0020 - 0x001C)
class UFortMissionFailedParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           FailedMission;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortMission** _FailedMission);
	void MakeData(class AFortMission* _FailedMission, class UFortMissionFailedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionFailedParams">();
	}
	static class UFortMissionFailedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionFailedParams>();
	}
};
static_assert(alignof(UFortMissionFailedParams) == 0x000004, "Wrong alignment on UFortMissionFailedParams");
static_assert(sizeof(UFortMissionFailedParams) == 0x000020, "Wrong size on UFortMissionFailedParams");
static_assert(offsetof(UFortMissionFailedParams, FailedMission) == 0x00001C, "Member 'UFortMissionFailedParams::FailedMission' has a wrong offset!");

// Class FortniteGame.FortMissionNeutralCompleteParams
// 0x0004 (0x0020 - 0x001C)
class UFortMissionNeutralCompleteParams final : public UFortMissionEventParams
{
public:
	class AFortMission*                           NeutrallyCompletedMission;                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortMission** _NeutrallyCompletedMission);
	void MakeData(class AFortMission* _NeutrallyCompletedMission, class UFortMissionNeutralCompleteParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionNeutralCompleteParams">();
	}
	static class UFortMissionNeutralCompleteParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionNeutralCompleteParams>();
	}
};
static_assert(alignof(UFortMissionNeutralCompleteParams) == 0x000004, "Wrong alignment on UFortMissionNeutralCompleteParams");
static_assert(sizeof(UFortMissionNeutralCompleteParams) == 0x000020, "Wrong size on UFortMissionNeutralCompleteParams");
static_assert(offsetof(UFortMissionNeutralCompleteParams, NeutrallyCompletedMission) == 0x00001C, "Member 'UFortMissionNeutralCompleteParams::NeutrallyCompletedMission' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Breathers
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_Breathers final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Breathers>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Breathers">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Breathers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Breathers>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Breathers) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Breathers");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Breathers) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_Breathers");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Breathers, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_Breathers::Options' has a wrong offset!");

// Class FortniteGame.FortObjectiveSucceededParams
// 0x0004 (0x0020 - 0x001C)
class UFortObjectiveSucceededParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     SucceededObjective;                                // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortObjectiveBase** _SucceededObjective);
	void MakeData(class AFortObjectiveBase* _SucceededObjective, class UFortObjectiveSucceededParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveSucceededParams">();
	}
	static class UFortObjectiveSucceededParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveSucceededParams>();
	}
};
static_assert(alignof(UFortObjectiveSucceededParams) == 0x000004, "Wrong alignment on UFortObjectiveSucceededParams");
static_assert(sizeof(UFortObjectiveSucceededParams) == 0x000020, "Wrong size on UFortObjectiveSucceededParams");
static_assert(offsetof(UFortObjectiveSucceededParams, SucceededObjective) == 0x00001C, "Member 'UFortObjectiveSucceededParams::SucceededObjective' has a wrong offset!");

// Class FortniteGame.FortObjectiveFailedParams
// 0x0004 (0x0020 - 0x001C)
class UFortObjectiveFailedParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     FailedObjective;                                   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortObjectiveBase** _FailedObjective);
	void MakeData(class AFortObjectiveBase* _FailedObjective, class UFortObjectiveFailedParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveFailedParams">();
	}
	static class UFortObjectiveFailedParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveFailedParams>();
	}
};
static_assert(alignof(UFortObjectiveFailedParams) == 0x000004, "Wrong alignment on UFortObjectiveFailedParams");
static_assert(sizeof(UFortObjectiveFailedParams) == 0x000020, "Wrong size on UFortObjectiveFailedParams");
static_assert(offsetof(UFortObjectiveFailedParams, FailedObjective) == 0x00001C, "Member 'UFortObjectiveFailedParams::FailedObjective' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsBurst
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsBurst>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsBurst">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst::Options' has a wrong offset!");

// Class FortniteGame.FortObjectiveNeutralCompleteParams
// 0x0004 (0x0020 - 0x001C)
class UFortObjectiveNeutralCompleteParams final : public UFortMissionEventParams
{
public:
	class AFortObjectiveBase*                     NeutrallyCompletedObjective;                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BreakData(class AFortObjectiveBase** _NeutrallyCompletedObjective);
	void MakeData(class AFortObjectiveBase* _NeutrallyCompletedObjective, class UFortObjectiveNeutralCompleteParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveNeutralCompleteParams">();
	}
	static class UFortObjectiveNeutralCompleteParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortObjectiveNeutralCompleteParams>();
	}
};
static_assert(alignof(UFortObjectiveNeutralCompleteParams) == 0x000004, "Wrong alignment on UFortObjectiveNeutralCompleteParams");
static_assert(sizeof(UFortObjectiveNeutralCompleteParams) == 0x000020, "Wrong size on UFortObjectiveNeutralCompleteParams");
static_assert(offsetof(UFortObjectiveNeutralCompleteParams, NeutrallyCompletedObjective) == 0x00001C, "Member 'UFortObjectiveNeutralCompleteParams::NeutrallyCompletedObjective' has a wrong offset!");

// Class FortniteGame.FortToggledCursorModeParams
// 0x0008 (0x0024 - 0x001C)
class UFortToggledCursorModeParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledCursorMode;                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCursorMode;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakData(class AFortPlayerController** _PlayerThatToggledCursorMode, bool* InCursorMode);
	void MakeData(class AFortPlayerController* _PlayerThatToggledCursorMode, bool InCursorMode, class UFortToggledCursorModeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledCursorModeParams">();
	}
	static class UFortToggledCursorModeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledCursorModeParams>();
	}
};
static_assert(alignof(UFortToggledCursorModeParams) == 0x000004, "Wrong alignment on UFortToggledCursorModeParams");
static_assert(sizeof(UFortToggledCursorModeParams) == 0x000024, "Wrong size on UFortToggledCursorModeParams");
static_assert(offsetof(UFortToggledCursorModeParams, PlayerThatToggledCursorMode) == 0x00001C, "Member 'UFortToggledCursorModeParams::PlayerThatToggledCursorMode' has a wrong offset!");
static_assert(offsetof(UFortToggledCursorModeParams, bInCursorMode) == 0x000020, "Member 'UFortToggledCursorModeParams::bInCursorMode' has a wrong offset!");

// Class FortniteGame.FortDynamicBuildingDeconstructor
// 0x0048 (0x0288 - 0x0240)
class AFortDynamicBuildingDeconstructor final : public AActor
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0240(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawBounds;                                  // 0x025C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSelectiveDestruction;                             // 0x025D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMissionActors;                              // 0x025E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShrinkAndDestroyEffect;                           // 0x025F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumOfPiecesToDestroyAtOnce;                        // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenChunks;                                 // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ABuildingSMActor>> SortedBuildingActors;                              // 0x0268(0x000C)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x0274(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDynamicBuildingDeconstructor">();
	}
	static class AFortDynamicBuildingDeconstructor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDynamicBuildingDeconstructor>();
	}
};
static_assert(alignof(AFortDynamicBuildingDeconstructor) == 0x000004, "Wrong alignment on AFortDynamicBuildingDeconstructor");
static_assert(sizeof(AFortDynamicBuildingDeconstructor) == 0x000288, "Wrong size on AFortDynamicBuildingDeconstructor");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, Bounds) == 0x000240, "Member 'AFortDynamicBuildingDeconstructor::Bounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bDebugDrawBounds) == 0x00025C, "Member 'AFortDynamicBuildingDeconstructor::bDebugDrawBounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bSelectiveDestruction) == 0x00025D, "Member 'AFortDynamicBuildingDeconstructor::bSelectiveDestruction' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bIgnoreMissionActors) == 0x00025E, "Member 'AFortDynamicBuildingDeconstructor::bIgnoreMissionActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, bShrinkAndDestroyEffect) == 0x00025F, "Member 'AFortDynamicBuildingDeconstructor::bShrinkAndDestroyEffect' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, NumOfPiecesToDestroyAtOnce) == 0x000260, "Member 'AFortDynamicBuildingDeconstructor::NumOfPiecesToDestroyAtOnce' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, TimeBetweenChunks) == 0x000264, "Member 'AFortDynamicBuildingDeconstructor::TimeBetweenChunks' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, SortedBuildingActors) == 0x000268, "Member 'AFortDynamicBuildingDeconstructor::SortedBuildingActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuildingDeconstructor, CurrentIndex) == 0x000274, "Member 'AFortDynamicBuildingDeconstructor::CurrentIndex' has a wrong offset!");

// Class FortniteGame.FortToggledOptionsMenuParams
// 0x0008 (0x0024 - 0x001C)
class UFortToggledOptionsMenuParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledOptionsMenu;                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInOptionsMenu;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakData(class AFortPlayerController** _PlayerThatToggledOptionsMenu, bool* Opened);
	void MakeData(class AFortPlayerController* _PlayerThatToggledOptionsMenu, bool Opened, class UFortToggledOptionsMenuParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledOptionsMenuParams">();
	}
	static class UFortToggledOptionsMenuParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledOptionsMenuParams>();
	}
};
static_assert(alignof(UFortToggledOptionsMenuParams) == 0x000004, "Wrong alignment on UFortToggledOptionsMenuParams");
static_assert(sizeof(UFortToggledOptionsMenuParams) == 0x000024, "Wrong size on UFortToggledOptionsMenuParams");
static_assert(offsetof(UFortToggledOptionsMenuParams, PlayerThatToggledOptionsMenu) == 0x00001C, "Member 'UFortToggledOptionsMenuParams::PlayerThatToggledOptionsMenu' has a wrong offset!");
static_assert(offsetof(UFortToggledOptionsMenuParams, bInOptionsMenu) == 0x000020, "Member 'UFortToggledOptionsMenuParams::bInOptionsMenu' has a wrong offset!");

// Class FortniteGame.FortToggledEditModeParams
// 0x0008 (0x0024 - 0x001C)
class UFortToggledEditModeParams final : public UFortMissionEventParams
{
public:
	class AFortPlayerController*                  PlayerThatToggledEditMode;                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInEditMode;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakData(class AFortPlayerController** _PlayerThatToggledEditMode, bool* InEditMode);
	void MakeData(class AFortPlayerController* _PlayerThatToggledEditMode, bool InEditMode, class UFortToggledEditModeParams** ThisParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortToggledEditModeParams">();
	}
	static class UFortToggledEditModeParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortToggledEditModeParams>();
	}
};
static_assert(alignof(UFortToggledEditModeParams) == 0x000004, "Wrong alignment on UFortToggledEditModeParams");
static_assert(sizeof(UFortToggledEditModeParams) == 0x000024, "Wrong size on UFortToggledEditModeParams");
static_assert(offsetof(UFortToggledEditModeParams, PlayerThatToggledEditMode) == 0x00001C, "Member 'UFortToggledEditModeParams::PlayerThatToggledEditMode' has a wrong offset!");
static_assert(offsetof(UFortToggledEditModeParams, bInEditMode) == 0x000020, "Member 'UFortToggledEditModeParams::bInEditMode' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesAdjustment
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesAdjustment>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesAdjustment">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment::Options' has a wrong offset!");

// Class FortniteGame.FortShutdownParams
// 0x0000 (0x001C - 0x001C)
class UFortShutdownParams final : public UFortMissionEventParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortShutdownParams">();
	}
	static class UFortShutdownParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortShutdownParams>();
	}
};
static_assert(alignof(UFortShutdownParams) == 0x000004, "Wrong alignment on UFortShutdownParams");
static_assert(sizeof(UFortShutdownParams) == 0x00001C, "Wrong size on UFortShutdownParams");

// Class FortniteGame.FortInitializationInterface
// 0x0000 (0x001C - 0x001C)
class IFortInitializationInterface final : public IInterface
{
public:
	bool IsGameImportant();
	void MatchStarted();
	bool NeedsWorldReady();
	void WorldReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInitializationInterface">();
	}
	static class IFortInitializationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInitializationInterface>();
	}
};
static_assert(alignof(IFortInitializationInterface) == 0x000004, "Wrong alignment on IFortInitializationInterface");
static_assert(sizeof(IFortInitializationInterface) == 0x00001C, "Wrong size on IFortInitializationInterface");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnLimitPawns
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnLimitPawns>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnLimitPawns">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns::Options' has a wrong offset!");

// Class FortniteGame.FortMissionState
// 0x0004 (0x0244 - 0x0240)
class AFortMissionState : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarted();
	void OnWorldReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionState">();
	}
	static class AFortMissionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionState>();
	}
};
static_assert(alignof(AFortMissionState) == 0x000004, "Wrong alignment on AFortMissionState");
static_assert(sizeof(AFortMissionState) == 0x000244, "Wrong size on AFortMissionState");

// Class FortniteGame.FortObjectiveBase
// 0x0050 (0x0294 - 0x0244)
class AFortObjectiveBase : public AFortMissionState
{
public:
	class UFortBadgeItemDefinition*               ObjectiveRewardBadge;                              // 0x0244(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortWorldItemDefinition*>       ItemsToGiveOnObjectiveStart;                       // 0x0248(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bStartPlayingOnMissionStart;                       // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAcceptsMissionEventsWhenFinished;                 // 0x0255(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_256[0x2];                                      // 0x0256(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ObjectiveHandle;                                   // 0x0258(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, SaveGame, NativeAccessSpecifierPublic)
	EFortObjectiveRequirement                     MissionRequirement;                                // 0x0270(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x1];                                      // 0x0271(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsObjectiveVisible;                               // 0x0272(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsProgressBarHidden;                              // 0x0273(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRelevantToSpecificTeam;                           // 0x0274(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFortTeam                                     RelevantTeam;                                      // 0x0275(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_276[0x2];                                      // 0x0276(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlacementActorFinderInfo          PlacementActorFinderInfo;                          // 0x0278(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EFortObjectiveStatus                          ObjectiveStatus;                                   // 0x028C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMissionTimerComponent*             TimerComponent;                                    // 0x0290(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttemptMissionSave(const class FString& OptionalSaveName);
	void BlueprintHandleMissionEventNoReply(const struct FFortMissionEvent& MissionEvent);
	void BlueprintOnActivated(class AActor* InObjectiveFocus, class AFortPawn* InObjectiveInstigator);
	void BlueprintOnObjectiveEnd(EFortObjectiveStatus Status);
	void BlueprintOnStartPlaying(class AActor* InObjectiveFocus, class AFortPawn* InObjectiveInstigator);
	void BlueprintPostObjectiveLoad();
	void ClearObjectiveTimer();
	void DrawAttentionToUI();
	void EnableTick(bool bEnabled);
	void FocusParentMission(bool bTemporaryFocus);
	void GrantRewardsByTag(const struct FGameplayTag& RewardTag, EFortRewardType RewardType);
	void OnMatchStarted();
	void OnRep_bIsObjectiveVisible();
	void OnRep_ObjectiveStatus();
	void OnWorldReady();
	void PauseObjectiveTimer();
	void PlayerStatChanged(class AFortPlayerController* OwningPlayer, class FName ChangedStat, int32 NewValueZone, int32 NewValueWorld, int32 NewValueAccount);
	void ResetObjectiveTimer();
	void SetObjectiveTimer(const class FString& FunctionName, float TimerLength, bool bStartPaused);
	void SetUiVisibility(bool bInIsObjectiveVisible);
	void StartMissionNotification(const struct FLatentActionInfo& LatentInfo, TSubclassOf<class AFortClientNotification> Notification, class AFortPlayerController* SpecificPlayer, const class FText& OverrideDisplayText, class AFortPlayerPawn* OptionalPlayerPawn1, class AFortPlayerPawn* OptionalPlayerPawn2, class FName OptionalActionName, const class USoundBase* OptionalSound, bool bTreatAsUnique, bool bCancelActiveNotification, bool bWaitForClients);
	bool StartPlayingObjective(const struct FFortMissionEvent& MissionEvent);
	void StopObjective(EFortObjectiveStatus Status, const class FString& Description, const struct FGameplayTagContainer& CompletionTags, class UFortBadgeItemDefinition* ExtraBadgeToGrant);
	void UnpauseObjectiveTimer();

	int32 BlueprintGetNumProgressBars() const;
	class FText BlueprintGetObjectiveDisplayText() const;
	struct FLinearColor BlueprintGetProgressBarColor(int32 ProgressBarIdx) const;
	float BlueprintGetProgressBarPercentage(int32 ProgressBarIdx) const;
	class FText BlueprintGetProgressBarText(int32 ProgressBarIdx) const;
	float BlueprintGetTimeForUI() const;
	struct FGuid GetMissionGuid() const;
	float GetObjectiveTimerNormalizedTime() const;
	float GetObjectiveTimerTimeRemaining() const;
	bool IsActorRelevantToTeam(const class AActor* Actor) const;
	bool IsObjectiveTimerPaused() const;
	bool IsObjectiveTimerSet() const;
	bool IsRelevantToASpecificTeam() const;
	bool IsRelevantToTeam(EFortTeam Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveBase">();
	}
	static class AFortObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortObjectiveBase>();
	}
};
static_assert(alignof(AFortObjectiveBase) == 0x000004, "Wrong alignment on AFortObjectiveBase");
static_assert(sizeof(AFortObjectiveBase) == 0x000294, "Wrong size on AFortObjectiveBase");
static_assert(offsetof(AFortObjectiveBase, ObjectiveRewardBadge) == 0x000244, "Member 'AFortObjectiveBase::ObjectiveRewardBadge' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ItemsToGiveOnObjectiveStart) == 0x000248, "Member 'AFortObjectiveBase::ItemsToGiveOnObjectiveStart' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bStartPlayingOnMissionStart) == 0x000254, "Member 'AFortObjectiveBase::bStartPlayingOnMissionStart' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bAcceptsMissionEventsWhenFinished) == 0x000255, "Member 'AFortObjectiveBase::bAcceptsMissionEventsWhenFinished' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveHandle) == 0x000258, "Member 'AFortObjectiveBase::ObjectiveHandle' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, MissionRequirement) == 0x000270, "Member 'AFortObjectiveBase::MissionRequirement' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bIsObjectiveVisible) == 0x000272, "Member 'AFortObjectiveBase::bIsObjectiveVisible' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bIsProgressBarHidden) == 0x000273, "Member 'AFortObjectiveBase::bIsProgressBarHidden' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, bRelevantToSpecificTeam) == 0x000274, "Member 'AFortObjectiveBase::bRelevantToSpecificTeam' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, RelevantTeam) == 0x000275, "Member 'AFortObjectiveBase::RelevantTeam' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, PlacementActorFinderInfo) == 0x000278, "Member 'AFortObjectiveBase::PlacementActorFinderInfo' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, ObjectiveStatus) == 0x00028C, "Member 'AFortObjectiveBase::ObjectiveStatus' has a wrong offset!");
static_assert(offsetof(AFortObjectiveBase, TimerComponent) == 0x000290, "Member 'AFortObjectiveBase::TimerComponent' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionSetEncounter
// 0x0054 (0x0070 - 0x001C)
class UFortDifficultyOptionSetEncounter final : public UDataAsset
{
public:
	EFortEncounterPacingMode                      PacingMode;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_IntensityCurveSequence* IntensityCurveSequenceCategory;                    // 0x0020(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve* SpawnPointsPercentageCurveSequenceCategory;        // 0x0024(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsBurst* SpawnPointsBurstCategory;                          // 0x0028(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Breathers* BreathersCategory;                                 // 0x002C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnPointsMultiplier* SpawnPointsMultiplierCategory;                     // 0x0030(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_PawnNumberCap* PawnNumberCapCategory;                             // 0x0034(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterSpawnLimitType                  SpawnLimitMode;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints* SpawnPointsLimitCategory;                          // 0x003C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnLimitPawns* PawnLimitCategory;                                 // 0x0040(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterUtilitiesMode                   UtilitiesMode;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked* LockedUtilitiesCategory;                           // 0x0048(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_UtilitiesFree* FreeUtilitiesCategory;                             // 0x004C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_UtilitiesAdjustment* UtilitiesAdjustmentCategory;                       // 0x0050(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortEncounterSpawnLocationPlacementMode      SpawnLocationPlacementMode;                        // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDifficultyOptionCategoryEncounter_DirectionNumber* DirectionNumberCategory;                           // 0x0058(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_DirectionChange* DirectionChangeCategory;                           // 0x005C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Distance* DistanceCategory;                                  // 0x0060(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression* SpawnGroupProgressionCategory;                     // 0x0064(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_Time* TimeCategory;                                      // 0x0068(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDifficultyOptionCategoryEncounter_ModifierTags* OptionalModifierTagsCategory;                      // 0x006C(0x0004)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionSetEncounter">();
	}
	static class UFortDifficultyOptionSetEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionSetEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionSetEncounter) == 0x000004, "Wrong alignment on UFortDifficultyOptionSetEncounter");
static_assert(sizeof(UFortDifficultyOptionSetEncounter) == 0x000070, "Wrong size on UFortDifficultyOptionSetEncounter");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PacingMode) == 0x00001C, "Member 'UFortDifficultyOptionSetEncounter::PacingMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, IntensityCurveSequenceCategory) == 0x000020, "Member 'UFortDifficultyOptionSetEncounter::IntensityCurveSequenceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsPercentageCurveSequenceCategory) == 0x000024, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsPercentageCurveSequenceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsBurstCategory) == 0x000028, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsBurstCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, BreathersCategory) == 0x00002C, "Member 'UFortDifficultyOptionSetEncounter::BreathersCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsMultiplierCategory) == 0x000030, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsMultiplierCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PawnNumberCapCategory) == 0x000034, "Member 'UFortDifficultyOptionSetEncounter::PawnNumberCapCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnLimitMode) == 0x000038, "Member 'UFortDifficultyOptionSetEncounter::SpawnLimitMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnPointsLimitCategory) == 0x00003C, "Member 'UFortDifficultyOptionSetEncounter::SpawnPointsLimitCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, PawnLimitCategory) == 0x000040, "Member 'UFortDifficultyOptionSetEncounter::PawnLimitCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, UtilitiesMode) == 0x000044, "Member 'UFortDifficultyOptionSetEncounter::UtilitiesMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, LockedUtilitiesCategory) == 0x000048, "Member 'UFortDifficultyOptionSetEncounter::LockedUtilitiesCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, FreeUtilitiesCategory) == 0x00004C, "Member 'UFortDifficultyOptionSetEncounter::FreeUtilitiesCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, UtilitiesAdjustmentCategory) == 0x000050, "Member 'UFortDifficultyOptionSetEncounter::UtilitiesAdjustmentCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnLocationPlacementMode) == 0x000054, "Member 'UFortDifficultyOptionSetEncounter::SpawnLocationPlacementMode' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DirectionNumberCategory) == 0x000058, "Member 'UFortDifficultyOptionSetEncounter::DirectionNumberCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DirectionChangeCategory) == 0x00005C, "Member 'UFortDifficultyOptionSetEncounter::DirectionChangeCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, DistanceCategory) == 0x000060, "Member 'UFortDifficultyOptionSetEncounter::DistanceCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, SpawnGroupProgressionCategory) == 0x000064, "Member 'UFortDifficultyOptionSetEncounter::SpawnGroupProgressionCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, TimeCategory) == 0x000068, "Member 'UFortDifficultyOptionSetEncounter::TimeCategory' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionSetEncounter, OptionalModifierTagsCategory) == 0x00006C, "Member 'UFortDifficultyOptionSetEncounter::OptionalModifierTagsCategory' has a wrong offset!");

// Class FortniteGame.CustomCharacterPartModifier
// 0x0010 (0x0250 - 0x0240)
class ACustomCharacterPartModifier final : public AActor
{
public:
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0240(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortPlayerPawn>         FortPlayerPawnPtr;                                 // 0x0244(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	EFortCustomPartType                           PartType;                                          // 0x024C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void PreDestruction();

	class AFortPlayerPawn* GetAssociatedPlayerPawn() const;
	const EFortCustomPartType GetCharacterPartType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartModifier">();
	}
	static class ACustomCharacterPartModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomCharacterPartModifier>();
	}
};
static_assert(alignof(ACustomCharacterPartModifier) == 0x000004, "Wrong alignment on ACustomCharacterPartModifier");
static_assert(sizeof(ACustomCharacterPartModifier) == 0x000250, "Wrong size on ACustomCharacterPartModifier");
static_assert(offsetof(ACustomCharacterPartModifier, FortPlayerPawnPtr) == 0x000244, "Member 'ACustomCharacterPartModifier::FortPlayerPawnPtr' has a wrong offset!");
static_assert(offsetof(ACustomCharacterPartModifier, PartType) == 0x00024C, "Member 'ACustomCharacterPartModifier::PartType' has a wrong offset!");

// Class FortniteGame.FortAttributeLookupTable
// 0x0048 (0x0064 - 0x001C)
class UFortAttributeLookupTable final : public UDataAsset
{
public:
	TArray<struct FFortAttributeInfo>             AttributeInfoList;                                 // 0x001C(0x000C)(Edit, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28[0x3C];                                      // 0x0028(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeLookupTable">();
	}
	static class UFortAttributeLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeLookupTable>();
	}
};
static_assert(alignof(UFortAttributeLookupTable) == 0x000004, "Wrong alignment on UFortAttributeLookupTable");
static_assert(sizeof(UFortAttributeLookupTable) == 0x000064, "Wrong size on UFortAttributeLookupTable");
static_assert(offsetof(UFortAttributeLookupTable, AttributeInfoList) == 0x00001C, "Member 'UFortAttributeLookupTable::AttributeInfoList' has a wrong offset!");

// Class FortniteGame.FortExhibitActor
// 0x0040 (0x0280 - 0x0240)
#pragma pack(push, 0x1)
class alignas(0x10) AFortExhibitActor : public AActor
{
public:
	struct FTransform                             CameraOffset;                                      // 0x0240(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CameraFOV;                                         // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortExhibitActor">();
	}
	static class AFortExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortExhibitActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortExhibitActor) == 0x000010, "Wrong alignment on AFortExhibitActor");
static_assert(sizeof(AFortExhibitActor) == 0x000280, "Wrong size on AFortExhibitActor");
static_assert(offsetof(AFortExhibitActor, CameraOffset) == 0x000240, "Member 'AFortExhibitActor::CameraOffset' has a wrong offset!");
static_assert(offsetof(AFortExhibitActor, CameraFOV) == 0x000270, "Member 'AFortExhibitActor::CameraFOV' has a wrong offset!");

// Class FortniteGame.FortHeroExhibitActor
// 0x0000 (0x0280 - 0x0280)
class AFortHeroExhibitActor final : public AFortExhibitActor
{
public:
	class UFortHeroType*                          HeroType;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerPawn*                        HeroExhibitPawn;                                   // 0x0278(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroExhibitActor">();
	}
	static class AFortHeroExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHeroExhibitActor>();
	}
};
static_assert(alignof(AFortHeroExhibitActor) == 0x000010, "Wrong alignment on AFortHeroExhibitActor");
static_assert(sizeof(AFortHeroExhibitActor) == 0x000280, "Wrong size on AFortHeroExhibitActor");
static_assert(offsetof(AFortHeroExhibitActor, HeroType) == 0x000274, "Member 'AFortHeroExhibitActor::HeroType' has a wrong offset!");
static_assert(offsetof(AFortHeroExhibitActor, HeroExhibitPawn) == 0x000278, "Member 'AFortHeroExhibitActor::HeroExhibitPawn' has a wrong offset!");

// Class FortniteGame.FortInventoryInterface
// 0x0000 (0x001C - 0x001C)
class IFortInventoryInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventoryInterface">();
	}
	static class IFortInventoryInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInventoryInterface>();
	}
};
static_assert(alignof(IFortInventoryInterface) == 0x000004, "Wrong alignment on IFortInventoryInterface");
static_assert(sizeof(IFortInventoryInterface) == 0x00001C, "Wrong size on IFortInventoryInterface");

// Class FortniteGame.FortInventory
// 0x0154 (0x0394 - 0x0240)
class AFortInventory final : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortItemList                          Inventory;                                         // 0x0244(0x0110)(Net, SaveGame, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bRequiresLocalUpdate;                              // 0x0354(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bRequiresSaving;                                   // 0x0355(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bIsShuttingDown;                                   // 0x0356(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_357[0xD];                                      // 0x0357(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortWorldItem*>                 PendingInstances;                                  // 0x0364(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyAdded;                                     // 0x0370(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyRemoved;                                   // 0x037C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortItem*>                      RecentlyChanged;                                   // 0x0388(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void HandleInventoryLocalUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInventory">();
	}
	static class AFortInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortInventory>();
	}
};
static_assert(alignof(AFortInventory) == 0x000004, "Wrong alignment on AFortInventory");
static_assert(sizeof(AFortInventory) == 0x000394, "Wrong size on AFortInventory");
static_assert(offsetof(AFortInventory, Inventory) == 0x000244, "Member 'AFortInventory::Inventory' has a wrong offset!");
static_assert(offsetof(AFortInventory, bRequiresLocalUpdate) == 0x000354, "Member 'AFortInventory::bRequiresLocalUpdate' has a wrong offset!");
static_assert(offsetof(AFortInventory, bRequiresSaving) == 0x000355, "Member 'AFortInventory::bRequiresSaving' has a wrong offset!");
static_assert(offsetof(AFortInventory, bIsShuttingDown) == 0x000356, "Member 'AFortInventory::bIsShuttingDown' has a wrong offset!");
static_assert(offsetof(AFortInventory, PendingInstances) == 0x000364, "Member 'AFortInventory::PendingInstances' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyAdded) == 0x000370, "Member 'AFortInventory::RecentlyAdded' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyRemoved) == 0x00037C, "Member 'AFortInventory::RecentlyRemoved' has a wrong offset!");
static_assert(offsetof(AFortInventory, RecentlyChanged) == 0x000388, "Member 'AFortInventory::RecentlyChanged' has a wrong offset!");

// Class FortniteGame.FortWorldItemDefinition
// 0x01A8 (0x05C0 - 0x0418)
#pragma pack(push, 0x1)
class alignas(0x10) UFortWorldItemDefinition : public UFortItemDefinition
{
public:
	struct FGameplayTagContainer                  RequiredEquipTags;                                 // 0x0418(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OverrideAutoEquipTags;                             // 0x0430(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanAutoEquipByClass;                              // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTakesUpSpaceInBackpack : 1;                       // 0x044C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsQuickbarFocus : 1;                        // 0x044C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bShouldShowItemToast : 1;                          // 0x044C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowDirectionalArrowWhenFarOff : 1;               // 0x044C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDropped : 1;                                 // 0x044C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bItemCanBeStolen : 1;                              // 0x044C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanBeDepositedInStorageVault : 1;                 // 0x044C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bItemHasDurability : 1;                            // 0x044C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_44D[0x3];                                      // 0x044D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DropCount;                                         // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortReplicatedStat                           AccumulatingStatType;                              // 0x0454(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0458(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MiniMapViewableDistance;                           // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OwnerPickupText;                                   // 0x04D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableCategoryHandle               LootLevelData;                                     // 0x04DC(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTransform                             PickupMeshTransform;                               // 0x04F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverridePickupMeshTransform : 1;                  // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDropOnDeath : 1;                                  // 0x0520(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDropOnLogout : 1;                                 // 0x0520(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             PickupStaticMesh;                                  // 0x0524(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeletalMesh>           PickupSkeletalMesh;                                // 0x053C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PickupEffectBlueprintClassOverride;                // 0x0554(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              PickupSound;                                       // 0x056C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              DropSound;                                         // 0x0584(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisassemblyLootTierKey;                            // 0x059C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisassembleDurabilityDegradePercentBegin;          // 0x05A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisassembleDurabilityDegradePercentEnd;            // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisassembleDurabilityDegradeMinLootPercent;        // 0x05AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDisintegrationValue;                           // 0x05B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUsesCraftingRecipeToGetDisintegrationValue;       // 0x05B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B2[0x2];                                      // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FabricationValueOverride;                          // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanBeDisassembled() const;
	float GetDPSAtLevel(int32 ItemLevel) const;
	float GetMaxDurability(int32 ItemLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItemDefinition">();
	}
	static class UFortWorldItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortWorldItemDefinition) == 0x000010, "Wrong alignment on UFortWorldItemDefinition");
static_assert(sizeof(UFortWorldItemDefinition) == 0x0005C0, "Wrong size on UFortWorldItemDefinition");
static_assert(offsetof(UFortWorldItemDefinition, RequiredEquipTags) == 0x000418, "Member 'UFortWorldItemDefinition::RequiredEquipTags' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, OverrideAutoEquipTags) == 0x000430, "Member 'UFortWorldItemDefinition::OverrideAutoEquipTags' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bCanAutoEquipByClass) == 0x000448, "Member 'UFortWorldItemDefinition::bCanAutoEquipByClass' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DropCount) == 0x000450, "Member 'UFortWorldItemDefinition::DropCount' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, AccumulatingStatType) == 0x000454, "Member 'UFortWorldItemDefinition::AccumulatingStatType' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, MiniMapIconBrush) == 0x000458, "Member 'UFortWorldItemDefinition::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, MiniMapViewableDistance) == 0x0004CC, "Member 'UFortWorldItemDefinition::MiniMapViewableDistance' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, OwnerPickupText) == 0x0004D0, "Member 'UFortWorldItemDefinition::OwnerPickupText' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, LootLevelData) == 0x0004DC, "Member 'UFortWorldItemDefinition::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupMeshTransform) == 0x0004F0, "Member 'UFortWorldItemDefinition::PickupMeshTransform' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupStaticMesh) == 0x000524, "Member 'UFortWorldItemDefinition::PickupStaticMesh' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupSkeletalMesh) == 0x00053C, "Member 'UFortWorldItemDefinition::PickupSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupEffectBlueprintClassOverride) == 0x000554, "Member 'UFortWorldItemDefinition::PickupEffectBlueprintClassOverride' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, PickupSound) == 0x00056C, "Member 'UFortWorldItemDefinition::PickupSound' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DropSound) == 0x000584, "Member 'UFortWorldItemDefinition::DropSound' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassemblyLootTierKey) == 0x00059C, "Member 'UFortWorldItemDefinition::DisassemblyLootTierKey' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleDurabilityDegradePercentBegin) == 0x0005A4, "Member 'UFortWorldItemDefinition::DisassembleDurabilityDegradePercentBegin' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleDurabilityDegradePercentEnd) == 0x0005A8, "Member 'UFortWorldItemDefinition::DisassembleDurabilityDegradePercentEnd' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, DisassembleDurabilityDegradeMinLootPercent) == 0x0005AC, "Member 'UFortWorldItemDefinition::DisassembleDurabilityDegradeMinLootPercent' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bHasDisintegrationValue) == 0x0005B0, "Member 'UFortWorldItemDefinition::bHasDisintegrationValue' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, bUsesCraftingRecipeToGetDisintegrationValue) == 0x0005B1, "Member 'UFortWorldItemDefinition::bUsesCraftingRecipeToGetDisintegrationValue' has a wrong offset!");
static_assert(offsetof(UFortWorldItemDefinition, FabricationValueOverride) == 0x0005B4, "Member 'UFortWorldItemDefinition::FabricationValueOverride' has a wrong offset!");

// Class FortniteGame.CustomCharacterPart
// 0x0030 (0x05F0 - 0x05C0)
class UCustomCharacterPart final : public UFortWorldItemDefinition
{
public:
	EFortCustomGender                             GenderPermitted;                                   // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortCustomPartType                           CharacterPartType;                                 // 0x05B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortCustomBodyType                           BodyTypesPermitted;                                // 0x05BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BB[0x1];                                      // 0x05BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  MasterSkeletalMeshes;                              // 0x05C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TArray<class UFortHeroType*>                  ClassesPermitted;                                  // 0x05CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FName                                   OutfitName;                                        // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSinglePieceMesh;                                  // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACustomCharacterPartModifier> PartModifierBlueprint;                             // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomCharacterPartData*               AdditionalData;                                    // 0x05E8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsColorSwatches;                            // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPart">();
	}
	static class UCustomCharacterPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPart>();
	}
};
static_assert(alignof(UCustomCharacterPart) == 0x000010, "Wrong alignment on UCustomCharacterPart");
static_assert(sizeof(UCustomCharacterPart) == 0x0005F0, "Wrong size on UCustomCharacterPart");
static_assert(offsetof(UCustomCharacterPart, GenderPermitted) == 0x0005B8, "Member 'UCustomCharacterPart::GenderPermitted' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, CharacterPartType) == 0x0005B9, "Member 'UCustomCharacterPart::CharacterPartType' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, BodyTypesPermitted) == 0x0005BA, "Member 'UCustomCharacterPart::BodyTypesPermitted' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, SkeletalMesh) == 0x0005BC, "Member 'UCustomCharacterPart::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, MasterSkeletalMeshes) == 0x0005C0, "Member 'UCustomCharacterPart::MasterSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, ClassesPermitted) == 0x0005CC, "Member 'UCustomCharacterPart::ClassesPermitted' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, OutfitName) == 0x0005D8, "Member 'UCustomCharacterPart::OutfitName' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, bSinglePieceMesh) == 0x0005E0, "Member 'UCustomCharacterPart::bSinglePieceMesh' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, PartModifierBlueprint) == 0x0005E4, "Member 'UCustomCharacterPart::PartModifierBlueprint' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, AdditionalData) == 0x0005E8, "Member 'UCustomCharacterPart::AdditionalData' has a wrong offset!");
static_assert(offsetof(UCustomCharacterPart, bSupportsColorSwatches) == 0x0005EC, "Member 'UCustomCharacterPart::bSupportsColorSwatches' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesLocked
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesLocked>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesLocked">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesLocked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesLocked>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesLocked");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesLocked");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesLocked, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesLocked::Options' has a wrong offset!");

// Class FortniteGame.FortGlobals
// 0x0544 (0x0560 - 0x001C)
class UFortGlobals final : public UObject
{
public:
	struct FStreamableManager                     StreamableManager;                                 // 0x001C(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameDataName;                                      // 0x0098(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActiveTheaterListPath;                             // 0x00A4(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestTheaterListPath;                               // 0x00B0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPAccountLevelsTable;                              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPAccountLevelsName;                               // 0x00C0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             XPHeroLevelsTable;                                 // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPHeroLevelsName;                                  // 0x00D0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            XPAccountItemLevelsTable;                          // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPAccountItemLevelsName;                           // 0x00E0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            XPAccountItemRewardsTable;                         // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XPAccountItemRewardsName;                          // 0x00F0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             TraitCostsTable;                                   // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TraitCostsTableName;                               // 0x0100(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SurfaceRatioDataTable;                             // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AIWildcardsTableName;                              // 0x0110(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x3C];                                     // 0x011C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyMap;                                          // 0x0158(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCullObjectSize;                             // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultCullDistance;                               // 0x0168(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCullObjectSize;                                 // 0x016C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCullDistance;                                   // 0x0170(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCullObjectSize;                                 // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCullDistance;                                   // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLoadConstructorReferencesAtStartup;          // 0x017C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableNewCustomizationPanel;                      // 0x017D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableNewEncounters;                              // 0x017E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableDormantHusks;                               // 0x017F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableAIDespawning;                               // 0x0180(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableNewAIEncounterTypeData;                     // 0x0181(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftObjectPtr<class UFortWorldItemDefinition>, TSoftObjectPtr<class UFortSchematicItemDefinition>> ItemToSchematicMap;                                // 0x0184(0x003C)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UFortGameData*                          GameData;                                          // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortObjectLibraryEntry                ObjectLibraries[0x22];                             // 0x01C8(0x0014)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0xF0];                                     // 0x0470(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobals">();
	}
	static class UFortGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGlobals>();
	}
};
static_assert(alignof(UFortGlobals) == 0x000004, "Wrong alignment on UFortGlobals");
static_assert(sizeof(UFortGlobals) == 0x000560, "Wrong size on UFortGlobals");
static_assert(offsetof(UFortGlobals, StreamableManager) == 0x00001C, "Member 'UFortGlobals::StreamableManager' has a wrong offset!");
static_assert(offsetof(UFortGlobals, GameDataName) == 0x000098, "Member 'UFortGlobals::GameDataName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, ActiveTheaterListPath) == 0x0000A4, "Member 'UFortGlobals::ActiveTheaterListPath' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TestTheaterListPath) == 0x0000B0, "Member 'UFortGlobals::TestTheaterListPath' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountLevelsTable) == 0x0000BC, "Member 'UFortGlobals::XPAccountLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountLevelsName) == 0x0000C0, "Member 'UFortGlobals::XPAccountLevelsName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPHeroLevelsTable) == 0x0000CC, "Member 'UFortGlobals::XPHeroLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPHeroLevelsName) == 0x0000D0, "Member 'UFortGlobals::XPHeroLevelsName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountItemLevelsTable) == 0x0000DC, "Member 'UFortGlobals::XPAccountItemLevelsTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountItemLevelsName) == 0x0000E0, "Member 'UFortGlobals::XPAccountItemLevelsName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountItemRewardsTable) == 0x0000EC, "Member 'UFortGlobals::XPAccountItemRewardsTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, XPAccountItemRewardsName) == 0x0000F0, "Member 'UFortGlobals::XPAccountItemRewardsName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TraitCostsTable) == 0x0000FC, "Member 'UFortGlobals::TraitCostsTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, TraitCostsTableName) == 0x000100, "Member 'UFortGlobals::TraitCostsTableName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, SurfaceRatioDataTable) == 0x00010C, "Member 'UFortGlobals::SurfaceRatioDataTable' has a wrong offset!");
static_assert(offsetof(UFortGlobals, AIWildcardsTableName) == 0x000110, "Member 'UFortGlobals::AIWildcardsTableName' has a wrong offset!");
static_assert(offsetof(UFortGlobals, LobbyMap) == 0x000158, "Member 'UFortGlobals::LobbyMap' has a wrong offset!");
static_assert(offsetof(UFortGlobals, DefaultCullObjectSize) == 0x000164, "Member 'UFortGlobals::DefaultCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, DefaultCullDistance) == 0x000168, "Member 'UFortGlobals::DefaultCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinCullObjectSize) == 0x00016C, "Member 'UFortGlobals::MinCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MinCullDistance) == 0x000170, "Member 'UFortGlobals::MinCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxCullObjectSize) == 0x000174, "Member 'UFortGlobals::MaxCullObjectSize' has a wrong offset!");
static_assert(offsetof(UFortGlobals, MaxCullDistance) == 0x000178, "Member 'UFortGlobals::MaxCullDistance' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bForceLoadConstructorReferencesAtStartup) == 0x00017C, "Member 'UFortGlobals::bForceLoadConstructorReferencesAtStartup' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableNewCustomizationPanel) == 0x00017D, "Member 'UFortGlobals::bEnableNewCustomizationPanel' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableNewEncounters) == 0x00017E, "Member 'UFortGlobals::bEnableNewEncounters' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableDormantHusks) == 0x00017F, "Member 'UFortGlobals::bEnableDormantHusks' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableAIDespawning) == 0x000180, "Member 'UFortGlobals::bEnableAIDespawning' has a wrong offset!");
static_assert(offsetof(UFortGlobals, bEnableNewAIEncounterTypeData) == 0x000181, "Member 'UFortGlobals::bEnableNewAIEncounterTypeData' has a wrong offset!");
static_assert(offsetof(UFortGlobals, ItemToSchematicMap) == 0x000184, "Member 'UFortGlobals::ItemToSchematicMap' has a wrong offset!");
static_assert(offsetof(UFortGlobals, GameData) == 0x0001C0, "Member 'UFortGlobals::GameData' has a wrong offset!");
static_assert(offsetof(UFortGlobals, ObjectLibraries) == 0x0001C8, "Member 'UFortGlobals::ObjectLibraries' has a wrong offset!");

// Class FortniteGame.FortMissionWeightedRewards
// 0x000C (0x0028 - 0x001C)
class UFortMissionWeightedRewards final : public UDataAsset
{
public:
	TArray<struct FFortMissionWeightedReward>     Rewards;                                           // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionWeightedRewards">();
	}
	static class UFortMissionWeightedRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionWeightedRewards>();
	}
};
static_assert(alignof(UFortMissionWeightedRewards) == 0x000004, "Wrong alignment on UFortMissionWeightedRewards");
static_assert(sizeof(UFortMissionWeightedRewards) == 0x000028, "Wrong size on UFortMissionWeightedRewards");
static_assert(offsetof(UFortMissionWeightedRewards, Rewards) == 0x00001C, "Member 'UFortMissionWeightedRewards::Rewards' has a wrong offset!");

// Class FortniteGame.FortEventNotificationBank
// 0x000C (0x0028 - 0x001C)
class UFortEventNotificationBank final : public UDataAsset
{
public:
	TArray<struct FFortEventNotification>         EventNotifications;                                // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEventNotificationBank">();
	}
	static class UFortEventNotificationBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEventNotificationBank>();
	}
};
static_assert(alignof(UFortEventNotificationBank) == 0x000004, "Wrong alignment on UFortEventNotificationBank");
static_assert(sizeof(UFortEventNotificationBank) == 0x000028, "Wrong size on UFortEventNotificationBank");
static_assert(offsetof(UFortEventNotificationBank, EventNotifications) == 0x00001C, "Member 'UFortEventNotificationBank::EventNotifications' has a wrong offset!");

// Class FortniteGame.FortMissionInfo
// 0x0224 (0x0240 - 0x001C)
class UFortMissionInfo final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   MissionRef;                                        // 0x001C(0x0018)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortMissionType                              MissionType;                                       // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MissionTags;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TimeOfDaySpeed;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortBadgeItemDefinition*               MissionRewardBadge;                                // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionRewardItemsLootTierGroup;                   // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRewardLootTierPoints;                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParTime;                                           // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortBadgeItemDefinition*               UnderParBadge;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMissionPoints;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictoryTileRequired;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   MissionDescription;                                // 0x0074(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DaysToLive;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortObjectiveBlock>            ObjectiveBlocks;                                   // 0x0084(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionInfoTagRequirement> RequiredBuildings;                                 // 0x0090(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinDistanceToOtherMissions;                        // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMinimapIconsOnlyIfFocused;                    // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpectedCompletionTime;                            // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissionEncounterTime;                              // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortPlacementActorFinderInfo          PlacementActorInfo;                                // 0x00AC(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bStartPlayingOnLoad;                               // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RewardsTitleText;                                  // 0x00C4(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   RewardsDescriptionText;                            // 0x00D0(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   NonParticipationRewardsDescriptionText;            // 0x00DC(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortMissionPopupWidgetData            PopupWidgetData;                                   // 0x00E8(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortMissionWeightedRewards*            WeightedRewards;                                   // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MissionName;                                       // 0x01D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortEncounterProfile>          EncounterProfiles;                                 // 0x01E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortEncounterSequenceSettings> EncounterSequences;                                // 0x01EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortDifficultyOptionSetMission> MissionOptions;                                    // 0x01F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MissionDifficultyOptionTags;                       // 0x0210(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortMissionTaggedRewards>      TaggedRewards;                                     // 0x0228(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FFortMissionConfigDataParams           ConfigParams;                                      // 0x0234(0x000C)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInfo">();
	}
	static class UFortMissionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionInfo>();
	}
};
static_assert(alignof(UFortMissionInfo) == 0x000004, "Wrong alignment on UFortMissionInfo");
static_assert(sizeof(UFortMissionInfo) == 0x000240, "Wrong size on UFortMissionInfo");
static_assert(offsetof(UFortMissionInfo, MissionRef) == 0x00001C, "Member 'UFortMissionInfo::MissionRef' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionType) == 0x000034, "Member 'UFortMissionInfo::MissionType' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionTags) == 0x000038, "Member 'UFortMissionInfo::MissionTags' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, TimeOfDaySpeed) == 0x000050, "Member 'UFortMissionInfo::TimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionRewardBadge) == 0x000054, "Member 'UFortMissionInfo::MissionRewardBadge' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionRewardItemsLootTierGroup) == 0x000058, "Member 'UFortMissionInfo::MissionRewardItemsLootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MaxRewardLootTierPoints) == 0x000060, "Member 'UFortMissionInfo::MaxRewardLootTierPoints' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ParTime) == 0x000064, "Member 'UFortMissionInfo::ParTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, UnderParBadge) == 0x000068, "Member 'UFortMissionInfo::UnderParBadge' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MaxMissionPoints) == 0x00006C, "Member 'UFortMissionInfo::MaxMissionPoints' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bVictoryTileRequired) == 0x000070, "Member 'UFortMissionInfo::bVictoryTileRequired' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionDescription) == 0x000074, "Member 'UFortMissionInfo::MissionDescription' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, DaysToLive) == 0x000080, "Member 'UFortMissionInfo::DaysToLive' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ObjectiveBlocks) == 0x000084, "Member 'UFortMissionInfo::ObjectiveBlocks' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, RequiredBuildings) == 0x000090, "Member 'UFortMissionInfo::RequiredBuildings' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MinDistanceToOtherMissions) == 0x00009C, "Member 'UFortMissionInfo::MinDistanceToOtherMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bShowMinimapIconsOnlyIfFocused) == 0x0000A0, "Member 'UFortMissionInfo::bShowMinimapIconsOnlyIfFocused' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ExpectedCompletionTime) == 0x0000A4, "Member 'UFortMissionInfo::ExpectedCompletionTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionEncounterTime) == 0x0000A8, "Member 'UFortMissionInfo::MissionEncounterTime' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, PlacementActorInfo) == 0x0000AC, "Member 'UFortMissionInfo::PlacementActorInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, bStartPlayingOnLoad) == 0x0000C0, "Member 'UFortMissionInfo::bStartPlayingOnLoad' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, RewardsTitleText) == 0x0000C4, "Member 'UFortMissionInfo::RewardsTitleText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, RewardsDescriptionText) == 0x0000D0, "Member 'UFortMissionInfo::RewardsDescriptionText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, NonParticipationRewardsDescriptionText) == 0x0000DC, "Member 'UFortMissionInfo::NonParticipationRewardsDescriptionText' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, PopupWidgetData) == 0x0000E8, "Member 'UFortMissionInfo::PopupWidgetData' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, WeightedRewards) == 0x0001D0, "Member 'UFortMissionInfo::WeightedRewards' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionName) == 0x0001D4, "Member 'UFortMissionInfo::MissionName' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, EncounterProfiles) == 0x0001E0, "Member 'UFortMissionInfo::EncounterProfiles' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, EncounterSequences) == 0x0001EC, "Member 'UFortMissionInfo::EncounterSequences' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionOptions) == 0x0001F8, "Member 'UFortMissionInfo::MissionOptions' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, MissionDifficultyOptionTags) == 0x000210, "Member 'UFortMissionInfo::MissionDifficultyOptionTags' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, TaggedRewards) == 0x000228, "Member 'UFortMissionInfo::TaggedRewards' has a wrong offset!");
static_assert(offsetof(UFortMissionInfo, ConfigParams) == 0x000234, "Member 'UFortMissionInfo::ConfigParams' has a wrong offset!");

// Class FortniteGame.FortTheaterMapViewer
// 0x0100 (0x0340 - 0x0240)
class AFortTheaterMapViewer : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAvailableTheaterMissions>  MissionAvailabilityList;                           // 0x0244(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBox                                   HexMapSize;                                        // 0x0250(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HexTileWidth;                                      // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HexTileHeight;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastTheaterRefresh;                                // 0x0274(0x0008)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FFortHexMapCoord                       PlayerMarkerTileCoord;                             // 0x027C(0x000C)(Protected, NativeAccessSpecifierProtected)
	TArray<class AFortTheaterMapTile*>            HexMap;                                            // 0x0288(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTheaterIndex;                               // 0x0294(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<bool>                                  LeaderTileAccessStates;                            // 0x0298(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentSelectedRegionIndex;                        // 0x02A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortTheaterMapTile*                    CurrentSelectedTile;                               // 0x02A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortTheaterMapData>            TheaterList;                                       // 0x02AC(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AFortHexMapPlayerMarker*>        PlayerMarkers;                                     // 0x02B8(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumValidHexMapTiles;                               // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x78];                                     // 0x02C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterMapViewer">();
	}
	static class AFortTheaterMapViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterMapViewer>();
	}
};
static_assert(alignof(AFortTheaterMapViewer) == 0x000004, "Wrong alignment on AFortTheaterMapViewer");
static_assert(sizeof(AFortTheaterMapViewer) == 0x000340, "Wrong size on AFortTheaterMapViewer");
static_assert(offsetof(AFortTheaterMapViewer, MissionAvailabilityList) == 0x000244, "Member 'AFortTheaterMapViewer::MissionAvailabilityList' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexMapSize) == 0x000250, "Member 'AFortTheaterMapViewer::HexMapSize' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexTileWidth) == 0x00026C, "Member 'AFortTheaterMapViewer::HexTileWidth' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexTileHeight) == 0x000270, "Member 'AFortTheaterMapViewer::HexTileHeight' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, LastTheaterRefresh) == 0x000274, "Member 'AFortTheaterMapViewer::LastTheaterRefresh' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, PlayerMarkerTileCoord) == 0x00027C, "Member 'AFortTheaterMapViewer::PlayerMarkerTileCoord' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, HexMap) == 0x000288, "Member 'AFortTheaterMapViewer::HexMap' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, CurrentTheaterIndex) == 0x000294, "Member 'AFortTheaterMapViewer::CurrentTheaterIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, LeaderTileAccessStates) == 0x000298, "Member 'AFortTheaterMapViewer::LeaderTileAccessStates' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, CurrentSelectedRegionIndex) == 0x0002A4, "Member 'AFortTheaterMapViewer::CurrentSelectedRegionIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, CurrentSelectedTile) == 0x0002A8, "Member 'AFortTheaterMapViewer::CurrentSelectedTile' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, TheaterList) == 0x0002AC, "Member 'AFortTheaterMapViewer::TheaterList' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, PlayerMarkers) == 0x0002B8, "Member 'AFortTheaterMapViewer::PlayerMarkers' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapViewer, NumValidHexMapTiles) == 0x0002C4, "Member 'AFortTheaterMapViewer::NumValidHexMapTiles' has a wrong offset!");

// Class FortniteGame.FortMcpWorlds
// 0x0030 (0x004C - 0x001C)
class UFortMcpWorlds final : public UObject
{
public:
	uint8                                         Pad_1C[0xC];                                       // 0x001C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EnumerateWorldsUrl;                                // 0x0028(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortActiveTheaterInfo                 TheaterInfo;                                       // 0x0034(0x0018)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpWorlds">();
	}
	static class UFortMcpWorlds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpWorlds>();
	}
};
static_assert(alignof(UFortMcpWorlds) == 0x000004, "Wrong alignment on UFortMcpWorlds");
static_assert(sizeof(UFortMcpWorlds) == 0x00004C, "Wrong size on UFortMcpWorlds");
static_assert(offsetof(UFortMcpWorlds, EnumerateWorldsUrl) == 0x000028, "Member 'UFortMcpWorlds::EnumerateWorldsUrl' has a wrong offset!");
static_assert(offsetof(UFortMcpWorlds, TheaterInfo) == 0x000034, "Member 'UFortMcpWorlds::TheaterInfo' has a wrong offset!");

// Class FortniteGame.FortGenericRecord
// 0x001C (0x0038 - 0x001C)
class UFortGenericRecord : public UObject
{
public:
	int32                                         DataVersion;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGenericRecord">();
	}
	static class UFortGenericRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGenericRecord>();
	}
};
static_assert(alignof(UFortGenericRecord) == 0x000004, "Wrong alignment on UFortGenericRecord");
static_assert(sizeof(UFortGenericRecord) == 0x000038, "Wrong size on UFortGenericRecord");
static_assert(offsetof(UFortGenericRecord, DataVersion) == 0x00001C, "Member 'UFortGenericRecord::DataVersion' has a wrong offset!");

// Class FortniteGame.FortFastLoadConfig
// 0x0004 (0x0020 - 0x001C)
class UFortFastLoadConfig final : public UObject
{
public:
	uint8                                         bDisableStreamInBuildings : 1;                     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableStartupAIDirector : 1;                     // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableNonDefaultFakeHeroesAtStartup : 1;         // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableUpgradePlayerBuildingClasses : 1;          // 0x001C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bUseMinimalPlayerBuildingClasses : 1;              // 0x001C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableStartingMissions : 1;                      // 0x001C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bUseFastLoadDefaultInventory : 1;                  // 0x001C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableNavAgentCostData : 1;                      // 0x001C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bDisableThreatVisualsManager : 1;                  // 0x001D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFastLoadConfig">();
	}
	static class UFortFastLoadConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFastLoadConfig>();
	}
};
static_assert(alignof(UFortFastLoadConfig) == 0x000004, "Wrong alignment on UFortFastLoadConfig");
static_assert(sizeof(UFortFastLoadConfig) == 0x000020, "Wrong size on UFortFastLoadConfig");

// Class FortniteGame.FortWorldRecord
// 0x0140 (0x0178 - 0x0038)
class UFortWorldRecord final : public UFortGenericRecord
{
public:
	int32                                         WorldSaveCount;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldDaysElapsed;                                  // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldLevel;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentZoneIndex;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortZoneInfoRecord>            SavedZones;                                        // 0x0048(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortPlayerRecord>              SavedPlayers;                                      // 0x0054(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FFortWorldData                         WorldMetadata;                                     // 0x0060(0x0084)(Transient, NativeAccessSpecifierPublic)
	struct FFortZoneInstanceDetails               ZoneInstanceInfo;                                  // 0x00E4(0x0064)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FFortClusterInfoRecord>         SavedClusters;                                     // 0x0148(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         VictoryZoneIndex;                                  // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortHexMapCoord                       PlayerMarkerTileCoord;                             // 0x0160(0x000C)(NativeAccessSpecifierPublic)
	class FString                                 WUID;                                              // 0x016C(0x000C)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldRecord">();
	}
	static class UFortWorldRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldRecord>();
	}
};
static_assert(alignof(UFortWorldRecord) == 0x000004, "Wrong alignment on UFortWorldRecord");
static_assert(sizeof(UFortWorldRecord) == 0x000178, "Wrong size on UFortWorldRecord");
static_assert(offsetof(UFortWorldRecord, WorldSaveCount) == 0x000038, "Member 'UFortWorldRecord::WorldSaveCount' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, WorldDaysElapsed) == 0x00003C, "Member 'UFortWorldRecord::WorldDaysElapsed' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, WorldLevel) == 0x000040, "Member 'UFortWorldRecord::WorldLevel' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, CurrentZoneIndex) == 0x000044, "Member 'UFortWorldRecord::CurrentZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, SavedZones) == 0x000048, "Member 'UFortWorldRecord::SavedZones' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, SavedPlayers) == 0x000054, "Member 'UFortWorldRecord::SavedPlayers' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, WorldMetadata) == 0x000060, "Member 'UFortWorldRecord::WorldMetadata' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, ZoneInstanceInfo) == 0x0000E4, "Member 'UFortWorldRecord::ZoneInstanceInfo' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, SavedClusters) == 0x000148, "Member 'UFortWorldRecord::SavedClusters' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, VictoryZoneIndex) == 0x000154, "Member 'UFortWorldRecord::VictoryZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, MapWidth) == 0x000158, "Member 'UFortWorldRecord::MapWidth' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, MapHeight) == 0x00015C, "Member 'UFortWorldRecord::MapHeight' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, PlayerMarkerTileCoord) == 0x000160, "Member 'UFortWorldRecord::PlayerMarkerTileCoord' has a wrong offset!");
static_assert(offsetof(UFortWorldRecord, WUID) == 0x00016C, "Member 'UFortWorldRecord::WUID' has a wrong offset!");

// Class FortniteGame.FortSpline
// 0x0030 (0x004C - 0x001C)
class UFortSpline final : public UObject
{
public:
	bool                                          bConstantVelocity;                                 // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCatmullRomSpline                  Spline;                                            // 0x0020(0x0018)(NativeAccessSpecifierPrivate)
	struct FInterpCurveFloat                      SplineLookupTable;                                 // 0x0038(0x0014)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddControlPoint(const struct FVector& Point, int32 INDEX);
	void ClearSpline();
	void DrawDebugSpline(class UObject* WorldContextObject, int32 Steps, float LifeTime, float Thickness, bool bPersistent, bool bJustDrawSpline, float BasisLength);
	void EnableConstantVelocity(bool ConstVelEnabled);
	void SetDuration(float InDuration);
	void SetupSpline(const TArray<struct FVector>& ControlPoints, float InDuration);

	struct FVector GetBinormalFromTime(float Time) const;
	float GetDuration() const;
	struct FVector GetEndPoint() const;
	struct FVector GetNormalFromTime(float Time) const;
	int32 GetNumberOfControlPoints() const;
	struct FVector GetPositionFromTime(float Time) const;
	float GetSplineLength(float StepSize) const;
	float GetSplineLengthAtTime(float Time, float StepSize) const;
	struct FVector GetStartPoint() const;
	struct FVector GetTangentFromTime(float Time) const;
	float GetVelocityCorrectedTime(float Time) const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpline">();
	}
	static class UFortSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpline>();
	}
};
static_assert(alignof(UFortSpline) == 0x000004, "Wrong alignment on UFortSpline");
static_assert(sizeof(UFortSpline) == 0x00004C, "Wrong size on UFortSpline");
static_assert(offsetof(UFortSpline, bConstantVelocity) == 0x00001C, "Member 'UFortSpline::bConstantVelocity' has a wrong offset!");
static_assert(offsetof(UFortSpline, Spline) == 0x000020, "Member 'UFortSpline::Spline' has a wrong offset!");
static_assert(offsetof(UFortSpline, SplineLookupTable) == 0x000038, "Member 'UFortSpline::SplineLookupTable' has a wrong offset!");

// Class FortniteGame.FortInteractInterface
// 0x0000 (0x001C - 0x001C)
class IFortInteractInterface final : public IInterface
{
public:
	bool CanInteract(const struct FInteractionType& InteractType);
	bool CanShowContextInfo(const struct FInteractionType& InteractType);
	struct FInteractContextInfo GetContextInfo(const struct FInteractionType& InteractType);
	bool HasDisplayWidget(const struct FInteractionType& InteractType);
	void LocalBeginLongUse();
	bool LocalOnAttemptInteract(const struct FInteractionType& InteractType);
	void LocalOnInterruptInteract(const struct FInteractionType& InteractType);
	bool ServerOnAttemptInteract(const struct FInteractionType& InteractType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInteractInterface">();
	}
	static class IFortInteractInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortInteractInterface>();
	}
};
static_assert(alignof(IFortInteractInterface) == 0x000004, "Wrong alignment on IFortInteractInterface");
static_assert(sizeof(IFortInteractInterface) == 0x00001C, "Wrong size on IFortInteractInterface");

// Class FortniteGame.FortPickup
// 0x0178 (0x03B8 - 0x0240)
class AFortPickup : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPickup;                                          // 0x0244(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortItemEntry                         PrimaryPickupItemEntry;                            // 0x0250(0x007C)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortItemEntry>                 MultiItemPickupEntries;                            // 0x02CC(0x000C)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortPickupLocationData                PickupLocationData;                                // 0x02D8(0x0044)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         OptionalOwnerID;                                   // 0x031C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  OptionalMissionGuid;                               // 0x0320(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFortItem*                              PrimaryPickupDummyItem;                            // 0x0330(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortPickupEffect>       PickupEffectBlueprint;                             // 0x0334(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      TouchCapsule;                                      // 0x033C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           MovementComponent;                                 // 0x0340(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPickedUp;                                         // 0x0344(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveVector>            SplineCurve;                                       // 0x0348(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SpawnEffect;                                       // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              LandedSound;                                       // 0x0364(0x0018)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastLandedSoundPlayTime;                           // 0x037C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x38];                                     // 0x0380(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetDisplayName();
	void OnRep_PickupLocationData();
	void OnRep_PickupOwnerData();
	void OnRep_PrimaryPickupItemEntry();
	void TossPickup(const struct FVector& FinalLocation, class APawn* ItemOwner, int32 OverrideMaxStackCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickup">();
	}
	static class AFortPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickup>();
	}
};
static_assert(alignof(AFortPickup) == 0x000004, "Wrong alignment on AFortPickup");
static_assert(sizeof(AFortPickup) == 0x0003B8, "Wrong size on AFortPickup");
static_assert(offsetof(AFortPickup, OnPickup) == 0x000244, "Member 'AFortPickup::OnPickup' has a wrong offset!");
static_assert(offsetof(AFortPickup, PrimaryPickupItemEntry) == 0x000250, "Member 'AFortPickup::PrimaryPickupItemEntry' has a wrong offset!");
static_assert(offsetof(AFortPickup, MultiItemPickupEntries) == 0x0002CC, "Member 'AFortPickup::MultiItemPickupEntries' has a wrong offset!");
static_assert(offsetof(AFortPickup, PickupLocationData) == 0x0002D8, "Member 'AFortPickup::PickupLocationData' has a wrong offset!");
static_assert(offsetof(AFortPickup, OptionalOwnerID) == 0x00031C, "Member 'AFortPickup::OptionalOwnerID' has a wrong offset!");
static_assert(offsetof(AFortPickup, OptionalMissionGuid) == 0x000320, "Member 'AFortPickup::OptionalMissionGuid' has a wrong offset!");
static_assert(offsetof(AFortPickup, PrimaryPickupDummyItem) == 0x000330, "Member 'AFortPickup::PrimaryPickupDummyItem' has a wrong offset!");
static_assert(offsetof(AFortPickup, PickupEffectBlueprint) == 0x000334, "Member 'AFortPickup::PickupEffectBlueprint' has a wrong offset!");
static_assert(offsetof(AFortPickup, TouchCapsule) == 0x00033C, "Member 'AFortPickup::TouchCapsule' has a wrong offset!");
static_assert(offsetof(AFortPickup, MovementComponent) == 0x000340, "Member 'AFortPickup::MovementComponent' has a wrong offset!");
static_assert(offsetof(AFortPickup, bPickedUp) == 0x000344, "Member 'AFortPickup::bPickedUp' has a wrong offset!");
static_assert(offsetof(AFortPickup, SplineCurve) == 0x000348, "Member 'AFortPickup::SplineCurve' has a wrong offset!");
static_assert(offsetof(AFortPickup, SpawnEffect) == 0x000360, "Member 'AFortPickup::SpawnEffect' has a wrong offset!");
static_assert(offsetof(AFortPickup, LandedSound) == 0x000364, "Member 'AFortPickup::LandedSound' has a wrong offset!");
static_assert(offsetof(AFortPickup, LastLandedSoundPlayTime) == 0x00037C, "Member 'AFortPickup::LastLandedSoundPlayTime' has a wrong offset!");

// Class FortniteGame.FortGameDeathPenalty
// 0x005C (0x0078 - 0x001C)
class UFortGameDeathPenalty final : public UDataAsset
{
public:
	float                                         PercentResourcesToDrop;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentWeaponsToDrop;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentCraftingIngredientsToDrop;                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentConsumablesToDrop;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentAmmoToDrop;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentResourcesToRecover;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentWeaponsToRecover;                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentCraftingIngredientsToRecover;               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentConsumablesToRecover;                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentAmmoToRecover;                              // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinResourcesToKeep;                                // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinWeaponsToKeep;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinCraftingIngredientsToKeep;                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinConsumablesToKeep;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinAmmoToKeep;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   RespawnDelays;                                     // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RespawnDelayOverTime;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRespawnDelay;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRegenHealthOnRespawn;                          // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentHealthOnRespawn;                            // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentStaminaOnRespawn;                           // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameDeathPenalty">();
	}
	static class UFortGameDeathPenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameDeathPenalty>();
	}
};
static_assert(alignof(UFortGameDeathPenalty) == 0x000004, "Wrong alignment on UFortGameDeathPenalty");
static_assert(sizeof(UFortGameDeathPenalty) == 0x000078, "Wrong size on UFortGameDeathPenalty");
static_assert(offsetof(UFortGameDeathPenalty, PercentResourcesToDrop) == 0x00001C, "Member 'UFortGameDeathPenalty::PercentResourcesToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentWeaponsToDrop) == 0x000020, "Member 'UFortGameDeathPenalty::PercentWeaponsToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentCraftingIngredientsToDrop) == 0x000024, "Member 'UFortGameDeathPenalty::PercentCraftingIngredientsToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentConsumablesToDrop) == 0x000028, "Member 'UFortGameDeathPenalty::PercentConsumablesToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentAmmoToDrop) == 0x00002C, "Member 'UFortGameDeathPenalty::PercentAmmoToDrop' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentResourcesToRecover) == 0x000030, "Member 'UFortGameDeathPenalty::PercentResourcesToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentWeaponsToRecover) == 0x000034, "Member 'UFortGameDeathPenalty::PercentWeaponsToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentCraftingIngredientsToRecover) == 0x000038, "Member 'UFortGameDeathPenalty::PercentCraftingIngredientsToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentConsumablesToRecover) == 0x00003C, "Member 'UFortGameDeathPenalty::PercentConsumablesToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentAmmoToRecover) == 0x000040, "Member 'UFortGameDeathPenalty::PercentAmmoToRecover' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinResourcesToKeep) == 0x000044, "Member 'UFortGameDeathPenalty::MinResourcesToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinWeaponsToKeep) == 0x000048, "Member 'UFortGameDeathPenalty::MinWeaponsToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinCraftingIngredientsToKeep) == 0x00004C, "Member 'UFortGameDeathPenalty::MinCraftingIngredientsToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinConsumablesToKeep) == 0x000050, "Member 'UFortGameDeathPenalty::MinConsumablesToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MinAmmoToKeep) == 0x000054, "Member 'UFortGameDeathPenalty::MinAmmoToKeep' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, RespawnDelays) == 0x000058, "Member 'UFortGameDeathPenalty::RespawnDelays' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, RespawnDelayOverTime) == 0x000064, "Member 'UFortGameDeathPenalty::RespawnDelayOverTime' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, MaxRespawnDelay) == 0x000068, "Member 'UFortGameDeathPenalty::MaxRespawnDelay' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, bUseRegenHealthOnRespawn) == 0x00006C, "Member 'UFortGameDeathPenalty::bUseRegenHealthOnRespawn' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentHealthOnRespawn) == 0x000070, "Member 'UFortGameDeathPenalty::PercentHealthOnRespawn' has a wrong offset!");
static_assert(offsetof(UFortGameDeathPenalty, PercentStaminaOnRespawn) == 0x000074, "Member 'UFortGameDeathPenalty::PercentStaminaOnRespawn' has a wrong offset!");

// Class FortniteGame.FortFeedbackManager
// 0x0068 (0x02A8 - 0x0240)
class AFortFeedbackManager : public AActor
{
public:
	TArray<struct FFortFeedbackEventData>         FeedbackEvents;                                    // 0x0240(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortPawn_FeedbackAnnouncer> AnnouncerPawnClass;                                // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPawn_FeedbackAnnouncer*            Announcer;                                         // 0x0250(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AController>>     SuppressedControllers;                             // 0x0254(0x000C)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x48];                                     // 0x0260(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AFortPawn_FeedbackAnnouncer* GetAnnouncerPawn(class UObject* WorldContextObject);
	static class AFortFeedbackManager* GetFeedbackManager(class UObject* WorldContextObject);

	void SuppressProceduralFeedback(const TArray<class AController*>& ControllersToSuppress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFeedbackManager">();
	}
	static class AFortFeedbackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFeedbackManager>();
	}
};
static_assert(alignof(AFortFeedbackManager) == 0x000004, "Wrong alignment on AFortFeedbackManager");
static_assert(sizeof(AFortFeedbackManager) == 0x0002A8, "Wrong size on AFortFeedbackManager");
static_assert(offsetof(AFortFeedbackManager, FeedbackEvents) == 0x000240, "Member 'AFortFeedbackManager::FeedbackEvents' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, AnnouncerPawnClass) == 0x00024C, "Member 'AFortFeedbackManager::AnnouncerPawnClass' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, Announcer) == 0x000250, "Member 'AFortFeedbackManager::Announcer' has a wrong offset!");
static_assert(offsetof(AFortFeedbackManager, SuppressedControllers) == 0x000254, "Member 'AFortFeedbackManager::SuppressedControllers' has a wrong offset!");

// Class FortniteGame.FortIndicator
// 0x0030 (0x004C - 0x001C)
class UFortIndicator : public UObject
{
public:
	struct FVector                                RelativeLocation;                                  // 0x001C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleDistance;                                  // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScaleDistance;                                  // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x10];                                      // 0x003C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIndicator">();
	}
	static class UFortIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIndicator>();
	}
};
static_assert(alignof(UFortIndicator) == 0x000004, "Wrong alignment on UFortIndicator");
static_assert(sizeof(UFortIndicator) == 0x00004C, "Wrong size on UFortIndicator");
static_assert(offsetof(UFortIndicator, RelativeLocation) == 0x00001C, "Member 'UFortIndicator::RelativeLocation' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MaxScale) == 0x000028, "Member 'UFortIndicator::MaxScale' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MinScale) == 0x00002C, "Member 'UFortIndicator::MinScale' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MaxDistance) == 0x000030, "Member 'UFortIndicator::MaxDistance' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MaxScaleDistance) == 0x000034, "Member 'UFortIndicator::MaxScaleDistance' has a wrong offset!");
static_assert(offsetof(UFortIndicator, MinScaleDistance) == 0x000038, "Member 'UFortIndicator::MinScaleDistance' has a wrong offset!");

// Class FortniteGame.FortMiniMapIndicator
// 0x0058 (0x00A4 - 0x004C)
class UFortMiniMapIndicator : public UFortIndicator
{
public:
	uint8                                         Pad_4C[0x58];                                      // 0x004C(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapIndicator">();
	}
	static class UFortMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapIndicator>();
	}
};
static_assert(alignof(UFortMiniMapIndicator) == 0x000004, "Wrong alignment on UFortMiniMapIndicator");
static_assert(sizeof(UFortMiniMapIndicator) == 0x0000A4, "Wrong size on UFortMiniMapIndicator");

// Class FortniteGame.FortAbilityTask_SpawnProjectileAndWait
// 0x014C (0x019C - 0x0050)
class UFortAbilityTask_SpawnProjectileAndWait final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Created;                                           // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Touched;                                           // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Bounced;                                           // 0x0068(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Stopped;                                           // 0x0074(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Exploded;                                          // 0x0080(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Destroyed;                                         // 0x008C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AFortProjectileBase>     SpawnedProj;                                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AActor*                                 RequestedBy;                                       // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnDirection;                                    // 0x00BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnHit;                   // 0x00CC(0x0064)(NativeAccessSpecifierPublic)
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnExplode;               // 0x0130(0x0064)(NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget;                                      // 0x0198(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UFortAbilityTask_SpawnProjectileAndWait* SpawnProjectileAndWait(class UObject* WorldContextObject, TSubclassOf<class AFortProjectileBase> Class_0, class AActor* RequestedBy_0, const struct FVector& SpawnLocation_0, const struct FRotator& SpawnRotation_0, const struct FRotator& SpawnDirection_0, float InitialSpeed_0, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit_0, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode_0, float GravityScale_0, class AActor* HomingTarget_0);

	bool BeginSpawningActor(class UObject* WorldContextObject, TSubclassOf<class AFortProjectileBase> Class_0, class AFortProjectileBase** SpawnedActor);
	void FinishSpawningActor(class UObject* WorldContextObject, class AFortProjectileBase* SpawnedActor);
	void OnProjectileDestroyed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_SpawnProjectileAndWait">();
	}
	static class UFortAbilityTask_SpawnProjectileAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_SpawnProjectileAndWait>();
	}
};
static_assert(alignof(UFortAbilityTask_SpawnProjectileAndWait) == 0x000004, "Wrong alignment on UFortAbilityTask_SpawnProjectileAndWait");
static_assert(sizeof(UFortAbilityTask_SpawnProjectileAndWait) == 0x00019C, "Wrong size on UFortAbilityTask_SpawnProjectileAndWait");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Created) == 0x000050, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Created' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Touched) == 0x00005C, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Touched' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Bounced) == 0x000068, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Bounced' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Stopped) == 0x000074, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Stopped' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Exploded) == 0x000080, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Exploded' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, Destroyed) == 0x00008C, "Member 'UFortAbilityTask_SpawnProjectileAndWait::Destroyed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnedProj) == 0x000098, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnedProj' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, RequestedBy) == 0x0000A0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::RequestedBy' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnLocation) == 0x0000A4, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnLocation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnRotation) == 0x0000B0, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnRotation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, SpawnDirection) == 0x0000BC, "Member 'UFortAbilityTask_SpawnProjectileAndWait::SpawnDirection' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, InitialSpeed) == 0x0000C8, "Member 'UFortAbilityTask_SpawnProjectileAndWait::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, EffectContainerSpecToApplyOnHit) == 0x0000CC, "Member 'UFortAbilityTask_SpawnProjectileAndWait::EffectContainerSpecToApplyOnHit' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, EffectContainerSpecToApplyOnExplode) == 0x000130, "Member 'UFortAbilityTask_SpawnProjectileAndWait::EffectContainerSpecToApplyOnExplode' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, GravityScale) == 0x000194, "Member 'UFortAbilityTask_SpawnProjectileAndWait::GravityScale' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SpawnProjectileAndWait, HomingTarget) == 0x000198, "Member 'UFortAbilityTask_SpawnProjectileAndWait::HomingTarget' has a wrong offset!");

// Class FortniteGame.FortAIEncounterInfoOwnerInterface
// 0x0000 (0x001C - 0x001C)
class IFortAIEncounterInfoOwnerInterface final : public IInterface
{
public:
	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfoOwnerInterface">();
	}
	static class IFortAIEncounterInfoOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterInfoOwnerInterface>();
	}
};
static_assert(alignof(IFortAIEncounterInfoOwnerInterface) == 0x000004, "Wrong alignment on IFortAIEncounterInfoOwnerInterface");
static_assert(sizeof(IFortAIEncounterInfoOwnerInterface) == 0x00001C, "Wrong size on IFortAIEncounterInfoOwnerInterface");

// Class FortniteGame.FortTeamActorInterface
// 0x0000 (0x001C - 0x001C)
class IFortTeamActorInterface final : public IGenericTeamAgentInterface
{
public:
	EFortTeam GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamActorInterface">();
	}
	static class IFortTeamActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTeamActorInterface>();
	}
};
static_assert(alignof(IFortTeamActorInterface) == 0x000004, "Wrong alignment on IFortTeamActorInterface");
static_assert(sizeof(IFortTeamActorInterface) == 0x00001C, "Wrong size on IFortTeamActorInterface");

// Class FortniteGame.FortDamageableActorInterface
// 0x0000 (0x001C - 0x001C)
class IFortDamageableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageableActorInterface">();
	}
	static class IFortDamageableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortDamageableActorInterface>();
	}
};
static_assert(alignof(IFortDamageableActorInterface) == 0x000004, "Wrong alignment on IFortDamageableActorInterface");
static_assert(sizeof(IFortDamageableActorInterface) == 0x00001C, "Wrong size on IFortDamageableActorInterface");

// Class FortniteGame.FortAIGoalProvider
// 0x0010 (0x002C - 0x001C)
class UFortAIGoalProvider : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      AssignmentOwner;                                   // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIEncounterInfo*                   EncounterInfo;                                     // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool InitializeGoalProvider(class UWorld* ContextWorld, class UFortAIAssignment* Assignment);
	void UpdateGoals();

	class UFortAIEncounterInfo* GetEncounterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider">();
	}
	static class UFortAIGoalProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider>();
	}
};
static_assert(alignof(UFortAIGoalProvider) == 0x000004, "Wrong alignment on UFortAIGoalProvider");
static_assert(sizeof(UFortAIGoalProvider) == 0x00002C, "Wrong size on UFortAIGoalProvider");
static_assert(offsetof(UFortAIGoalProvider, World) == 0x000020, "Member 'UFortAIGoalProvider::World' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, AssignmentOwner) == 0x000024, "Member 'UFortAIGoalProvider::AssignmentOwner' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider, EncounterInfo) == 0x000028, "Member 'UFortAIGoalProvider::EncounterInfo' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_PointsInVolume
// 0x0024 (0x0058 - 0x0034)
class UFortQueryGenerator_PointsInVolume final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumberOfPoints;                                    // 0x0034(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFortNamedNavmesh                             NavMeshToUse;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateIn;                                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsInVolume">();
	}
	static class UFortQueryGenerator_PointsInVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsInVolume>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsInVolume) == 0x000004, "Wrong alignment on UFortQueryGenerator_PointsInVolume");
static_assert(sizeof(UFortQueryGenerator_PointsInVolume) == 0x000058, "Wrong size on UFortQueryGenerator_PointsInVolume");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NumberOfPoints) == 0x000034, "Member 'UFortQueryGenerator_PointsInVolume::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, NavMeshToUse) == 0x000050, "Member 'UFortQueryGenerator_PointsInVolume::NavMeshToUse' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsInVolume, GenerateIn) == 0x000054, "Member 'UFortQueryGenerator_PointsInVolume::GenerateIn' has a wrong offset!");

// Class FortniteGame.FortSpottableActorInterface
// 0x0000 (0x001C - 0x001C)
class IFortSpottableActorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpottableActorInterface">();
	}
	static class IFortSpottableActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpottableActorInterface>();
	}
};
static_assert(alignof(IFortSpottableActorInterface) == 0x000004, "Wrong alignment on IFortSpottableActorInterface");
static_assert(sizeof(IFortSpottableActorInterface) == 0x00001C, "Wrong size on IFortSpottableActorInterface");

// Class FortniteGame.FortTargetSelectionInterface
// 0x0000 (0x001C - 0x001C)
class IFortTargetSelectionInterface final : public IInterface
{
public:
	struct FTransform GetTargetingTransform(EFortAbilityTargetingSource Source, class UFortGameplayAbility* SourceAbility) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTargetSelectionInterface">();
	}
	static class IFortTargetSelectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortTargetSelectionInterface>();
	}
};
static_assert(alignof(IFortTargetSelectionInterface) == 0x000004, "Wrong alignment on IFortTargetSelectionInterface");
static_assert(sizeof(IFortTargetSelectionInterface) == 0x00001C, "Wrong size on IFortTargetSelectionInterface");

// Class FortniteGame.FortAbilityTask_PlayMontageWaitTarget
// 0x0078 (0x00C8 - 0x0050)
class UFortAbilityTask_PlayMontageWaitTarget final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Triggered;                                         // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Cancelled;                                         // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Completed;                                         // 0x0068(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortGameplayAbilityMontageInfo        MontageInfo;                                       // 0x0074(0x0044)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageInfoAndWaitForTrigger(class UObject* WorldContextObject, class FName TaskInstanceName, const struct FFortGameplayAbilityMontageInfo& MontageInfo_0);
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageWaitTarget(class UObject* WorldContextObject, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, float AnimPlayRate, EFortGameplayAbilityMontageSectionToPlay SectionToPlay, class FName OverrideSection, float AnimRootMotionTranslationScale);
	static class UFortAbilityTask_PlayMontageWaitTarget* PlayMontageWithCharPartsWait(class UObject* WorldContextObject, class FName TaskInstanceName, class UAnimMontage* MontageToPlay, const TArray<struct FFortCharacterPartMontageInfo>& CharacterPartMontages, float AnimPlayRate, EFortGameplayAbilityMontageSectionToPlay SectionToPlay, class FName OverrideSection, float AnimRootMotionTranslationScale);

	void OnTargetDataCancelledCallback();
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_PlayMontageWaitTarget">();
	}
	static class UFortAbilityTask_PlayMontageWaitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_PlayMontageWaitTarget>();
	}
};
static_assert(alignof(UFortAbilityTask_PlayMontageWaitTarget) == 0x000004, "Wrong alignment on UFortAbilityTask_PlayMontageWaitTarget");
static_assert(sizeof(UFortAbilityTask_PlayMontageWaitTarget) == 0x0000C8, "Wrong size on UFortAbilityTask_PlayMontageWaitTarget");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Triggered) == 0x000050, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Triggered' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Cancelled) == 0x00005C, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Cancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, Completed) == 0x000068, "Member 'UFortAbilityTask_PlayMontageWaitTarget::Completed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_PlayMontageWaitTarget, MontageInfo) == 0x000074, "Member 'UFortAbilityTask_PlayMontageWaitTarget::MontageInfo' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalBase
// 0x0010 (0x011C - 0x010C)
class UFortQueryTest_GoalBase : public UEnvQueryTest
{
public:
	uint8                                         bScoreEnemies : 1;                                 // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bScoreEncounterGoals : 1;                          // 0x010C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bScoreWorldGoals : 1;                              // 0x010C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bScoreSpecificAssignments : 1;                     // 0x010C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIAssignmentIdentifier>    AssignmentIDs;                                     // 0x0110(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalBase">();
	}
	static class UFortQueryTest_GoalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalBase>();
	}
};
static_assert(alignof(UFortQueryTest_GoalBase) == 0x000004, "Wrong alignment on UFortQueryTest_GoalBase");
static_assert(sizeof(UFortQueryTest_GoalBase) == 0x00011C, "Wrong size on UFortQueryTest_GoalBase");
static_assert(offsetof(UFortQueryTest_GoalBase, AssignmentIDs) == 0x000110, "Member 'UFortQueryTest_GoalBase::AssignmentIDs' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalDiscouragement
// 0x001C (0x0138 - 0x011C)
class UFortQueryTest_GoalDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderBoolValue               DisableDiscouragementWhenUndermining;              // 0x011C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDiscouragement">();
	}
	static class UFortQueryTest_GoalDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDiscouragement) == 0x000004, "Wrong alignment on UFortQueryTest_GoalDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalDiscouragement) == 0x000138, "Wrong size on UFortQueryTest_GoalDiscouragement");
static_assert(offsetof(UFortQueryTest_GoalDiscouragement, DisableDiscouragementWhenUndermining) == 0x00011C, "Member 'UFortQueryTest_GoalDiscouragement::DisableDiscouragementWhenUndermining' has a wrong offset!");

// Class FortniteGame.FortPawn
// 0x0350 (0x0860 - 0x0510)
#pragma pack(push, 0x1)
class alignas(0x10) AFortPawn : public ACharacter
{
public:
	uint8                                         Pad_50C[0x24];                                     // 0x050C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    PawnStatHandle;                                    // 0x0530(0x000C)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlidingFriction;                                   // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlidingBrakingDeceleration;                        // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortMovementStyle                            CurrentMovementStyle;                              // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBaseChanged;                                   // 0x0549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54A[0x2];                                      // 0x054A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnUniqueID;                                      // 0x054C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortWeapon*                            CurrentWeapon;                                     // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortWeapon*>                    CurrentWeaponList;                                 // 0x0554(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0560(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDirection;                                 // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedMovementDirection;                         // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedMovementDirectionInterpSpeed;              // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSmoothedMovementDirection;                     // 0x0570(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedMovementDirectionRate;                     // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRateUpdateTime;                                // 0x0578(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastYawRotation;                                   // 0x057C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationRate;                                   // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingStartedZ;                                   // 0x0584(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreNextFallingDamage;                          // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandSocketName;                              // 0x058C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnSpot;                                         // 0x0594(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitch;                                          // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DeathTags;                                         // 0x059C(0x0018)(Transient, NativeAccessSpecifierPublic)
	float                                         SpawnImmunityTime;                                 // 0x05B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDying;                                          // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenForDeath;                                 // 0x05B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BA[0x2];                                      // 0x05BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeRange;                                        // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastMeleeTime;                                     // 0x05C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKnockedback;                                    // 0x05C4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsStunned;                                        // 0x05C5(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C6[0x2];                                      // 0x05C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AdditiveCringeCount;                               // 0x05C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveCringeDuration;                            // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    PushMomentum;                                      // 0x05D0(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x3C];                                     // 0x05DC(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    DeathHitSocket;                                    // 0x0618(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPostRenderTraceTime;                           // 0x061C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostRenderTraceSucceeded;                         // 0x0620(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x3];                                      // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamBeaconMaxDist;                                 // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TeamBeaconTextColor;                               // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastTakeHitTimeTimeout;                            // 0x062C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDamagedTime;                                   // 0x0630(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortWeapon*                            CurrentlyAttachedWeapon;                           // 0x0634(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    CachedNavFloor;                                    // 0x0638(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFootstepDistance;                               // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultFootstepSound;                              // 0x0640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultFastFootstepSound;                          // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultLandingSound;                               // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultHardLandingSound;                           // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DefaultJumpSound;                                  // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCapsuleBeUsedForTargeting;                     // 0x0654(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPawnDamageZones                       DamageZones[0x4];                                  // 0x0658(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         DamageZoneActiveBitMask;                           // 0x0698(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_699[0x3];                                      // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPawnLanded;                                      // 0x069C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitPawn;                                         // 0x06A8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDied;                                            // 0x06B4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDeathEffects;                                    // 0x06C0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CC[0x38];                                     // 0x06CC(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x0704(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWeaponEquippedDelegate;                          // 0x0710(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_71C[0xC];                                      // 0x071C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponHolsterCounter;                              // 0x0728(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWeaponHolstered;                                  // 0x072C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_72D[0x3];                                      // 0x072D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaySpottedTime;                                   // 0x0730(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpottedEvent;                                      // 0x0734(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSpotted : 1;                                      // 0x073C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_73D[0x3];                                      // 0x073D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortFeedbackBank*                      DefaultFeedback;                                   // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortPawnVocalChord>            VocalChords;                                       // 0x0744(0x000C)(Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_750[0x4];                                      // 0x0750(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortHealthSet*                         HealthSet;                                         // 0x0754(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDamageSet*                         DamageSet;                                         // 0x0758(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMovementSet*                       MovementSet;                                       // 0x075C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHealthSynced;                                     // 0x0760(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAbilityDecisionWindowStackUpdated;               // 0x0764(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0770(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortActiveMontageDecisionWindow> DecisionWindowStack;                               // 0x0774(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrimaryInputHeld;                                 // 0x0780(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSecondaryInputHeld;                               // 0x0781(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPrimaryInputQueued;                               // 0x0782(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_783[0x1];                                      // 0x0783(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0784(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x079C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDamagerInfo>                   Damagers;                                          // 0x07A8(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UFortHealthBarIndicator*                HealthBarIndicator;                                // 0x07B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthBarHeightMultiplier;                         // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            SpottedBrush;                                      // 0x07BC(0x0074)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpottedDuration;                                   // 0x0830(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SpottedIconOffset;                                 // 0x0834(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0x1C];                                     // 0x0840(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AlignRotationTo4WaysHitReaction(const struct FVector& HitDirection, float FrontOffset, float BackOffset, float LeftOffset, float RightOffset);
	void AlignRotationToHitDirection(const struct FVector& HitDirection);
	bool AnimMontage_LocalJumpToSectionName(class FName SectionName);
	void AnimMontage_LocalSetNextSectionName(class UAnimMontage* AnimMontage, class FName SectionName, class FName NextSectionName);
	void ApplyKnockback(float KnockbackMagnitude, float KnockbackZAngle, const struct FVector& ImpulseDir);
	void AttachAssetToSocket(const struct FAssetAttachment& InAttachment);
	void ClientInternalEquipWeapon(class AFortWeapon* Weap);
	void DetachAssetFromSocket(class FName SocketName);
	void DoFatalDamage(class UAbilitySystemComponent* KillerAbilitySystemComponent);
	void ForceKill(const struct FGameplayTag& DeathReason, class AController* KillerController, class AActor* KillerActor);
	void GameplayCue(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_InstantDeath(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	class USkeletalMeshComponent* GetAssetSkeletalMeshComponentAttachment(class FName SocketName);
	class UStaticMeshComponent* GetAssetStaticMeshComponentAttachment(class FName SocketName);
	float GetCurrentFeedbackDuration();
	float GetCurrentMontageSectionTimeLeft();
	class UAudioComponent* GetFeedbackAudioComponent();
	float GetHealthPercent();
	class AActor* GetMyMovementBaseActor();
	class UMaterialInstanceDynamic* GetPawnMID(int32 ElementIndex);
	void HandleIsDying();
	void HandleIsHiddenForDeath();
	void HideBodyOnDeath();
	void HoldAnimationFrames(float StartTime, float HoldTime);
	void InitializeDeathHitSocket(const struct FVector& WorldLocation, const struct FVector& WorldNormal);
	void OnBaseChanged(class AActor* NewBase);
	void OnBumpPushedPawn(class AFortPawn* InstigatedBy, float PushTimeLeft);
	void OnDamagePlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageZoneStatusChanged(EFortDamageZone Zone, bool bStatus);
	void OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnRep_bWeaponHolstered();
	void OnRep_CurrentWeapon();
	void OnRep_DamageZoneActiveBitMask();
	void OnRep_PawnUniqueID();
	void OnRep_PushMomentum();
	void OnRep_VocalChords();
	void OnStunned();
	void OnStunnedEffectBegin();
	void OnStunnedEffectEnd();
	void OnWeaponEquipped(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon);
	void PawnUniqueIDSet();
	bool PickUpActor(class AActor* PickupTarget, class UFortDecoItemDefinition* PlacementDecoItemDefinition);
	void PlayFootStepSound(int32 FootDown);
	void PlayHitReactionAdditiveCringe();
	float PlayLocalAnimMontage(class UAnimMontage* NewAnimMontage, float InPlayRate, class FName StartSectionName);
	void PlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
	void PrototypeCharacterMovement(EMovementMode MovementMode, const struct FVector& LaunchVelocity);
	void ServerInternalEquipWeapon(class AFortWeapon* Weap);
	void ServerTeleportNearLocation(const struct FVector& ActorLocation);
	void SetDamageZoneActiveStatus(EFortDamageZone Zone, bool bActive);
	void SetFNameBasedOnHitDirection(const struct FVector& HitDirection, class FName* NameResult, class FName NameFront, class FName NameBack, class FName NameLeft, class FName NameRight);
	void SetHealth(float NewHealthVal);
	void SetHolsterWeapon(bool bHolster);
	void SetPawnAndControlRotation(const struct FRotator& NewRotation);
	void SetPawnVisibility(bool bNewHidden);
	void StartPushMomentum(const struct FVector& NewPushMomentum, float Duration);
	bool StealFromActor(class AFortPawn* PawnToStealFrom);
	void StopPushMomentum();
	void TriggerFeedbackEvent(class FName EventName, class AFortPawn* InstigatorPawn, class AFortPawn* Recipient, float OverriddenDelay);

	struct FGameplayTag GetAbilityDecisionWindowTriggerTag(bool bPrimaryInput) const;
	EFortDamageZone GetDamageZone(class FName BoneName) const;
	struct FVector GetDefaultTargetingOrigin() const;
	struct FRotator GetDefaultTargetingRotation() const;
	class UFortAIEncounterInfo* GetEncounterInfo() const;
	float GetHealth() const;
	float GetMaxHealth() const;
	float GetMaxShield() const;
	int32 GetMeleeComboCounter() const;
	float GetMeleeRange() const;
	float GetMeleeReticleStrikeAngle(bool bPrimaryInput) const;
	struct FVector GetMovementPredictionPosition(float PredictionDeltaTime) const;
	float GetShield() const;
	void GetSphericalHitDirection(const struct FVector& HitDirection, float* Azimuth, float* Elevation) const;
	struct FTransform GetTargetingTransform(EFortAbilityTargetingSource Source, class UFortGameplayAbility* SourceAbility) const;
	bool HasCurrentMontage() const;
	bool IsDamageZoneActive(EFortDamageZone Zone) const;
	bool IsDead() const;
	bool IsFrontalHit(const struct FVector& HitDirection) const;
	bool IsWeaponHolstered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn">();
	}
	static class AFortPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn>();
	}
};
#pragma pack(pop)
static_assert(alignof(AFortPawn) == 0x000010, "Wrong alignment on AFortPawn");
static_assert(sizeof(AFortPawn) == 0x000860, "Wrong size on AFortPawn");
static_assert(offsetof(AFortPawn, PawnStatHandle) == 0x000530, "Member 'AFortPawn::PawnStatHandle' has a wrong offset!");
static_assert(offsetof(AFortPawn, SlidingFriction) == 0x000540, "Member 'AFortPawn::SlidingFriction' has a wrong offset!");
static_assert(offsetof(AFortPawn, SlidingBrakingDeceleration) == 0x000544, "Member 'AFortPawn::SlidingBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentMovementStyle) == 0x000548, "Member 'AFortPawn::CurrentMovementStyle' has a wrong offset!");
static_assert(offsetof(AFortPawn, bUseBaseChanged) == 0x000549, "Member 'AFortPawn::bUseBaseChanged' has a wrong offset!");
static_assert(offsetof(AFortPawn, PawnUniqueID) == 0x00054C, "Member 'AFortPawn::PawnUniqueID' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentWeapon) == 0x000550, "Member 'AFortPawn::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentWeaponList) == 0x000554, "Member 'AFortPawn::CurrentWeaponList' has a wrong offset!");
static_assert(offsetof(AFortPawn, Health) == 0x000560, "Member 'AFortPawn::Health' has a wrong offset!");
static_assert(offsetof(AFortPawn, MovementDirection) == 0x000564, "Member 'AFortPawn::MovementDirection' has a wrong offset!");
static_assert(offsetof(AFortPawn, SmoothedMovementDirection) == 0x000568, "Member 'AFortPawn::SmoothedMovementDirection' has a wrong offset!");
static_assert(offsetof(AFortPawn, SmoothedMovementDirectionInterpSpeed) == 0x00056C, "Member 'AFortPawn::SmoothedMovementDirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastSmoothedMovementDirection) == 0x000570, "Member 'AFortPawn::LastSmoothedMovementDirection' has a wrong offset!");
static_assert(offsetof(AFortPawn, SmoothedMovementDirectionRate) == 0x000574, "Member 'AFortPawn::SmoothedMovementDirectionRate' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastRateUpdateTime) == 0x000578, "Member 'AFortPawn::LastRateUpdateTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastYawRotation) == 0x00057C, "Member 'AFortPawn::LastYawRotation' has a wrong offset!");
static_assert(offsetof(AFortPawn, YawRotationRate) == 0x000580, "Member 'AFortPawn::YawRotationRate' has a wrong offset!");
static_assert(offsetof(AFortPawn, FallingStartedZ) == 0x000584, "Member 'AFortPawn::FallingStartedZ' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIgnoreNextFallingDamage) == 0x000588, "Member 'AFortPawn::bIgnoreNextFallingDamage' has a wrong offset!");
static_assert(offsetof(AFortPawn, WeaponHandSocketName) == 0x00058C, "Member 'AFortPawn::WeaponHandSocketName' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpawnSpot) == 0x000594, "Member 'AFortPawn::SpawnSpot' has a wrong offset!");
static_assert(offsetof(AFortPawn, AimPitch) == 0x000598, "Member 'AFortPawn::AimPitch' has a wrong offset!");
static_assert(offsetof(AFortPawn, DeathTags) == 0x00059C, "Member 'AFortPawn::DeathTags' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpawnImmunityTime) == 0x0005B4, "Member 'AFortPawn::SpawnImmunityTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsDying) == 0x0005B8, "Member 'AFortPawn::bIsDying' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsHiddenForDeath) == 0x0005B9, "Member 'AFortPawn::bIsHiddenForDeath' has a wrong offset!");
static_assert(offsetof(AFortPawn, MeleeRange) == 0x0005BC, "Member 'AFortPawn::MeleeRange' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastMeleeTime) == 0x0005C0, "Member 'AFortPawn::LastMeleeTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsKnockedback) == 0x0005C4, "Member 'AFortPawn::bIsKnockedback' has a wrong offset!");
static_assert(offsetof(AFortPawn, bIsStunned) == 0x0005C5, "Member 'AFortPawn::bIsStunned' has a wrong offset!");
static_assert(offsetof(AFortPawn, AdditiveCringeCount) == 0x0005C8, "Member 'AFortPawn::AdditiveCringeCount' has a wrong offset!");
static_assert(offsetof(AFortPawn, AdditiveCringeDuration) == 0x0005CC, "Member 'AFortPawn::AdditiveCringeDuration' has a wrong offset!");
static_assert(offsetof(AFortPawn, PushMomentum) == 0x0005D0, "Member 'AFortPawn::PushMomentum' has a wrong offset!");
static_assert(offsetof(AFortPawn, DeathHitSocket) == 0x000618, "Member 'AFortPawn::DeathHitSocket' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastPostRenderTraceTime) == 0x00061C, "Member 'AFortPawn::LastPostRenderTraceTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPostRenderTraceSucceeded) == 0x000620, "Member 'AFortPawn::bPostRenderTraceSucceeded' has a wrong offset!");
static_assert(offsetof(AFortPawn, TeamBeaconMaxDist) == 0x000624, "Member 'AFortPawn::TeamBeaconMaxDist' has a wrong offset!");
static_assert(offsetof(AFortPawn, TeamBeaconTextColor) == 0x000628, "Member 'AFortPawn::TeamBeaconTextColor' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastTakeHitTimeTimeout) == 0x00062C, "Member 'AFortPawn::LastTakeHitTimeTimeout' has a wrong offset!");
static_assert(offsetof(AFortPawn, LastDamagedTime) == 0x000630, "Member 'AFortPawn::LastDamagedTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, CurrentlyAttachedWeapon) == 0x000634, "Member 'AFortPawn::CurrentlyAttachedWeapon' has a wrong offset!");
static_assert(offsetof(AFortPawn, CachedNavFloor) == 0x000638, "Member 'AFortPawn::CachedNavFloor' has a wrong offset!");
static_assert(offsetof(AFortPawn, MaxFootstepDistance) == 0x00063C, "Member 'AFortPawn::MaxFootstepDistance' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFootstepSound) == 0x000640, "Member 'AFortPawn::DefaultFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFastFootstepSound) == 0x000644, "Member 'AFortPawn::DefaultFastFootstepSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultLandingSound) == 0x000648, "Member 'AFortPawn::DefaultLandingSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultHardLandingSound) == 0x00064C, "Member 'AFortPawn::DefaultHardLandingSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultJumpSound) == 0x000650, "Member 'AFortPawn::DefaultJumpSound' has a wrong offset!");
static_assert(offsetof(AFortPawn, bCanCapsuleBeUsedForTargeting) == 0x000654, "Member 'AFortPawn::bCanCapsuleBeUsedForTargeting' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageZones) == 0x000658, "Member 'AFortPawn::DamageZones' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageZoneActiveBitMask) == 0x000698, "Member 'AFortPawn::DamageZoneActiveBitMask' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnPawnLanded) == 0x00069C, "Member 'AFortPawn::OnPawnLanded' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnHitPawn) == 0x0006A8, "Member 'AFortPawn::OnHitPawn' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDied) == 0x0006B4, "Member 'AFortPawn::OnDied' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDeathEffects) == 0x0006C0, "Member 'AFortPawn::OnDeathEffects' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnDamaged) == 0x000704, "Member 'AFortPawn::OnDamaged' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnWeaponEquippedDelegate) == 0x000710, "Member 'AFortPawn::OnWeaponEquippedDelegate' has a wrong offset!");
static_assert(offsetof(AFortPawn, WeaponHolsterCounter) == 0x000728, "Member 'AFortPawn::WeaponHolsterCounter' has a wrong offset!");
static_assert(offsetof(AFortPawn, bWeaponHolstered) == 0x00072C, "Member 'AFortPawn::bWeaponHolstered' has a wrong offset!");
static_assert(offsetof(AFortPawn, StaySpottedTime) == 0x000730, "Member 'AFortPawn::StaySpottedTime' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedEvent) == 0x000734, "Member 'AFortPawn::SpottedEvent' has a wrong offset!");
static_assert(offsetof(AFortPawn, DefaultFeedback) == 0x000740, "Member 'AFortPawn::DefaultFeedback' has a wrong offset!");
static_assert(offsetof(AFortPawn, VocalChords) == 0x000744, "Member 'AFortPawn::VocalChords' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthSet) == 0x000754, "Member 'AFortPawn::HealthSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, DamageSet) == 0x000758, "Member 'AFortPawn::DamageSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, MovementSet) == 0x00075C, "Member 'AFortPawn::MovementSet' has a wrong offset!");
static_assert(offsetof(AFortPawn, bHealthSynced) == 0x000760, "Member 'AFortPawn::bHealthSynced' has a wrong offset!");
static_assert(offsetof(AFortPawn, OnAbilityDecisionWindowStackUpdated) == 0x000764, "Member 'AFortPawn::OnAbilityDecisionWindowStackUpdated' has a wrong offset!");
static_assert(offsetof(AFortPawn, AbilitySystemComponent) == 0x000770, "Member 'AFortPawn::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortPawn, DecisionWindowStack) == 0x000774, "Member 'AFortPawn::DecisionWindowStack' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPrimaryInputHeld) == 0x000780, "Member 'AFortPawn::bPrimaryInputHeld' has a wrong offset!");
static_assert(offsetof(AFortPawn, bSecondaryInputHeld) == 0x000781, "Member 'AFortPawn::bSecondaryInputHeld' has a wrong offset!");
static_assert(offsetof(AFortPawn, bPrimaryInputQueued) == 0x000782, "Member 'AFortPawn::bPrimaryInputQueued' has a wrong offset!");
static_assert(offsetof(AFortPawn, GameplayTags) == 0x000784, "Member 'AFortPawn::GameplayTags' has a wrong offset!");
static_assert(offsetof(AFortPawn, DisplayName) == 0x00079C, "Member 'AFortPawn::DisplayName' has a wrong offset!");
static_assert(offsetof(AFortPawn, Damagers) == 0x0007A8, "Member 'AFortPawn::Damagers' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthBarIndicator) == 0x0007B4, "Member 'AFortPawn::HealthBarIndicator' has a wrong offset!");
static_assert(offsetof(AFortPawn, HealthBarHeightMultiplier) == 0x0007B8, "Member 'AFortPawn::HealthBarHeightMultiplier' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedBrush) == 0x0007BC, "Member 'AFortPawn::SpottedBrush' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedDuration) == 0x000830, "Member 'AFortPawn::SpottedDuration' has a wrong offset!");
static_assert(offsetof(AFortPawn, SpottedIconOffset) == 0x000834, "Member 'AFortPawn::SpottedIconOffset' has a wrong offset!");

// Class FortniteGame.FortCarriedObjectHolderInterface
// 0x0000 (0x001C - 0x001C)
class IFortCarriedObjectHolderInterface final : public IInterface
{
public:
	void OnCarriedObjectAttach(class AActor* AttachedObject);
	void OnCarriedObjectDetach(class AActor* DetachedObject);

	bool CanHoldObject(class AActor* CarriableObject) const;
	class USceneComponent* GetAttachmentComponent(class FName SocketName) const;
	void GetCarriedObjectAttachmentInfo(struct FCarriedObjectAttachmentInfo* OutAttachInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObjectHolderInterface">();
	}
	static class IFortCarriedObjectHolderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortCarriedObjectHolderInterface>();
	}
};
static_assert(alignof(IFortCarriedObjectHolderInterface) == 0x000004, "Wrong alignment on IFortCarriedObjectHolderInterface");
static_assert(sizeof(IFortCarriedObjectHolderInterface) == 0x00001C, "Wrong size on IFortCarriedObjectHolderInterface");

// Class FortniteGame.FortAIDirector
// 0x0700 (0x0940 - 0x0240)
class AFortAIDirector final : public AActor
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   MaxAliveCurve;                                     // 0x0248(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinAliveCurve;                                     // 0x0254(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FIntensityData                         IntensityInfo;                                     // 0x0260(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          AIDirectorPIDController;                           // 0x0280(0x0058)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDControllerSettings  PIDControllerSettings;                             // 0x02D8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FUtilityData                           UtilityContributionData[0x10];                     // 0x02FC(0x0038)(Edit, NativeAccessSpecifierPublic)
	float                                         UnreachableLocationPathCost;                       // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortPlayerPerformanceEstimateSettings PlayerPerformanceEstimateSettings;                 // 0x0680(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bUsePrototypeEnemies : 1;                          // 0x06B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortEncounterDirection>               DebugEncounterDirections;                          // 0x06B4(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         BurstSpawnThreatVisualsEndDelay;                   // 0x06C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterSpawnGroupCapsProfile> EncounterSpawnGroupCapSettings;                    // 0x06C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIEncounterSpawnPointsProfile> EncounterSpawnPointsSettings;                      // 0x06D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DiscreteEncounterUtilityDesireMappings[0x4];       // 0x06DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortAIUtility                                InitialDynamicUtilities[0x4];                      // 0x06EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEncounterEnvironmentQueryInfo         SpawnLocationPlacementQueries[0x4];                // 0x06F0(0x001C)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UFortAIDirectorDataTrackingSettings*    DataTrackingSettings;                              // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugEncounterQueries : 1;                        // 0x0764(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_765[0x3];                                      // 0x0765(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortEncounterPawnNumberCaps           DefaultEncounterPawnCaps;                          // 0x0768(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x18];                                     // 0x0778(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UReporterGraph*                         IntensityGraph;                                    // 0x0790(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         UtilitiesGraph;                                    // 0x0794(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDValuesGraph;                                    // 0x0798(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDContributionsGraph;                             // 0x079C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNightActive : 1;                                  // 0x07A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAIDisabled : 1;                                   // 0x07A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x07A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseSpawnCap : 1;                                  // 0x07A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_7A1[0x3];                                      // 0x07A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NightCount;                                        // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABuildingRift*>                  RiftSpawnPoints;                                   // 0x07A8(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         NightEncounterFailureBreatherTime;                 // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterPawnSpawnInterval;                        // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DefaultNightEncounter;                             // 0x07BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       DummyDebugEncounter;                               // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortAIEncounterInfo>       BaseEncounterClass;                                // 0x07C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxActiveAlive;                                    // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActiveAlive;                                    // 0x07CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumActiveDormant;                                  // 0x07D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D4[0x3C];                                     // 0x07D4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPendingSpawnInfo>              PendingSpawns;                                     // 0x0810(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AFortAIPawn>>     PendingDespawns;                                   // 0x081C(0x000C)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FDormantSpawnInfo>              DormantSpawnSets;                                  // 0x0828(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DormantClusterRadius;                              // 0x0834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DormantSpawnPointTags;                             // 0x0838(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DormantSpawnModifierTags;                          // 0x0850(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinAISpawnDistanceFromPlayers;                     // 0x0868(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumDormantAlive;                                   // 0x086C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AFortPlacementActor*>            DormantSpawnPoints;                                // 0x0870(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterInfo*>           ActiveEncounters;                                  // 0x087C(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDefaultEncounter;                            // 0x0888(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   ActiveDummyDebugEncounter;                         // 0x088C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAIEncounterSequence*>       EncounterSequences;                                // 0x0890(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UEQSRenderingComponent*                 EQSRenderingComp;                                  // 0x089C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugGraphUpdateFrequency;                         // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalLODDistanceToPlayer;                      // 0x08A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIRelevantDistanceToPlayer;                        // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterRelevantDistanceToPlayer;                 // 0x08AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B0[0x40];                                     // 0x08B0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TScriptInterface<class IFortPatrolWardInterface>> PatrolWards;                                       // 0x08F0(0x000C)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTotalActiveAliveAI;                             // 0x0900(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterActiveAliveAI;                         // 0x0904(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSPUsed;                                         // 0x0908(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90C[0x4];                                      // 0x090C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          DebugEncounterTopUtilityPercentages;               // 0x0910(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveFloat*>                    DebugEncounterSpawnPointsCurves;                   // 0x091C(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         SimulatedNumberOfPlayersForAIEncounters;           // 0x0928(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_92C[0x14];                                     // 0x092C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ShouldSpawnGuardians();

	void Activate();
	void Deactivate();
	class ABuildingRift* GetClosestRift(const struct FVector& TestPosition, float MinDistance, float MaxDistance);
	int32 GetNumPlayers();
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnDirectorDeactivated();
	void OnFadeStarted();
	void OnPawnDied(class AFortAIPawn* KilledPawn);
	void OnPeakStarted();
	void OnPlayerDied(class AFortPlayerPawn* PlayerPawn);
	void OnPlayerSpawn(class AFortPlayerPawn* PlayerPawn);
	void OnRampStarted();
	void OnReadyToSpawnGuardians(const TArray<class ABuildingContainer*>& BuildingContainersToGuard);
	void OnRestStarted();
	void OnStartSpawningPATrolls();
	void OnStopSpawningPATrolls();
	void PostDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void ReceivePawnSpawned(class AFortPawn* SpawnedPawn);
	void RegisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);
	void UnregisterPatrolWard(TScriptInterface<class IFortPatrolWardInterface> PatrolWard);

	bool IsAnyActiveEncounterRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyAIRelevantToPlayer(class AFortPlayerPawn* Player) const;
	bool IsAnyEncounterGoalWithinDistanceOfPoint(const struct FVector& Point, float Distance, bool bOnlyActiveEncounters) const;
	bool IsLineTooCloseToPatrolWards(const struct FVector& LineStart, const struct FVector& LineEnd) const;
	bool IsPointTooCloseToPatrolWards(const struct FVector& Point, const EWardAffectType WardEffectTypeFilter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirector">();
	}
	static class AFortAIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirector>();
	}
};
static_assert(alignof(AFortAIDirector) == 0x000004, "Wrong alignment on AFortAIDirector");
static_assert(sizeof(AFortAIDirector) == 0x000940, "Wrong size on AFortAIDirector");
static_assert(offsetof(AFortAIDirector, MaxAliveCurve) == 0x000248, "Member 'AFortAIDirector::MaxAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAliveCurve) == 0x000254, "Member 'AFortAIDirector::MinAliveCurve' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityInfo) == 0x000260, "Member 'AFortAIDirector::IntensityInfo' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIDirectorPIDController) == 0x000280, "Member 'AFortAIDirector::AIDirectorPIDController' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDControllerSettings) == 0x0002D8, "Member 'AFortAIDirector::PIDControllerSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilityContributionData) == 0x0002FC, "Member 'AFortAIDirector::UtilityContributionData' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UnreachableLocationPathCost) == 0x00067C, "Member 'AFortAIDirector::UnreachableLocationPathCost' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PlayerPerformanceEstimateSettings) == 0x000680, "Member 'AFortAIDirector::PlayerPerformanceEstimateSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterDirections) == 0x0006B4, "Member 'AFortAIDirector::DebugEncounterDirections' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BurstSpawnThreatVisualsEndDelay) == 0x0006C0, "Member 'AFortAIDirector::BurstSpawnThreatVisualsEndDelay' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnGroupCapSettings) == 0x0006C4, "Member 'AFortAIDirector::EncounterSpawnGroupCapSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSpawnPointsSettings) == 0x0006D0, "Member 'AFortAIDirector::EncounterSpawnPointsSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DiscreteEncounterUtilityDesireMappings) == 0x0006DC, "Member 'AFortAIDirector::DiscreteEncounterUtilityDesireMappings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, InitialDynamicUtilities) == 0x0006EC, "Member 'AFortAIDirector::InitialDynamicUtilities' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SpawnLocationPlacementQueries) == 0x0006F0, "Member 'AFortAIDirector::SpawnLocationPlacementQueries' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DataTrackingSettings) == 0x000760, "Member 'AFortAIDirector::DataTrackingSettings' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultEncounterPawnCaps) == 0x000768, "Member 'AFortAIDirector::DefaultEncounterPawnCaps' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, IntensityGraph) == 0x000790, "Member 'AFortAIDirector::IntensityGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, UtilitiesGraph) == 0x000794, "Member 'AFortAIDirector::UtilitiesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDValuesGraph) == 0x000798, "Member 'AFortAIDirector::PIDValuesGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PIDContributionsGraph) == 0x00079C, "Member 'AFortAIDirector::PIDContributionsGraph' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightCount) == 0x0007A4, "Member 'AFortAIDirector::NightCount' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, RiftSpawnPoints) == 0x0007A8, "Member 'AFortAIDirector::RiftSpawnPoints' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NightEncounterFailureBreatherTime) == 0x0007B4, "Member 'AFortAIDirector::NightEncounterFailureBreatherTime' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterPawnSpawnInterval) == 0x0007B8, "Member 'AFortAIDirector::EncounterPawnSpawnInterval' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DefaultNightEncounter) == 0x0007BC, "Member 'AFortAIDirector::DefaultNightEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DummyDebugEncounter) == 0x0007C0, "Member 'AFortAIDirector::DummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, BaseEncounterClass) == 0x0007C4, "Member 'AFortAIDirector::BaseEncounterClass' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxActiveAlive) == 0x0007C8, "Member 'AFortAIDirector::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumActiveAlive) == 0x0007CC, "Member 'AFortAIDirector::NumActiveAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumActiveDormant) == 0x0007D0, "Member 'AFortAIDirector::NumActiveDormant' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingSpawns) == 0x000810, "Member 'AFortAIDirector::PendingSpawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PendingDespawns) == 0x00081C, "Member 'AFortAIDirector::PendingDespawns' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DormantSpawnSets) == 0x000828, "Member 'AFortAIDirector::DormantSpawnSets' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DormantClusterRadius) == 0x000834, "Member 'AFortAIDirector::DormantClusterRadius' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DormantSpawnPointTags) == 0x000838, "Member 'AFortAIDirector::DormantSpawnPointTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DormantSpawnModifierTags) == 0x000850, "Member 'AFortAIDirector::DormantSpawnModifierTags' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MinAISpawnDistanceFromPlayers) == 0x000868, "Member 'AFortAIDirector::MinAISpawnDistanceFromPlayers' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, NumDormantAlive) == 0x00086C, "Member 'AFortAIDirector::NumDormantAlive' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DormantSpawnPoints) == 0x000870, "Member 'AFortAIDirector::DormantSpawnPoints' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveEncounters) == 0x00087C, "Member 'AFortAIDirector::ActiveEncounters' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDefaultEncounter) == 0x000888, "Member 'AFortAIDirector::ActiveDefaultEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, ActiveDummyDebugEncounter) == 0x00088C, "Member 'AFortAIDirector::ActiveDummyDebugEncounter' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterSequences) == 0x000890, "Member 'AFortAIDirector::EncounterSequences' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EQSRenderingComp) == 0x00089C, "Member 'AFortAIDirector::EQSRenderingComp' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugGraphUpdateFrequency) == 0x0008A0, "Member 'AFortAIDirector::DebugGraphUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxNormalLODDistanceToPlayer) == 0x0008A4, "Member 'AFortAIDirector::MaxNormalLODDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, AIRelevantDistanceToPlayer) == 0x0008A8, "Member 'AFortAIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, EncounterRelevantDistanceToPlayer) == 0x0008AC, "Member 'AFortAIDirector::EncounterRelevantDistanceToPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, PatrolWards) == 0x0008F0, "Member 'AFortAIDirector::PatrolWards' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxTotalActiveAliveAI) == 0x000900, "Member 'AFortAIDirector::MaxTotalActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxEncounterActiveAliveAI) == 0x000904, "Member 'AFortAIDirector::MaxEncounterActiveAliveAI' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, MaxSPUsed) == 0x000908, "Member 'AFortAIDirector::MaxSPUsed' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterTopUtilityPercentages) == 0x000910, "Member 'AFortAIDirector::DebugEncounterTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, DebugEncounterSpawnPointsCurves) == 0x00091C, "Member 'AFortAIDirector::DebugEncounterSpawnPointsCurves' has a wrong offset!");
static_assert(offsetof(AFortAIDirector, SimulatedNumberOfPlayersForAIEncounters) == 0x000928, "Member 'AFortAIDirector::SimulatedNumberOfPlayersForAIEncounters' has a wrong offset!");

// Class FortniteGame.FortAttributeSet
// 0x0000 (0x0020 - 0x0020)
class UFortAttributeSet : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeSet">();
	}
	static class UFortAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeSet>();
	}
};
static_assert(alignof(UFortAttributeSet) == 0x000004, "Wrong alignment on UFortAttributeSet");
static_assert(sizeof(UFortAttributeSet) == 0x000020, "Wrong size on UFortAttributeSet");

// Class FortniteGame.FortHealthSet
// 0x00D0 (0x00F0 - 0x0020)
class UFortHealthSet : public UFortAttributeSet
{
public:
	float                                         Health;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentShield;                                     // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shield;                                            // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistance;                                  // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectDamageAbsolute;                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReflectDamageFromSource;                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldDamage;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingSource;                                     // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealingBonusTarget;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Healing;                                           // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0xA0];                                      // 0x0050(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentShield();
	void OnRep_Health();
	void OnRep_MaxHealth();
	void OnRep_Shield();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthSet">();
	}
	static class UFortHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthSet>();
	}
};
static_assert(alignof(UFortHealthSet) == 0x000004, "Wrong alignment on UFortHealthSet");
static_assert(sizeof(UFortHealthSet) == 0x0000F0, "Wrong size on UFortHealthSet");
static_assert(offsetof(UFortHealthSet, Health) == 0x000020, "Member 'UFortHealthSet::Health' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, MaxHealth) == 0x000024, "Member 'UFortHealthSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, CurrentShield) == 0x000028, "Member 'UFortHealthSet::CurrentShield' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Shield) == 0x00002C, "Member 'UFortHealthSet::Shield' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, DamageResistance) == 0x000030, "Member 'UFortHealthSet::DamageResistance' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ReflectDamageAbsolute) == 0x000034, "Member 'UFortHealthSet::ReflectDamageAbsolute' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ReflectDamageFromSource) == 0x000038, "Member 'UFortHealthSet::ReflectDamageFromSource' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Damage) == 0x00003C, "Member 'UFortHealthSet::Damage' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, ShieldDamage) == 0x000040, "Member 'UFortHealthSet::ShieldDamage' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, HealingSource) == 0x000044, "Member 'UFortHealthSet::HealingSource' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, HealingBonusTarget) == 0x000048, "Member 'UFortHealthSet::HealingBonusTarget' has a wrong offset!");
static_assert(offsetof(UFortHealthSet, Healing) == 0x00004C, "Member 'UFortHealthSet::Healing' has a wrong offset!");

// Class FortniteGame.FortAIPawn
// 0x05F0 (0x0E50 - 0x0860)
class AFortAIPawn : public AFortPawn
{
public:
	float                                         GoalRange;                                         // 0x085C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortNavObstacleComponent*              NavObstacleComponent;                              // 0x0860(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_864[0x4];                                      // 0x0864(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   EncounterInfo;                                     // 0x0868(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnSetIndex;                                     // 0x086C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  SpawnGroupGuid;                                    // 0x0870(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EnemyIndexInSpawnGroup;                            // 0x0880(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEngaged;                                       // 0x0884(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_885[0x3];                                      // 0x0885(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EncounterAIStartMovingAndThinkingDelay;            // 0x0888(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncounterAIFinishSpawningDelay;                    // 0x088C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishSpawning;                                   // 0x0890(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsDebugSpawnedAI;                                 // 0x0891(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEncounterExpectedLifespanExpired;                 // 0x0892(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_893[0x1];                                      // 0x0893(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           EncounterExpectedLifespanTimerHandle;              // 0x0894(0x0004)(NativeAccessSpecifierPublic)
	class AActor*                                 SpawnRift;                                         // 0x0898(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnSourceActor;                                  // 0x089C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortressAIType                               AIType;                                            // 0x08A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortHotSpotSlot                              HotspotType;                                       // 0x08A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortPartialPathUsage                         PartialPathUsage;                                  // 0x08A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortAILODLevel                               CurrentFortAILODLevel;                             // 0x08A3(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequiresNormalLOD;                                // 0x08A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A5[0x3F];                                     // 0x08A5(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BehaviorTree;                                      // 0x08E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     DefaultNavFilter;                                  // 0x08E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     HuntingNavFilter;                                  // 0x08EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F0[0x4];                                      // 0x08F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecentlySeenInterval;                              // 0x08F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugAI : 1;                                      // 0x08F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDebugAIAnim : 1;                                  // 0x08F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseSmartLinks : 1;                                // 0x08F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseBuildingAttackingHotspots : 1;                 // 0x08F8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCanMoveThroughWalls : 1;                          // 0x08F8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCanSleep : 1;                                     // 0x08F8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseCrowdSimulation : 1;                           // 0x08F8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_8F9[0x3];                                      // 0x08F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPendingSuicide;                                   // 0x08FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNeedsDeathNotification;                           // 0x08FD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bKilledByPlayer;                                   // 0x08FE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDespawnedDueToInactivity;                         // 0x08FF(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNotifySpawnRift;                                  // 0x0900(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_901[0x3];                                      // 0x0901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BumpNormal;                                        // 0x0904(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EFortMovementStyle                            MovementStyles[0x4];                               // 0x0910(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortMovementUrgency                          MovementUrgency;                                   // 0x0914(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_915[0x3];                                      // 0x0915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TurnTransitionGameplayAbilityTag;                  // 0x0918(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_930[0x4];                                      // 0x0930(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         DeathParticles;                                    // 0x0934(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHeadshotHideHead;                               // 0x094C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94D[0x3];                                      // 0x094D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRunVariations;                                  // 0x0950(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRunVariationIndex;                          // 0x0954(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunVariationRadius;                                // 0x0958(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EyeIndex;                                          // 0x095C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkinIndex;                                         // 0x0960(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultEyeColor;                                   // 0x0964(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DefaultEyeBrightness;                              // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultSkinColor;                                  // 0x0978(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DefaultSkinGlow;                                   // 0x0988(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortItemEntry                         StolenItem;                                        // 0x098C(0x007C)(Transient, NativeAccessSpecifierPublic)
	bool                                          bIsCharging;                                       // 0x0A08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSleeping;                                       // 0x0A09(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0A[0x2];                                      // 0x0A0A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x0A0C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               SpawnRotation;                                     // 0x0A18(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABuildingActor>          SleepingFloor;                                     // 0x0A24(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FLinearColor                           MinimapDefaultIconColor;                           // 0x0A2C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int8                                          MinimapGoalByTagColorIndex;                        // 0x0A3C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3D[0x13];                                     // 0x0A3D(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0A50(0x0074)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MiniMapAboveBelowIconBrush;                        // 0x0AC4(0x0074)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShowMinimapFarOffDirectionArrow;                  // 0x0B38(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B39[0x3];                                      // 0x0B39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimapViewableDistane;                            // 0x0B3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMinimapGoalByTagColorsData>    MinimapGoalByTagColors;                            // 0x0B40(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EFortTeam                                     Team;                                              // 0x0B4C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4D[0x3];                                      // 0x0B4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ImpactPhysicalSurfaceSounds[0x3F];                 // 0x0B50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ImpactPhysicalSurfaceEffects[0x3F];                // 0x0C4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D48[0x4];                                      // 0x0D48(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MiniMapScale;                                      // 0x0D4C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D54[0x40];                                     // 0x0D54(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	EFortCombatEvents                             FollowPlayerEvent;                                 // 0x0D94(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D95[0x3];                                      // 0x0D95(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAbilitySet*>                DefaultGameplayAbilitySets;                        // 0x0D98(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAbilitySet*>                SpawnInheritedCharacterAbilitySets;                // 0x0DA4(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UFortAbilitySystemComponent*            AIPawnAbilitySystemComponent;                      // 0x0DB0(0x0004)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  WallAttackGameplayAbilityTags;                     // 0x0DB4(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  WallRangedAttackGameplayAbilityTags;               // 0x0DCC(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CeilingAttackGameplayAbilityTags;                  // 0x0DE4(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  FloorAttackGameplayAbilityTags;                    // 0x0DFC(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTagContainer>          FailedAbilityQueryTags;                            // 0x0E14(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E20[0x30];                                     // 0x0E20(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetGroundSpeedForUrgency(class AFortAIPawn* FortAIPawn, EFortMovementUrgency Urgency);
	static EFortMovementStyle GetMovementStyle(const class AFortAIPawn* FortAIPawn);
	static EFortMovementUrgency GetMovementUrgency(class AFortAIPawn* FortAIPawn);

	void AddFortAbilitySet(class UFortAbilitySet* FortAbilitySet);
	void BroadcastSpawnFromRift();
	void DestroyStolenItem();
	void DetermineFailedToReachGoalState();
	void DetermineProximateState();
	void DetermineReachedGoalState();
	void DropStolenItem();
	void FailsafeKill();
	void FinishSpawning();
	void HandleFailedToReachGoalState(const class AActor* GoalActor);
	void HandleReachedGoalState(const class AActor* GoalActor);
	bool HasStolenItem();
	bool IsValidNavigationLocation(const struct FVector& Location);
	void OnBeginSleepEffects();
	void OnDetermineProximateState(const class AActor* GoalActor);
	void OnEndSleepEffects();
	void OnForceSpawnEffectCompletion();
	void OnRep_bIsSleeping();
	void OnRep_CurrentFortAILODLevel();
	void OnRep_FinishSpawning();
	void OnSleepingAIsFloorBuildingActorDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnSpawnedFromRift();
	void SetAIType(EFortressAIType InAIType);
	void SetEncounterInfo(class UFortAIEncounterInfo* InEncounterInfo);
	void SetEyeColor(const struct FLinearColor& NewEyeColor, float NewEyeBrightness);
	void SetIsCharging(bool bNewIsCharging);
	void SetMovementUrgency(EFortMovementUrgency Urgency);
	void SetRequiresNormalLOD(bool bRequiresNormalLOD_0);
	void SetSkinColor(const struct FLinearColor& NewSkinColor, float NewSkinBrightness);
	void StartMovingAndThinking();
	void TurnOnSleepingOptimizations();

	bool CanOpenDoors() const;
	class UParticleSystem* GetImpactPhysicalSurfaceEffect(const struct FHitResult& Impact) const;
	class USoundBase* GetImpactPhysicalSurfaceSound(const struct FHitResult& Impact) const;
	float GetLocalWildcardAsFloat(const struct FFortLocalWildcardData& Data) const;
	int32 GetLocalWildcardAsInt(const struct FFortLocalWildcardData& Data) const;
	float GetProximityNotifyDistXY() const;
	struct FVector GetSpawnLocation() const;
	struct FRotator GetSpawnRotation() const;
	float GetTimeSinceLastHit() const;
	float GetWildcardDataAsFloat(const struct FFortWildcardData& Data) const;
	int32 GetWildcardDataAsInt(const struct FFortWildcardData& Data) const;
	bool ShouldPauseAfterMelee() const;
	bool ShouldPerformMeleeLungeAttacks() const;
	bool ShouldStopOnMelee() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawn">();
	}
	static class AFortAIPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIPawn>();
	}
};
static_assert(alignof(AFortAIPawn) == 0x000010, "Wrong alignment on AFortAIPawn");
static_assert(sizeof(AFortAIPawn) == 0x000E50, "Wrong size on AFortAIPawn");
static_assert(offsetof(AFortAIPawn, GoalRange) == 0x00085C, "Member 'AFortAIPawn::GoalRange' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NavObstacleComponent) == 0x000860, "Member 'AFortAIPawn::NavObstacleComponent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterInfo) == 0x000868, "Member 'AFortAIPawn::EncounterInfo' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnSetIndex) == 0x00086C, "Member 'AFortAIPawn::SpawnSetIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnGroupGuid) == 0x000870, "Member 'AFortAIPawn::SpawnGroupGuid' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EnemyIndexInSpawnGroup) == 0x000880, "Member 'AFortAIPawn::EnemyIndexInSpawnGroup' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bHasEngaged) == 0x000884, "Member 'AFortAIPawn::bHasEngaged' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterAIStartMovingAndThinkingDelay) == 0x000888, "Member 'AFortAIPawn::EncounterAIStartMovingAndThinkingDelay' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterAIFinishSpawningDelay) == 0x00088C, "Member 'AFortAIPawn::EncounterAIFinishSpawningDelay' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bFinishSpawning) == 0x000890, "Member 'AFortAIPawn::bFinishSpawning' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bIsDebugSpawnedAI) == 0x000891, "Member 'AFortAIPawn::bIsDebugSpawnedAI' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bEncounterExpectedLifespanExpired) == 0x000892, "Member 'AFortAIPawn::bEncounterExpectedLifespanExpired' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EncounterExpectedLifespanTimerHandle) == 0x000894, "Member 'AFortAIPawn::EncounterExpectedLifespanTimerHandle' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnRift) == 0x000898, "Member 'AFortAIPawn::SpawnRift' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnSourceActor) == 0x00089C, "Member 'AFortAIPawn::SpawnSourceActor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AIType) == 0x0008A0, "Member 'AFortAIPawn::AIType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, HotspotType) == 0x0008A1, "Member 'AFortAIPawn::HotspotType' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, PartialPathUsage) == 0x0008A2, "Member 'AFortAIPawn::PartialPathUsage' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentFortAILODLevel) == 0x0008A3, "Member 'AFortAIPawn::CurrentFortAILODLevel' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bRequiresNormalLOD) == 0x0008A4, "Member 'AFortAIPawn::bRequiresNormalLOD' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, BehaviorTree) == 0x0008E4, "Member 'AFortAIPawn::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultNavFilter) == 0x0008E8, "Member 'AFortAIPawn::DefaultNavFilter' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, HuntingNavFilter) == 0x0008EC, "Member 'AFortAIPawn::HuntingNavFilter' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, RecentlySeenInterval) == 0x0008F4, "Member 'AFortAIPawn::RecentlySeenInterval' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bPendingSuicide) == 0x0008FC, "Member 'AFortAIPawn::bPendingSuicide' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bNeedsDeathNotification) == 0x0008FD, "Member 'AFortAIPawn::bNeedsDeathNotification' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bKilledByPlayer) == 0x0008FE, "Member 'AFortAIPawn::bKilledByPlayer' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bDespawnedDueToInactivity) == 0x0008FF, "Member 'AFortAIPawn::bDespawnedDueToInactivity' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bNotifySpawnRift) == 0x000900, "Member 'AFortAIPawn::bNotifySpawnRift' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, BumpNormal) == 0x000904, "Member 'AFortAIPawn::BumpNormal' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MovementStyles) == 0x000910, "Member 'AFortAIPawn::MovementStyles' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MovementUrgency) == 0x000914, "Member 'AFortAIPawn::MovementUrgency' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, TurnTransitionGameplayAbilityTag) == 0x000918, "Member 'AFortAIPawn::TurnTransitionGameplayAbilityTag' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DeathParticles) == 0x000934, "Member 'AFortAIPawn::DeathParticles' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bIsHeadshotHideHead) == 0x00094C, "Member 'AFortAIPawn::bIsHeadshotHideHead' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, NumRunVariations) == 0x000950, "Member 'AFortAIPawn::NumRunVariations' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CurrentRunVariationIndex) == 0x000954, "Member 'AFortAIPawn::CurrentRunVariationIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, RunVariationRadius) == 0x000958, "Member 'AFortAIPawn::RunVariationRadius' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, EyeIndex) == 0x00095C, "Member 'AFortAIPawn::EyeIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SkinIndex) == 0x000960, "Member 'AFortAIPawn::SkinIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultEyeColor) == 0x000964, "Member 'AFortAIPawn::DefaultEyeColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultEyeBrightness) == 0x000974, "Member 'AFortAIPawn::DefaultEyeBrightness' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultSkinColor) == 0x000978, "Member 'AFortAIPawn::DefaultSkinColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultSkinGlow) == 0x000988, "Member 'AFortAIPawn::DefaultSkinGlow' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, StolenItem) == 0x00098C, "Member 'AFortAIPawn::StolenItem' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bIsCharging) == 0x000A08, "Member 'AFortAIPawn::bIsCharging' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bIsSleeping) == 0x000A09, "Member 'AFortAIPawn::bIsSleeping' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnLocation) == 0x000A0C, "Member 'AFortAIPawn::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnRotation) == 0x000A18, "Member 'AFortAIPawn::SpawnRotation' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SleepingFloor) == 0x000A24, "Member 'AFortAIPawn::SleepingFloor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapDefaultIconColor) == 0x000A2C, "Member 'AFortAIPawn::MinimapDefaultIconColor' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapGoalByTagColorIndex) == 0x000A3C, "Member 'AFortAIPawn::MinimapGoalByTagColorIndex' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapIconBrush) == 0x000A50, "Member 'AFortAIPawn::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapAboveBelowIconBrush) == 0x000AC4, "Member 'AFortAIPawn::MiniMapAboveBelowIconBrush' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, bShowMinimapFarOffDirectionArrow) == 0x000B38, "Member 'AFortAIPawn::bShowMinimapFarOffDirectionArrow' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapViewableDistane) == 0x000B3C, "Member 'AFortAIPawn::MinimapViewableDistane' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MinimapGoalByTagColors) == 0x000B40, "Member 'AFortAIPawn::MinimapGoalByTagColors' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, Team) == 0x000B4C, "Member 'AFortAIPawn::Team' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, ImpactPhysicalSurfaceSounds) == 0x000B50, "Member 'AFortAIPawn::ImpactPhysicalSurfaceSounds' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, ImpactPhysicalSurfaceEffects) == 0x000C4C, "Member 'AFortAIPawn::ImpactPhysicalSurfaceEffects' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, MiniMapScale) == 0x000D4C, "Member 'AFortAIPawn::MiniMapScale' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FollowPlayerEvent) == 0x000D94, "Member 'AFortAIPawn::FollowPlayerEvent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, DefaultGameplayAbilitySets) == 0x000D98, "Member 'AFortAIPawn::DefaultGameplayAbilitySets' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, SpawnInheritedCharacterAbilitySets) == 0x000DA4, "Member 'AFortAIPawn::SpawnInheritedCharacterAbilitySets' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, AIPawnAbilitySystemComponent) == 0x000DB0, "Member 'AFortAIPawn::AIPawnAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WallAttackGameplayAbilityTags) == 0x000DB4, "Member 'AFortAIPawn::WallAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, WallRangedAttackGameplayAbilityTags) == 0x000DCC, "Member 'AFortAIPawn::WallRangedAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, CeilingAttackGameplayAbilityTags) == 0x000DE4, "Member 'AFortAIPawn::CeilingAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FloorAttackGameplayAbilityTags) == 0x000DFC, "Member 'AFortAIPawn::FloorAttackGameplayAbilityTags' has a wrong offset!");
static_assert(offsetof(AFortAIPawn, FailedAbilityQueryTags) == 0x000E14, "Member 'AFortAIPawn::FailedAbilityQueryTags' has a wrong offset!");

// Class FortniteGame.FortHealthRegenInterface
// 0x0000 (0x001C - 0x001C)
class IFortHealthRegenInterface final : public IInterface
{
public:
	class UGameplayEffect* GetHealthRegenDelayGameplayEffect() const;
	class UGameplayEffect* GetHealthRegenGameplayEffect() const;
	TSubclassOf<class UGameplayEffect> GetHealthRegenGameplayEffectClass() const;
	class UGameplayEffect* GetShieldRegenDelayGameplayEffect() const;
	class UGameplayEffect* GetShieldRegenGameplayEffect() const;
	TSubclassOf<class UGameplayEffect> GetShieldRegenGameplayEffectClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthRegenInterface">();
	}
	static class IFortHealthRegenInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortHealthRegenInterface>();
	}
};
static_assert(alignof(IFortHealthRegenInterface) == 0x000004, "Wrong alignment on IFortHealthRegenInterface");
static_assert(sizeof(IFortHealthRegenInterface) == 0x00001C, "Wrong size on IFortHealthRegenInterface");

// Class FortniteGame.FortRegenHealthSet
// 0x0028 (0x0118 - 0x00F0)
class UFortRegenHealthSet final : public UFortHealthSet
{
public:
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenRate;                                   // 0x00F4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenDelay;                                  // 0x00F8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthRegenThreshold;                              // 0x00FC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldRegenRate;                                   // 0x0100(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldRegenDelay;                                  // 0x0104(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldRegenThreshold;                              // 0x0108(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0xC];                                      // 0x010C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRegenHealthSet">();
	}
	static class UFortRegenHealthSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRegenHealthSet>();
	}
};
static_assert(alignof(UFortRegenHealthSet) == 0x000004, "Wrong alignment on UFortRegenHealthSet");
static_assert(sizeof(UFortRegenHealthSet) == 0x000118, "Wrong size on UFortRegenHealthSet");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenRate) == 0x0000F4, "Member 'UFortRegenHealthSet::HealthRegenRate' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenDelay) == 0x0000F8, "Member 'UFortRegenHealthSet::HealthRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, HealthRegenThreshold) == 0x0000FC, "Member 'UFortRegenHealthSet::HealthRegenThreshold' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenRate) == 0x000100, "Member 'UFortRegenHealthSet::ShieldRegenRate' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenDelay) == 0x000104, "Member 'UFortRegenHealthSet::ShieldRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortRegenHealthSet, ShieldRegenThreshold) == 0x000108, "Member 'UFortRegenHealthSet::ShieldRegenThreshold' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter
// 0x0000 (0x002C - 0x002C)
class UFortDifficultyOptionEncounter : public UFortDifficultyOption
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter">();
	}
	static class UFortDifficultyOptionEncounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter");
static_assert(sizeof(UFortDifficultyOptionEncounter) == 0x00002C, "Wrong size on UFortDifficultyOptionEncounter");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesFree
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_UtilitiesFree final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         NumFreeUtilitySlots;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesFree">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesFree>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesFree) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesFree");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesFree) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesFree");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesFree, NumFreeUtilitySlots) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_UtilitiesFree::NumFreeUtilitySlots' has a wrong offset!");

// Class FortniteGame.FortQueryTest_PerceptionAll
// 0x0140 (0x025C - 0x011C)
class UFortQueryTest_PerceptionAll final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              SenseScores[0x6];                                  // 0x011C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinSenseAge;                                       // 0x01C4(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxSenseAge;                                       // 0x01E0(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              SenseValues[0x6];                                  // 0x01FC(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              MinAge;                                            // 0x0244(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              MaxAge;                                            // 0x0250(0x000C)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAll">();
	}
	static class UFortQueryTest_PerceptionAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAll>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAll) == 0x000004, "Wrong alignment on UFortQueryTest_PerceptionAll");
static_assert(sizeof(UFortQueryTest_PerceptionAll) == 0x00025C, "Wrong size on UFortQueryTest_PerceptionAll");
static_assert(offsetof(UFortQueryTest_PerceptionAll, SenseScores) == 0x00011C, "Member 'UFortQueryTest_PerceptionAll::SenseScores' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MinSenseAge) == 0x0001C4, "Member 'UFortQueryTest_PerceptionAll::MinSenseAge' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MaxSenseAge) == 0x0001E0, "Member 'UFortQueryTest_PerceptionAll::MaxSenseAge' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, SenseValues) == 0x0001FC, "Member 'UFortQueryTest_PerceptionAll::SenseValues' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MinAge) == 0x000244, "Member 'UFortQueryTest_PerceptionAll::MinAge' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAll, MaxAge) == 0x000250, "Member 'UFortQueryTest_PerceptionAll::MaxAge' has a wrong offset!");

// Class FortniteGame.FortPlayerPawn
// 0x0410 (0x0C70 - 0x0860)
class AFortPlayerPawn : public AFortPawn
{
public:
	uint8                                         Pad_85C[0x4];                                      // 0x085C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            HealthRegenDelayGameplayEffect;                    // 0x0860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            HealthRegenGameplayEffect;                         // 0x0864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ShieldRegenDelayGameplayEffect;                    // 0x0868(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            ShieldRegenGameplayEffect;                         // 0x086C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortPawnStasisMode                           StasisMode;                                        // 0x0870(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortPawnStasisMode                           PreviousStasisMode;                                // 0x0871(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSprintJump;                                     // 0x0872(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_873[0x1];                                      // 0x0873(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintCancelTime;                                  // 0x0874(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPredictJumpApex;                               // 0x0878(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_879[0x3];                                      // 0x0879(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CoolDownColor;                                     // 0x087C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           HeavyAttackColor;                                  // 0x088C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           SuperAttackColor;                                  // 0x089C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FlashWhiteColor;                                   // 0x08AC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           DeniedByCoolDownColor;                             // 0x08BC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastAbilityFailed;                                 // 0x08CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LastAbilityFailedText;                             // 0x08D0(0x000C)(Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LastAbilityFailedTags;                             // 0x08DC(0x0018)(Transient, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DeniedByCoolDownMontage;                           // 0x08F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSoundStimulusBroadcastInterval;                // 0x08F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowingOverdriveEffect;                           // 0x0900(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EFortBuildingState                            BuildingState;                                     // 0x0901(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargeting;                                      // 0x0902(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_903[0x2D];                                     // 0x0903(0x002D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  LastEquippedWeaponGUID;                            // 0x0930(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           BluePrintPlaceAnimation;                           // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BluePrintEditAnimation;                            // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InteractionActor;                                  // 0x0948(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPartChanged;                                     // 0x094C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BlueprintPaperMID;                                 // 0x0958(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              BlueprintPaperPulseTimeline;                       // 0x095C(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCustomColorComponent*                  AccessoryColorSwatchHandler[0x6];                  // 0x09DC(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARecastNavMesh*                         MyNavMesh;                                         // 0x09F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortHero>               Hero;                                              // 0x09F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UCustomPlayerComponent*                 HACK_CustomPRIComponent;                           // 0x0A00(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCustomGender                             CharacterGender;                                   // 0x0A04(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFortCustomBodyType                           CharacterBodyType;                                 // 0x0A05(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A06[0x2];                                      // 0x0A06(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterPart*                   CharacterParts[0x6];                               // 0x0A08(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomColorSwatch*                     CharacterColorSwatches[0x2];                       // 0x0A20(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x6];                   // 0x0A28(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 CharacterPartSkeletalMeshComponents[0x6];          // 0x0A40(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomCharacterPart*                   PreviousCharacterParts[0x6];                       // 0x0A58(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACustomCharacterPartModifier*           CharacterPartModifiers[0x6];                       // 0x0A70(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortCharacterPartsRepMontageInfo      RepCharPartAnimMontageInfo;                        // 0x0A88(0x0014)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9C[0x4];                                      // 0x0A9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CarriedObjectAttachmentSocket;                     // 0x0AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargettingZOffset;                                 // 0x0AA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0AAC(0x0074)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            AboveBelowMiniMapIconBrush;                        // 0x0B20(0x0074)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            FarOffMiniMapIconBrush;                            // 0x0B94(0x0074)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MaxIndicatorVisibilityDistForEnemies;              // 0x0C08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortPickup*>                    IncomingPickups;                                   // 0x0C0C(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FFortPickupEntryData>           PickupDirectionData;                               // 0x0C18(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SpawnParticles;                                    // 0x0C24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SpawnSound;                                        // 0x0C28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumSecondsOnGroundBeforeStoppingRagdoll;           // 0x0C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C30[0x8];                                      // 0x0C30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDamagedEnemy : 1;                                 // 0x0C38(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_C39[0x7];                                      // 0x0C39(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PlayerStatus;                                      // 0x0C40(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortAnimNotifyState_RootMotionInterrupt*> RootMotionInterruptNotifyStack;                    // 0x0C44(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UAnimMontage*>                   RootMotionInterruptMontageStack;                   // 0x0C50(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5C[0x4];                                      // 0x0C5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortVisibilityComponent*               VisibilityComponent;                               // 0x0C60(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  BlendablesPostProcessComp;                         // 0x0C64(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C68[0x8];                                      // 0x0C68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanPredictJumpApex();
	void ClientNotifyAbilityFailed(const class UGameplayAbility* FailedAbility, const struct FGameplayTagContainer& FailedReason);
	void CycleNextOutfit();
	void CyclePreviousOutfit();
	struct FVector GetNavLocation();
	void HandleInStasis();
	void InternalServerSetTargeting(bool bNewTargeting);
	void OnCharacterPartsReinitialized();
	void OnCoolDownEnded();
	void OnCoolDownStarted();
	void OnRep_CharPartAnimMontageInfo();
	void RandomizeCharacter(const class FString& GenderString);
	void RandomizeOutfit(const class FString& GenderString);
	void ServerChooseGender(EFortCustomGender Gender);
	void ServerChoosePart(EFortCustomPartType Part, class UCustomCharacterPart* ChosenCharacterPart);
	void ServerCycleAccessoryColorSwatch(EFortCustomPartType Part, bool bNext);
	void ServerCycleColorSwatch(EColorSwatchType SwatchType, bool bNext);
	void ServerCycleOutfit(bool bNextOutfit);
	void ServerCyclePart(EFortCustomPartType Part, bool bNextPart);
	void ServerHandlePickup(class AFortPickup* Pickup, float InFlyTime, const struct FVector& InStartDirection, bool bPlayPickupSound);
	void ServerPlayDeniedByCoolDown();
	void ServerRootMotionInterruptNotifyStopMontage(class UAnimMontage* MontageToStop);
	void ServerToggleBodyType();
	void ServerToggleGender();
	void SetFirstPersonCamera(bool bNewUseFirstPersonCamera);
	void SetHomeActor(class AActor* NewActor);
	void SetVectorParameterValueForAllCharacterParts(class FName ParameterName, const struct FLinearColor& Value);
	void SetVectorParameterValueForBodyParts(class FName ParameterName, const struct FLinearColor& Value);
	void SwitchToNextPart(const class FString& PartName);
	void SwitchToPreviousPart(const class FString& PartName);
	void ToggleBodyType();
	void ToggleGender();

	float DefaultTimeToJumpApex() const;
	EFortCustomBodyType GetCharacterBodyType() const;
	EFortCustomGender GetCharacterGender() const;
	void GetGender(bool* IsMale, bool* IsFemale) const;
	class AActor* GetHomeActor() const;
	float GetJumpZ() const;
	float GetMaxStamina() const;
	float GetPercentageOutfitComplete(EFortCustomPartType Part) const;
	class USkeletalMeshComponent* GetSkeletalMeshForPartType(EFortCustomPartType PartType) const;
	float GetStamina() const;
	bool IsSprinting() const;
	void ListCharacterParts(const class FString& GenderAndOrPartString) const;
	bool PartOutfitIsComplete(EFortCustomPartType Part) const;
	float TimeFromJumpApex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerPawn">();
	}
	static class AFortPlayerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerPawn>();
	}
};
static_assert(alignof(AFortPlayerPawn) == 0x000010, "Wrong alignment on AFortPlayerPawn");
static_assert(sizeof(AFortPlayerPawn) == 0x000C70, "Wrong size on AFortPlayerPawn");
static_assert(offsetof(AFortPlayerPawn, HealthRegenDelayGameplayEffect) == 0x000860, "Member 'AFortPlayerPawn::HealthRegenDelayGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, HealthRegenGameplayEffect) == 0x000864, "Member 'AFortPlayerPawn::HealthRegenGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, ShieldRegenDelayGameplayEffect) == 0x000868, "Member 'AFortPlayerPawn::ShieldRegenDelayGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, ShieldRegenGameplayEffect) == 0x00086C, "Member 'AFortPlayerPawn::ShieldRegenGameplayEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, StasisMode) == 0x000870, "Member 'AFortPlayerPawn::StasisMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PreviousStasisMode) == 0x000871, "Member 'AFortPlayerPawn::PreviousStasisMode' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bIsSprintJump) == 0x000872, "Member 'AFortPlayerPawn::bIsSprintJump' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SprintCancelTime) == 0x000874, "Member 'AFortPlayerPawn::SprintCancelTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bCanPredictJumpApex) == 0x000878, "Member 'AFortPlayerPawn::bCanPredictJumpApex' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CoolDownColor) == 0x00087C, "Member 'AFortPlayerPawn::CoolDownColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, HeavyAttackColor) == 0x00088C, "Member 'AFortPlayerPawn::HeavyAttackColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SuperAttackColor) == 0x00089C, "Member 'AFortPlayerPawn::SuperAttackColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, FlashWhiteColor) == 0x0008AC, "Member 'AFortPlayerPawn::FlashWhiteColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DeniedByCoolDownColor) == 0x0008BC, "Member 'AFortPlayerPawn::DeniedByCoolDownColor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, LastAbilityFailed) == 0x0008CC, "Member 'AFortPlayerPawn::LastAbilityFailed' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, LastAbilityFailedText) == 0x0008D0, "Member 'AFortPlayerPawn::LastAbilityFailedText' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, LastAbilityFailedTags) == 0x0008DC, "Member 'AFortPlayerPawn::LastAbilityFailedTags' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, DeniedByCoolDownMontage) == 0x0008F4, "Member 'AFortPlayerPawn::DeniedByCoolDownMontage' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MoveSoundStimulusBroadcastInterval) == 0x0008F8, "Member 'AFortPlayerPawn::MoveSoundStimulusBroadcastInterval' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bShowingOverdriveEffect) == 0x000900, "Member 'AFortPlayerPawn::bShowingOverdriveEffect' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BuildingState) == 0x000901, "Member 'AFortPlayerPawn::BuildingState' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, bIsTargeting) == 0x000902, "Member 'AFortPlayerPawn::bIsTargeting' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, LastEquippedWeaponGUID) == 0x000930, "Member 'AFortPlayerPawn::LastEquippedWeaponGUID' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BluePrintPlaceAnimation) == 0x000940, "Member 'AFortPlayerPawn::BluePrintPlaceAnimation' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BluePrintEditAnimation) == 0x000944, "Member 'AFortPlayerPawn::BluePrintEditAnimation' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, InteractionActor) == 0x000948, "Member 'AFortPlayerPawn::InteractionActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, OnPartChanged) == 0x00094C, "Member 'AFortPlayerPawn::OnPartChanged' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlueprintPaperMID) == 0x000958, "Member 'AFortPlayerPawn::BlueprintPaperMID' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlueprintPaperPulseTimeline) == 0x00095C, "Member 'AFortPlayerPawn::BlueprintPaperPulseTimeline' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, AccessoryColorSwatchHandler) == 0x0009DC, "Member 'AFortPlayerPawn::AccessoryColorSwatchHandler' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MyNavMesh) == 0x0009F4, "Member 'AFortPlayerPawn::MyNavMesh' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, Hero) == 0x0009F8, "Member 'AFortPlayerPawn::Hero' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, HACK_CustomPRIComponent) == 0x000A00, "Member 'AFortPlayerPawn::HACK_CustomPRIComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterGender) == 0x000A04, "Member 'AFortPlayerPawn::CharacterGender' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterBodyType) == 0x000A05, "Member 'AFortPlayerPawn::CharacterBodyType' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterParts) == 0x000A08, "Member 'AFortPlayerPawn::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterColorSwatches) == 0x000A20, "Member 'AFortPlayerPawn::CharacterColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartColorSwatches) == 0x000A28, "Member 'AFortPlayerPawn::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartSkeletalMeshComponents) == 0x000A40, "Member 'AFortPlayerPawn::CharacterPartSkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PreviousCharacterParts) == 0x000A58, "Member 'AFortPlayerPawn::PreviousCharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CharacterPartModifiers) == 0x000A70, "Member 'AFortPlayerPawn::CharacterPartModifiers' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RepCharPartAnimMontageInfo) == 0x000A88, "Member 'AFortPlayerPawn::RepCharPartAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, CarriedObjectAttachmentSocket) == 0x000AA0, "Member 'AFortPlayerPawn::CarriedObjectAttachmentSocket' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, TargettingZOffset) == 0x000AA8, "Member 'AFortPlayerPawn::TargettingZOffset' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MiniMapIconBrush) == 0x000AAC, "Member 'AFortPlayerPawn::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, AboveBelowMiniMapIconBrush) == 0x000B20, "Member 'AFortPlayerPawn::AboveBelowMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, FarOffMiniMapIconBrush) == 0x000B94, "Member 'AFortPlayerPawn::FarOffMiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, MaxIndicatorVisibilityDistForEnemies) == 0x000C08, "Member 'AFortPlayerPawn::MaxIndicatorVisibilityDistForEnemies' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, IncomingPickups) == 0x000C0C, "Member 'AFortPlayerPawn::IncomingPickups' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PickupDirectionData) == 0x000C18, "Member 'AFortPlayerPawn::PickupDirectionData' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SpawnParticles) == 0x000C24, "Member 'AFortPlayerPawn::SpawnParticles' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, SpawnSound) == 0x000C28, "Member 'AFortPlayerPawn::SpawnSound' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, NumSecondsOnGroundBeforeStoppingRagdoll) == 0x000C2C, "Member 'AFortPlayerPawn::NumSecondsOnGroundBeforeStoppingRagdoll' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, PlayerStatus) == 0x000C40, "Member 'AFortPlayerPawn::PlayerStatus' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RootMotionInterruptNotifyStack) == 0x000C44, "Member 'AFortPlayerPawn::RootMotionInterruptNotifyStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, RootMotionInterruptMontageStack) == 0x000C50, "Member 'AFortPlayerPawn::RootMotionInterruptMontageStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, VisibilityComponent) == 0x000C60, "Member 'AFortPlayerPawn::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerPawn, BlendablesPostProcessComp) == 0x000C64, "Member 'AFortPlayerPawn::BlendablesPostProcessComp' has a wrong offset!");

// Class FortniteGame.FortPlayerState
// 0x036C (0x0614 - 0x02A8)
class AFortPlayerState : public APlayerState
{
public:
	uint8                                         Pad_2A8[0xC];                                      // 0x02A8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsWorldDataOwner : 1;                             // 0x02B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsGameSessionOwner : 1;                           // 0x02B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2B4_2 : 6;                                  // 0x02B4(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_2B5[0x3B];                                     // 0x02B5(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsGameSessionAdmin : 1;                           // 0x02F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsReadyToContinue : 1;                            // 0x02F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bHasFinishedLoading : 1;                           // 0x02F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bHasStartedPlaying : 1;                            // 0x02F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PartyOwnerUniqueId;                                // 0x02F4(0x0008)(Net, RepNotify, NativeAccessSpecifierPublic)
	int32                                         WorldPlayerId;                                     // 0x02FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroId;                                            // 0x0300(0x000C)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHeroType*                          HeroType;                                          // 0x030C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x1C];                                     // 0x0310(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCharXP;                                     // 0x032C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x54];                                     // 0x0330(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AFortPickup>             MyBackpackPickup;                                  // 0x0384(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EFortCustomGender                             CharacterGender;                                   // 0x038C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortCustomBodyType                           CharacterBodyType;                                 // 0x038D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38E[0x2];                                      // 0x038E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomCharacterPart*                   CharacterParts[0x6];                               // 0x0390(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     CharacterColorSwatches[0x2];                       // 0x03A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomPlayerComponent*                 CustomPRIComponent;                                // 0x03B0(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AFortPlayerPawn>         CachedPawn;                                        // 0x03B4(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x6];                   // 0x03BC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortTeamInfo*                          PlayerTeam;                                        // 0x03D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FReplicatedStatValues                  ReplicatedStats_Campaign[0x21];                    // 0x03D8(0x0008)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedStatValues                  ReplicatedStats_Zone[0x21];                        // 0x04E0(0x0008)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	EReadyCheckState                              ReadyCheckState;                                   // 0x05E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E9[0x3];                                      // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HomeActor;                                         // 0x05EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortPlayerAttributeSets               AttributeSets;                                     // 0x05F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0608(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerAttributesProxyActor*        PlayerAttributesProxyActor;                        // 0x060C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x4];                                      // 0x0610(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortPlayerPawn* GetCurrentPawn();
	void OnRep_AccessoryColorSwatches();
	void OnRep_CharacterColorSwatches();
	void OnRep_CharacterParts();
	void OnRep_CurrentCharXP();
	void OnRep_HeroID();
	void OnRep_HeroType();
	void OnRep_HomeActor(class AActor* OldHomeActor);
	void OnRep_PartyOwner();
	void OnRep_PlayerName();
	void OnRep_PlayerTeam();
	void OnRep_ScoreStatChanged();
	void OnRep_SessionOwner();

	class AFortPlayerAttributesProxyActor* GetPlayerAttributesProxyActor() const;
	struct FUniqueNetIdRepl GetUniqueID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerState">();
	}
	static class AFortPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerState>();
	}
};
static_assert(alignof(AFortPlayerState) == 0x000004, "Wrong alignment on AFortPlayerState");
static_assert(sizeof(AFortPlayerState) == 0x000614, "Wrong size on AFortPlayerState");
static_assert(offsetof(AFortPlayerState, PartyOwnerUniqueId) == 0x0002F4, "Member 'AFortPlayerState::PartyOwnerUniqueId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, WorldPlayerId) == 0x0002FC, "Member 'AFortPlayerState::WorldPlayerId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HeroId) == 0x000300, "Member 'AFortPlayerState::HeroId' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HeroType) == 0x00030C, "Member 'AFortPlayerState::HeroType' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CurrentCharXP) == 0x00032C, "Member 'AFortPlayerState::CurrentCharXP' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, MyBackpackPickup) == 0x000384, "Member 'AFortPlayerState::MyBackpackPickup' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterGender) == 0x00038C, "Member 'AFortPlayerState::CharacterGender' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterBodyType) == 0x00038D, "Member 'AFortPlayerState::CharacterBodyType' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterParts) == 0x000390, "Member 'AFortPlayerState::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterColorSwatches) == 0x0003A8, "Member 'AFortPlayerState::CharacterColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CustomPRIComponent) == 0x0003B0, "Member 'AFortPlayerState::CustomPRIComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CachedPawn) == 0x0003B4, "Member 'AFortPlayerState::CachedPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, CharacterPartColorSwatches) == 0x0003BC, "Member 'AFortPlayerState::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlayerTeam) == 0x0003D4, "Member 'AFortPlayerState::PlayerTeam' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReplicatedStats_Campaign) == 0x0003D8, "Member 'AFortPlayerState::ReplicatedStats_Campaign' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReplicatedStats_Zone) == 0x0004E0, "Member 'AFortPlayerState::ReplicatedStats_Zone' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, ReadyCheckState) == 0x0005E8, "Member 'AFortPlayerState::ReadyCheckState' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, HomeActor) == 0x0005EC, "Member 'AFortPlayerState::HomeActor' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, AttributeSets) == 0x0005F0, "Member 'AFortPlayerState::AttributeSets' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, AbilitySystemComponent) == 0x000608, "Member 'AFortPlayerState::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerState, PlayerAttributesProxyActor) == 0x00060C, "Member 'AFortPlayerState::PlayerAttributesProxyActor' has a wrong offset!");

// Class FortniteGame.FortAIDirectorDataTrackingSettings
// 0x0008 (0x0024 - 0x001C)
class UFortAIDirectorDataTrackingSettings final : public UDataAsset
{
public:
	TSubclassOf<class AFortAIDirectorDataManager> PlayerDataManager;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAIDirectorDataManager> EncounterDataManager;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataTrackingSettings">();
	}
	static class UFortAIDirectorDataTrackingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDirectorDataTrackingSettings>();
	}
};
static_assert(alignof(UFortAIDirectorDataTrackingSettings) == 0x000004, "Wrong alignment on UFortAIDirectorDataTrackingSettings");
static_assert(sizeof(UFortAIDirectorDataTrackingSettings) == 0x000024, "Wrong size on UFortAIDirectorDataTrackingSettings");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, PlayerDataManager) == 0x00001C, "Member 'UFortAIDirectorDataTrackingSettings::PlayerDataManager' has a wrong offset!");
static_assert(offsetof(UFortAIDirectorDataTrackingSettings, EncounterDataManager) == 0x000020, "Member 'UFortAIDirectorDataTrackingSettings::EncounterDataManager' has a wrong offset!");

// Class FortniteGame.FortQueryTest_BuildingCriteria
// 0x01C4 (0x02E0 - 0x011C)
class UFortQueryTest_BuildingCriteria final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              ScoreForGroundSupportedFloor;                      // 0x011C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForBeingGroundSupported;                      // 0x0138(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForTraps;                                     // 0x0154(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForWalls;                                     // 0x0170(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForNavigableOpening;                          // 0x018C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x01A8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferCloserToRootAssignment;                     // 0x01C8(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ScoreForDistanceFromClosestRootAssignmentGoal;     // 0x01E4(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MinDistanceForDistanceScoring;                     // 0x0200(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxDistanceForDistanceScoring;                     // 0x021C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthScore;                                    // 0x0238(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealth;                               // 0x0254(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMaxHealthValue;                               // 0x0270(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              ClampMinHealthValue;                               // 0x028C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bPreferHigherHealthPercentage;                     // 0x02A8(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              MaxHealthPercentageScore;                          // 0x02C4(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_BuildingCriteria">();
	}
	static class UFortQueryTest_BuildingCriteria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_BuildingCriteria>();
	}
};
static_assert(alignof(UFortQueryTest_BuildingCriteria) == 0x000004, "Wrong alignment on UFortQueryTest_BuildingCriteria");
static_assert(sizeof(UFortQueryTest_BuildingCriteria) == 0x0002E0, "Wrong size on UFortQueryTest_BuildingCriteria");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForGroundSupportedFloor) == 0x00011C, "Member 'UFortQueryTest_BuildingCriteria::ScoreForGroundSupportedFloor' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForBeingGroundSupported) == 0x000138, "Member 'UFortQueryTest_BuildingCriteria::ScoreForBeingGroundSupported' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForTraps) == 0x000154, "Member 'UFortQueryTest_BuildingCriteria::ScoreForTraps' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForWalls) == 0x000170, "Member 'UFortQueryTest_BuildingCriteria::ScoreForWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForNavigableOpening) == 0x00018C, "Member 'UFortQueryTest_BuildingCriteria::ScoreForNavigableOpening' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, RootAssignmentID) == 0x0001A8, "Member 'UFortQueryTest_BuildingCriteria::RootAssignmentID' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferCloserToRootAssignment) == 0x0001C8, "Member 'UFortQueryTest_BuildingCriteria::bPreferCloserToRootAssignment' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ScoreForDistanceFromClosestRootAssignmentGoal) == 0x0001E4, "Member 'UFortQueryTest_BuildingCriteria::ScoreForDistanceFromClosestRootAssignmentGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MinDistanceForDistanceScoring) == 0x000200, "Member 'UFortQueryTest_BuildingCriteria::MinDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxDistanceForDistanceScoring) == 0x00021C, "Member 'UFortQueryTest_BuildingCriteria::MaxDistanceForDistanceScoring' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthScore) == 0x000238, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthScore' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealth) == 0x000254, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealth' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMaxHealthValue) == 0x000270, "Member 'UFortQueryTest_BuildingCriteria::ClampMaxHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, ClampMinHealthValue) == 0x00028C, "Member 'UFortQueryTest_BuildingCriteria::ClampMinHealthValue' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, bPreferHigherHealthPercentage) == 0x0002A8, "Member 'UFortQueryTest_BuildingCriteria::bPreferHigherHealthPercentage' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_BuildingCriteria, MaxHealthPercentageScore) == 0x0002C4, "Member 'UFortQueryTest_BuildingCriteria::MaxHealthPercentageScore' has a wrong offset!");

// Class FortniteGame.FortPlayerAttributesProxyActor
// 0x0020 (0x0260 - 0x0240)
class AFortPlayerAttributesProxyActor final : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortPlayerAttributeSets               AttributeSets;                                     // 0x0244(0x0018)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x025C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAttributesProxyActor">();
	}
	static class AFortPlayerAttributesProxyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerAttributesProxyActor>();
	}
};
static_assert(alignof(AFortPlayerAttributesProxyActor) == 0x000004, "Wrong alignment on AFortPlayerAttributesProxyActor");
static_assert(sizeof(AFortPlayerAttributesProxyActor) == 0x000260, "Wrong size on AFortPlayerAttributesProxyActor");
static_assert(offsetof(AFortPlayerAttributesProxyActor, AttributeSets) == 0x000244, "Member 'AFortPlayerAttributesProxyActor::AttributeSets' has a wrong offset!");
static_assert(offsetof(AFortPlayerAttributesProxyActor, AbilitySystemComponent) == 0x00025C, "Member 'AFortPlayerAttributesProxyActor::AbilitySystemComponent' has a wrong offset!");

// Class FortniteGame.MyTownManager
// 0x0308 (0x0324 - 0x001C)
class UMyTownManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x54];                                      // 0x001C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlayerAttributesProxyActor*        HomebaseAttributesProxyActor;                      // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x2B0];                                     // 0x0074(0x02B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterSlotCamera(int32 MapSlotId, class UCameraComponent* InCameraComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownManager">();
	}
	static class UMyTownManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyTownManager>();
	}
};
static_assert(alignof(UMyTownManager) == 0x000004, "Wrong alignment on UMyTownManager");
static_assert(sizeof(UMyTownManager) == 0x000324, "Wrong size on UMyTownManager");
static_assert(offsetof(UMyTownManager, HomebaseAttributesProxyActor) == 0x000070, "Member 'UMyTownManager::HomebaseAttributesProxyActor' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_Pawn
// 0x0010 (0x002C - 0x001C)
class UFortAIDataProvider_Pawn final : public UAIDataProvider
{
public:
	float                                         SightRadius;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingRadius;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewLocationOffsetFromGround;                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepHeight;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Pawn">();
	}
	static class UFortAIDataProvider_Pawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Pawn>();
	}
};
static_assert(alignof(UFortAIDataProvider_Pawn) == 0x000004, "Wrong alignment on UFortAIDataProvider_Pawn");
static_assert(sizeof(UFortAIDataProvider_Pawn) == 0x00002C, "Wrong size on UFortAIDataProvider_Pawn");
static_assert(offsetof(UFortAIDataProvider_Pawn, SightRadius) == 0x00001C, "Member 'UFortAIDataProvider_Pawn::SightRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, HearingRadius) == 0x000020, "Member 'UFortAIDataProvider_Pawn::HearingRadius' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, ViewLocationOffsetFromGround) == 0x000024, "Member 'UFortAIDataProvider_Pawn::ViewLocationOffsetFromGround' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Pawn, MaxStepHeight) == 0x000028, "Member 'UFortAIDataProvider_Pawn::MaxStepHeight' has a wrong offset!");

// Class FortniteGame.HomeBaseContext
// 0x0098 (0x00B4 - 0x001C)
class UHomeBaseContext final : public UBlueprintContextBase
{
public:
	UMulticastDelegateProperty_                   OnOpenBuildingPanel;                               // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCloseBuildingPanel;                              // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnOpenOverview;                                    // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCloseOverview;                                   // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWorkerPreviewStateChanged;                       // 0x004C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHomebaseInventoryUpdated;                        // 0x0058(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x14];                                      // 0x0064(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UHomeBaseMainBuilding*> CachedBuildings;                                   // 0x0078(0x003C)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void GetStaticSetBonusData(const struct FGameplayTag& InSetBonusTag, const EFortBrushSize InBrushSize, int32* OutRequiredWorkersCount, class FText* OutSetBonusName, struct FSlateBrush* OutBrush);

	void AutoSlotAllWorkers();
	void BeginWorkerPreview(const class UFortWorker* WorkerItem, const class UHomeBaseMainBuilding* BuildingToOccupy, const int32 WorkerSlotToOccupy);
	void EndWorkerPreview();
	int32 GetWorkerRatingAtLevelForBuilding(const class UFortWorker* WorkerItem, const int32 WorkerLevel, const class UHomeBaseMainBuilding* Building);
	void RequestCloseBuildingPanel();
	void RequestCloseOverview();
	void RequestOpenBuildingPanel(const class UHomeBaseMainBuilding* Building);
	void RequestOpenOverview();
	bool ShouldShowBang(const class UHomeBaseBuilding* Building);
	void UnslotAllWorkers();

	int32 GetAccountLevel() const;
	TArray<class UHomeBaseMainBuilding*> GetAllBuildings() const;
	class UHomeBaseMainBuilding* GetBuilding(const class FString& TemplateId) const;
	TArray<struct FSingleBuildingBonusDescription> GetBuildingBonusDescriptionsForSetBonus(const struct FGameplayTag& SetBonusTag) const;
	class FString GetBuildingTemplateIdFromInstanceId(const class FString& InstanceId) const;
	class UMyTownData* GetHomeBaseData() const;
	void GetWorkerPreviewStatus(bool* OutIsPreviewing, class UFortWorker** OutWorker, bool* OutMatchesPersonality, bool* OutMatchesBuildingType, struct FWorkerSetBonusState* OutSetBonusState) const;
	TArray<struct FWorkerSetBonusState> GetWorkerSetBonusStates(const TArray<class UFortWorker*>& Workers) const;
	void GetWorkerSlottingPreviewState(class UFortWorker** OutWorkerItem, class UHomeBaseMainBuilding** OutHostBuilding, int32* OutSlotIndex) const;
	bool IsBuildingPanelOpen() const;
	bool IsPreviewingWorkerSlotting() const;
	void NotifyBuildingPanelClosed() const;
	void NotifyBuildingPanelOpened(const class UHomeBaseMainBuilding* Building) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseContext">();
	}
	static class UHomeBaseContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseContext>();
	}
};
static_assert(alignof(UHomeBaseContext) == 0x000004, "Wrong alignment on UHomeBaseContext");
static_assert(sizeof(UHomeBaseContext) == 0x0000B4, "Wrong size on UHomeBaseContext");
static_assert(offsetof(UHomeBaseContext, OnOpenBuildingPanel) == 0x00001C, "Member 'UHomeBaseContext::OnOpenBuildingPanel' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnCloseBuildingPanel) == 0x000028, "Member 'UHomeBaseContext::OnCloseBuildingPanel' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnOpenOverview) == 0x000034, "Member 'UHomeBaseContext::OnOpenOverview' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnCloseOverview) == 0x000040, "Member 'UHomeBaseContext::OnCloseOverview' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnWorkerPreviewStateChanged) == 0x00004C, "Member 'UHomeBaseContext::OnWorkerPreviewStateChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, OnHomebaseInventoryUpdated) == 0x000058, "Member 'UHomeBaseContext::OnHomebaseInventoryUpdated' has a wrong offset!");
static_assert(offsetof(UHomeBaseContext, CachedBuildings) == 0x000078, "Member 'UHomeBaseContext::CachedBuildings' has a wrong offset!");

// Class FortniteGame.FortQueryTest_Random
// 0x0000 (0x010C - 0x010C)
class UFortQueryTest_Random final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_Random">();
	}
	static class UFortQueryTest_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_Random>();
	}
};
static_assert(alignof(UFortQueryTest_Random) == 0x000004, "Wrong alignment on UFortQueryTest_Random");
static_assert(sizeof(UFortQueryTest_Random) == 0x00010C, "Wrong size on UFortQueryTest_Random");

// Class FortniteGame.BlueprintContextLibrary
// 0x0000 (0x001C - 0x001C)
class UBlueprintContextLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UBlueprintContextBase* GetContext(class UObject* ContextObject, TSubclassOf<class UBlueprintContextBase> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintContextLibrary">();
	}
	static class UBlueprintContextLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintContextLibrary>();
	}
};
static_assert(alignof(UBlueprintContextLibrary) == 0x000004, "Wrong alignment on UBlueprintContextLibrary");
static_assert(sizeof(UBlueprintContextLibrary) == 0x00001C, "Wrong size on UBlueprintContextLibrary");

// Class FortniteGame.FortSpawnableByPlacementSystemInterface
// 0x0000 (0x001C - 0x001C)
class IFortSpawnableByPlacementSystemInterface final : public IInterface
{
public:
	class AFortMission* GetMission() const;
	struct FGuid GetMissionGuid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnableByPlacementSystemInterface">();
	}
	static class IFortSpawnableByPlacementSystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpawnableByPlacementSystemInterface>();
	}
};
static_assert(alignof(IFortSpawnableByPlacementSystemInterface) == 0x000004, "Wrong alignment on IFortSpawnableByPlacementSystemInterface");
static_assert(sizeof(IFortSpawnableByPlacementSystemInterface) == 0x00001C, "Wrong size on IFortSpawnableByPlacementSystemInterface");

// Class FortniteGame.FortAIGoalProvider_EnvQuery
// 0x0044 (0x0070 - 0x002C)
class UFortAIGoalProvider_EnvQuery : public UFortAIGoalProvider
{
public:
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              GoalQuery;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutomaticUpdatePeriodInSeconds;                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortAIAssignmentIdentifier            SpecificAssignmentContext;                         // 0x0038(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AFortAIPawn>                AIPawnContext;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x14];                                      // 0x005C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalProvider_EnvQuery">();
	}
	static class UFortAIGoalProvider_EnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIGoalProvider_EnvQuery>();
	}
};
static_assert(alignof(UFortAIGoalProvider_EnvQuery) == 0x000004, "Wrong alignment on UFortAIGoalProvider_EnvQuery");
static_assert(sizeof(UFortAIGoalProvider_EnvQuery) == 0x000070, "Wrong size on UFortAIGoalProvider_EnvQuery");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, GoalQuery) == 0x000030, "Member 'UFortAIGoalProvider_EnvQuery::GoalQuery' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AutomaticUpdatePeriodInSeconds) == 0x000034, "Member 'UFortAIGoalProvider_EnvQuery::AutomaticUpdatePeriodInSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, SpecificAssignmentContext) == 0x000038, "Member 'UFortAIGoalProvider_EnvQuery::SpecificAssignmentContext' has a wrong offset!");
static_assert(offsetof(UFortAIGoalProvider_EnvQuery, AIPawnContext) == 0x000058, "Member 'UFortAIGoalProvider_EnvQuery::AIPawnContext' has a wrong offset!");

// Class FortniteGame.BuildingActor
// 0x01D8 (0x0418 - 0x0240)
class ABuildingActor : public AActor
{
public:
	uint8                                         Pad_240[0x30];                                     // 0x0240(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EFortBuildingType                             BuildingType;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MyGuid;                                            // 0x0274(0x0010)(Net, ZeroConstructor, DuplicateTransient, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x0284(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0290(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         OwnerPersistentID;                                 // 0x029C(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AreaClass;                                         // 0x02A0(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NavigationLinksClass;                              // 0x02B8(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentBuildingLevel;                              // 0x02D0(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaximumBuildingLevel;                              // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUpgradeUsesSameClass : 1;                         // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bSupportsQuickUpgrade : 1;                         // 0x02D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDisplayLevelInInfoWidget : 1;                     // 0x02D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bAllowUpgradeRegardlessOfPlayerBuildLevel : 1;     // 0x02D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortBuildingActorSet>      BuildingAttributeSetClass;                         // 0x02DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortBuildingActorSet*                  BuildingAttributeSet;                              // 0x02E0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x02E4(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSurpressHealthBar;                                // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRecentlyDamaged;                                  // 0x02E9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DefaultTags;                                       // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ConstTags;                                         // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  StaticGameplayTags;                                // 0x0320(0x0018)(Protected, NativeAccessSpecifierProtected)
	EDynamicBuildingPlacementType                 DynamicBuildingPlacementType;                      // 0x0338(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavigationObstacleOverride                   NavigationObstacleOverride;                        // 0x0339(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A[0x2];                                      // 0x033A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDestroyed : 1;                                    // 0x033C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bPersistToWorld : 1;                               // 0x033C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRefreshFullSaveDataBeforeZoneSave : 1;            // 0x033C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bBeingDragged : 1;                                 // 0x033C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRotateInPlaceGame : 1;                            // 0x033C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsNavigationModifier : 1;                         // 0x033C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, Config, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bBlockNavigationLinks : 1;                         // 0x033C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCanExportNavigationCollisions : 1;                // 0x033C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCanExportNavigationObstacle : 1;                  // 0x033D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bMirrorNavLinksX : 1;                              // 0x033D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bMirrorNavLinksY : 1;                              // 0x033D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreMoveGoalCollisionRadius : 1;                // 0x033D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bForceDisableRootNavigationRelevance : 1;          // 0x033D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bForceAutomationPass : 1;                          // 0x033D(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bWorldReadyCalled : 1;                             // 0x033D(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseDefaultCullDistance : 1;                       // 0x033D(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bBeingRotatedOrScaled : 1;                         // 0x033E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bBeingTranslated : 1;                              // 0x033E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRotateInPlaceEditor : 1;                          // 0x033E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bEditorPlaced : 1;                                 // 0x033E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bPlayerPlaced : 1;                                 // 0x033E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bShouldTick : 1;                                   // 0x033E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x033E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsDynamic : 1;                                    // 0x033E(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsDynamicOnDedicatedServer : 1;                   // 0x033F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected))
	uint8                                         bIsMovable : 1;                                    // 0x033F(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x033F(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseAbilitySystemComponent : 1;                    // 0x033F(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bForceDamagePing : 1;                              // 0x033F(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	float                                         LDMaxDrawDistance;                                 // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifespanAfterDeath;                                // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDoNotBlockBuildings : 1;                          // 0x0348(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDestroyOnPlayerBuildingPlacement : 1;             // 0x0348(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseCentroidForBlockBuildingsCheck : 1;            // 0x0348(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bIsPlayerBuildable : 1;                            // 0x0348(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPublic))
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDied;                                            // 0x034C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x0358(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bFireBuiltAndDestroyedEvents;                      // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortMission*                           AssociatedMissionParam;                            // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              PrimarySurfaceType;                                // 0x036C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortBaseWeaponDamage                         WeaponResponseType;                                // 0x036D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPlacementActor*                    OriginatingPlacementActor;                         // 0x0370(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnInteract;                                        // 0x0374(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowInteract;                                    // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowHostileBlueprintInteraction;                 // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   InteractionSpeed;                                  // 0x0384(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x1C];                                     // 0x0390(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataVersion;                                       // 0x03AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTakeHitTimeTimeout;                            // 0x03B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortDamageSource>              CurFrameDmgSources;                                // 0x03B4(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         CullDistance;                                      // 0x03C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HealthOverride;                                    // 0x03C4(0x000C)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SnapGridSize;                                      // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VertSnapGridSize;                                  // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SnapOffset;                                        // 0x03D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                CentroidOffset;                                    // 0x03E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BaseLocToPivotOffset;                              // 0x03F0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 CustomState;                                       // 0x03FC(0x000C)(Net, ZeroConstructor, SaveGame, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x0408(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsNavigationRelevant : 1;                         // 0x040C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUseHotSpotAsMoveGoalReplacement : 1;              // 0x040C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingActorHotSpotConfig*            HotSpotConfig;                                     // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnBeginInteract();
	void BlueprintOnInteract(const class AFortPawn* InteractingPawn);
	void CustomStateChanged();
	void GameplayCue_Damage(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Healing(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_InstantDeath(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void HandleDestroyed();
	void InitializeKismetSpawnedBuildingActor(class ABuildingActor* BuildingOwner, class AFortPlayerController* SpawningController);
	void OnBuildingActorInitialized(EFortBuildingInitializationReason InitializationReason, EFortBuildingPersistentState BuildingPersistentState);
	void OnDamagePlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnDeathPlayEffects(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AFortPawn* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnDeathServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext);
	void OnMatchStarted();
	void OnRep_CurrentBuildingLevel();
	void OnRep_CustomState();
	void OnWorldReady();
	void PlacedByPlacementTool();
	void SetCanExportNavigationObstacle(bool InCanExportNavigationObstacle);
	void SetCustomState(const class FString& NewState);
	void SetNavigationModifier(bool bEnableModifier);
	bool ShouldDie(float Damage, class AController* EventInstigator, class AActor* DamageCauser);
	void SilentDie();

	bool BlueprintCanInteract(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetFailedInteractionString(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const;
	struct FVector GetCentroid() const;
	int32 GetCurrentBuildingLevel() const;
	class FString GetCustomState() const;
	float GetHealth() const;
	float GetHealthPercent() const;
	float GetMaxHealth() const;
	float GetMissingHealth() const;
	class AController* GetOwningController() const;
	class AFortPlayerState* GetOwningPlayerState() const;
	bool HasHealthLeft() const;
	bool IsAcceptablePositionForPlacement(const struct FVector& InLocation, const struct FRotator& InRotation, class AFortDecoTool* DecoTool, bool bIsCDO, class FText* OutFailureReason) const;
	bool IsDamaged() const;
	bool IsPlayerBuilt() const;
	bool UseDefaultHealthBar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActor">();
	}
	static class ABuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingActor>();
	}
};
static_assert(alignof(ABuildingActor) == 0x000004, "Wrong alignment on ABuildingActor");
static_assert(sizeof(ABuildingActor) == 0x000418, "Wrong size on ABuildingActor");
static_assert(offsetof(ABuildingActor, BuildingType) == 0x000270, "Member 'ABuildingActor::BuildingType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, MyGuid) == 0x000274, "Member 'ABuildingActor::MyGuid' has a wrong offset!");
static_assert(offsetof(ABuildingActor, InteractionText) == 0x000284, "Member 'ABuildingActor::InteractionText' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DisplayName) == 0x000290, "Member 'ABuildingActor::DisplayName' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OwnerPersistentID) == 0x00029C, "Member 'ABuildingActor::OwnerPersistentID' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AreaClass) == 0x0002A0, "Member 'ABuildingActor::AreaClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, NavigationLinksClass) == 0x0002B8, "Member 'ABuildingActor::NavigationLinksClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CurrentBuildingLevel) == 0x0002D0, "Member 'ABuildingActor::CurrentBuildingLevel' has a wrong offset!");
static_assert(offsetof(ABuildingActor, MaximumBuildingLevel) == 0x0002D4, "Member 'ABuildingActor::MaximumBuildingLevel' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BuildingAttributeSetClass) == 0x0002DC, "Member 'ABuildingActor::BuildingAttributeSetClass' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BuildingAttributeSet) == 0x0002E0, "Member 'ABuildingActor::BuildingAttributeSet' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AbilitySystemComponent) == 0x0002E4, "Member 'ABuildingActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bSurpressHealthBar) == 0x0002E8, "Member 'ABuildingActor::bSurpressHealthBar' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bRecentlyDamaged) == 0x0002E9, "Member 'ABuildingActor::bRecentlyDamaged' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DefaultTags) == 0x0002F0, "Member 'ABuildingActor::DefaultTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, ConstTags) == 0x000308, "Member 'ABuildingActor::ConstTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, StaticGameplayTags) == 0x000320, "Member 'ABuildingActor::StaticGameplayTags' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DynamicBuildingPlacementType) == 0x000338, "Member 'ABuildingActor::DynamicBuildingPlacementType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, NavigationObstacleOverride) == 0x000339, "Member 'ABuildingActor::NavigationObstacleOverride' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LDMaxDrawDistance) == 0x000340, "Member 'ABuildingActor::LDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LifespanAfterDeath) == 0x000344, "Member 'ABuildingActor::LifespanAfterDeath' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnDied) == 0x00034C, "Member 'ABuildingActor::OnDied' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnDamaged) == 0x000358, "Member 'ABuildingActor::OnDamaged' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bFireBuiltAndDestroyedEvents) == 0x000364, "Member 'ABuildingActor::bFireBuiltAndDestroyedEvents' has a wrong offset!");
static_assert(offsetof(ABuildingActor, AssociatedMissionParam) == 0x000368, "Member 'ABuildingActor::AssociatedMissionParam' has a wrong offset!");
static_assert(offsetof(ABuildingActor, PrimarySurfaceType) == 0x00036C, "Member 'ABuildingActor::PrimarySurfaceType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, WeaponResponseType) == 0x00036D, "Member 'ABuildingActor::WeaponResponseType' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OriginatingPlacementActor) == 0x000370, "Member 'ABuildingActor::OriginatingPlacementActor' has a wrong offset!");
static_assert(offsetof(ABuildingActor, OnInteract) == 0x000374, "Member 'ABuildingActor::OnInteract' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bAllowInteract) == 0x000380, "Member 'ABuildingActor::bAllowInteract' has a wrong offset!");
static_assert(offsetof(ABuildingActor, bAllowHostileBlueprintInteraction) == 0x000381, "Member 'ABuildingActor::bAllowHostileBlueprintInteraction' has a wrong offset!");
static_assert(offsetof(ABuildingActor, InteractionSpeed) == 0x000384, "Member 'ABuildingActor::InteractionSpeed' has a wrong offset!");
static_assert(offsetof(ABuildingActor, DataVersion) == 0x0003AC, "Member 'ABuildingActor::DataVersion' has a wrong offset!");
static_assert(offsetof(ABuildingActor, LastTakeHitTimeTimeout) == 0x0003B0, "Member 'ABuildingActor::LastTakeHitTimeTimeout' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CurFrameDmgSources) == 0x0003B4, "Member 'ABuildingActor::CurFrameDmgSources' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CullDistance) == 0x0003C0, "Member 'ABuildingActor::CullDistance' has a wrong offset!");
static_assert(offsetof(ABuildingActor, HealthOverride) == 0x0003C4, "Member 'ABuildingActor::HealthOverride' has a wrong offset!");
static_assert(offsetof(ABuildingActor, SnapGridSize) == 0x0003D0, "Member 'ABuildingActor::SnapGridSize' has a wrong offset!");
static_assert(offsetof(ABuildingActor, VertSnapGridSize) == 0x0003D4, "Member 'ABuildingActor::VertSnapGridSize' has a wrong offset!");
static_assert(offsetof(ABuildingActor, SnapOffset) == 0x0003D8, "Member 'ABuildingActor::SnapOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CentroidOffset) == 0x0003E4, "Member 'ABuildingActor::CentroidOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, BaseLocToPivotOffset) == 0x0003F0, "Member 'ABuildingActor::BaseLocToPivotOffset' has a wrong offset!");
static_assert(offsetof(ABuildingActor, CustomState) == 0x0003FC, "Member 'ABuildingActor::CustomState' has a wrong offset!");
static_assert(offsetof(ABuildingActor, Team) == 0x000408, "Member 'ABuildingActor::Team' has a wrong offset!");
static_assert(offsetof(ABuildingActor, HotSpotConfig) == 0x000410, "Member 'ABuildingActor::HotSpotConfig' has a wrong offset!");

// Class FortniteGame.FortDamageSourceInterface
// 0x0000 (0x001C - 0x001C)
class IFortDamageSourceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageSourceInterface">();
	}
	static class IFortDamageSourceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortDamageSourceInterface>();
	}
};
static_assert(alignof(IFortDamageSourceInterface) == 0x000004, "Wrong alignment on IFortDamageSourceInterface");
static_assert(sizeof(IFortDamageSourceInterface) == 0x00001C, "Wrong size on IFortDamageSourceInterface");

// Class FortniteGame.FortAIEncounterRiftManager
// 0x0130 (0x014C - 0x001C)
class UFortAIEncounterRiftManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   MyEncounter;                                       // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIDirector*                        AIDirector;                                        // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              CurrentSpawnArea;                                  // 0x0028(0x0028)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnArea              FutureSpawnArea;                                   // 0x0050(0x0028)(NativeAccessSpecifierPublic)
	float                                         UpdateIntervalTimeSeconds;                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRiftsToUse;                                     // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortEncounterSettings                 EncounterSettings;                                 // 0x0088(0x0030)(NativeAccessSpecifierPublic)
	float                                         ExtraSpawnLocationPercentage;                      // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         CurrentEnvironmentQueryInfo;                       // 0x00BC(0x001C)(NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         FallbackEnvironmentQueryInfo;                      // 0x00D8(0x001C)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterQueryDirectionTracker  EncounterQueryDirectionTracker;                    // 0x00F4(0x0034)(NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastObjectiveBatchPathCostUpdateTime;              // 0x012C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPlayerBatchPathCostUpdateTime;                 // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x18];                                     // 0x0134(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AFortMission* GetAssociatedMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterRiftManager">();
	}
	static class UFortAIEncounterRiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterRiftManager>();
	}
};
static_assert(alignof(UFortAIEncounterRiftManager) == 0x000004, "Wrong alignment on UFortAIEncounterRiftManager");
static_assert(sizeof(UFortAIEncounterRiftManager) == 0x00014C, "Wrong size on UFortAIEncounterRiftManager");
static_assert(offsetof(UFortAIEncounterRiftManager, MyEncounter) == 0x000020, "Member 'UFortAIEncounterRiftManager::MyEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, AIDirector) == 0x000024, "Member 'UFortAIEncounterRiftManager::AIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentSpawnArea) == 0x000028, "Member 'UFortAIEncounterRiftManager::CurrentSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FutureSpawnArea) == 0x000050, "Member 'UFortAIEncounterRiftManager::FutureSpawnArea' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, UpdateIntervalTimeSeconds) == 0x000078, "Member 'UFortAIEncounterRiftManager::UpdateIntervalTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, NumRiftsToUse) == 0x000080, "Member 'UFortAIEncounterRiftManager::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, MinRiftsToUse) == 0x000084, "Member 'UFortAIEncounterRiftManager::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterSettings) == 0x000088, "Member 'UFortAIEncounterRiftManager::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, ExtraSpawnLocationPercentage) == 0x0000B8, "Member 'UFortAIEncounterRiftManager::ExtraSpawnLocationPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, CurrentEnvironmentQueryInfo) == 0x0000BC, "Member 'UFortAIEncounterRiftManager::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, FallbackEnvironmentQueryInfo) == 0x0000D8, "Member 'UFortAIEncounterRiftManager::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, EncounterQueryDirectionTracker) == 0x0000F4, "Member 'UFortAIEncounterRiftManager::EncounterQueryDirectionTracker' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, RiftClassTemplate) == 0x000128, "Member 'UFortAIEncounterRiftManager::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastObjectiveBatchPathCostUpdateTime) == 0x00012C, "Member 'UFortAIEncounterRiftManager::LastObjectiveBatchPathCostUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterRiftManager, LastPlayerBatchPathCostUpdateTime) == 0x000130, "Member 'UFortAIEncounterRiftManager::LastPlayerBatchPathCostUpdateTime' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalNumberOfAIAssigned
// 0x0004 (0x0120 - 0x011C)
class UFortQueryTest_GoalNumberOfAIAssigned final : public UFortQueryTest_GoalBase
{
public:
	ECountAIAssignedToType                        TypeOfMatchToCount;                                // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalNumberOfAIAssigned">();
	}
	static class UFortQueryTest_GoalNumberOfAIAssigned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalNumberOfAIAssigned>();
	}
};
static_assert(alignof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x000004, "Wrong alignment on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(sizeof(UFortQueryTest_GoalNumberOfAIAssigned) == 0x000120, "Wrong size on UFortQueryTest_GoalNumberOfAIAssigned");
static_assert(offsetof(UFortQueryTest_GoalNumberOfAIAssigned, TypeOfMatchToCount) == 0x00011C, "Member 'UFortQueryTest_GoalNumberOfAIAssigned::TypeOfMatchToCount' has a wrong offset!");

// Class FortniteGame.BuildingGameplayActor
// 0x0070 (0x0488 - 0x0418)
class ABuildingGameplayActor : public ABuildingActor
{
public:
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         InitialMaxHealth;                                  // 0x0420(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortAbilitySet*                        AbilitySet;                                        // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageSet;                                         // 0x0438(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x043C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInstigatorCollision;                        // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAddOwnerVelocity;                                 // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuildingGameplayActorAbilityDeliveryInfo DeliverableAbilityInfo;                            // 0x044C(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x8];                                      // 0x047C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0484(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisableAbilityDeliveryInfo(const struct FGameplayTag& BucketTag);
	void EnableAbilityDeliveryInfo(const struct FGameplayTag& BucketTag);
	void K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context);
	void K2_ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag);
	void SetIgnoreInstigatorCollision(bool bShouldIgnore);
	void SetInitialVelocity(const struct FVector& InitialVelocity);

	struct FTransform GetTargetingSourceTransform(EFortAbilityTargetingSource Source) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingGameplayActor">();
	}
	static class ABuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingGameplayActor>();
	}
};
static_assert(alignof(ABuildingGameplayActor) == 0x000004, "Wrong alignment on ABuildingGameplayActor");
static_assert(sizeof(ABuildingGameplayActor) == 0x000488, "Wrong size on ABuildingGameplayActor");
static_assert(offsetof(ABuildingGameplayActor, InitialMaxHealth) == 0x000420, "Member 'ABuildingGameplayActor::InitialMaxHealth' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, AbilitySet) == 0x000434, "Member 'ABuildingGameplayActor::AbilitySet' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DamageSet) == 0x000438, "Member 'ABuildingGameplayActor::DamageSet' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DamageStatHandle) == 0x00043C, "Member 'ABuildingGameplayActor::DamageStatHandle' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, bIgnoreInstigatorCollision) == 0x000448, "Member 'ABuildingGameplayActor::bIgnoreInstigatorCollision' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, bAddOwnerVelocity) == 0x000449, "Member 'ABuildingGameplayActor::bAddOwnerVelocity' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, DeliverableAbilityInfo) == 0x00044C, "Member 'ABuildingGameplayActor::DeliverableAbilityInfo' has a wrong offset!");
static_assert(offsetof(ABuildingGameplayActor, ProjectileMovementComponent) == 0x000484, "Member 'ABuildingGameplayActor::ProjectileMovementComponent' has a wrong offset!");

// Class FortniteGame.BuildingCapturePointActor
// 0x0090 (0x0518 - 0x0488)
class ABuildingCapturePointActor final : public ABuildingGameplayActor
{
public:
	uint8                                         bUseHUDIndicator : 1;                              // 0x0488(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HUDStyle;                                          // 0x048C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HUDOffset;                                         // 0x0494(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHUDClampToScreenEdge : 1;                         // 0x04A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionComponent;                                // 0x04A8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bActivated : 1;                                    // 0x04AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EContentionRules                              ContentionRules;                                   // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortTeam>                             TeamsBarredFromCapture;                            // 0x04B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         PercentIncreasePerPlayerCaptor;                    // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentIncreasePerAICaptor;                        // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PercentDecreaseNoCaptor;                           // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLocked : 1;                                       // 0x04CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnlockInterval;                                    // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUnlockRules                                  UnlockRules;                                       // 0x04D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumCapturingPoint;                                 // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamCapturingPoint;                                // 0x04DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamControllingPoint;                              // 0x04DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     TeamOwningPoint;                                   // 0x04DE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECaptureState                                 CaptureState;                                      // 0x04DF(0x0001)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapturePercentage;                                 // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReplicatedCapturePercentage;                       // 0x04E4(0x0004)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnCapturePointStateChanged;                        // 0x04E8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnTeamOwningPointChanges;                          // 0x04F4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x18];                                     // 0x0500(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCapturePointActiveStateChange(bool bInActive);
	void OnCapturePointLockStateChange(bool bInLocked);
	void OnCapturePointStateChange(ECaptureState InState, EFortTeam InTeam);
	void OnEnterCapturePoint(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnLeaveCapturePoint(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_bActivated();
	void OnRep_bLocked();
	void OnRep_CaptureState();
	void OnRep_ReplicatedCapturePercentage();
	void SetActivatedState(bool bInActivated);

	ECaptureState GetCaptureState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingCapturePointActor">();
	}
	static class ABuildingCapturePointActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingCapturePointActor>();
	}
};
static_assert(alignof(ABuildingCapturePointActor) == 0x000004, "Wrong alignment on ABuildingCapturePointActor");
static_assert(sizeof(ABuildingCapturePointActor) == 0x000518, "Wrong size on ABuildingCapturePointActor");
static_assert(offsetof(ABuildingCapturePointActor, HUDStyle) == 0x00048C, "Member 'ABuildingCapturePointActor::HUDStyle' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, HUDOffset) == 0x000494, "Member 'ABuildingCapturePointActor::HUDOffset' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CollisionComponent) == 0x0004A8, "Member 'ABuildingCapturePointActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, ContentionRules) == 0x0004B0, "Member 'ABuildingCapturePointActor::ContentionRules' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamsBarredFromCapture) == 0x0004B4, "Member 'ABuildingCapturePointActor::TeamsBarredFromCapture' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentIncreasePerPlayerCaptor) == 0x0004C0, "Member 'ABuildingCapturePointActor::PercentIncreasePerPlayerCaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentIncreasePerAICaptor) == 0x0004C4, "Member 'ABuildingCapturePointActor::PercentIncreasePerAICaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, PercentDecreaseNoCaptor) == 0x0004C8, "Member 'ABuildingCapturePointActor::PercentDecreaseNoCaptor' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, UnlockInterval) == 0x0004D0, "Member 'ABuildingCapturePointActor::UnlockInterval' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, UnlockRules) == 0x0004D4, "Member 'ABuildingCapturePointActor::UnlockRules' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, NumCapturingPoint) == 0x0004D8, "Member 'ABuildingCapturePointActor::NumCapturingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamCapturingPoint) == 0x0004DC, "Member 'ABuildingCapturePointActor::TeamCapturingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamControllingPoint) == 0x0004DD, "Member 'ABuildingCapturePointActor::TeamControllingPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, TeamOwningPoint) == 0x0004DE, "Member 'ABuildingCapturePointActor::TeamOwningPoint' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CaptureState) == 0x0004DF, "Member 'ABuildingCapturePointActor::CaptureState' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, CapturePercentage) == 0x0004E0, "Member 'ABuildingCapturePointActor::CapturePercentage' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, ReplicatedCapturePercentage) == 0x0004E4, "Member 'ABuildingCapturePointActor::ReplicatedCapturePercentage' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, OnCapturePointStateChanged) == 0x0004E8, "Member 'ABuildingCapturePointActor::OnCapturePointStateChanged' has a wrong offset!");
static_assert(offsetof(ABuildingCapturePointActor, OnTeamOwningPointChanges) == 0x0004F4, "Member 'ABuildingCapturePointActor::OnTeamOwningPointChanges' has a wrong offset!");

// Class FortniteGame.FortAIEncounterGoalSelectionTable
// 0x000C (0x0028 - 0x001C)
class UFortAIEncounterGoalSelectionTable final : public UDataAsset
{
public:
	TArray<struct FEncounterGoalSelectionTableEntry> EncounterGoalSelectionCriteria;                    // 0x001C(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterGoalSelectionTable">();
	}
	static class UFortAIEncounterGoalSelectionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterGoalSelectionTable>();
	}
};
static_assert(alignof(UFortAIEncounterGoalSelectionTable) == 0x000004, "Wrong alignment on UFortAIEncounterGoalSelectionTable");
static_assert(sizeof(UFortAIEncounterGoalSelectionTable) == 0x000028, "Wrong size on UFortAIEncounterGoalSelectionTable");
static_assert(offsetof(UFortAIEncounterGoalSelectionTable, EncounterGoalSelectionCriteria) == 0x00001C, "Member 'UFortAIEncounterGoalSelectionTable::EncounterGoalSelectionCriteria' has a wrong offset!");

// Class FortniteGame.BuildingFlagSpawn
// 0x0050 (0x04D8 - 0x0488)
class ABuildingFlagSpawn final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_488[0x4];                                      // 0x0488(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HUDIndicatorRelativeOffset;                        // 0x048C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bPickupOnTouch;                                    // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortCarriedObject>         CarriedObjectClass;                                // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeTranslation;                               // 0x04A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFortCarriedObject*                     SpawnedObject;                                     // 0x04AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EmptyString;                                       // 0x04B0(0x000C)(Protected, NativeAccessSpecifierProtected)
	class FText                                   SearchString;                                      // 0x04BC(0x000C)(Protected, NativeAccessSpecifierProtected)
	float                                         SpawnDelay;                                        // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0xC];                                      // 0x04CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCarriedObjectAttachedEvent();
	void OnCarriedObjectDetachedEvent();
	void SpawnCarriedObject();

	bool IsSpawnedObjectAwayFromBase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFlagSpawn">();
	}
	static class ABuildingFlagSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFlagSpawn>();
	}
};
static_assert(alignof(ABuildingFlagSpawn) == 0x000004, "Wrong alignment on ABuildingFlagSpawn");
static_assert(sizeof(ABuildingFlagSpawn) == 0x0004D8, "Wrong size on ABuildingFlagSpawn");
static_assert(offsetof(ABuildingFlagSpawn, HUDIndicatorRelativeOffset) == 0x00048C, "Member 'ABuildingFlagSpawn::HUDIndicatorRelativeOffset' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, bPickupOnTouch) == 0x000498, "Member 'ABuildingFlagSpawn::bPickupOnTouch' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, CarriedObjectClass) == 0x00049C, "Member 'ABuildingFlagSpawn::CarriedObjectClass' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, RelativeTranslation) == 0x0004A0, "Member 'ABuildingFlagSpawn::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, SpawnedObject) == 0x0004AC, "Member 'ABuildingFlagSpawn::SpawnedObject' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, EmptyString) == 0x0004B0, "Member 'ABuildingFlagSpawn::EmptyString' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, SearchString) == 0x0004BC, "Member 'ABuildingFlagSpawn::SearchString' has a wrong offset!");
static_assert(offsetof(ABuildingFlagSpawn, SpawnDelay) == 0x0004C8, "Member 'ABuildingFlagSpawn::SpawnDelay' has a wrong offset!");

// Class FortniteGame.BuildingItemCollectorActor
// 0x004C (0x04D4 - 0x0488)
class ABuildingItemCollectorActor final : public ABuildingGameplayActor
{
public:
	uint8                                         Pad_488[0x1C];                                     // 0x0488(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	EFortItemCollectorBehavior                    ItemCollectorBehavior;                             // 0x04A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortItemCollectorState                       ItemCollectorState;                                // 0x04A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTeam                                     ControllingTeam;                                   // 0x04A6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A7[0x1];                                      // 0x04A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItemDefinition*               ItemToDeposit;                                     // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MaxDepositCurve;                                   // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamDepositAmounts;                                // 0x04B0(0x000C)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamDepositGoals;                                  // 0x04BC(0x000C)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0xC];                                      // 0x04C8(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetNumberOfTeamCaptures(EFortTeam InTeam);
	int32 GetTeamDepositAmount(EFortTeam InTeam);
	int32 GetTeamDepositGoal(EFortTeam InTeam);
	int32 GetTeamReachedGoalCount(EFortTeam InTeam);
	void OnItemCollectorStateChanged(EFortItemCollectorState InItemCollectorState);
	void OnRep_ControllingTeam();
	void OnRep_ItemCollectorState();
	void OnRep_TeamDepositAmounts();
	void OnRep_TeamDepositGoals();
	void OnTeamReachedDepositGoal(EFortTeam InControllingTeam);
	void SetItemCollectorState(EFortItemCollectorState InItemCollectorState);
	void UpdateTeamDepositValues(const TArray<int32>& DepositAmounts, const TArray<int32>& DepositGoals);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingItemCollectorActor">();
	}
	static class ABuildingItemCollectorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingItemCollectorActor>();
	}
};
static_assert(alignof(ABuildingItemCollectorActor) == 0x000004, "Wrong alignment on ABuildingItemCollectorActor");
static_assert(sizeof(ABuildingItemCollectorActor) == 0x0004D4, "Wrong size on ABuildingItemCollectorActor");
static_assert(offsetof(ABuildingItemCollectorActor, ItemCollectorBehavior) == 0x0004A4, "Member 'ABuildingItemCollectorActor::ItemCollectorBehavior' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ItemCollectorState) == 0x0004A5, "Member 'ABuildingItemCollectorActor::ItemCollectorState' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ControllingTeam) == 0x0004A6, "Member 'ABuildingItemCollectorActor::ControllingTeam' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, ItemToDeposit) == 0x0004A8, "Member 'ABuildingItemCollectorActor::ItemToDeposit' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, MaxDepositCurve) == 0x0004AC, "Member 'ABuildingItemCollectorActor::MaxDepositCurve' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, TeamDepositAmounts) == 0x0004B0, "Member 'ABuildingItemCollectorActor::TeamDepositAmounts' has a wrong offset!");
static_assert(offsetof(ABuildingItemCollectorActor, TeamDepositGoals) == 0x0004BC, "Member 'ABuildingItemCollectorActor::TeamDepositGoals' has a wrong offset!");

// Class FortniteGame.FortAIGoalManager
// 0x00D4 (0x0314 - 0x0240)
class AFortAIGoalManager : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHorizontalTilesToUndermineGoal;                 // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalTilesToUndermineGoal;                   // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortAIAssignment*>              WorldAssignments;                                  // 0x024C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFortAIAssignment*>              WorldEnemyAssignments;                             // 0x0258(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UFortAIAssignment*                      DefaultAttackPlayersAssignment;                    // 0x0264(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x48];                                     // 0x0268(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEnvQuery*>                      CombinedQueries;                                   // 0x02B0(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x3C];                                     // 0x02BC(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignmentSettings*              DefaultUnderminingAssignmentSettings;              // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAIAssignmentSettings*              DefaultEnemyAssignmentSettings;                    // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPawnGoalSelectionTableEntry>   PawnGoalSelectionTable;                            // 0x0304(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x4];                                      // 0x0310(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddGoalsToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void AddGoalToWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void CreateWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& WorldAssignmentIdentifier, class UFortAIAssignmentSettings* AssignmentSettings, TSubclassOf<class UFortAIGoalProvider> GoalProvider, struct FFortAIAssignmentIdentifier* AssignmentIdentifier, EAssignmentCreationResult* CreationResult);
	static void MakeGoalFromActor(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, const class AActor*& GoalActor, bool bActorAlwaysPerceived, bool bGoalActorAllowsUndermining);
	static void MakeGoalFromLocation(struct FFortAIGoalInfo* Goal, const class UObject* WorldContextObject, const struct FVector& GoalLocation);
	static void MakeGoalsFromActors(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<class AActor*>& GoalActors, bool bActorsAlwaysPerceived, bool bGoalActorsAllowUndermining);
	static void MakeGoalsFromLocations(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations);
	static void MakeGoalsFromLocationsAndActor(TArray<struct FFortAIGoalInfo>* Goals, const class UObject* WorldContextObject, const TArray<struct FVector>& GoalLocations, const class AActor* GoalActor);
	static void RemoveGoalFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const struct FFortAIGoalInfo& GoalInfo);
	static void RemoveGoalsFromWorldAssignment(class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	static void RemoveWorldAssignment(const class UObject* WorldContextObject, const struct FFortAIAssignmentIdentifier& AssignmentIdentifier);

	void AddGoal(class AActor* GoalActor, class UFortAIAssignmentSettings* GoalSettings);
	void AddGoalActorToAssignment(class UFortAIAssignment* Assignment, class AActor* GoalActor);
	class UFortAIAssignment* AddWorldAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIGoalManager">();
	}
	static class AFortAIGoalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIGoalManager>();
	}
};
static_assert(alignof(AFortAIGoalManager) == 0x000004, "Wrong alignment on AFortAIGoalManager");
static_assert(sizeof(AFortAIGoalManager) == 0x000314, "Wrong size on AFortAIGoalManager");
static_assert(offsetof(AFortAIGoalManager, MaxHorizontalTilesToUndermineGoal) == 0x000244, "Member 'AFortAIGoalManager::MaxHorizontalTilesToUndermineGoal' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, MaxVerticalTilesToUndermineGoal) == 0x000248, "Member 'AFortAIGoalManager::MaxVerticalTilesToUndermineGoal' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, WorldAssignments) == 0x00024C, "Member 'AFortAIGoalManager::WorldAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, WorldEnemyAssignments) == 0x000258, "Member 'AFortAIGoalManager::WorldEnemyAssignments' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultAttackPlayersAssignment) == 0x000264, "Member 'AFortAIGoalManager::DefaultAttackPlayersAssignment' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, CombinedQueries) == 0x0002B0, "Member 'AFortAIGoalManager::CombinedQueries' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEncounterAssignmentSettings) == 0x0002F8, "Member 'AFortAIGoalManager::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultUnderminingAssignmentSettings) == 0x0002FC, "Member 'AFortAIGoalManager::DefaultUnderminingAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, DefaultEnemyAssignmentSettings) == 0x000300, "Member 'AFortAIGoalManager::DefaultEnemyAssignmentSettings' has a wrong offset!");
static_assert(offsetof(AFortAIGoalManager, PawnGoalSelectionTable) == 0x000304, "Member 'AFortAIGoalManager::PawnGoalSelectionTable' has a wrong offset!");

// Class FortniteGame.SBAGrantedBuildingGameplayActor
// 0x0004 (0x048C - 0x0488)
class ASBAGrantedBuildingGameplayActor final : public ABuildingGameplayActor
{
public:
	struct FTeamStrategicBuildingHandle           OwningSBAHandle;                                   // 0x0488(0x0004)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	class AStrategicBuildingActor* GetOwnerStrategicBuildingActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SBAGrantedBuildingGameplayActor">();
	}
	static class ASBAGrantedBuildingGameplayActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASBAGrantedBuildingGameplayActor>();
	}
};
static_assert(alignof(ASBAGrantedBuildingGameplayActor) == 0x000004, "Wrong alignment on ASBAGrantedBuildingGameplayActor");
static_assert(sizeof(ASBAGrantedBuildingGameplayActor) == 0x00048C, "Wrong size on ASBAGrantedBuildingGameplayActor");
static_assert(offsetof(ASBAGrantedBuildingGameplayActor, OwningSBAHandle) == 0x000488, "Member 'ASBAGrantedBuildingGameplayActor::OwningSBAHandle' has a wrong offset!");

// Class FortniteGame.StrategicBuildingActor
// 0x00D8 (0x0560 - 0x0488)
class AStrategicBuildingActor : public ABuildingGameplayActor
{
public:
	float                                         HealthBarVisibilityDistance;                       // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthBarVisibilityDistanceSquared;                // 0x048C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          TouchBoxComponent;                                 // 0x0490(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortStrategicBuildingCategory                StrategicBuildingCategory;                         // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_495[0x3];                                      // 0x0495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAbilitySet*>                PermanentInherentAbilitySets;                      // 0x0498(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStrategicBuildingLevelInformation> LevelInfo;                                         // 0x04A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         ProximityPulseInterval;                            // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortGameplayAbility>       DeathPenaltyAbility;                               // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathParticles;                                    // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DeathSound;                                        // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortGadgetItemDefinition*              SpawnedFromItemDefinition;                         // 0x04C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamStrategicBuildingHandle           SBAHandle;                                         // 0x04C4(0x0004)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FStrategicBuildingActiveConstructionInfo ConstructionProgress;                              // 0x04C8(0x0014)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStrategicBuildingLevelActiveCriteriaProgress> LevelProgress;                                     // 0x04DC(0x000C)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          StrategicBuildingAbilitySets;                      // 0x04E8(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          PersistentlyAppliedAbilitySets;                    // 0x04F4(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         DeferredTouchActorsToProcess;                      // 0x0500(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x40];                                     // 0x050C(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsActive : 1;                                     // 0x054C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasGEsToApplyOnTouch : 1;                         // 0x054C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasGEsToApplyOnPulseTimer : 1;                    // 0x054C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortVisibilityComponent*               VisibilityComponent;                               // 0x0550(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MiniMapIcon;                                       // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyProximityPulseEffects();
	bool AttemptIncrementLevelUnlockProgress(int32 InLevel, float InProgressDelta);
	void GiveItemFromStrategicBuildingToPlayer(class AFortPlayerController* PlayerController, const class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive);
	void OnActiveStatusChanged(bool bNewActiveStatus);
	void OnConstructionEndedPlayEffects(int32 ConstructionLevel);
	void OnConstructionStartedPlayEffects(float ServerStartTime, float ServerEndTime, float CurrentServerTime, float ElapsedPct, int32 ConstructionLvl);
	void OnConstructionTickPlayEffects(float DeltaTime, float ElapsedPct, int32 ConstructionLvl);
	void OnRep_bIsActive();
	void OnRep_ConstructionProgress();
	void ProcessDeferredTouchActors();
	void SetupIndicators();
	void SetupVisibilityComponent();

	float GetCurrentLevelUnlockProgress(int32 InLevel) const;
	struct FVector GetDeathEffectsLocation() const;
	struct FRotator GetDeathEffectsRotation() const;
	struct FVector GetDeathEffectsScale() const;
	float GetMaxLevelUnlockProgress(int32 InLevel) const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrategicBuildingActor">();
	}
	static class AStrategicBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStrategicBuildingActor>();
	}
};
static_assert(alignof(AStrategicBuildingActor) == 0x000004, "Wrong alignment on AStrategicBuildingActor");
static_assert(sizeof(AStrategicBuildingActor) == 0x000560, "Wrong size on AStrategicBuildingActor");
static_assert(offsetof(AStrategicBuildingActor, HealthBarVisibilityDistance) == 0x000488, "Member 'AStrategicBuildingActor::HealthBarVisibilityDistance' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, HealthBarVisibilityDistanceSquared) == 0x00048C, "Member 'AStrategicBuildingActor::HealthBarVisibilityDistanceSquared' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, TouchBoxComponent) == 0x000490, "Member 'AStrategicBuildingActor::TouchBoxComponent' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, StrategicBuildingCategory) == 0x000494, "Member 'AStrategicBuildingActor::StrategicBuildingCategory' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, PermanentInherentAbilitySets) == 0x000498, "Member 'AStrategicBuildingActor::PermanentInherentAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, LevelInfo) == 0x0004A4, "Member 'AStrategicBuildingActor::LevelInfo' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, ProximityPulseInterval) == 0x0004B0, "Member 'AStrategicBuildingActor::ProximityPulseInterval' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathPenaltyAbility) == 0x0004B4, "Member 'AStrategicBuildingActor::DeathPenaltyAbility' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathParticles) == 0x0004B8, "Member 'AStrategicBuildingActor::DeathParticles' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeathSound) == 0x0004BC, "Member 'AStrategicBuildingActor::DeathSound' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, SpawnedFromItemDefinition) == 0x0004C0, "Member 'AStrategicBuildingActor::SpawnedFromItemDefinition' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, SBAHandle) == 0x0004C4, "Member 'AStrategicBuildingActor::SBAHandle' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, ConstructionProgress) == 0x0004C8, "Member 'AStrategicBuildingActor::ConstructionProgress' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, LevelProgress) == 0x0004DC, "Member 'AStrategicBuildingActor::LevelProgress' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, StrategicBuildingAbilitySets) == 0x0004E8, "Member 'AStrategicBuildingActor::StrategicBuildingAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, PersistentlyAppliedAbilitySets) == 0x0004F4, "Member 'AStrategicBuildingActor::PersistentlyAppliedAbilitySets' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, DeferredTouchActorsToProcess) == 0x000500, "Member 'AStrategicBuildingActor::DeferredTouchActorsToProcess' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, VisibilityComponent) == 0x000550, "Member 'AStrategicBuildingActor::VisibilityComponent' has a wrong offset!");
static_assert(offsetof(AStrategicBuildingActor, MiniMapIcon) == 0x000554, "Member 'AStrategicBuildingActor::MiniMapIcon' has a wrong offset!");

// Class FortniteGame.FortPvPBaseCornerstone
// 0x0024 (0x0584 - 0x0560)
class AFortPvPBaseCornerstone final : public AStrategicBuildingActor
{
public:
	uint8                                         bInvincible : 1;                                   // 0x0560(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCornerstoneDamaged;                              // 0x0564(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnCornerstoneOutOfHealth;                          // 0x0570(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x8];                                      // 0x057C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInvincibilityChanged(bool bIsInvincible);
	void OnRep_bInvincible();
	void SetInvincibility(bool bInInvincible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPBaseCornerstone">();
	}
	static class AFortPvPBaseCornerstone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPBaseCornerstone>();
	}
};
static_assert(alignof(AFortPvPBaseCornerstone) == 0x000004, "Wrong alignment on AFortPvPBaseCornerstone");
static_assert(sizeof(AFortPvPBaseCornerstone) == 0x000584, "Wrong size on AFortPvPBaseCornerstone");
static_assert(offsetof(AFortPvPBaseCornerstone, OnCornerstoneDamaged) == 0x000564, "Member 'AFortPvPBaseCornerstone::OnCornerstoneDamaged' has a wrong offset!");
static_assert(offsetof(AFortPvPBaseCornerstone, OnCornerstoneOutOfHealth) == 0x000570, "Member 'AFortPvPBaseCornerstone::OnCornerstoneOutOfHealth' has a wrong offset!");

// Class FortniteGame.BuildingRift
// 0x0070 (0x0488 - 0x0418)
class ABuildingRift : public ABuildingActor
{
public:
	float                                         DistToTarget;                                      // 0x0418(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathLengthToTarget;                                // 0x041C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x4];                                      // 0x0420(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelay;                                        // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnvQuery*                              EnvironmentQuery;                                  // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEnvNamedValue>                 QueryParams;                                       // 0x042C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         QueryRadius;                                       // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        FreeSpawnSlots;                                    // 0x043C(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortSpawnSlotData>             UsedSpawnSlots;                                    // 0x0448(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x8];                                      // 0x0454(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRiftIsVisible;                                    // 0x045C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRiftIsActive;                                     // 0x045D(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsReadyToSpawnAI;                                 // 0x045E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasBadRiftSlots;                                  // 0x045F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x28];                                     // 0x0460(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastRiftSpawningAI();
	void OnActivated();
	void OnDeactivated();
	void OnPlaced();
	void OnReceiveSpawnedAIPawn(class AFortAIPawn* SpawnedAI);
	void OnRemoved();
	void OnRep_RiftIsActive();
	void OnRep_RiftIsVisible();
	void OnSpawnAI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingRift">();
	}
	static class ABuildingRift* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingRift>();
	}
};
static_assert(alignof(ABuildingRift) == 0x000004, "Wrong alignment on ABuildingRift");
static_assert(sizeof(ABuildingRift) == 0x000488, "Wrong size on ABuildingRift");
static_assert(offsetof(ABuildingRift, DistToTarget) == 0x000418, "Member 'ABuildingRift::DistToTarget' has a wrong offset!");
static_assert(offsetof(ABuildingRift, PathLengthToTarget) == 0x00041C, "Member 'ABuildingRift::PathLengthToTarget' has a wrong offset!");
static_assert(offsetof(ABuildingRift, SpawnDelay) == 0x000424, "Member 'ABuildingRift::SpawnDelay' has a wrong offset!");
static_assert(offsetof(ABuildingRift, EnvironmentQuery) == 0x000428, "Member 'ABuildingRift::EnvironmentQuery' has a wrong offset!");
static_assert(offsetof(ABuildingRift, QueryParams) == 0x00042C, "Member 'ABuildingRift::QueryParams' has a wrong offset!");
static_assert(offsetof(ABuildingRift, QueryRadius) == 0x000438, "Member 'ABuildingRift::QueryRadius' has a wrong offset!");
static_assert(offsetof(ABuildingRift, FreeSpawnSlots) == 0x00043C, "Member 'ABuildingRift::FreeSpawnSlots' has a wrong offset!");
static_assert(offsetof(ABuildingRift, UsedSpawnSlots) == 0x000448, "Member 'ABuildingRift::UsedSpawnSlots' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bRiftIsVisible) == 0x00045C, "Member 'ABuildingRift::bRiftIsVisible' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bRiftIsActive) == 0x00045D, "Member 'ABuildingRift::bRiftIsActive' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bIsReadyToSpawnAI) == 0x00045E, "Member 'ABuildingRift::bIsReadyToSpawnAI' has a wrong offset!");
static_assert(offsetof(ABuildingRift, bHasBadRiftSlots) == 0x00045F, "Member 'ABuildingRift::bHasBadRiftSlots' has a wrong offset!");

// Class FortniteGame.FortAIPawnVariant
// 0x0034 (0x0050 - 0x001C)
class UFortAIPawnVariant final : public UObject
{
public:
	TArray<TSubclassOf<class AFortAIPawn>>        PawnClasses;                                       // 0x001C(0x000C)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FFortAIPawnVariantDefinition>   PawnVariantDefinitions;                            // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MinPlayersToSpawnVariant;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    SpawnPointValueHandle;                             // 0x0038(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	int32                                         CachedSpawnPointValue;                             // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EncounterExpectedLifespan;                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VersionNum;                                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPawnVariant">();
	}
	static class UFortAIPawnVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPawnVariant>();
	}
};
static_assert(alignof(UFortAIPawnVariant) == 0x000004, "Wrong alignment on UFortAIPawnVariant");
static_assert(sizeof(UFortAIPawnVariant) == 0x000050, "Wrong size on UFortAIPawnVariant");
static_assert(offsetof(UFortAIPawnVariant, PawnClasses) == 0x00001C, "Member 'UFortAIPawnVariant::PawnClasses' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, PawnVariantDefinitions) == 0x000028, "Member 'UFortAIPawnVariant::PawnVariantDefinitions' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, MinPlayersToSpawnVariant) == 0x000034, "Member 'UFortAIPawnVariant::MinPlayersToSpawnVariant' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, SpawnPointValueHandle) == 0x000038, "Member 'UFortAIPawnVariant::SpawnPointValueHandle' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, CachedSpawnPointValue) == 0x000044, "Member 'UFortAIPawnVariant::CachedSpawnPointValue' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, EncounterExpectedLifespan) == 0x000048, "Member 'UFortAIPawnVariant::EncounterExpectedLifespan' has a wrong offset!");
static_assert(offsetof(UFortAIPawnVariant, VersionNum) == 0x00004C, "Member 'UFortAIPawnVariant::VersionNum' has a wrong offset!");

// Class FortniteGame.FortQueryTest_IsGoalForAssignment
// 0x0024 (0x0130 - 0x010C)
class UFortQueryTest_IsGoalForAssignment final : public UEnvQueryTest
{
public:
	bool                                          bRetrieveRootAssignmentFromOwner;                  // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortAIAssignmentIdentifier            RootAssignmentID;                                  // 0x0110(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsGoalForAssignment">();
	}
	static class UFortQueryTest_IsGoalForAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsGoalForAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_IsGoalForAssignment) == 0x000004, "Wrong alignment on UFortQueryTest_IsGoalForAssignment");
static_assert(sizeof(UFortQueryTest_IsGoalForAssignment) == 0x000130, "Wrong size on UFortQueryTest_IsGoalForAssignment");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, bRetrieveRootAssignmentFromOwner) == 0x00010C, "Member 'UFortQueryTest_IsGoalForAssignment::bRetrieveRootAssignmentFromOwner' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_IsGoalForAssignment, RootAssignmentID) == 0x000110, "Member 'UFortQueryTest_IsGoalForAssignment::RootAssignmentID' has a wrong offset!");

// Class FortniteGame.FortTakerRift
// 0x001C (0x04A4 - 0x0488)
class AFortTakerRift final : public ABuildingRift
{
public:
	TSoftObjectPtr<class UParticleSystem>         TakerRiftParticle;                                 // 0x0488(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TakerRiftParticleComponent;                        // 0x04A0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTakerRift">();
	}
	static class AFortTakerRift* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTakerRift>();
	}
};
static_assert(alignof(AFortTakerRift) == 0x000004, "Wrong alignment on AFortTakerRift");
static_assert(sizeof(AFortTakerRift) == 0x0004A4, "Wrong size on AFortTakerRift");
static_assert(offsetof(AFortTakerRift, TakerRiftParticle) == 0x000488, "Member 'AFortTakerRift::TakerRiftParticle' has a wrong offset!");
static_assert(offsetof(AFortTakerRift, TakerRiftParticleComponent) == 0x0004A0, "Member 'AFortTakerRift::TakerRiftParticleComponent' has a wrong offset!");

// Class FortniteGame.FortCrackEffect
// 0x0098 (0x02D8 - 0x0240)
class AFortCrackEffect : public AActor
{
public:
	uint8                                         Pad_240[0xC];                                      // 0x0240(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFadingOut;                                        // 0x024C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ABuildingSMActor>        ParentBuilding;                                    // 0x0250(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bHit : 1;                                          // 0x0258(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CrackHitCount;                                     // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CrackLevel;                                        // 0x0260(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCrackLevel;                                     // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    StartingLocation;                                  // 0x0268(0x000C)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              StartingNormal;                                    // 0x0274(0x000C)(Edit, BlueprintVisible, Net, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitNormal;                                         // 0x0280(0x000C)(Net, RepNotify, NativeAccessSpecifierPublic)
	EPhysicalSurface                              PhysicalSurfaceType;                               // 0x028C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D[0x3];                                      // 0x028D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPhysicalMaterial>       WoodMaterial;                                      // 0x0290(0x0018)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPhysicalMaterial>       StoneMaterial;                                     // 0x02A8(0x0018)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPhysicalMaterial>       MetalMaterial;                                     // 0x02C0(0x0018)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void NetFadeOut();
	void NetOnHitCrack();
	void OnBounceAnimationUpdate(const struct FFortBounceData& BounceData);
	void OnFadeOut();
	void OnHitCrack();
	void OnRep_HitNormal();
	void OnRep_PhysicalSurfaceType();
	void OnStartDirectionEffect();

	bool HasStartingPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCrackEffect">();
	}
	static class AFortCrackEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCrackEffect>();
	}
};
static_assert(alignof(AFortCrackEffect) == 0x000004, "Wrong alignment on AFortCrackEffect");
static_assert(sizeof(AFortCrackEffect) == 0x0002D8, "Wrong size on AFortCrackEffect");
static_assert(offsetof(AFortCrackEffect, bFadingOut) == 0x00024C, "Member 'AFortCrackEffect::bFadingOut' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, ParentBuilding) == 0x000250, "Member 'AFortCrackEffect::ParentBuilding' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, CrackHitCount) == 0x00025C, "Member 'AFortCrackEffect::CrackHitCount' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, CrackLevel) == 0x000260, "Member 'AFortCrackEffect::CrackLevel' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, MaxCrackLevel) == 0x000264, "Member 'AFortCrackEffect::MaxCrackLevel' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StartingLocation) == 0x000268, "Member 'AFortCrackEffect::StartingLocation' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StartingNormal) == 0x000274, "Member 'AFortCrackEffect::StartingNormal' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, HitNormal) == 0x000280, "Member 'AFortCrackEffect::HitNormal' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, PhysicalSurfaceType) == 0x00028C, "Member 'AFortCrackEffect::PhysicalSurfaceType' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, WoodMaterial) == 0x000290, "Member 'AFortCrackEffect::WoodMaterial' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, StoneMaterial) == 0x0002A8, "Member 'AFortCrackEffect::StoneMaterial' has a wrong offset!");
static_assert(offsetof(AFortCrackEffect, MetalMaterial) == 0x0002C0, "Member 'AFortCrackEffect::MetalMaterial' has a wrong offset!");

// Class FortniteGame.FortAIEncounterTargetInterface
// 0x0000 (0x001C - 0x001C)
class IFortAIEncounterTargetInterface final : public IInterface
{
public:
	float GetObjectiveCompletionPercentage();
	bool IsFloatingTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterTargetInterface">();
	}
	static class IFortAIEncounterTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIEncounterTargetInterface>();
	}
};
static_assert(alignof(IFortAIEncounterTargetInterface) == 0x000004, "Wrong alignment on IFortAIEncounterTargetInterface");
static_assert(sizeof(IFortAIEncounterTargetInterface) == 0x00001C, "Wrong size on IFortAIEncounterTargetInterface");

// Class FortniteGame.FortAttachToActorInterface
// 0x0000 (0x001C - 0x001C)
class IFortAttachToActorInterface final : public IInterface
{
public:
	class AActor* GetActorAttachedTo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttachToActorInterface">();
	}
	static class IFortAttachToActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAttachToActorInterface>();
	}
};
static_assert(alignof(IFortAttachToActorInterface) == 0x000004, "Wrong alignment on IFortAttachToActorInterface");
static_assert(sizeof(IFortAttachToActorInterface) == 0x00001C, "Wrong size on IFortAttachToActorInterface");

// Class FortniteGame.BuildingSMActor
// 0x052C (0x0944 - 0x0418)
class ABuildingSMActor : public ABuildingActor
{
public:
	uint8                                         Pad_418[0x4];                                      // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuildingTextureData*                   TextureData[0x4];                                  // 0x041C(0x0004)(Edit, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x042C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTierMeshSets>                  AlternateMeshes;                                   // 0x0430(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         AltMeshIdx;                                        // 0x043C(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLootTier;                                    // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             ResourceType;                                      // 0x0444(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowBuildingCheat : 1;                           // 0x0448(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bMirrored : 1;                                     // 0x0448(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnTemplate, SaveGame, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoCollision : 1;                                  // 0x0448(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoCameraCollision : 1;                            // 0x0448(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoPawnCollision : 1;                              // 0x0448(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoAIPawnCollision : 1;                            // 0x0448(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic))
	uint8                                         bNoWeaponCollision : 1;                            // 0x0448(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoRangedWeaponCollision : 1;                      // 0x0448(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bNoProjectileCollision : 1;                        // 0x0449(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDoNotBlockInteract : 1;                           // 0x0449(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bBlocksCeilingPlacement : 1;                       // 0x0449(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bBlocksAttachmentPlacement : 1;                    // 0x0449(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSupportsRepairing : 1;                            // 0x0449(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRandomYawOnPlacement : 1;                         // 0x0449(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRandomScaleOnPlacement : 1;                       // 0x0449(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RandomScaleRange;                                  // 0x044C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortBounceData                        BounceData;                                        // 0x0454(0x0030)(Transient, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BASEEffectMeshComponent;                           // 0x0484(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBuildingNavObstacle>           NavObstacles;                                      // 0x0488(0x000C)(Edit, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   CachedNavAreaHusk;                                 // 0x0494(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   CachedNavAreaSmasher;                              // 0x0498(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x14];                                     // 0x049C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExpectedUpgradeLevel;                              // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   HealthLevelModifierHandle;                         // 0x04B4(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AFortCrackEffect>> WeakSpotEffects;                                   // 0x04C0(0x000C)(Net, ZeroConstructor, Transient, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bAllowWeakSpots;                                   // 0x04CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseComplexForWeakSpots;                           // 0x04CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CE[0x2];                                      // 0x04CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ReplicatedDrawScale3D;                             // 0x04D0(0x000C)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceConstant*              ReplicatedMIC;                                     // 0x04DC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x04E0(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DestructionLootTierGroup;                          // 0x04E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DestructionLootTierKey;                            // 0x04EC(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingResourceAmountOverride;                    // 0x04F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxResourcesToSpawn;                               // 0x0500(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPropagatesBounceEffects;                          // 0x0504(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_505[0x3];                                      // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BreakEffect;                                       // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        DeathParticles;                                    // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DeathParticleSocketName;                           // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         FallbackDeathParticles;                            // 0x0518(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DeathSound;                                        // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ConstructedEffect;                                 // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsDamageOverlay;                               // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRandomDayphaseFX>              RandomDayphaseFXList;                              // 0x053C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         FallbackConstructedEffect;                         // 0x0548(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UParticleSystem>         RepairEffect;                                      // 0x0560(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              ConstructionCompleteSound;                         // 0x0578(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        ConstructionAudioComponent;                        // 0x0590(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       AnimatingMIDs;                                     // 0x0594(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DamageOverlayComponent;                            // 0x05A0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MIDDamageOverlay;                                  // 0x05A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      DamageMaterial;                                    // 0x05A8(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             BounceCurve;                                       // 0x05C0(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAmountStart;                                 // 0x05D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastDamageAmount;                                  // 0x05DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             LastDamageHit;                                     // 0x05E0(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_660[0x54];                                     // 0x0660(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BuildingPlacementDistance;                         // 0x06B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UBuildingEditModeMetadata*              EditModePatternData;                               // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C4[0x8];                                      // 0x06C4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortConnectivityComponentData         ConnectivityData;                                  // 0x06CC(0x0010)(SaveGame, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     AnimatingMaterial;                                 // 0x06DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimatingSubObjects;                               // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumFrameSubObjects;                                // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBuildingEditModeSupport>   EditModeSupportClass;                              // 0x06E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeSupport*               EditModeSupport;                                   // 0x06EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthToAutoBuild;                                 // 0x06F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AccumulatedAutoBuildTime;                          // 0x06F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInitiallyBuilding;                              // 0x06F8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBuildingReplacementType                      BuildingReplacementType;                           // 0x06F9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAnim                                 CurBuildingAnimType;                               // 0x06FA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FB[0x1];                                      // 0x06FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurAnimSubObjectNum;                               // 0x06FC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurBuildingAnimStartTime;                          // 0x0700(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurAnimSubObjectTargetNum;                         // 0x0704(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      BlueprintParentMaterial;                           // 0x0708(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BlueprintMIDs;                                     // 0x0720(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BlueprintMeshComp;                                 // 0x072C(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             EditCurve;                                         // 0x0730(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveVector>            BlueprintDamageCurve;                              // 0x0748(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             FullHealthAnimCurve;                               // 0x0760(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             RepairAnimCurve;                                   // 0x0778(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             DynamicLODEffectCurve;                             // 0x0790(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerStateZone*                   EditingPlayer;                                     // 0x07A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LogicalBuildingIdx;                                // 0x07AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B0[0x1C];                                     // 0x07B0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ConnectivityIcon;                                  // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingAttachmentPointOffset;                     // 0x07D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BuildingAttachmentRadius;                          // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAttachmentSlot                       BuildingAttachmentSlot;                            // 0x07E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBuildingAttachmentType                       BuildingAttachmentType;                            // 0x07E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E2[0x2];                                      // 0x07E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       ParentActorToAttachTo;                             // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlacementType                                BuildingPlacementType;                             // 0x07E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E9[0x3];                                      // 0x07E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerGridSnapSize;                                // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingSMActor*>               AttachedBuildingActors;                            // 0x07F0(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABuildingSMActor*>               BuildingActorsAttachedTo;                          // 0x07FC(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       AttachmentPlacementBlockingActor;                  // 0x0808(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingConnectivityComponent*         ConnectivityComponent;                             // 0x080C(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LockedString;                                      // 0x0810(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FTimeline                              RepairAnimTimeline;                                // 0x081C(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bAllowResourceDrop : 1;                            // 0x089C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHideOnDeath : 1;                                  // 0x089C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bPlayDestructionEffects : 1;                       // 0x089C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bSupportedDirectly : 1;                            // 0x089C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bForciblyStructurallySupported : 1;                // 0x089C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRegisterWithStructuralGrid : 1;                   // 0x089C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUnderConstruction : 1;                            // 0x089C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, SaveGame, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bUnderRepair : 1;                                  // 0x089C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCollisionBlockedByPawns : 1;                      // 0x089D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRequiresPlacementAnim : 1;                        // 0x089D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRequiresDynamicLODEffect : 1;                     // 0x089D(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDoDynamicShrinkAndDestroyEffect : 1;              // 0x089D(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCurrentlyBeingEdited : 1;                         // 0x089D(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_89E[0x2];                                      // 0x089E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       DamagerOwner;                                      // 0x08A0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              DynamicLODEffectTimeline;                          // 0x08A4(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_924[0x20];                                     // 0x0924(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachBuildingActorToMe(class ABuildingSMActor* ActorToAttach, bool bForceAttachment);
	void BlueprintAttemptBuildingUpgrade(class AFortPlayerController* PC, int32 UpgradeLevelDelta);
	void BlueprintOnStructurallyUnstable();
	void DetachBuildingActorFromMe(class ABuildingSMActor* ActorToAttach, bool bBeingDestroyed);
	void ForceIntoStructuralGridDuringRuntime();
	class UMaterialInstanceDynamic* GetAnimatingMID(int32 ElementIndex);
	void MulticastPlayFullHealthEffects();
	void OnAttachToBuilding(class ABuildingSMActor* AttachedToBuilding);
	void OnBounceAnimationUpdate(const struct FFortBounceData& Data);
	void OnDetachFromBuilding(class ABuildingSMActor* AttachedToBuilding, bool bBeingDestroyed);
	void OnDynamicShrinkAndDestroyEffectFinished();
	void OnLODOverrideEffectFinished();
	void OnRep_bCollisionBlockedByPawns();
	void OnRep_bDoDynamicShrinkAndDestroyEffect();
	void OnRep_bRequiresDynamicLODEffect();
	void OnRep_BuildingReplacementType();
	void OnRep_bUnderConstruction();
	void OnRep_bUnderRepair();
	void OnRep_EditingPlayer();
	void OnRep_MetaData();
	void OnRep_ReplicatedDrawScale3D();
	void OnRep_ReplicatedMIC();
	void OnRep_ResourceType(EFortResourceType OldType);
	void OnRep_WeakSpotPositions();
	void OnRepairStarted();
	void RepairBuilding(class AFortPlayerController* RepairingController);
	void UpdateDynamicShrinkAndDestroyEffectt(float CurveValue);
	void UpdateLODOverrideEffect(float CurveValue);
	void UpdateRepairMaterialAnim(float CurveValue);

	class UStaticMeshComponent* GetBuildingMeshComponent() const;
	int32 GetLogicalBuildingIndex() const;
	bool HasDestructionLoot() const;
	bool IsStructurallySupported() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingSMActor">();
	}
	static class ABuildingSMActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingSMActor>();
	}
};
static_assert(alignof(ABuildingSMActor) == 0x000004, "Wrong alignment on ABuildingSMActor");
static_assert(sizeof(ABuildingSMActor) == 0x000944, "Wrong size on ABuildingSMActor");
static_assert(offsetof(ABuildingSMActor, TextureData) == 0x00041C, "Member 'ABuildingSMActor::TextureData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, StaticMesh) == 0x00042C, "Member 'ABuildingSMActor::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AlternateMeshes) == 0x000430, "Member 'ABuildingSMActor::AlternateMeshes' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AltMeshIdx) == 0x00043C, "Member 'ABuildingSMActor::AltMeshIdx' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ForcedLootTier) == 0x000440, "Member 'ABuildingSMActor::ForcedLootTier' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ResourceType) == 0x000444, "Member 'ABuildingSMActor::ResourceType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RandomScaleRange) == 0x00044C, "Member 'ABuildingSMActor::RandomScaleRange' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BounceData) == 0x000454, "Member 'ABuildingSMActor::BounceData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BASEEffectMeshComponent) == 0x000484, "Member 'ABuildingSMActor::BASEEffectMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, NavObstacles) == 0x000488, "Member 'ABuildingSMActor::NavObstacles' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CachedNavAreaHusk) == 0x000494, "Member 'ABuildingSMActor::CachedNavAreaHusk' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CachedNavAreaSmasher) == 0x000498, "Member 'ABuildingSMActor::CachedNavAreaSmasher' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ExpectedUpgradeLevel) == 0x0004B0, "Member 'ABuildingSMActor::ExpectedUpgradeLevel' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, HealthLevelModifierHandle) == 0x0004B4, "Member 'ABuildingSMActor::HealthLevelModifierHandle' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, WeakSpotEffects) == 0x0004C0, "Member 'ABuildingSMActor::WeakSpotEffects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bAllowWeakSpots) == 0x0004CC, "Member 'ABuildingSMActor::bAllowWeakSpots' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bUseComplexForWeakSpots) == 0x0004CD, "Member 'ABuildingSMActor::bUseComplexForWeakSpots' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ReplicatedDrawScale3D) == 0x0004D0, "Member 'ABuildingSMActor::ReplicatedDrawScale3D' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ReplicatedMIC) == 0x0004DC, "Member 'ABuildingSMActor::ReplicatedMIC' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, StaticMeshComponent) == 0x0004E0, "Member 'ABuildingSMActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DestructionLootTierGroup) == 0x0004E4, "Member 'ABuildingSMActor::DestructionLootTierGroup' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DestructionLootTierKey) == 0x0004EC, "Member 'ABuildingSMActor::DestructionLootTierKey' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingResourceAmountOverride) == 0x0004F4, "Member 'ABuildingSMActor::BuildingResourceAmountOverride' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, MaxResourcesToSpawn) == 0x000500, "Member 'ABuildingSMActor::MaxResourcesToSpawn' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bPropagatesBounceEffects) == 0x000504, "Member 'ABuildingSMActor::bPropagatesBounceEffects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BreakEffect) == 0x000508, "Member 'ABuildingSMActor::BreakEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathParticles) == 0x00050C, "Member 'ABuildingSMActor::DeathParticles' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathParticleSocketName) == 0x000510, "Member 'ABuildingSMActor::DeathParticleSocketName' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, FallbackDeathParticles) == 0x000518, "Member 'ABuildingSMActor::FallbackDeathParticles' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DeathSound) == 0x000530, "Member 'ABuildingSMActor::DeathSound' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConstructedEffect) == 0x000534, "Member 'ABuildingSMActor::ConstructedEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bNeedsDamageOverlay) == 0x000538, "Member 'ABuildingSMActor::bNeedsDamageOverlay' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RandomDayphaseFXList) == 0x00053C, "Member 'ABuildingSMActor::RandomDayphaseFXList' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, FallbackConstructedEffect) == 0x000548, "Member 'ABuildingSMActor::FallbackConstructedEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RepairEffect) == 0x000560, "Member 'ABuildingSMActor::RepairEffect' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConstructionCompleteSound) == 0x000578, "Member 'ABuildingSMActor::ConstructionCompleteSound' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConstructionAudioComponent) == 0x000590, "Member 'ABuildingSMActor::ConstructionAudioComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingMIDs) == 0x000594, "Member 'ABuildingSMActor::AnimatingMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageOverlayComponent) == 0x0005A0, "Member 'ABuildingSMActor::DamageOverlayComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, MIDDamageOverlay) == 0x0005A4, "Member 'ABuildingSMActor::MIDDamageOverlay' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageMaterial) == 0x0005A8, "Member 'ABuildingSMActor::DamageMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BounceCurve) == 0x0005C0, "Member 'ABuildingSMActor::BounceCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamageAmountStart) == 0x0005D8, "Member 'ABuildingSMActor::DamageAmountStart' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastDamageAmount) == 0x0005DC, "Member 'ABuildingSMActor::LastDamageAmount' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LastDamageHit) == 0x0005E0, "Member 'ABuildingSMActor::LastDamageHit' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingPlacementDistance) == 0x0006B4, "Member 'ABuildingSMActor::BuildingPlacementDistance' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModePatternData) == 0x0006C0, "Member 'ABuildingSMActor::EditModePatternData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityData) == 0x0006CC, "Member 'ABuildingSMActor::ConnectivityData' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingMaterial) == 0x0006DC, "Member 'ABuildingSMActor::AnimatingMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AnimatingSubObjects) == 0x0006E0, "Member 'ABuildingSMActor::AnimatingSubObjects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, NumFrameSubObjects) == 0x0006E4, "Member 'ABuildingSMActor::NumFrameSubObjects' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModeSupportClass) == 0x0006E8, "Member 'ABuildingSMActor::EditModeSupportClass' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditModeSupport) == 0x0006EC, "Member 'ABuildingSMActor::EditModeSupport' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, HealthToAutoBuild) == 0x0006F0, "Member 'ABuildingSMActor::HealthToAutoBuild' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AccumulatedAutoBuildTime) == 0x0006F4, "Member 'ABuildingSMActor::AccumulatedAutoBuildTime' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, bIsInitiallyBuilding) == 0x0006F8, "Member 'ABuildingSMActor::bIsInitiallyBuilding' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingReplacementType) == 0x0006F9, "Member 'ABuildingSMActor::BuildingReplacementType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurBuildingAnimType) == 0x0006FA, "Member 'ABuildingSMActor::CurBuildingAnimType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurAnimSubObjectNum) == 0x0006FC, "Member 'ABuildingSMActor::CurAnimSubObjectNum' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurBuildingAnimStartTime) == 0x000700, "Member 'ABuildingSMActor::CurBuildingAnimStartTime' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, CurAnimSubObjectTargetNum) == 0x000704, "Member 'ABuildingSMActor::CurAnimSubObjectTargetNum' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintParentMaterial) == 0x000708, "Member 'ABuildingSMActor::BlueprintParentMaterial' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintMIDs) == 0x000720, "Member 'ABuildingSMActor::BlueprintMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintMeshComp) == 0x00072C, "Member 'ABuildingSMActor::BlueprintMeshComp' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditCurve) == 0x000730, "Member 'ABuildingSMActor::EditCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BlueprintDamageCurve) == 0x000748, "Member 'ABuildingSMActor::BlueprintDamageCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, FullHealthAnimCurve) == 0x000760, "Member 'ABuildingSMActor::FullHealthAnimCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RepairAnimCurve) == 0x000778, "Member 'ABuildingSMActor::RepairAnimCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DynamicLODEffectCurve) == 0x000790, "Member 'ABuildingSMActor::DynamicLODEffectCurve' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, EditingPlayer) == 0x0007A8, "Member 'ABuildingSMActor::EditingPlayer' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LogicalBuildingIdx) == 0x0007AC, "Member 'ABuildingSMActor::LogicalBuildingIdx' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityIcon) == 0x0007CC, "Member 'ABuildingSMActor::ConnectivityIcon' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentPointOffset) == 0x0007D0, "Member 'ABuildingSMActor::BuildingAttachmentPointOffset' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentRadius) == 0x0007DC, "Member 'ABuildingSMActor::BuildingAttachmentRadius' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentSlot) == 0x0007E0, "Member 'ABuildingSMActor::BuildingAttachmentSlot' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingAttachmentType) == 0x0007E1, "Member 'ABuildingSMActor::BuildingAttachmentType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ParentActorToAttachTo) == 0x0007E4, "Member 'ABuildingSMActor::ParentActorToAttachTo' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingPlacementType) == 0x0007E8, "Member 'ABuildingSMActor::BuildingPlacementType' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, PlayerGridSnapSize) == 0x0007EC, "Member 'ABuildingSMActor::PlayerGridSnapSize' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AttachedBuildingActors) == 0x0007F0, "Member 'ABuildingSMActor::AttachedBuildingActors' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, BuildingActorsAttachedTo) == 0x0007FC, "Member 'ABuildingSMActor::BuildingActorsAttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, AttachmentPlacementBlockingActor) == 0x000808, "Member 'ABuildingSMActor::AttachmentPlacementBlockingActor' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, ConnectivityComponent) == 0x00080C, "Member 'ABuildingSMActor::ConnectivityComponent' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, LockedString) == 0x000810, "Member 'ABuildingSMActor::LockedString' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, RepairAnimTimeline) == 0x00081C, "Member 'ABuildingSMActor::RepairAnimTimeline' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DamagerOwner) == 0x0008A0, "Member 'ABuildingSMActor::DamagerOwner' has a wrong offset!");
static_assert(offsetof(ABuildingSMActor, DynamicLODEffectTimeline) == 0x0008A4, "Member 'ABuildingSMActor::DynamicLODEffectTimeline' has a wrong offset!");

// Class FortniteGame.BuildingContainer
// 0x0138 (0x0A7C - 0x0944)
class ABuildingContainer : public ABuildingSMActor
{
public:
	float                                         SearchingSoundFadeOutDuration;                     // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SearchingSoundCueLoop;                             // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LootRepeatSoundCue;                                // 0x094C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnDamageSoundCue;                                  // 0x0950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnDeathSoundCue;                                   // 0x0954(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SearchedMesh;                                      // 0x0958(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             SearchedMaterialOverrides;                         // 0x095C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	float                                         SearchBounceRadiusOverride;                        // 0x0968(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SearchLootTierGroup;                               // 0x096C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELootQuotaLevel                               QuotaLevel;                                        // 0x0974(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_975[0x3];                                      // 0x0975(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ContainerLootTierKey;                              // 0x0978(0x0008)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSpawnAtLowerQuotaLevels;                       // 0x0980(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_981[0x3];                                      // 0x0981(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              NumItemsToDropRange;                               // 0x0984(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               LootTestingData;                                   // 0x098C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootNoiseRange;                                    // 0x0990(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LootNoiseLoudness;                                 // 0x0994(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LootSpawnLocation;                                 // 0x0998(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LootFinalLocation;                                 // 0x09A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   EmptyString;                                       // 0x09B0(0x000C)(NativeAccessSpecifierPublic)
	class FText                                   SearchString;                                      // 0x09BC(0x000C)(NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractFullBounceCurve;                           // 0x09C8(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractFullBounceNormalCurve;                     // 0x09E0(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractEmptyBounceCurve;                          // 0x09F8(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             InteractEmptyBounceNormalCurve;                    // 0x0A10(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortRarity                                   HighestRarity;                                     // 0x0A28(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A29[0x3];                                      // 0x0A29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAlwaysShowContainer : 1;                          // 0x0A2C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDestroyContainerOnSearch : 1;                     // 0x0A2C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAlreadySearched : 1;                              // 0x0A2C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_A2D[0x3];                                      // 0x0A2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        SearchingAudioComponent;                           // 0x0A30(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBuriedTreasure : 1;                               // 0x0A34(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasRaisedTreasure : 1;                            // 0x0A34(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRegenerateLoot : 1;                               // 0x0A34(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_A35[0x3];                                      // 0x0A35(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LootedWeaponsDurabilityModifier;                   // 0x0A38(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeUntilLootRegenerates;                          // 0x0A3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSearchBounceData                  SearchBounceData;                                  // 0x0A40(0x0010)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseLocationForDrop;                               // 0x0A50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A51[0x3];                                      // 0x0A51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   SearchSpeed;                                       // 0x0A54(0x000C)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A60[0x1C];                                     // 0x0A60(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceContainer();
	int32 GetLootTier();
	void OnBeginSearch();
	void OnLoot();
	void OnLootRepeat();
	void OnLootReset();
	void OnRaiseTreasure();
	void OnRep_bAlreadySearched();
	void OnSearchInterrupted();
	void OnSetSearched();
	void RaiseTreasure();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingContainer">();
	}
	static class ABuildingContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingContainer>();
	}
};
static_assert(alignof(ABuildingContainer) == 0x000004, "Wrong alignment on ABuildingContainer");
static_assert(sizeof(ABuildingContainer) == 0x000A7C, "Wrong size on ABuildingContainer");
static_assert(offsetof(ABuildingContainer, SearchingSoundFadeOutDuration) == 0x000944, "Member 'ABuildingContainer::SearchingSoundFadeOutDuration' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchingSoundCueLoop) == 0x000948, "Member 'ABuildingContainer::SearchingSoundCueLoop' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootRepeatSoundCue) == 0x00094C, "Member 'ABuildingContainer::LootRepeatSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, OnDamageSoundCue) == 0x000950, "Member 'ABuildingContainer::OnDamageSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, OnDeathSoundCue) == 0x000954, "Member 'ABuildingContainer::OnDeathSoundCue' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchedMesh) == 0x000958, "Member 'ABuildingContainer::SearchedMesh' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchedMaterialOverrides) == 0x00095C, "Member 'ABuildingContainer::SearchedMaterialOverrides' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchBounceRadiusOverride) == 0x000968, "Member 'ABuildingContainer::SearchBounceRadiusOverride' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchLootTierGroup) == 0x00096C, "Member 'ABuildingContainer::SearchLootTierGroup' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, QuotaLevel) == 0x000974, "Member 'ABuildingContainer::QuotaLevel' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, ContainerLootTierKey) == 0x000978, "Member 'ABuildingContainer::ContainerLootTierKey' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, bCanSpawnAtLowerQuotaLevels) == 0x000980, "Member 'ABuildingContainer::bCanSpawnAtLowerQuotaLevels' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, NumItemsToDropRange) == 0x000984, "Member 'ABuildingContainer::NumItemsToDropRange' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootTestingData) == 0x00098C, "Member 'ABuildingContainer::LootTestingData' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootNoiseRange) == 0x000990, "Member 'ABuildingContainer::LootNoiseRange' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootNoiseLoudness) == 0x000994, "Member 'ABuildingContainer::LootNoiseLoudness' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootSpawnLocation) == 0x000998, "Member 'ABuildingContainer::LootSpawnLocation' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootFinalLocation) == 0x0009A4, "Member 'ABuildingContainer::LootFinalLocation' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, EmptyString) == 0x0009B0, "Member 'ABuildingContainer::EmptyString' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchString) == 0x0009BC, "Member 'ABuildingContainer::SearchString' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, InteractFullBounceCurve) == 0x0009C8, "Member 'ABuildingContainer::InteractFullBounceCurve' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, InteractFullBounceNormalCurve) == 0x0009E0, "Member 'ABuildingContainer::InteractFullBounceNormalCurve' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, InteractEmptyBounceCurve) == 0x0009F8, "Member 'ABuildingContainer::InteractEmptyBounceCurve' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, InteractEmptyBounceNormalCurve) == 0x000A10, "Member 'ABuildingContainer::InteractEmptyBounceNormalCurve' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, HighestRarity) == 0x000A28, "Member 'ABuildingContainer::HighestRarity' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchingAudioComponent) == 0x000A30, "Member 'ABuildingContainer::SearchingAudioComponent' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, LootedWeaponsDurabilityModifier) == 0x000A38, "Member 'ABuildingContainer::LootedWeaponsDurabilityModifier' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, TimeUntilLootRegenerates) == 0x000A3C, "Member 'ABuildingContainer::TimeUntilLootRegenerates' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchBounceData) == 0x000A40, "Member 'ABuildingContainer::SearchBounceData' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, bUseLocationForDrop) == 0x000A50, "Member 'ABuildingContainer::bUseLocationForDrop' has a wrong offset!");
static_assert(offsetof(ABuildingContainer, SearchSpeed) == 0x000A54, "Member 'ABuildingContainer::SearchSpeed' has a wrong offset!");

// Class FortniteGame.KeepItemContainer
// 0x0058 (0x0AD4 - 0x0A7C)
class AKeepItemContainer : public ABuildingContainer
{
public:
	uint8                                         Pad_A7C[0x4];                                      // 0x0A7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HostUpgradeLevel;                                  // 0x0A80(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AFortPlayerState>> SearchedBy;                                        // 0x0A84(0x000C)(Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EKeepContainerType                            ContainerType;                                     // 0x0A90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseDefaultLootLogic;                              // 0x0A91(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bResetThisWhenKeepResets;                          // 0x0A92(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A93[0x1];                                      // 0x0A93(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ContainerNameKey;                                  // 0x0A94(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ContainerDataTable;                                // 0x0A9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowChoiceUI;                                     // 0x0AA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA1[0x3];                                      // 0x0AA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortItemType>                         ItemsInChoiceUI;                                   // 0x0AA4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB0[0xC];                                      // 0x0AB0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EFortRarity                                   BestAvailableRarity;                               // 0x0ABC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ABD[0x3];                                      // 0x0ABD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItems;                                          // 0x0AC0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC4[0x10];                                     // 0x0AC4(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetContainerNameAndLevelKey();
	void InitializeContainer(int32 InitUpgradeLevel);
	void OnRep_HostUpgradeLevel();
	void OnRep_SearchedBy();
	void ResetContainer(class AFortPlayerController* FortPC);
	void RestoreLoot();

	int32 GetLootTierOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepItemContainer">();
	}
	static class AKeepItemContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepItemContainer>();
	}
};
static_assert(alignof(AKeepItemContainer) == 0x000004, "Wrong alignment on AKeepItemContainer");
static_assert(sizeof(AKeepItemContainer) == 0x000AD4, "Wrong size on AKeepItemContainer");
static_assert(offsetof(AKeepItemContainer, HostUpgradeLevel) == 0x000A80, "Member 'AKeepItemContainer::HostUpgradeLevel' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, SearchedBy) == 0x000A84, "Member 'AKeepItemContainer::SearchedBy' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerType) == 0x000A90, "Member 'AKeepItemContainer::ContainerType' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bUseDefaultLootLogic) == 0x000A91, "Member 'AKeepItemContainer::bUseDefaultLootLogic' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bResetThisWhenKeepResets) == 0x000A92, "Member 'AKeepItemContainer::bResetThisWhenKeepResets' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerNameKey) == 0x000A94, "Member 'AKeepItemContainer::ContainerNameKey' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ContainerDataTable) == 0x000A9C, "Member 'AKeepItemContainer::ContainerDataTable' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, bShowChoiceUI) == 0x000AA0, "Member 'AKeepItemContainer::bShowChoiceUI' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, ItemsInChoiceUI) == 0x000AA4, "Member 'AKeepItemContainer::ItemsInChoiceUI' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, BestAvailableRarity) == 0x000ABC, "Member 'AKeepItemContainer::BestAvailableRarity' has a wrong offset!");
static_assert(offsetof(AKeepItemContainer, MaxItems) == 0x000AC0, "Member 'AKeepItemContainer::MaxItems' has a wrong offset!");

// Class FortniteGame.KeepItemCoreContainer
// 0x0000 (0x0AD4 - 0x0AD4)
class AKeepItemCoreContainer final : public AKeepItemContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepItemCoreContainer">();
	}
	static class AKeepItemCoreContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepItemCoreContainer>();
	}
};
static_assert(alignof(AKeepItemCoreContainer) == 0x000004, "Wrong alignment on AKeepItemCoreContainer");
static_assert(sizeof(AKeepItemCoreContainer) == 0x000AD4, "Wrong size on AKeepItemCoreContainer");

// Class FortniteGame.BuildingCorner
// 0x0008 (0x094C - 0x0944)
class ABuildingCorner : public ABuildingSMActor
{
public:
	class ABuildingSMActor*                       PrimaryWall;                                       // 0x0944(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       SecondaryWall;                                     // 0x0948(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingCorner">();
	}
	static class ABuildingCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingCorner>();
	}
};
static_assert(alignof(ABuildingCorner) == 0x000004, "Wrong alignment on ABuildingCorner");
static_assert(sizeof(ABuildingCorner) == 0x00094C, "Wrong size on ABuildingCorner");
static_assert(offsetof(ABuildingCorner, PrimaryWall) == 0x000944, "Member 'ABuildingCorner::PrimaryWall' has a wrong offset!");
static_assert(offsetof(ABuildingCorner, SecondaryWall) == 0x000948, "Member 'ABuildingCorner::SecondaryWall' has a wrong offset!");

// Class FortniteGame.BuildingPropCorner
// 0x0000 (0x094C - 0x094C)
class ABuildingPropCorner final : public ABuildingCorner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPropCorner">();
	}
	static class ABuildingPropCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPropCorner>();
	}
};
static_assert(alignof(ABuildingPropCorner) == 0x000004, "Wrong alignment on ABuildingPropCorner");
static_assert(sizeof(ABuildingPropCorner) == 0x00094C, "Wrong size on ABuildingPropCorner");

// Class FortniteGame.BuildingDeco
// 0x0004 (0x0948 - 0x0944)
class ABuildingDeco final : public ABuildingSMActor
{
public:
	bool                                          bCastShadow;                                       // 0x0944(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_945[0x3];                                      // 0x0945(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingDeco">();
	}
	static class ABuildingDeco* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingDeco>();
	}
};
static_assert(alignof(ABuildingDeco) == 0x000004, "Wrong alignment on ABuildingDeco");
static_assert(sizeof(ABuildingDeco) == 0x000948, "Wrong size on ABuildingDeco");
static_assert(offsetof(ABuildingDeco, bCastShadow) == 0x000944, "Member 'ABuildingDeco::bCastShadow' has a wrong offset!");

// Class FortniteGame.BuildingDoor
// 0x0008 (0x094C - 0x0944)
class ABuildingDoor final : public ABuildingSMActor
{
public:
	class USoundBase*                             DoorOpeningSound;                                  // 0x0944(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DoorClosingSound;                                  // 0x0948(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingDoor">();
	}
	static class ABuildingDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingDoor>();
	}
};
static_assert(alignof(ABuildingDoor) == 0x000004, "Wrong alignment on ABuildingDoor");
static_assert(sizeof(ABuildingDoor) == 0x00094C, "Wrong size on ABuildingDoor");
static_assert(offsetof(ABuildingDoor, DoorOpeningSound) == 0x000944, "Member 'ABuildingDoor::DoorOpeningSound' has a wrong offset!");
static_assert(offsetof(ABuildingDoor, DoorClosingSound) == 0x000948, "Member 'ABuildingDoor::DoorClosingSound' has a wrong offset!");

// Class FortniteGame.BuildingFloor
// 0x0004 (0x0948 - 0x0944)
class ABuildingFloor : public ABuildingSMActor
{
public:
	uint8                                         Pad_944[0x4];                                      // 0x0944(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBalcony() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFloor">();
	}
	static class ABuildingFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFloor>();
	}
};
static_assert(alignof(ABuildingFloor) == 0x000004, "Wrong alignment on ABuildingFloor");
static_assert(sizeof(ABuildingFloor) == 0x000948, "Wrong size on ABuildingFloor");

// Class FortniteGame.BuildingStairs
// 0x0004 (0x094C - 0x0948)
class ABuildingStairs final : public ABuildingFloor
{
public:
	EBuildingStairsRailing                        RailingType;                                       // 0x0948(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_949[0x3];                                      // 0x0949(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingStairs">();
	}
	static class ABuildingStairs* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingStairs>();
	}
};
static_assert(alignof(ABuildingStairs) == 0x000004, "Wrong alignment on ABuildingStairs");
static_assert(sizeof(ABuildingStairs) == 0x00094C, "Wrong size on ABuildingStairs");
static_assert(offsetof(ABuildingStairs, RailingType) == 0x000948, "Member 'ABuildingStairs::RailingType' has a wrong offset!");

// Class FortniteGame.BuildingFoundation
// 0x0044 (0x0988 - 0x0944)
class ABuildingFoundation : public ABuildingSMActor
{
public:
	TArray<class UBuildingGroup*>                 BuildingGroups;                                    // 0x0944(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          AdditionalWorlds;                                  // 0x0950(0x000C)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BuildingGroupTagsToPickFrom;                       // 0x095C(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBuildingFoundationType                       FoundationType;                                    // 0x0974(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_975[0x3];                                      // 0x0975(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LevelToStream;                                     // 0x0978(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_980[0x8];                                      // 0x0980(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LevelToStream();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation">();
	}
	static class ABuildingFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation>();
	}
};
static_assert(alignof(ABuildingFoundation) == 0x000004, "Wrong alignment on ABuildingFoundation");
static_assert(sizeof(ABuildingFoundation) == 0x000988, "Wrong size on ABuildingFoundation");
static_assert(offsetof(ABuildingFoundation, BuildingGroups) == 0x000944, "Member 'ABuildingFoundation::BuildingGroups' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, AdditionalWorlds) == 0x000950, "Member 'ABuildingFoundation::AdditionalWorlds' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, BuildingGroupTagsToPickFrom) == 0x00095C, "Member 'ABuildingFoundation::BuildingGroupTagsToPickFrom' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, FoundationType) == 0x000974, "Member 'ABuildingFoundation::FoundationType' has a wrong offset!");
static_assert(offsetof(ABuildingFoundation, LevelToStream) == 0x000978, "Member 'ABuildingFoundation::LevelToStream' has a wrong offset!");

// Class FortniteGame.BuildingFoundation3x3
// 0x0000 (0x0988 - 0x0988)
class ABuildingFoundation3x3 final : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation3x3">();
	}
	static class ABuildingFoundation3x3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation3x3>();
	}
};
static_assert(alignof(ABuildingFoundation3x3) == 0x000004, "Wrong alignment on ABuildingFoundation3x3");
static_assert(sizeof(ABuildingFoundation3x3) == 0x000988, "Wrong size on ABuildingFoundation3x3");

// Class FortniteGame.BuildingFoundation5x10
// 0x0000 (0x0988 - 0x0988)
class ABuildingFoundation5x10 final : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation5x10">();
	}
	static class ABuildingFoundation5x10* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation5x10>();
	}
};
static_assert(alignof(ABuildingFoundation5x10) == 0x000004, "Wrong alignment on ABuildingFoundation5x10");
static_assert(sizeof(ABuildingFoundation5x10) == 0x000988, "Wrong size on ABuildingFoundation5x10");

// Class FortniteGame.BuildingFoundation5x5
// 0x0000 (0x0988 - 0x0988)
class ABuildingFoundation5x5 final : public ABuildingFoundation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingFoundation5x5">();
	}
	static class ABuildingFoundation5x5* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingFoundation5x5>();
	}
};
static_assert(alignof(ABuildingFoundation5x5) == 0x000004, "Wrong alignment on ABuildingFoundation5x5");
static_assert(sizeof(ABuildingFoundation5x5) == 0x000988, "Wrong size on ABuildingFoundation5x5");

// Class FortniteGame.WorldTileFoundation
// 0x0024 (0x09AC - 0x0988)
class AWorldTileFoundation final : public ABuildingFoundation
{
public:
	uint8                                         NumRotations;                                      // 0x0988(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_989[0x23];                                     // 0x0989(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileFoundation">();
	}
	static class AWorldTileFoundation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldTileFoundation>();
	}
};
static_assert(alignof(AWorldTileFoundation) == 0x000004, "Wrong alignment on AWorldTileFoundation");
static_assert(sizeof(AWorldTileFoundation) == 0x0009AC, "Wrong size on AWorldTileFoundation");
static_assert(offsetof(AWorldTileFoundation, NumRotations) == 0x000988, "Member 'AWorldTileFoundation::NumRotations' has a wrong offset!");

// Class FortniteGame.BuildingPillar
// 0x0000 (0x0944 - 0x0944)
class ABuildingPillar final : public ABuildingSMActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPillar">();
	}
	static class ABuildingPillar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPillar>();
	}
};
static_assert(alignof(ABuildingPillar) == 0x000004, "Wrong alignment on ABuildingPillar");
static_assert(sizeof(ABuildingPillar) == 0x000944, "Wrong size on ABuildingPillar");

// Class FortniteGame.BuildingPlayerPrimitivePreview
// 0x0000 (0x0944 - 0x0944)
class ABuildingPlayerPrimitivePreview final : public ABuildingSMActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPlayerPrimitivePreview">();
	}
	static class ABuildingPlayerPrimitivePreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPlayerPrimitivePreview>();
	}
};
static_assert(alignof(ABuildingPlayerPrimitivePreview) == 0x000004, "Wrong alignment on ABuildingPlayerPrimitivePreview");
static_assert(sizeof(ABuildingPlayerPrimitivePreview) == 0x000944, "Wrong size on ABuildingPlayerPrimitivePreview");

// Class FortniteGame.BuildingProp
// 0x0000 (0x0944 - 0x0944)
class ABuildingProp : public ABuildingSMActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingProp">();
	}
	static class ABuildingProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingProp>();
	}
};
static_assert(alignof(ABuildingProp) == 0x000004, "Wrong alignment on ABuildingProp");
static_assert(sizeof(ABuildingProp) == 0x000944, "Wrong size on ABuildingProp");

// Class FortniteGame.BuildingPropWall
// 0x0008 (0x094C - 0x0944)
class ABuildingPropWall final : public ABuildingProp
{
public:
	struct FBuildingActorNavArea                  AreaPatternOverride;                               // 0x0944(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBuildingWallArea                             AreaShapeType;                                     // 0x0948(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_949[0x3];                                      // 0x0949(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPropWall">();
	}
	static class ABuildingPropWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingPropWall>();
	}
};
static_assert(alignof(ABuildingPropWall) == 0x000004, "Wrong alignment on ABuildingPropWall");
static_assert(sizeof(ABuildingPropWall) == 0x00094C, "Wrong size on ABuildingPropWall");
static_assert(offsetof(ABuildingPropWall, AreaPatternOverride) == 0x000944, "Member 'ABuildingPropWall::AreaPatternOverride' has a wrong offset!");
static_assert(offsetof(ABuildingPropWall, AreaShapeType) == 0x000948, "Member 'ABuildingPropWall::AreaShapeType' has a wrong offset!");

// Class FortniteGame.FortWeaponItemDefinition
// 0x0100 (0x06C0 - 0x05C0)
#pragma pack(push, 0x1)
class alignas(0x10) UFortWeaponItemDefinition : public UFortWorldItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   WeaponActorClass;                                  // 0x05B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          WeaponMeshOverride;                                // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    WeaponStatHandle;                                  // 0x05D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFortAlterationItemDefinition*          BaseAlteration;                                    // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAlterationItemDefinition> BaseCosmeticAlteration;                            // 0x05E4(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PrimaryFireAbility;                                // 0x05FC(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SecondaryFireAbility;                              // 0x0614(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ReloadAbility;                                     // 0x062C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           EquippedAbilities;                                 // 0x0644(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               AmmoData;                                          // 0x0650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutOfAmmoText;                                     // 0x0654(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LowAmmoPercentage;                                 // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegradedPercentage;                                // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortWeaponTriggerType                        TriggerType;                                       // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTargetingDuringReload;                       // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_66A[0x2];                                      // 0x066A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReticleImage;                                      // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ReticleCornerAngles;                               // 0x0670(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             HitNotifyImage;                                    // 0x067C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 HitNotifyCornerAngles;                             // 0x0680(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReticleCenterImage;                                // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReticleCenterImageOffset;                          // 0x0690(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HitNotifyDuration;                                 // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             HitNotifyOpacityCurve;                             // 0x069C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidForLastEquipped;                             // 0x06B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B5[0x3];                                      // 0x06B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponItemDefinition">();
	}
	static class UFortWeaponItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponItemDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortWeaponItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponItemDefinition");
static_assert(sizeof(UFortWeaponItemDefinition) == 0x0006C0, "Wrong size on UFortWeaponItemDefinition");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponActorClass) == 0x0005B8, "Member 'UFortWeaponItemDefinition::WeaponActorClass' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponMeshOverride) == 0x0005D0, "Member 'UFortWeaponItemDefinition::WeaponMeshOverride' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, WeaponStatHandle) == 0x0005D4, "Member 'UFortWeaponItemDefinition::WeaponStatHandle' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, BaseAlteration) == 0x0005E0, "Member 'UFortWeaponItemDefinition::BaseAlteration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, BaseCosmeticAlteration) == 0x0005E4, "Member 'UFortWeaponItemDefinition::BaseCosmeticAlteration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, PrimaryFireAbility) == 0x0005FC, "Member 'UFortWeaponItemDefinition::PrimaryFireAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, SecondaryFireAbility) == 0x000614, "Member 'UFortWeaponItemDefinition::SecondaryFireAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReloadAbility) == 0x00062C, "Member 'UFortWeaponItemDefinition::ReloadAbility' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, EquippedAbilities) == 0x000644, "Member 'UFortWeaponItemDefinition::EquippedAbilities' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, AmmoData) == 0x000650, "Member 'UFortWeaponItemDefinition::AmmoData' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, OutOfAmmoText) == 0x000654, "Member 'UFortWeaponItemDefinition::OutOfAmmoText' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, LowAmmoPercentage) == 0x000660, "Member 'UFortWeaponItemDefinition::LowAmmoPercentage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, DegradedPercentage) == 0x000664, "Member 'UFortWeaponItemDefinition::DegradedPercentage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, TriggerType) == 0x000668, "Member 'UFortWeaponItemDefinition::TriggerType' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, bAllowTargetingDuringReload) == 0x000669, "Member 'UFortWeaponItemDefinition::bAllowTargetingDuringReload' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleImage) == 0x00066C, "Member 'UFortWeaponItemDefinition::ReticleImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCornerAngles) == 0x000670, "Member 'UFortWeaponItemDefinition::ReticleCornerAngles' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyImage) == 0x00067C, "Member 'UFortWeaponItemDefinition::HitNotifyImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyCornerAngles) == 0x000680, "Member 'UFortWeaponItemDefinition::HitNotifyCornerAngles' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCenterImage) == 0x00068C, "Member 'UFortWeaponItemDefinition::ReticleCenterImage' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, ReticleCenterImageOffset) == 0x000690, "Member 'UFortWeaponItemDefinition::ReticleCenterImageOffset' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyDuration) == 0x000698, "Member 'UFortWeaponItemDefinition::HitNotifyDuration' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, HitNotifyOpacityCurve) == 0x00069C, "Member 'UFortWeaponItemDefinition::HitNotifyOpacityCurve' has a wrong offset!");
static_assert(offsetof(UFortWeaponItemDefinition, bValidForLastEquipped) == 0x0006B4, "Member 'UFortWeaponItemDefinition::bValidForLastEquipped' has a wrong offset!");

// Class FortniteGame.FortConstructorBASE
// 0x023C (0x0B80 - 0x0944)
class AFortConstructorBASE : public ABuildingProp
{
public:
	uint8                                         Pad_944[0x4];                                      // 0x0944(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBASEGameplayEffect>            BASEBuildingApplicationEffects;                    // 0x0948(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBASEGameplayEffect>            BASEFriendlyApplicationEffects;                    // 0x0954(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBASEGameplayEffect>            BASEEnemyApplicationEffects;                       // 0x0960(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InBASETag;                                         // 0x096C(0x0008)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NodesToAffect;                                     // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseLevel;                                         // 0x0978(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPatternBASEEffect>             BASEEffectPatterns;                                // 0x097C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFortBaseWeaponStats                   DamageStats;                                       // 0x0988(0x00EC)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageAttributeSet;                                // 0x0A74(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABuildingSMActor*>               ReplicatedAffectedNeighbors;                       // 0x0A78(0x000C)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_A84[0xFC];                                     // 0x0A84(0x00FC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class ABuildingSMActor*> GetBuildingActorsInBase();
	void OnBaseCollisionTouched(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBaseCollisionUnTouched(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnBasePawnDestroyed(class AFortPawn* Pawn);
	void OnBasePawnDied(float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum, class AFortPawn* Pawn);
	void OnPawnAddedToBase(class AFortPawn* Pawn);
	void OnPawnRemovedFromBase(class AFortPawn* Pawn);
	void OnPlaced(class UAbilitySystemComponent* InstigatorAbilitySystemComponent);
	void OnRep_ReplicatedAffectedNeighbors();
	void StartBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp);
	void StopBuildingActorVisuals(class ABuildingSMActor* BuildingActor, class UStaticMeshComponent* EffectMeshComp);

	void AddToEffectList(TArray<struct FBASEGameplayEffect>* EffectList, TSubclassOf<class UGameplayEffect> Effect) const;
	void AddToEffectListWithLevelOverride(TArray<struct FBASEGameplayEffect>* EffectList, TSubclassOf<class UGameplayEffect> Effect, int32 Level) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConstructorBASE">();
	}
	static class AFortConstructorBASE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortConstructorBASE>();
	}
};
static_assert(alignof(AFortConstructorBASE) == 0x000004, "Wrong alignment on AFortConstructorBASE");
static_assert(sizeof(AFortConstructorBASE) == 0x000B80, "Wrong size on AFortConstructorBASE");
static_assert(offsetof(AFortConstructorBASE, BASEBuildingApplicationEffects) == 0x000948, "Member 'AFortConstructorBASE::BASEBuildingApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEFriendlyApplicationEffects) == 0x000954, "Member 'AFortConstructorBASE::BASEFriendlyApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEEnemyApplicationEffects) == 0x000960, "Member 'AFortConstructorBASE::BASEEnemyApplicationEffects' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, InBASETag) == 0x00096C, "Member 'AFortConstructorBASE::InBASETag' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, NodesToAffect) == 0x000974, "Member 'AFortConstructorBASE::NodesToAffect' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BaseLevel) == 0x000978, "Member 'AFortConstructorBASE::BaseLevel' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, BASEEffectPatterns) == 0x00097C, "Member 'AFortConstructorBASE::BASEEffectPatterns' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, DamageStats) == 0x000988, "Member 'AFortConstructorBASE::DamageStats' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, DamageAttributeSet) == 0x000A74, "Member 'AFortConstructorBASE::DamageAttributeSet' has a wrong offset!");
static_assert(offsetof(AFortConstructorBASE, ReplicatedAffectedNeighbors) == 0x000A78, "Member 'AFortConstructorBASE::ReplicatedAffectedNeighbors' has a wrong offset!");

// Class FortniteGame.FortTrack
// 0x00E4 (0x0A28 - 0x0944)
class AFortTrack final : public ABuildingProp
{
public:
	UMulticastDelegateProperty_                   OnTrackGraphChanged;                               // 0x0944(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   ToggleSwitchText;                                  // 0x0950(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ToggleInteractTime;                                // 0x095C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTrackMeshTrackPieceTypeConfig         MeshesByTrackPieceType[0x3];                       // 0x0960(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AFortTrack*                             NeighborsByDirection[0x4];                         // 0x09A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrackIncline                                 InclinesByDirection[0x4];                          // 0x09B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwitchState;                                       // 0x09BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigurationIdx;                                  // 0x09C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackMeshComp1;                                    // 0x09C4(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackMeshComp2;                                    // 0x09C8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComp1;                                       // 0x09CC(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComp2;                                       // 0x09D0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SwitchCompBase;                                    // 0x09D4(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    SwitchComp;                                        // 0x09D8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DC[0x4C];                                     // 0x09DC(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetOutgoingNeighborFromSpline(class USplineComponent* InSpline, bool InReverseDirection, class AFortTrack** OutNeighbor);
	float GetPathDistanceToTrack(class AFortTrack* TargetTrack, class USplineComponent* InCurrentSpline, float CurrentDistanceAlongSpline, bool InReverseDirection);
	void GetSplineFromIncomingNeighbor(class AFortTrack* InNeighbor, class USplineComponent** OutSpline, bool* OutReverseDirection);
	void GetSplineFromPositionAndOrientation(const struct FVector& InLocation, const struct FRotator& InRotation, class USplineComponent** OutSpline, float* OutDistanceAlongSpline, bool* OutReverseDirection);
	void InitializeTrack(class UStaticMeshComponent* InTrackMeshComp1, class UStaticMeshComponent* InTrackMeshComp2, class USplineComponent* InSplineComp1, class USplineComponent* InSplineComp2, class USceneComponent* InSwitchCompBase, class UPrimitiveComponent* InSwitchComp);
	bool IsConnectedToTrack(class AFortTrack* TargetTrack);
	bool IsConnectedToTrackList(const TArray<class AFortTrack*>& TargetTracks);
	void OnConfigurationChanged(int32 NewConfigurationIdx, int32 OldConfigurationIdx);
	void OnRep_ConfigurationIdx();
	void OnRep_SwitchState();
	void OnSwitchStateChanged(int32 NewSwitchState, int32 OldSwitchState, int32 NumSwitchStates);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrack">();
	}
	static class AFortTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrack>();
	}
};
static_assert(alignof(AFortTrack) == 0x000004, "Wrong alignment on AFortTrack");
static_assert(sizeof(AFortTrack) == 0x000A28, "Wrong size on AFortTrack");
static_assert(offsetof(AFortTrack, OnTrackGraphChanged) == 0x000944, "Member 'AFortTrack::OnTrackGraphChanged' has a wrong offset!");
static_assert(offsetof(AFortTrack, ToggleSwitchText) == 0x000950, "Member 'AFortTrack::ToggleSwitchText' has a wrong offset!");
static_assert(offsetof(AFortTrack, ToggleInteractTime) == 0x00095C, "Member 'AFortTrack::ToggleInteractTime' has a wrong offset!");
static_assert(offsetof(AFortTrack, MeshesByTrackPieceType) == 0x000960, "Member 'AFortTrack::MeshesByTrackPieceType' has a wrong offset!");
static_assert(offsetof(AFortTrack, NeighborsByDirection) == 0x0009A8, "Member 'AFortTrack::NeighborsByDirection' has a wrong offset!");
static_assert(offsetof(AFortTrack, InclinesByDirection) == 0x0009B8, "Member 'AFortTrack::InclinesByDirection' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchState) == 0x0009BC, "Member 'AFortTrack::SwitchState' has a wrong offset!");
static_assert(offsetof(AFortTrack, ConfigurationIdx) == 0x0009C0, "Member 'AFortTrack::ConfigurationIdx' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackMeshComp1) == 0x0009C4, "Member 'AFortTrack::TrackMeshComp1' has a wrong offset!");
static_assert(offsetof(AFortTrack, TrackMeshComp2) == 0x0009C8, "Member 'AFortTrack::TrackMeshComp2' has a wrong offset!");
static_assert(offsetof(AFortTrack, SplineComp1) == 0x0009CC, "Member 'AFortTrack::SplineComp1' has a wrong offset!");
static_assert(offsetof(AFortTrack, SplineComp2) == 0x0009D0, "Member 'AFortTrack::SplineComp2' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchCompBase) == 0x0009D4, "Member 'AFortTrack::SwitchCompBase' has a wrong offset!");
static_assert(offsetof(AFortTrack, SwitchComp) == 0x0009D8, "Member 'AFortTrack::SwitchComp' has a wrong offset!");

// Class FortniteGame.OutpostStructureBase
// 0x000C (0x0950 - 0x0944)
class AOutpostStructureBase : public ABuildingProp
{
public:
	class UFortAbilitySet*                        AbilitySet;                                        // 0x0944(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutpostOwnerStructureLevel;                        // 0x0948(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortOutpostItemDefinition*             ItemDefinition;                                    // 0x094C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnOutpostOwnerStructureLevelChanged();
	void OnRep_OutpostOwnerStructureLevel();

	int32 GetOutpostOwnerStructureLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutpostStructureBase">();
	}
	static class AOutpostStructureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutpostStructureBase>();
	}
};
static_assert(alignof(AOutpostStructureBase) == 0x000004, "Wrong alignment on AOutpostStructureBase");
static_assert(sizeof(AOutpostStructureBase) == 0x000950, "Wrong size on AOutpostStructureBase");
static_assert(offsetof(AOutpostStructureBase, AbilitySet) == 0x000944, "Member 'AOutpostStructureBase::AbilitySet' has a wrong offset!");
static_assert(offsetof(AOutpostStructureBase, OutpostOwnerStructureLevel) == 0x000948, "Member 'AOutpostStructureBase::OutpostOwnerStructureLevel' has a wrong offset!");
static_assert(offsetof(AOutpostStructureBase, ItemDefinition) == 0x00094C, "Member 'AOutpostStructureBase::ItemDefinition' has a wrong offset!");

// Class FortniteGame.FortGameplayEffectExecutionCalculation
// 0x0000 (0x002C - 0x002C)
class UFortGameplayEffectExecutionCalculation : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectExecutionCalculation">();
	}
	static class UFortGameplayEffectExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayEffectExecutionCalculation>();
	}
};
static_assert(alignof(UFortGameplayEffectExecutionCalculation) == 0x000004, "Wrong alignment on UFortGameplayEffectExecutionCalculation");
static_assert(sizeof(UFortGameplayEffectExecutionCalculation) == 0x00002C, "Wrong size on UFortGameplayEffectExecutionCalculation");

// Class FortniteGame.FortActiveDurationExecutionCalculation
// 0x0000 (0x002C - 0x002C)
class UFortActiveDurationExecutionCalculation final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortActiveDurationExecutionCalculation">();
	}
	static class UFortActiveDurationExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortActiveDurationExecutionCalculation>();
	}
};
static_assert(alignof(UFortActiveDurationExecutionCalculation) == 0x000004, "Wrong alignment on UFortActiveDurationExecutionCalculation");
static_assert(sizeof(UFortActiveDurationExecutionCalculation) == 0x00002C, "Wrong size on UFortActiveDurationExecutionCalculation");

// Class FortniteGame.BuildingOutpostCraftingTable
// 0x0004 (0x0954 - 0x0950)
class ABuildingOutpostCraftingTable final : public AOutpostStructureBase
{
public:
	TSubclassOf<class UGameplayEffect>            ActivationEffect;                                  // 0x0950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Activate(class AFortPlayerControllerOutpost* InPC);
	void Deactivate(class AFortPlayerControllerOutpost* InPC);

	bool CanActivate(class AFortPlayerControllerOutpost* InPC) const;
	void GetActivationCost(class AFortPlayerControllerOutpost* InPC, TArray<struct FFortItemQuantityPair>* OutWorldItems) const;
	int32 GetNumberOfItemsPerActivation(class AFortPlayerControllerOutpost* InPC) const;
	int32 GetNumberOfItemsRemaining(class AFortPlayerControllerOutpost* InPC) const;
	bool IsActive(class AFortPlayerControllerOutpost* InPC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostCraftingTable">();
	}
	static class ABuildingOutpostCraftingTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostCraftingTable>();
	}
};
static_assert(alignof(ABuildingOutpostCraftingTable) == 0x000004, "Wrong alignment on ABuildingOutpostCraftingTable");
static_assert(sizeof(ABuildingOutpostCraftingTable) == 0x000954, "Wrong size on ABuildingOutpostCraftingTable");
static_assert(offsetof(ABuildingOutpostCraftingTable, ActivationEffect) == 0x000950, "Member 'ABuildingOutpostCraftingTable::ActivationEffect' has a wrong offset!");

// Class FortniteGame.BuildingOutpostFabricator
// 0x0010 (0x0960 - 0x0950)
class ABuildingOutpostFabricator final : public AOutpostStructureBase
{
public:
	TArray<class UFortWorldItemDefinition*>       AlwaysAvailableItemsToFabricate;                   // 0x0950(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         FabricationDuration;                               // 0x095C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbortDisintegration(class AFortPlayerControllerOutpost* FortPC);
	int32 CanDisintegrateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItem* Item, int32 Count);
	void DisintegrateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItem* Item, int32 Count);
	void FabricateItem(class AFortPlayerControllerOutpost* FortPC, class UFortWorldItemDefinition* ItemDef);

	TArray<class UFortItem*> GetAvailableRecipes(class AFortPlayerControllerOutpost* FortPC, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter) const;
	int32 GetDisintegrationDurationInSeconds(class AFortPlayerControllerOutpost* FortPC) const;
	int32 GetDisintegrationDurationInSecondsForItem(class UFortWorldItem* Item, int32 Count) const;
	int32 GetDisintegrationMinutesRemaining(class AFortPlayerControllerOutpost* FortPC) const;
	int32 GetDisintegrationSecondsRemaining(class AFortPlayerControllerOutpost* FortPC) const;
	struct FDateTime GetDisintegrationStartTime(class AFortPlayerControllerOutpost* FortPC) const;
	int32 GetGooFromDisintegrationAmount(const class UFortWorldItem* Item) const;
	int32 GetGooToFabricateAmount(const class UFortWorldItem* Item) const;
	int32 GetIncomingGooAmount(class AFortPlayerControllerOutpost* FortPC) const;
	int32 GetIncomingGooAmountProgress(class AFortPlayerControllerOutpost* FortPC) const;
	int32 GetMaxGooCapacity(class AFortPlayerControllerOutpost* FortPC) const;
	TArray<class UFortItem*> GetPlayerItems(class AFortPlayerControllerOutpost* FortPC, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter) const;
	int32 GetStoredGooAmount(class AFortPlayerControllerOutpost* FortPC) const;
	bool IsDisintegrating(class AFortPlayerControllerOutpost* FortPC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostFabricator">();
	}
	static class ABuildingOutpostFabricator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostFabricator>();
	}
};
static_assert(alignof(ABuildingOutpostFabricator) == 0x000004, "Wrong alignment on ABuildingOutpostFabricator");
static_assert(sizeof(ABuildingOutpostFabricator) == 0x000960, "Wrong size on ABuildingOutpostFabricator");
static_assert(offsetof(ABuildingOutpostFabricator, AlwaysAvailableItemsToFabricate) == 0x000950, "Member 'ABuildingOutpostFabricator::AlwaysAvailableItemsToFabricate' has a wrong offset!");
static_assert(offsetof(ABuildingOutpostFabricator, FabricationDuration) == 0x00095C, "Member 'ABuildingOutpostFabricator::FabricationDuration' has a wrong offset!");

// Class FortniteGame.FortBuildingActorSet
// 0x0008 (0x00F8 - 0x00F0)
class UFortBuildingActorSet : public UFortHealthSet
{
public:
	float                                         BuildTime;                                         // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepairTime;                                        // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingActorSet">();
	}
	static class UFortBuildingActorSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingActorSet>();
	}
};
static_assert(alignof(UFortBuildingActorSet) == 0x000004, "Wrong alignment on UFortBuildingActorSet");
static_assert(sizeof(UFortBuildingActorSet) == 0x0000F8, "Wrong size on UFortBuildingActorSet");
static_assert(offsetof(UFortBuildingActorSet, BuildTime) == 0x0000F0, "Member 'UFortBuildingActorSet::BuildTime' has a wrong offset!");
static_assert(offsetof(UFortBuildingActorSet, RepairTime) == 0x0000F4, "Member 'UFortBuildingActorSet::RepairTime' has a wrong offset!");

// Class FortniteGame.FortWeapon
// 0x03B4 (0x05F4 - 0x0240)
class AFortWeapon : public AActor
{
public:
	uint8                                         Pad_240[0xC];                                      // 0x0240(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsEquippingWeapon;                                // 0x024C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsReloadingWeapon;                                // 0x024D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsChargingWeapon;                                 // 0x024E(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWeaponItemDefinition*              WeaponData;                                        // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDrawNativeReticle;                          // 0x0254(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReticleImage;                                      // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleDefaultColor;                               // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleEnemyColor;                                 // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 ReticleBuildingColor;                              // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             HitNotifyReticleImage;                             // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitNotifyDisplayDuration;                          // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             ReticleCenterImage;                                // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleDefaultPrimaryStrikeAngle;                  // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReticleDefaultSecondaryStrikeAngle;                // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraBase3PClass;                                 // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraTargeting3PClass;                            // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraBase1PClass;                                 // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortCameraMode>            CameraTargeting1PClass;                            // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DestroyedSound;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             OutOfAmmoSound;                                    // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ReloadSounds[0x3];                                 // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PrimaryFireSound[0x3];                             // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PrimaryFireStopSound[0x3];                         // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SecondaryFireSound[0x3];                           // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SecondaryFireStopSound[0x3];                       // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PrimaryFireSoundFadeOutTime;                       // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ImpactPhysicalSurfaceSounds[0x3F];                 // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ImpactPhysicalSurfaceEffects[0x3F];                // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               ImpactCameraShake;                                 // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FireAudioChannels[0x3];                            // 0x04D0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 WeaponMesh;                                        // 0x04DC(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             DefaultWeaponMaterials;                            // 0x04E0(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         FireAudioChannelWantsToPlay[0x3];                  // 0x04EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingSecondaryFireAudio;                          // 0x04F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            CurrentReticleIcon;                                // 0x04FC(0x0014)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            CurrentHitNotifyReticleIcon;                       // 0x0510(0x0014)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            CurrentReticleCenterIcon;                          // 0x0524(0x0014)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 CurrentReticleColor;                               // 0x0538(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LastFireTime;                                      // 0x053C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPlayingFireFX;                                  // 0x0540(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x3];                                      // 0x0541(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerIntervalAdjustment;                           // 0x0544(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputQueueTimePercent;                             // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowTargeting;                                   // 0x054C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsTargeting;                                      // 0x054D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_54E[0x2];                                      // 0x054E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetSourceOffset;                                // 0x0550(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                TargetSourceOffsetWhileTargeting;                  // 0x055C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceThroughPawns;                                // 0x0568(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastReloadTime;                                    // 0x056C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReloadDuration;                                    // 0x0570(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  ItemEntryGuid;                                     // 0x0574(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         WeaponLevel;                                       // 0x0584(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount;                                         // 0x0588(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeTime;                                        // 0x0590(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentShotLogIndex;                               // 0x0594(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint32>                                ShotLogFlags;                                      // 0x0598(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bInitializedWeaponItem;                            // 0x05A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUpdateLocalAmmoCount;                             // 0x05A5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A6[0x2];                                      // 0x05A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortGameplayAbility*                   ActiveAbility;                                     // 0x05A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             PrimaryAbilitySpecHandle;                          // 0x05AC(0x0004)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             SecondaryAbilitySpecHandle;                        // 0x05B0(0x0004)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             ReloadAbilitySpecHandle;                           // 0x05B4(0x0004)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     EquippedAbilityHandles;                            // 0x05B8(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          EquippedAbilitySetHandles;                         // 0x05C4(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAlterationItemDefinition*>  AppliedAlterations;                                // 0x05D0(0x000C)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EquipAnimation;                                    // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadAnimation;                                   // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponEquipMontage;                                // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponReloadMontage;                               // 0x05EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortWeaponCoreAnimation                      WeaponCoreAnimation;                               // 0x05F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTempWeaponMaterialOverride(class UMaterialInterface* MaterialOverride);
	void ClientGivenTo(class APawn* P);
	void ClientReportShotFlags(uint32 ShotFlags, int32 ShotIndex);
	struct FColor DetermineReticleColor();
	void GameplayCue_Impact(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Weapons_Activation(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GameplayCue_Weapons_ChargeUp(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters);
	void GetActiveAlterations(TArray<class UFortAlterationItemDefinition*>* outActiveAlterations);
	void K2_OnUnEquip();
	void OnAmmoCountChanged();
	void OnEndCharge();
	void OnEquippedWeaponDestory();
	void OnEquippedWeaponDestroyWrapper();
	void OnInitAlteration(class UFortAlterationItemDefinition* NewAlteration);
	void OnInitCosmeticAlterations(const struct FFortCosmeticModification& CosmeticMod, class UMaterialInstanceDynamic* DynamicMaterialInstance);
	void OnOutOfAmmoFire();
	void OnPawnMontageStarted(class UAnimMontage* PawnMontage);
	void OnPlayImpactFX(const struct FHitResult& HitResult, EPhysicalSurface ImpactPhysicalSurface, class UParticleSystemComponent* SpawnedPSC);
	void OnPlayReloadFX(EFortReloadFXState ReloadStage);
	void OnPlayWeaponFireFX(bool bPersistentFire);
	void OnReachedMaxCharge();
	void OnReachedMinCharge();
	void OnRep_AmmoCount();
	void OnRep_ReplicatedAppliedAlterations();
	void OnRep_ReplicatedWeaponData();
	void OnSetTargeting(bool bNewIsTargeting);
	void OnStartCharge();
	void OnStopWeaponFireFX();
	void OnWeaponAttached();
	void OnWeaponVisibilityChanged(bool bVisible);
	void PlayNativeImpactFX(const struct FHitResult& HitResult, const struct FGameplayCueParameters& GameplayCueParameters);
	void PlayReloadFX(EFortReloadFXState ReloadStage);
	void PlayWeaponFireFX(bool bSecondaryFire);
	void ResetTempWeaponMaterialOverride();
	void ServerResetShotReport();
	void ServerStartCharge();
	void SetShouldDrawNativeReticle(bool bInShouldDrawReticle);
	void SetWeaponVisibility(bool bDesiredVisibility, bool bForceUpdate);
	void StopWeaponFireFX();
	void UseWeaponDurability(float DurabilityScale);

	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	int32 GetBulletsPerClip() const;
	float GetChargePercent() const;
	EFortWeaponCoreAnimation GetCoreAnimation() const;
	float GetCurrentMaxChargePercent() const;
	struct FVector GetDamageStartLocation(struct FVector* AimDir) const;
	int32 GetLocalMagazineAmmoCount() const;
	int32 GetLocalRemainingAmmo() const;
	int32 GetMagazineAmmoCount() const;
	float GetRange() const;
	float GetReloadProgress() const;
	float GetReloadTime() const;
	int32 GetRemainingAmmo() const;
	struct FColor GetReticleColor() const;
	bool IsReloading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeapon">();
	}
	static class AFortWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeapon>();
	}
};
static_assert(alignof(AFortWeapon) == 0x000004, "Wrong alignment on AFortWeapon");
static_assert(sizeof(AFortWeapon) == 0x0005F4, "Wrong size on AFortWeapon");
static_assert(offsetof(AFortWeapon, bIsEquippingWeapon) == 0x00024C, "Member 'AFortWeapon::bIsEquippingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsReloadingWeapon) == 0x00024D, "Member 'AFortWeapon::bIsReloadingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsChargingWeapon) == 0x00024E, "Member 'AFortWeapon::bIsChargingWeapon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponData) == 0x000250, "Member 'AFortWeapon::WeaponData' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bShouldDrawNativeReticle) == 0x000254, "Member 'AFortWeapon::bShouldDrawNativeReticle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleImage) == 0x000258, "Member 'AFortWeapon::ReticleImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultColor) == 0x00025C, "Member 'AFortWeapon::ReticleDefaultColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleEnemyColor) == 0x000260, "Member 'AFortWeapon::ReticleEnemyColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleBuildingColor) == 0x000264, "Member 'AFortWeapon::ReticleBuildingColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, HitNotifyReticleImage) == 0x000268, "Member 'AFortWeapon::HitNotifyReticleImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, HitNotifyDisplayDuration) == 0x00026C, "Member 'AFortWeapon::HitNotifyDisplayDuration' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleCenterImage) == 0x000270, "Member 'AFortWeapon::ReticleCenterImage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultPrimaryStrikeAngle) == 0x000274, "Member 'AFortWeapon::ReticleDefaultPrimaryStrikeAngle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReticleDefaultSecondaryStrikeAngle) == 0x000278, "Member 'AFortWeapon::ReticleDefaultSecondaryStrikeAngle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraBase3PClass) == 0x00027C, "Member 'AFortWeapon::CameraBase3PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraTargeting3PClass) == 0x000280, "Member 'AFortWeapon::CameraTargeting3PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraBase1PClass) == 0x000284, "Member 'AFortWeapon::CameraBase1PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CameraTargeting1PClass) == 0x000288, "Member 'AFortWeapon::CameraTargeting1PClass' has a wrong offset!");
static_assert(offsetof(AFortWeapon, DestroyedSound) == 0x00028C, "Member 'AFortWeapon::DestroyedSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, OutOfAmmoSound) == 0x000290, "Member 'AFortWeapon::OutOfAmmoSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadSounds) == 0x000294, "Member 'AFortWeapon::ReloadSounds' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireSound) == 0x0002A0, "Member 'AFortWeapon::PrimaryFireSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireStopSound) == 0x0002AC, "Member 'AFortWeapon::PrimaryFireStopSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryFireSound) == 0x0002B8, "Member 'AFortWeapon::SecondaryFireSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryFireStopSound) == 0x0002C4, "Member 'AFortWeapon::SecondaryFireStopSound' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryFireSoundFadeOutTime) == 0x0002D0, "Member 'AFortWeapon::PrimaryFireSoundFadeOutTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactPhysicalSurfaceSounds) == 0x0002D4, "Member 'AFortWeapon::ImpactPhysicalSurfaceSounds' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactPhysicalSurfaceEffects) == 0x0003D0, "Member 'AFortWeapon::ImpactPhysicalSurfaceEffects' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ImpactCameraShake) == 0x0004CC, "Member 'AFortWeapon::ImpactCameraShake' has a wrong offset!");
static_assert(offsetof(AFortWeapon, FireAudioChannels) == 0x0004D0, "Member 'AFortWeapon::FireAudioChannels' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponMesh) == 0x0004DC, "Member 'AFortWeapon::WeaponMesh' has a wrong offset!");
static_assert(offsetof(AFortWeapon, DefaultWeaponMaterials) == 0x0004E0, "Member 'AFortWeapon::DefaultWeaponMaterials' has a wrong offset!");
static_assert(offsetof(AFortWeapon, FireAudioChannelWantsToPlay) == 0x0004EC, "Member 'AFortWeapon::FireAudioChannelWantsToPlay' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bUsingSecondaryFireAudio) == 0x0004F8, "Member 'AFortWeapon::bUsingSecondaryFireAudio' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentReticleIcon) == 0x0004FC, "Member 'AFortWeapon::CurrentReticleIcon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentHitNotifyReticleIcon) == 0x000510, "Member 'AFortWeapon::CurrentHitNotifyReticleIcon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentReticleCenterIcon) == 0x000524, "Member 'AFortWeapon::CurrentReticleCenterIcon' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentReticleColor) == 0x000538, "Member 'AFortWeapon::CurrentReticleColor' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastFireTime) == 0x00053C, "Member 'AFortWeapon::LastFireTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsPlayingFireFX) == 0x000540, "Member 'AFortWeapon::bIsPlayingFireFX' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TimerIntervalAdjustment) == 0x000544, "Member 'AFortWeapon::TimerIntervalAdjustment' has a wrong offset!");
static_assert(offsetof(AFortWeapon, InputQueueTimePercent) == 0x000548, "Member 'AFortWeapon::InputQueueTimePercent' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bAllowTargeting) == 0x00054C, "Member 'AFortWeapon::bAllowTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bIsTargeting) == 0x00054D, "Member 'AFortWeapon::bIsTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TargetSourceOffset) == 0x000550, "Member 'AFortWeapon::TargetSourceOffset' has a wrong offset!");
static_assert(offsetof(AFortWeapon, TargetSourceOffsetWhileTargeting) == 0x00055C, "Member 'AFortWeapon::TargetSourceOffsetWhileTargeting' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bTraceThroughPawns) == 0x000568, "Member 'AFortWeapon::bTraceThroughPawns' has a wrong offset!");
static_assert(offsetof(AFortWeapon, LastReloadTime) == 0x00056C, "Member 'AFortWeapon::LastReloadTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadDuration) == 0x000570, "Member 'AFortWeapon::ReloadDuration' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ItemEntryGuid) == 0x000574, "Member 'AFortWeapon::ItemEntryGuid' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponLevel) == 0x000584, "Member 'AFortWeapon::WeaponLevel' has a wrong offset!");
static_assert(offsetof(AFortWeapon, AmmoCount) == 0x000588, "Member 'AFortWeapon::AmmoCount' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ChargeTime) == 0x000590, "Member 'AFortWeapon::ChargeTime' has a wrong offset!");
static_assert(offsetof(AFortWeapon, CurrentShotLogIndex) == 0x000594, "Member 'AFortWeapon::CurrentShotLogIndex' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ShotLogFlags) == 0x000598, "Member 'AFortWeapon::ShotLogFlags' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bInitializedWeaponItem) == 0x0005A4, "Member 'AFortWeapon::bInitializedWeaponItem' has a wrong offset!");
static_assert(offsetof(AFortWeapon, bUpdateLocalAmmoCount) == 0x0005A5, "Member 'AFortWeapon::bUpdateLocalAmmoCount' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ActiveAbility) == 0x0005A8, "Member 'AFortWeapon::ActiveAbility' has a wrong offset!");
static_assert(offsetof(AFortWeapon, PrimaryAbilitySpecHandle) == 0x0005AC, "Member 'AFortWeapon::PrimaryAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, SecondaryAbilitySpecHandle) == 0x0005B0, "Member 'AFortWeapon::SecondaryAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadAbilitySpecHandle) == 0x0005B4, "Member 'AFortWeapon::ReloadAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquippedAbilityHandles) == 0x0005B8, "Member 'AFortWeapon::EquippedAbilityHandles' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquippedAbilitySetHandles) == 0x0005C4, "Member 'AFortWeapon::EquippedAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(AFortWeapon, AppliedAlterations) == 0x0005D0, "Member 'AFortWeapon::AppliedAlterations' has a wrong offset!");
static_assert(offsetof(AFortWeapon, EquipAnimation) == 0x0005E0, "Member 'AFortWeapon::EquipAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeapon, ReloadAnimation) == 0x0005E4, "Member 'AFortWeapon::ReloadAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponEquipMontage) == 0x0005E8, "Member 'AFortWeapon::WeaponEquipMontage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponReloadMontage) == 0x0005EC, "Member 'AFortWeapon::WeaponReloadMontage' has a wrong offset!");
static_assert(offsetof(AFortWeapon, WeaponCoreAnimation) == 0x0005F0, "Member 'AFortWeapon::WeaponCoreAnimation' has a wrong offset!");

// Class FortniteGame.FortDecoTool
// 0x002C (0x0620 - 0x05F4)
class AFortDecoTool : public AFortWeapon
{
public:
	bool                                          bButtonDown;                                       // 0x05F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortItemDefinition*                    ItemDefinition;                                    // 0x05F8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortDecoHelper*                        DecoHelper;                                        // 0x05FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CarriedActor;                                      // 0x0600(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlaceCarriedActor;                                // 0x0604(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         SpawnEffect;                                       // 0x0608(0x0018)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCarriedActorDestroyed();
	void OnRep_CarriedActor();
	void OnRep_ItemDefinition();
	void ServerSpawnDeco(const struct FVector& Location, const struct FRotator& Rotation, class ABuildingSMActor* AttachedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoTool">();
	}
	static class AFortDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoTool>();
	}
};
static_assert(alignof(AFortDecoTool) == 0x000004, "Wrong alignment on AFortDecoTool");
static_assert(sizeof(AFortDecoTool) == 0x000620, "Wrong size on AFortDecoTool");
static_assert(offsetof(AFortDecoTool, bButtonDown) == 0x0005F4, "Member 'AFortDecoTool::bButtonDown' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, ItemDefinition) == 0x0005F8, "Member 'AFortDecoTool::ItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, DecoHelper) == 0x0005FC, "Member 'AFortDecoTool::DecoHelper' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, CarriedActor) == 0x000600, "Member 'AFortDecoTool::CarriedActor' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, bPlaceCarriedActor) == 0x000604, "Member 'AFortDecoTool::bPlaceCarriedActor' has a wrong offset!");
static_assert(offsetof(AFortDecoTool, SpawnEffect) == 0x000608, "Member 'AFortDecoTool::SpawnEffect' has a wrong offset!");

// Class FortniteGame.BuildingOutpostStorageVault
// 0x0000 (0x0950 - 0x0950)
class ABuildingOutpostStorageVault final : public AOutpostStructureBase
{
public:
	void MoveItemFromStorage(class AFortPlayerControllerOutpost* Player, class UFortWorldItem* Item, int32 Count);
	void MoveItemToStorage(class AFortPlayerControllerOutpost* Player, class UFortWorldItem* Item, int32 Count);

	int32 GetMaxSlotsNum(class AFortPlayerControllerOutpost* Player) const;
	int32 GetOccupiedSlotsNum(class AFortPlayerControllerOutpost* Player) const;
	TArray<class UFortItem*> GetPlayerItems(class AFortPlayerControllerOutpost* Player, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter) const;
	TArray<class UFortItem*> GetStoredItems(class AFortPlayerControllerOutpost* Player, EFortInventoryFilter InventoryFilter, const class FString& SearchFilter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStorageVault">();
	}
	static class ABuildingOutpostStorageVault* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStorageVault>();
	}
};
static_assert(alignof(ABuildingOutpostStorageVault) == 0x000004, "Wrong alignment on ABuildingOutpostStorageVault");
static_assert(sizeof(ABuildingOutpostStorageVault) == 0x000950, "Wrong size on ABuildingOutpostStorageVault");

// Class FortniteGame.FortGameState
// 0x0150 (0x03D0 - 0x0280)
class AFortGameState : public AGameState
{
public:
	class FString                                 WorldDisplayName;                                  // 0x0280(0x000C)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentWUID;                                       // 0x028C(0x000C)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldDaysElapsed;                                  // 0x0298(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParTime;                                           // 0x029C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WorldLevel;                                        // 0x02A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CraftingBonus;                                     // 0x02A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentReadyToContinueTimer;                       // 0x02A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x02AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x02B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoteTimeLeft;                                      // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0xC];                                      // 0x02B8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EFortRequestedGameplayAction                  GameplayActionVoteResult;                          // 0x02C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortFeedbackManager*                   FeedbackManager;                                   // 0x02C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMissionManager*                    MissionManager;                                    // 0x02CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortScriptedActionManager*             ScriptedActionManager;                             // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedGameDifficultyData              CachedGameDifficultyData;                          // 0x02D4(0x0050)(Net, Protected, NativeAccessSpecifierProtected)
	class AFortLobbyBeaconState*                  LobbyGameState;                                    // 0x0324(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortWorldManager*                      WorldManager;                                      // 0x0328(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortDayNightLightingAndFog*            FortDayPhaseHandler;                               // 0x032C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortGameplayState                            GameplayState;                                     // 0x0330(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         SharedInventory;                                   // 0x0334(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  LocalGameSessionID;                                // 0x0338(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOnTimeHitInfo>                 TimeOfDayCallbacks;                                // 0x0348(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x1C];                                     // 0x0354(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortVisibilityManager*                 VisibilityManager;                                 // 0x0370(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortTeamInfo*>                  Teams;                                             // 0x0374(0x000C)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTeamChangeRequest>             PendingTeamChangeRequests;                         // 0x0380(0x000C)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowPendingTeamChangeRequests;                   // 0x038C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38D[0x3F];                                     // 0x038D(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortGlobalAbilityTargetingActor*       GlobalAbilityTargetingActor;                       // 0x03CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleSharedInventoryUpdate();
	void OnRep_CurrentWUID();
	void OnRep_DayPhaseHandler();
	void OnRep_FeedbackManager();
	void OnRep_GameplayState();
	void OnRep_MissionManager();
	void OnRep_WorldManager();

	class AFortDayNightLightingAndFog* GetDayPhaseHandler() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameState">();
	}
	static class AFortGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameState>();
	}
};
static_assert(alignof(AFortGameState) == 0x000004, "Wrong alignment on AFortGameState");
static_assert(sizeof(AFortGameState) == 0x0003D0, "Wrong size on AFortGameState");
static_assert(offsetof(AFortGameState, WorldDisplayName) == 0x000280, "Member 'AFortGameState::WorldDisplayName' has a wrong offset!");
static_assert(offsetof(AFortGameState, CurrentWUID) == 0x00028C, "Member 'AFortGameState::CurrentWUID' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldDaysElapsed) == 0x000298, "Member 'AFortGameState::WorldDaysElapsed' has a wrong offset!");
static_assert(offsetof(AFortGameState, ParTime) == 0x00029C, "Member 'AFortGameState::ParTime' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldLevel) == 0x0002A0, "Member 'AFortGameState::WorldLevel' has a wrong offset!");
static_assert(offsetof(AFortGameState, CraftingBonus) == 0x0002A4, "Member 'AFortGameState::CraftingBonus' has a wrong offset!");
static_assert(offsetof(AFortGameState, CurrentReadyToContinueTimer) == 0x0002A8, "Member 'AFortGameState::CurrentReadyToContinueTimer' has a wrong offset!");
static_assert(offsetof(AFortGameState, TeamCount) == 0x0002AC, "Member 'AFortGameState::TeamCount' has a wrong offset!");
static_assert(offsetof(AFortGameState, TeamSize) == 0x0002B0, "Member 'AFortGameState::TeamSize' has a wrong offset!");
static_assert(offsetof(AFortGameState, VoteTimeLeft) == 0x0002B4, "Member 'AFortGameState::VoteTimeLeft' has a wrong offset!");
static_assert(offsetof(AFortGameState, GameplayActionVoteResult) == 0x0002C4, "Member 'AFortGameState::GameplayActionVoteResult' has a wrong offset!");
static_assert(offsetof(AFortGameState, FeedbackManager) == 0x0002C8, "Member 'AFortGameState::FeedbackManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, MissionManager) == 0x0002CC, "Member 'AFortGameState::MissionManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, ScriptedActionManager) == 0x0002D0, "Member 'AFortGameState::ScriptedActionManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, CachedGameDifficultyData) == 0x0002D4, "Member 'AFortGameState::CachedGameDifficultyData' has a wrong offset!");
static_assert(offsetof(AFortGameState, LobbyGameState) == 0x000324, "Member 'AFortGameState::LobbyGameState' has a wrong offset!");
static_assert(offsetof(AFortGameState, WorldManager) == 0x000328, "Member 'AFortGameState::WorldManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, FortDayPhaseHandler) == 0x00032C, "Member 'AFortGameState::FortDayPhaseHandler' has a wrong offset!");
static_assert(offsetof(AFortGameState, GameplayState) == 0x000330, "Member 'AFortGameState::GameplayState' has a wrong offset!");
static_assert(offsetof(AFortGameState, SharedInventory) == 0x000334, "Member 'AFortGameState::SharedInventory' has a wrong offset!");
static_assert(offsetof(AFortGameState, LocalGameSessionID) == 0x000338, "Member 'AFortGameState::LocalGameSessionID' has a wrong offset!");
static_assert(offsetof(AFortGameState, TimeOfDayCallbacks) == 0x000348, "Member 'AFortGameState::TimeOfDayCallbacks' has a wrong offset!");
static_assert(offsetof(AFortGameState, VisibilityManager) == 0x000370, "Member 'AFortGameState::VisibilityManager' has a wrong offset!");
static_assert(offsetof(AFortGameState, Teams) == 0x000374, "Member 'AFortGameState::Teams' has a wrong offset!");
static_assert(offsetof(AFortGameState, PendingTeamChangeRequests) == 0x000380, "Member 'AFortGameState::PendingTeamChangeRequests' has a wrong offset!");
static_assert(offsetof(AFortGameState, bAllowPendingTeamChangeRequests) == 0x00038C, "Member 'AFortGameState::bAllowPendingTeamChangeRequests' has a wrong offset!");
static_assert(offsetof(AFortGameState, GlobalAbilityTargetingActor) == 0x0003CC, "Member 'AFortGameState::GlobalAbilityTargetingActor' has a wrong offset!");

// Class FortniteGame.BuildingOutpostStormshieldUpgrade
// 0x0004 (0x0954 - 0x0950)
class ABuildingOutpostStormshieldUpgrade : public AOutpostStructureBase
{
public:
	bool                                          bDefended;                                         // 0x0950(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBuilt;                                            // 0x0951(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_952[0x2];                                      // 0x0952(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnBuilt();
	void BlueprintOnDefended();
	void Build(class AFortPlayerControllerOutpost* InBuildingPlayer);
	void EmergencySetBuildFlag(bool bNewBuild);
	void OnRep_bBuilt();
	void OnRep_bDefended();
	void WasDefended();

	bool CanBuild(class AFortPlayerControllerOutpost* InBuildingPlayer, bool bLog) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStormshieldUpgrade">();
	}
	static class ABuildingOutpostStormshieldUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStormshieldUpgrade>();
	}
};
static_assert(alignof(ABuildingOutpostStormshieldUpgrade) == 0x000004, "Wrong alignment on ABuildingOutpostStormshieldUpgrade");
static_assert(sizeof(ABuildingOutpostStormshieldUpgrade) == 0x000954, "Wrong size on ABuildingOutpostStormshieldUpgrade");
static_assert(offsetof(ABuildingOutpostStormshieldUpgrade, bDefended) == 0x000950, "Member 'ABuildingOutpostStormshieldUpgrade::bDefended' has a wrong offset!");
static_assert(offsetof(ABuildingOutpostStormshieldUpgrade, bBuilt) == 0x000951, "Member 'ABuildingOutpostStormshieldUpgrade::bBuilt' has a wrong offset!");

// Class FortniteGame.BuildingOutpostStormshieldCore
// 0x000C (0x0960 - 0x0954)
class ABuildingOutpostStormshieldCore final : public ABuildingOutpostStormshieldUpgrade
{
public:
	TArray<class FString>                         AccountsWithEditPermission;                        // 0x0954(0x000C)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingOutpostStormshieldCore">();
	}
	static class ABuildingOutpostStormshieldCore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingOutpostStormshieldCore>();
	}
};
static_assert(alignof(ABuildingOutpostStormshieldCore) == 0x000004, "Wrong alignment on ABuildingOutpostStormshieldCore");
static_assert(sizeof(ABuildingOutpostStormshieldCore) == 0x000960, "Wrong size on ABuildingOutpostStormshieldCore");
static_assert(offsetof(ABuildingOutpostStormshieldCore, AccountsWithEditPermission) == 0x000954, "Member 'ABuildingOutpostStormshieldCore::AccountsWithEditPermission' has a wrong offset!");

// Class FortniteGame.BuildingRoof
// 0x0000 (0x0944 - 0x0944)
class ABuildingRoof final : public ABuildingSMActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingRoof">();
	}
	static class ABuildingRoof* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingRoof>();
	}
};
static_assert(alignof(ABuildingRoof) == 0x000004, "Wrong alignment on ABuildingRoof");
static_assert(sizeof(ABuildingRoof) == 0x000944, "Wrong size on ABuildingRoof");

// Class FortniteGame.FortPlayerAttrSet
// 0x00A0 (0x00C0 - 0x0020)
class UFortPlayerAttrSet final : public UFortAttributeSet
{
public:
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stamina;                                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaRegenRate;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaRegenDelay;                                 // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStamina;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaCost;                                       // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCost;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponChanceToNotConsumeAmmo;                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedWeaponChanceToNotConsumeAmmo;           // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRateOfFire;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponHorizontalRecoil;                            // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponVerticalRecoil;                              // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponReloadSpeed;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponAmmoClipSize;                                // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterItemDurabilityDecayChance;                // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemRegenMaxStack;                                 // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleLootRollChance;                              // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleItemLootChance;                              // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoubleCraftChance;                                 // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraftingTimeMultiplier;                            // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x8];                                       // 0x0074(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceHarvesting;                                // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scrappiness;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swagger;                                           // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tenacity;                                          // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Armour;                                            // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vitality;                                          // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offense;                                           // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Prowess;                                           // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Defense;                                           // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveEffectDuration;                              // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x1C];                                      // 0x00A4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ItemRegenMaxStack();
	void OnRep_MaxStamina();
	void OnRep_SprintCost();
	void OnRep_Stamina();
	void OnRep_StaminaCost();
	void OnRep_StaminaRegenDelay();
	void OnRep_StaminaRegenRate();
	void OnRep_WeaponRateOfFire();
	void OnRep_WeaponReloadSpeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAttrSet">();
	}
	static class UFortPlayerAttrSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAttrSet>();
	}
};
static_assert(alignof(UFortPlayerAttrSet) == 0x000004, "Wrong alignment on UFortPlayerAttrSet");
static_assert(sizeof(UFortPlayerAttrSet) == 0x0000C0, "Wrong size on UFortPlayerAttrSet");
static_assert(offsetof(UFortPlayerAttrSet, Stamina) == 0x000024, "Member 'UFortPlayerAttrSet::Stamina' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaRegenRate) == 0x000028, "Member 'UFortPlayerAttrSet::StaminaRegenRate' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaRegenDelay) == 0x00002C, "Member 'UFortPlayerAttrSet::StaminaRegenDelay' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, MaxStamina) == 0x000030, "Member 'UFortPlayerAttrSet::MaxStamina' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, StaminaCost) == 0x000034, "Member 'UFortPlayerAttrSet::StaminaCost' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, SprintCost) == 0x000038, "Member 'UFortPlayerAttrSet::SprintCost' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponChanceToNotConsumeAmmo) == 0x000040, "Member 'UFortPlayerAttrSet::WeaponChanceToNotConsumeAmmo' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, AccumulatedWeaponChanceToNotConsumeAmmo) == 0x000044, "Member 'UFortPlayerAttrSet::AccumulatedWeaponChanceToNotConsumeAmmo' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponRateOfFire) == 0x000048, "Member 'UFortPlayerAttrSet::WeaponRateOfFire' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponHorizontalRecoil) == 0x00004C, "Member 'UFortPlayerAttrSet::WeaponHorizontalRecoil' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponVerticalRecoil) == 0x000050, "Member 'UFortPlayerAttrSet::WeaponVerticalRecoil' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponReloadSpeed) == 0x000054, "Member 'UFortPlayerAttrSet::WeaponReloadSpeed' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, WeaponAmmoClipSize) == 0x000058, "Member 'UFortPlayerAttrSet::WeaponAmmoClipSize' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, CharacterItemDurabilityDecayChance) == 0x00005C, "Member 'UFortPlayerAttrSet::CharacterItemDurabilityDecayChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ItemRegenMaxStack) == 0x000060, "Member 'UFortPlayerAttrSet::ItemRegenMaxStack' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleLootRollChance) == 0x000064, "Member 'UFortPlayerAttrSet::DoubleLootRollChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleItemLootChance) == 0x000068, "Member 'UFortPlayerAttrSet::DoubleItemLootChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, DoubleCraftChance) == 0x00006C, "Member 'UFortPlayerAttrSet::DoubleCraftChance' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, CraftingTimeMultiplier) == 0x000070, "Member 'UFortPlayerAttrSet::CraftingTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ResourceHarvesting) == 0x00007C, "Member 'UFortPlayerAttrSet::ResourceHarvesting' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Scrappiness) == 0x000080, "Member 'UFortPlayerAttrSet::Scrappiness' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Swagger) == 0x000084, "Member 'UFortPlayerAttrSet::Swagger' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Tenacity) == 0x000088, "Member 'UFortPlayerAttrSet::Tenacity' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Armour) == 0x00008C, "Member 'UFortPlayerAttrSet::Armour' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Vitality) == 0x000090, "Member 'UFortPlayerAttrSet::Vitality' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Offense) == 0x000094, "Member 'UFortPlayerAttrSet::Offense' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Prowess) == 0x000098, "Member 'UFortPlayerAttrSet::Prowess' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, Defense) == 0x00009C, "Member 'UFortPlayerAttrSet::Defense' has a wrong offset!");
static_assert(offsetof(UFortPlayerAttrSet, ActiveEffectDuration) == 0x0000A0, "Member 'UFortPlayerAttrSet::ActiveEffectDuration' has a wrong offset!");

// Class FortniteGame.FortTooltip
// 0x000C (0x0028 - 0x001C)
class UFortTooltip : public UObject
{
public:
	class FText                                   Description;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	bool GetNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, float* OutVal) const;
	bool GetNumericValueInternal(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, float* OutVal) const;
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTextForTokenInternal(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;
	bool GetTokenizedDescriptionTextInternal(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTooltip">();
	}
	static class UFortTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTooltip>();
	}
};
static_assert(alignof(UFortTooltip) == 0x000004, "Wrong alignment on UFortTooltip");
static_assert(sizeof(UFortTooltip) == 0x000028, "Wrong size on UFortTooltip");
static_assert(offsetof(UFortTooltip, Description) == 0x00001C, "Member 'UFortTooltip::Description' has a wrong offset!");

// Class FortniteGame.FortItemDefinitionTooltip
// 0x0000 (0x0028 - 0x0028)
class UFortItemDefinitionTooltip : public UFortTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemDefinitionTooltip">();
	}
	static class UFortItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortItemDefinitionTooltip) == 0x000004, "Wrong alignment on UFortItemDefinitionTooltip");
static_assert(sizeof(UFortItemDefinitionTooltip) == 0x000028, "Wrong size on UFortItemDefinitionTooltip");

// Class FortniteGame.FortWorldItemDefinitionTooltip
// 0x0000 (0x0028 - 0x0028)
class UFortWorldItemDefinitionTooltip : public UFortItemDefinitionTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItemDefinitionTooltip">();
	}
	static class UFortWorldItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortWorldItemDefinitionTooltip) == 0x000004, "Wrong alignment on UFortWorldItemDefinitionTooltip");
static_assert(sizeof(UFortWorldItemDefinitionTooltip) == 0x000028, "Wrong size on UFortWorldItemDefinitionTooltip");

// Class FortniteGame.FortAlterationItemDefinition
// 0x0054 (0x0484 - 0x0430)
class UFortAlterationItemDefinition : public UFortAccountItemDefinition
{
public:
	EFortAlteration                               AlterationType;                                    // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCosmeticModification              DefaultCosmetic;                                   // 0x0434(0x0034)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FFortConditionalCosmeticModification> ConditionalCosmetics;                              // 0x0468(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortConditionalIncludeTags>    AdditionalGameplayTags;                            // 0x0474(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortAbilitySet*                        AlterationAbilitySet;                              // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterationItemDefinition">();
	}
	static class UFortAlterationItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterationItemDefinition>();
	}
};
static_assert(alignof(UFortAlterationItemDefinition) == 0x000004, "Wrong alignment on UFortAlterationItemDefinition");
static_assert(sizeof(UFortAlterationItemDefinition) == 0x000484, "Wrong size on UFortAlterationItemDefinition");
static_assert(offsetof(UFortAlterationItemDefinition, AlterationType) == 0x000430, "Member 'UFortAlterationItemDefinition::AlterationType' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, DefaultCosmetic) == 0x000434, "Member 'UFortAlterationItemDefinition::DefaultCosmetic' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, ConditionalCosmetics) == 0x000468, "Member 'UFortAlterationItemDefinition::ConditionalCosmetics' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, AdditionalGameplayTags) == 0x000474, "Member 'UFortAlterationItemDefinition::AdditionalGameplayTags' has a wrong offset!");
static_assert(offsetof(UFortAlterationItemDefinition, AlterationAbilitySet) == 0x000480, "Member 'UFortAlterationItemDefinition::AlterationAbilitySet' has a wrong offset!");

// Class FortniteGame.BuildingTrap
// 0x00AC (0x09F0 - 0x0944)
class ABuildingTrap : public ABuildingSMActor
{
public:
	uint8                                         Pad_944[0x8];                                      // 0x0944(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            TrapRangeMesh;                                     // 0x094C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            TrapPreviewMesh;                                   // 0x0950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTrapItemDefinition*                TrapData;                                          // 0x0954(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AttachmentHintText;                                // 0x0958(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFortTargetFilter                      TriggerFilter;                                     // 0x0964(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UFortAbilitySet*                        AbilitySet;                                        // 0x0978(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDamageSet*                         DamageAttributeSet;                                // 0x097C(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortAlterationItemDefinition*>  AppliedAlterations;                                // 0x0980(0x000C)(Net, ZeroConstructor, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAbilitySetHandle>          AlterationAbilitySetHandles;                       // 0x098C(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       AttachedTo;                                        // 0x0998(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       LastAttachedTo;                                    // 0x099C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayBeforeDestroyAfterDurabilityExpired;          // 0x09A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A4[0x4];                                      // 0x09A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            TriggerComponents;                                 // 0x09A8(0x000C)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            DamageComponents;                                  // 0x09B4(0x000C)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           StaticMeshes;                                      // 0x09C0(0x000C)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         TrapLevel;                                         // 0x09CC(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D0[0x20];                                     // 0x09D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamageComponent(class UPrimitiveComponent* DamageComponent);
	void AddTriggerComponent(class UPrimitiveComponent* TriggerComponent);
	void AttemptRetrigger(float Seconds);
	void FinishTrigger();
	float GetArmTime();
	float GetBuildTime();
	struct FVector GetCenter();
	float GetReloadTime();
	void OnDestroy();
	void OnFinishedBuilding();
	void OnInitAlteration(class UFortAlterationItemDefinition* NewAlteration);
	void OnInitCosmeticAlterations(const struct FFortCosmeticModification& CosmeticMod);
	void OnOutOfDurability();
	void OnPlaced();
	void OnReloadBegin();
	void OnReloadEnd();
	void OnRep_AttachedTo();
	void OnRep_ReplicatedAppliedAlterations();
	void OnTriggerTouch(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void TriggerIfAppropriate();

	bool BP_ShouldTrigger(const TArray<class AActor*>& TouchingActors) const;
	TArray<class UFortAlterationItemDefinition*> GetAlterations() const;
	class ABuildingSMActor* GetBuildingAttachedTo() const;
	float GetDamageDelay() const;
	float GetDurabilityPercent() const;
	float GetFireDelay() const;
	struct FTransform GetFireLocationAndRotation() const;
	float GetMaxDurability() const;
	TArray<class AActor*> GetTouchingDamageTargets(const struct FFortTargetFilter& Filter) const;
	int32 GetTrapLevel() const;
	bool HasDurability() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrap">();
	}
	static class ABuildingTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrap>();
	}
};
static_assert(alignof(ABuildingTrap) == 0x000004, "Wrong alignment on ABuildingTrap");
static_assert(sizeof(ABuildingTrap) == 0x0009F0, "Wrong size on ABuildingTrap");
static_assert(offsetof(ABuildingTrap, TrapRangeMesh) == 0x00094C, "Member 'ABuildingTrap::TrapRangeMesh' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapPreviewMesh) == 0x000950, "Member 'ABuildingTrap::TrapPreviewMesh' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapData) == 0x000954, "Member 'ABuildingTrap::TrapData' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AttachmentHintText) == 0x000958, "Member 'ABuildingTrap::AttachmentHintText' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TriggerFilter) == 0x000964, "Member 'ABuildingTrap::TriggerFilter' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AbilitySet) == 0x000978, "Member 'ABuildingTrap::AbilitySet' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DamageAttributeSet) == 0x00097C, "Member 'ABuildingTrap::DamageAttributeSet' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AppliedAlterations) == 0x000980, "Member 'ABuildingTrap::AppliedAlterations' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AlterationAbilitySetHandles) == 0x00098C, "Member 'ABuildingTrap::AlterationAbilitySetHandles' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, AttachedTo) == 0x000998, "Member 'ABuildingTrap::AttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, LastAttachedTo) == 0x00099C, "Member 'ABuildingTrap::LastAttachedTo' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DelayBeforeDestroyAfterDurabilityExpired) == 0x0009A0, "Member 'ABuildingTrap::DelayBeforeDestroyAfterDurabilityExpired' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TriggerComponents) == 0x0009A8, "Member 'ABuildingTrap::TriggerComponents' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, DamageComponents) == 0x0009B4, "Member 'ABuildingTrap::DamageComponents' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, StaticMeshes) == 0x0009C0, "Member 'ABuildingTrap::StaticMeshes' has a wrong offset!");
static_assert(offsetof(ABuildingTrap, TrapLevel) == 0x0009CC, "Member 'ABuildingTrap::TrapLevel' has a wrong offset!");

// Class FortniteGame.FortConstructionSet
// 0x002C (0x004C - 0x0020)
class UFortConstructionSet final : public UFortAttributeSet
{
public:
	float                                         BuildSpeed;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepairSpeed;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildCost;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepairCost;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBuildLevel;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapArmSpeed;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapReloadSpeed;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapBaseDamage;                                    // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapMaxDurability;                                 // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapDiceCritChance;                                // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrapDiceCritMultiplier;                            // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConstructionSet">();
	}
	static class UFortConstructionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConstructionSet>();
	}
};
static_assert(alignof(UFortConstructionSet) == 0x000004, "Wrong alignment on UFortConstructionSet");
static_assert(sizeof(UFortConstructionSet) == 0x00004C, "Wrong size on UFortConstructionSet");
static_assert(offsetof(UFortConstructionSet, BuildSpeed) == 0x000020, "Member 'UFortConstructionSet::BuildSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, RepairSpeed) == 0x000024, "Member 'UFortConstructionSet::RepairSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, BuildCost) == 0x000028, "Member 'UFortConstructionSet::BuildCost' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, RepairCost) == 0x00002C, "Member 'UFortConstructionSet::RepairCost' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, MaxBuildLevel) == 0x000030, "Member 'UFortConstructionSet::MaxBuildLevel' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapArmSpeed) == 0x000034, "Member 'UFortConstructionSet::TrapArmSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapReloadSpeed) == 0x000038, "Member 'UFortConstructionSet::TrapReloadSpeed' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapBaseDamage) == 0x00003C, "Member 'UFortConstructionSet::TrapBaseDamage' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapMaxDurability) == 0x000040, "Member 'UFortConstructionSet::TrapMaxDurability' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapDiceCritChance) == 0x000044, "Member 'UFortConstructionSet::TrapDiceCritChance' has a wrong offset!");
static_assert(offsetof(UFortConstructionSet, TrapDiceCritMultiplier) == 0x000048, "Member 'UFortConstructionSet::TrapDiceCritMultiplier' has a wrong offset!");

// Class FortniteGame.FortGameplayTagVolume
// 0x001C (0x0284 - 0x0268)
class AFortGameplayTagVolume final : public AVolume
{
public:
	uint8                                         Pad_268[0x4];                                      // 0x0268(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToApplyOnSave;                                 // 0x026C(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagVolume">();
	}
	static class AFortGameplayTagVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayTagVolume>();
	}
};
static_assert(alignof(AFortGameplayTagVolume) == 0x000004, "Wrong alignment on AFortGameplayTagVolume");
static_assert(sizeof(AFortGameplayTagVolume) == 0x000284, "Wrong size on AFortGameplayTagVolume");
static_assert(offsetof(AFortGameplayTagVolume, TagsToApplyOnSave) == 0x00026C, "Member 'AFortGameplayTagVolume::TagsToApplyOnSave' has a wrong offset!");

// Class FortniteGame.BuildingTrapCeiling
// 0x0000 (0x09F0 - 0x09F0)
class ABuildingTrapCeiling final : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapCeiling">();
	}
	static class ABuildingTrapCeiling* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapCeiling>();
	}
};
static_assert(alignof(ABuildingTrapCeiling) == 0x000004, "Wrong alignment on ABuildingTrapCeiling");
static_assert(sizeof(ABuildingTrapCeiling) == 0x0009F0, "Wrong size on ABuildingTrapCeiling");

// Class FortniteGame.BuildingTrapFloor
// 0x0000 (0x09F0 - 0x09F0)
class ABuildingTrapFloor : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapFloor">();
	}
	static class ABuildingTrapFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapFloor>();
	}
};
static_assert(alignof(ABuildingTrapFloor) == 0x000004, "Wrong alignment on ABuildingTrapFloor");
static_assert(sizeof(ABuildingTrapFloor) == 0x0009F0, "Wrong size on ABuildingTrapFloor");

// Class FortniteGame.FortBehaviorTreeComponent
// 0x0000 (0x01AC - 0x01AC)
class UFortBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBehaviorTreeComponent">();
	}
	static class UFortBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBehaviorTreeComponent>();
	}
};
static_assert(alignof(UFortBehaviorTreeComponent) == 0x000004, "Wrong alignment on UFortBehaviorTreeComponent");
static_assert(sizeof(UFortBehaviorTreeComponent) == 0x0001AC, "Wrong size on UFortBehaviorTreeComponent");

// Class FortniteGame.FortWeaponRanged
// 0x0074 (0x0668 - 0x05F4)
class AFortWeaponRanged : public AFortWeapon
{
public:
	bool                                          bAtMinimumReticleSpread;                           // 0x05F4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentReticleSpread;                              // 0x05F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentReticleSpreadMultiplier;                    // 0x05FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentStandingStillSpreadMultiplier;              // 0x0600(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MuzzleSocketName;                                  // 0x0604(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleFalloffSocketName;                           // 0x060C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPersistentFireFX;                                 // 0x0614(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortTracerBase>            TracerTemplate;                                    // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentNumBullets;                                 // 0x061C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BurstFireCounter;                                  // 0x0620(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldDisplayAmmoCounter;                         // 0x0624(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_625[0x33];                                     // 0x0625(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FireAnimation;                                     // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FireDownsightsAnimation;                           // 0x065C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponFireMontage;                                 // 0x0660(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WeaponFireDownsightsMontage;                       // 0x0664(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UParticleSystem* GetBulletShellFXTemplate();
	bool ShouldSpawnBulletShellFX();

	struct FVector GetMuzzleLocation() const;
	struct FTransform GetMuzzleSocketTransform() const;
	float GetTimeToNextFire() const;
	bool ShouldDisplayAmmoCounter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRanged">();
	}
	static class AFortWeaponRanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeaponRanged>();
	}
};
static_assert(alignof(AFortWeaponRanged) == 0x000004, "Wrong alignment on AFortWeaponRanged");
static_assert(sizeof(AFortWeaponRanged) == 0x000668, "Wrong size on AFortWeaponRanged");
static_assert(offsetof(AFortWeaponRanged, bAtMinimumReticleSpread) == 0x0005F4, "Member 'AFortWeaponRanged::bAtMinimumReticleSpread' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentReticleSpread) == 0x0005F8, "Member 'AFortWeaponRanged::CurrentReticleSpread' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentReticleSpreadMultiplier) == 0x0005FC, "Member 'AFortWeaponRanged::CurrentReticleSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentStandingStillSpreadMultiplier) == 0x000600, "Member 'AFortWeaponRanged::CurrentStandingStillSpreadMultiplier' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, MuzzleSocketName) == 0x000604, "Member 'AFortWeaponRanged::MuzzleSocketName' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, MuzzleFalloffSocketName) == 0x00060C, "Member 'AFortWeaponRanged::MuzzleFalloffSocketName' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, bPersistentFireFX) == 0x000614, "Member 'AFortWeaponRanged::bPersistentFireFX' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, TracerTemplate) == 0x000618, "Member 'AFortWeaponRanged::TracerTemplate' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, CurrentNumBullets) == 0x00061C, "Member 'AFortWeaponRanged::CurrentNumBullets' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, BurstFireCounter) == 0x000620, "Member 'AFortWeaponRanged::BurstFireCounter' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, bShouldDisplayAmmoCounter) == 0x000624, "Member 'AFortWeaponRanged::bShouldDisplayAmmoCounter' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, FireAnimation) == 0x000658, "Member 'AFortWeaponRanged::FireAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, FireDownsightsAnimation) == 0x00065C, "Member 'AFortWeaponRanged::FireDownsightsAnimation' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, WeaponFireMontage) == 0x000660, "Member 'AFortWeaponRanged::WeaponFireMontage' has a wrong offset!");
static_assert(offsetof(AFortWeaponRanged, WeaponFireDownsightsMontage) == 0x000664, "Member 'AFortWeaponRanged::WeaponFireDownsightsMontage' has a wrong offset!");

// Class FortniteGame.FortWeap_WannaGun
// 0x0050 (0x06B8 - 0x0668)
class AFortWeap_WannaGun final : public AFortWeaponRanged
{
public:
	uint8                                         Pad_668[0x1C];                                     // 0x0668(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastHitActorScale;                                 // 0x0684(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               LastHitActorRotation;                              // 0x0690(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UClass*                                 LastHitActorClass;                                 // 0x069C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UBuildingTextureData>    TransparentTextureData;                            // 0x06A0(0x0018)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_LastHitActorClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_WannaGun">();
	}
	static class AFortWeap_WannaGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_WannaGun>();
	}
};
static_assert(alignof(AFortWeap_WannaGun) == 0x000004, "Wrong alignment on AFortWeap_WannaGun");
static_assert(sizeof(AFortWeap_WannaGun) == 0x0006B8, "Wrong size on AFortWeap_WannaGun");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorScale) == 0x000684, "Member 'AFortWeap_WannaGun::LastHitActorScale' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorRotation) == 0x000690, "Member 'AFortWeap_WannaGun::LastHitActorRotation' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, LastHitActorClass) == 0x00069C, "Member 'AFortWeap_WannaGun::LastHitActorClass' has a wrong offset!");
static_assert(offsetof(AFortWeap_WannaGun, TransparentTextureData) == 0x0006A0, "Member 'AFortWeap_WannaGun::TransparentTextureData' has a wrong offset!");

// Class FortniteGame.BuildingTrapWall
// 0x0000 (0x09F0 - 0x09F0)
class ABuildingTrapWall : public ABuildingTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTrapWall">();
	}
	static class ABuildingTrapWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingTrapWall>();
	}
};
static_assert(alignof(ABuildingTrapWall) == 0x000004, "Wrong alignment on ABuildingTrapWall");
static_assert(sizeof(ABuildingTrapWall) == 0x0009F0, "Wrong size on ABuildingTrapWall");

// Class FortniteGame.BuildingWall
// 0x00AC (0x09F0 - 0x0944)
class ABuildingWall final : public ABuildingSMActor
{
public:
	uint8                                         Pad_944[0x4];                                      // 0x0944(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FClimbLinkData                         ClimbLink;                                         // 0x0948(0x002C)(DuplicateTransient, NativeAccessSpecifierPublic)
	EBuildingWallArea                             AreaShapeType;                                     // 0x0974(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_975[0x3];                                      // 0x0975(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABuildingDoor>              DoorClass;                                         // 0x0978(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DoorOffset;                                        // 0x097C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DoorObstacleClass;                                 // 0x0988(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorComponent;                                     // 0x09A0(0x0004)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavLinkCustomComponent*                DoorSmartLinkComp;                                 // 0x09A4(0x0004)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   DoorBlueprintMeshComp;                             // 0x09A8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DoorAnimatingMIDs;                                 // 0x09AC(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDoorOpen : 1;                                     // 0x09B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDoorCollisionDisabled : 1;                        // 0x09B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_9B9[0x3];                                      // 0x09B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DoorDesiredRotation;                               // 0x09BC(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x20];                                     // 0x09C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuildingActorNavArea                  AreaPatternOverride;                               // 0x09E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCreateClimbLink : 1;                              // 0x09EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_9ED[0x3];                                      // 0x09ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bDoorCollisionDisabled();
	void OnRep_bDoorOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingWall">();
	}
	static class ABuildingWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingWall>();
	}
};
static_assert(alignof(ABuildingWall) == 0x000004, "Wrong alignment on ABuildingWall");
static_assert(sizeof(ABuildingWall) == 0x0009F0, "Wrong size on ABuildingWall");
static_assert(offsetof(ABuildingWall, ClimbLink) == 0x000948, "Member 'ABuildingWall::ClimbLink' has a wrong offset!");
static_assert(offsetof(ABuildingWall, AreaShapeType) == 0x000974, "Member 'ABuildingWall::AreaShapeType' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorClass) == 0x000978, "Member 'ABuildingWall::DoorClass' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorOffset) == 0x00097C, "Member 'ABuildingWall::DoorOffset' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorObstacleClass) == 0x000988, "Member 'ABuildingWall::DoorObstacleClass' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorComponent) == 0x0009A0, "Member 'ABuildingWall::DoorComponent' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorSmartLinkComp) == 0x0009A4, "Member 'ABuildingWall::DoorSmartLinkComp' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorBlueprintMeshComp) == 0x0009A8, "Member 'ABuildingWall::DoorBlueprintMeshComp' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorAnimatingMIDs) == 0x0009AC, "Member 'ABuildingWall::DoorAnimatingMIDs' has a wrong offset!");
static_assert(offsetof(ABuildingWall, DoorDesiredRotation) == 0x0009BC, "Member 'ABuildingWall::DoorDesiredRotation' has a wrong offset!");
static_assert(offsetof(ABuildingWall, AreaPatternOverride) == 0x0009E8, "Member 'ABuildingWall::AreaPatternOverride' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_QueryGameplayAbility
// 0x0054 (0x009C - 0x0048)
class UFortBTDecorator_QueryGameplayAbility : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0048(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Target;                                            // 0x0060(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActiveAbilityTagsToSkipTesting;                    // 0x0080(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseTarget;                                        // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_QueryGameplayAbility">();
	}
	static class UFortBTDecorator_QueryGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_QueryGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_QueryGameplayAbility) == 0x000004, "Wrong alignment on UFortBTDecorator_QueryGameplayAbility");
static_assert(sizeof(UFortBTDecorator_QueryGameplayAbility) == 0x00009C, "Wrong size on UFortBTDecorator_QueryGameplayAbility");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, GameplayAbilityTag) == 0x000048, "Member 'UFortBTDecorator_QueryGameplayAbility::GameplayAbilityTag' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, Target) == 0x000060, "Member 'UFortBTDecorator_QueryGameplayAbility::Target' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, ActiveAbilityTagsToSkipTesting) == 0x000080, "Member 'UFortBTDecorator_QueryGameplayAbility::ActiveAbilityTagsToSkipTesting' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_QueryGameplayAbility, bUseTarget) == 0x000098, "Member 'UFortBTDecorator_QueryGameplayAbility::bUseTarget' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CompareDistance
// 0x000C (0x00A8 - 0x009C)
class UFortBTDecorator_GameplayAbility_CompareDistance final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	TArray<struct FDistanceToTargetComparison>    DistanceComparisons;                               // 0x009C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CompareDistance">();
	}
	static class UFortBTDecorator_GameplayAbility_CompareDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CompareDistance>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CompareDistance) == 0x0000A8, "Wrong size on UFortBTDecorator_GameplayAbility_CompareDistance");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_CompareDistance, DistanceComparisons) == 0x00009C, "Member 'UFortBTDecorator_GameplayAbility_CompareDistance::DistanceComparisons' has a wrong offset!");

// Class FortniteGame.FortGameStateFrontEnd
// 0x0000 (0x03D0 - 0x03D0)
class AFortGameStateFrontEnd final : public AFortGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateFrontEnd">();
	}
	static class AFortGameStateFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateFrontEnd>();
	}
};
static_assert(alignof(AFortGameStateFrontEnd) == 0x000004, "Wrong alignment on AFortGameStateFrontEnd");
static_assert(sizeof(AFortGameStateFrontEnd) == 0x0003D0, "Wrong size on AFortGameStateFrontEnd");

// Class FortniteGame.KeepHeartBase
// 0x002C (0x0970 - 0x0944)
class AKeepHeartBase : public ABuildingSMActor
{
public:
	TSoftClassPtr<class UClass>                   BuildingInstructionsHandlerClass;                  // 0x0944(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95C[0x10];                                     // 0x095C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortSaveFileBuildingInstructionsHandler* SaveFileInstructionsHandler;                       // 0x096C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AssociateWithTheMission(class AFortMission* KeepMission);
	bool IsKeepLoaded();
	bool IsKeepOwner(const class AFortPlayerController* FortPC);
	void LoadUserKeep(class AFortPlayerController* FortPC);
	bool ResetUserKeep(class AFortPlayerController* FortPC);
	bool SaveUserKeep(class AFortPlayerController* FortPC);
	void SetAllowLooting(bool bAllowed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepHeartBase">();
	}
	static class AKeepHeartBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepHeartBase>();
	}
};
static_assert(alignof(AKeepHeartBase) == 0x000004, "Wrong alignment on AKeepHeartBase");
static_assert(sizeof(AKeepHeartBase) == 0x000970, "Wrong size on AKeepHeartBase");
static_assert(offsetof(AKeepHeartBase, BuildingInstructionsHandlerClass) == 0x000944, "Member 'AKeepHeartBase::BuildingInstructionsHandlerClass' has a wrong offset!");
static_assert(offsetof(AKeepHeartBase, SaveFileInstructionsHandler) == 0x00096C, "Member 'AKeepHeartBase::SaveFileInstructionsHandler' has a wrong offset!");

// Class FortniteGame.FortKeepEventInfo
// 0x0018 (0x0034 - 0x001C)
class UFortKeepEventInfo final : public UDataAsset
{
public:
	class FText                                   EventDescription;                                  // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FKeepEventWaveData>             Waves;                                             // 0x0028(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	const struct FKeepEventWaveData GetWave(int32 INDEX);
	int32 NumberOfWaves();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepEventInfo">();
	}
	static class UFortKeepEventInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepEventInfo>();
	}
};
static_assert(alignof(UFortKeepEventInfo) == 0x000004, "Wrong alignment on UFortKeepEventInfo");
static_assert(sizeof(UFortKeepEventInfo) == 0x000034, "Wrong size on UFortKeepEventInfo");
static_assert(offsetof(UFortKeepEventInfo, EventDescription) == 0x00001C, "Member 'UFortKeepEventInfo::EventDescription' has a wrong offset!");
static_assert(offsetof(UFortKeepEventInfo, Waves) == 0x000028, "Member 'UFortKeepEventInfo::Waves' has a wrong offset!");

// Class FortniteGame.FortVisibilityComponent
// 0x0014 (0x00A0 - 0x008C)
class UFortVisibilityComponent : public UActorComponent
{
public:
	uint8                                         bRegisterWithVisibilityManager : 1;                // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bObserver : 1;                                     // 0x008C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortVisibilityBehavior                       VisibilityBehavior;                                // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCheckFacing : 1;                                  // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCheckLOS : 1;                                     // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVisibilityComponent">();
	}
	static class UFortVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortVisibilityComponent>();
	}
};
static_assert(alignof(UFortVisibilityComponent) == 0x000004, "Wrong alignment on UFortVisibilityComponent");
static_assert(sizeof(UFortVisibilityComponent) == 0x0000A0, "Wrong size on UFortVisibilityComponent");
static_assert(offsetof(UFortVisibilityComponent, VisibilityBehavior) == 0x000090, "Member 'UFortVisibilityComponent::VisibilityBehavior' has a wrong offset!");
static_assert(offsetof(UFortVisibilityComponent, Radius) == 0x000094, "Member 'UFortVisibilityComponent::Radius' has a wrong offset!");

// Class FortniteGame.FortKeepEventList
// 0x000C (0x0028 - 0x001C)
class UFortKeepEventList final : public UDataAsset
{
public:
	TArray<struct FKeepEventInfo>                 Events;                                            // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FKeepEventInfo GetEvent(int32 Idx);
	class FText GetEventDescription(int32 Idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepEventList">();
	}
	static class UFortKeepEventList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepEventList>();
	}
};
static_assert(alignof(UFortKeepEventList) == 0x000004, "Wrong alignment on UFortKeepEventList");
static_assert(sizeof(UFortKeepEventList) == 0x000028, "Wrong size on UFortKeepEventList");
static_assert(offsetof(UFortKeepEventList, Events) == 0x00001C, "Member 'UFortKeepEventList::Events' has a wrong offset!");

// Class FortniteGame.FortKeepDefenseManager
// 0x008C (0x02CC - 0x0240)
class AFortKeepDefenseManager final : public AActor
{
public:
	UMulticastDelegateProperty_                   OnEventStarted;                                    // 0x0240(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWarmupEnded;                                     // 0x024C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterTimeout;                                // 0x0258(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEventEnded;                                      // 0x0264(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEventStopped;                                    // 0x0270(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllEnemiesKilled;                                // 0x027C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterStarted;                                // 0x0288(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterEnded;                                  // 0x0294(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDefenseStateChanged;                             // 0x02A0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x8];                                      // 0x02AC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAIEncounterInfo*                   ActiveAIEncounter;                                 // 0x02B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortAISpawnGroupProgressionInfo*       ActiveAISpawnGroup;                                // 0x02B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0x10];                                     // 0x02BC(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetEventDescriptionFromTheList(class UFortKeepEventList* EventList, int32 EventNumber);
	int32 GetNumberAliveEnemies();
	class FText GetWaveDescription();
	void GoToNextWave();
	void SkipWarmup();
	class UFortAIEncounterInfo* StartAIEncounter(TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, class UFortAISpawnGroupProgressionInfo* SpawnGroupProgressionInfo, int32 ActivationDelay, int32 EncounterDifficultyLevel, float AliveMultiplier);
	void StartEvent(class UFortKeepEventInfo* EventTemplate, int32 DifficultyLevelOffset);
	void StartEventFromList(class UFortKeepEventList* EventList, int32 EventNumber);
	void StopEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepDefenseManager">();
	}
	static class AFortKeepDefenseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortKeepDefenseManager>();
	}
};
static_assert(alignof(AFortKeepDefenseManager) == 0x000004, "Wrong alignment on AFortKeepDefenseManager");
static_assert(sizeof(AFortKeepDefenseManager) == 0x0002CC, "Wrong size on AFortKeepDefenseManager");
static_assert(offsetof(AFortKeepDefenseManager, OnEventStarted) == 0x000240, "Member 'AFortKeepDefenseManager::OnEventStarted' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnWarmupEnded) == 0x00024C, "Member 'AFortKeepDefenseManager::OnWarmupEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterTimeout) == 0x000258, "Member 'AFortKeepDefenseManager::OnEncounterTimeout' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEventEnded) == 0x000264, "Member 'AFortKeepDefenseManager::OnEventEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEventStopped) == 0x000270, "Member 'AFortKeepDefenseManager::OnEventStopped' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnAllEnemiesKilled) == 0x00027C, "Member 'AFortKeepDefenseManager::OnAllEnemiesKilled' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterStarted) == 0x000288, "Member 'AFortKeepDefenseManager::OnEncounterStarted' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnEncounterEnded) == 0x000294, "Member 'AFortKeepDefenseManager::OnEncounterEnded' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, OnDefenseStateChanged) == 0x0002A0, "Member 'AFortKeepDefenseManager::OnDefenseStateChanged' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, ActiveAIEncounter) == 0x0002B4, "Member 'AFortKeepDefenseManager::ActiveAIEncounter' has a wrong offset!");
static_assert(offsetof(AFortKeepDefenseManager, ActiveAISpawnGroup) == 0x0002B8, "Member 'AFortKeepDefenseManager::ActiveAISpawnGroup' has a wrong offset!");

// Class FortniteGame.MyTownBuildingActor
// 0x0098 (0x02D8 - 0x0240)
class AMyTownBuildingActor : public AActor
{
public:
	class UStaticMeshComponent*                   BuildingMeshComponent;                             // 0x0240(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       CollisionComponent;                                // 0x0244(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       TooltipComponent;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       CollectComponent;                                  // 0x024C(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnMyTownBuildingPanelOpened;                       // 0x0250(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingPanelClosed;                       // 0x025C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingWorkersChanged;                    // 0x0268(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingUpgradeStarted;                    // 0x0274(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingUpgradeFinished;                   // 0x0280(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingStateChanged;                      // 0x028C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     UnbuiltMaterial;                                   // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ZoomScreenPosition;                                // 0x029C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ZoomDistance;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildingTemplateId;                                // 0x02A8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortPersistentResources                      ProducedResourceType;                              // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ParentBuildingTemplateId;                          // 0x02B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSubBuilding;                                    // 0x02C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C5[0x7];                                      // 0x02C5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	EMyTownBuildingActorDisplayState              PreferredDispayState;                              // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD[0xB];                                      // 0x02CD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPreferredDisplayState();
	bool CreateUMGCollectWidget(class UNativeWidgetHost* InNativeWidgetHost);
	void OnBuildingClicked();
	void OnMouseOverBegin();
	void OnMouseOverEnd();
	void OnMyTownBuildingCustomDisplayChanged(EMyTownBuildingActorDisplayState NewDisplayState);
	void SetBuildingTemplateId(const class FString& InBuildingTemplateId);
	void SetCustomDisplayState(EMyTownBuildingActorDisplayState NewDisplayState);
	bool ShouldShowBang();

	TArray<class ABuildingActor*> GetCustomDisplayActors() const;
	EMyTownBuildingActorDisplayState GetCustomDisplayState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownBuildingActor">();
	}
	static class AMyTownBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyTownBuildingActor>();
	}
};
static_assert(alignof(AMyTownBuildingActor) == 0x000004, "Wrong alignment on AMyTownBuildingActor");
static_assert(sizeof(AMyTownBuildingActor) == 0x0002D8, "Wrong size on AMyTownBuildingActor");
static_assert(offsetof(AMyTownBuildingActor, BuildingMeshComponent) == 0x000240, "Member 'AMyTownBuildingActor::BuildingMeshComponent' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, CollisionComponent) == 0x000244, "Member 'AMyTownBuildingActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, TooltipComponent) == 0x000248, "Member 'AMyTownBuildingActor::TooltipComponent' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, CollectComponent) == 0x00024C, "Member 'AMyTownBuildingActor::CollectComponent' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingPanelOpened) == 0x000250, "Member 'AMyTownBuildingActor::OnMyTownBuildingPanelOpened' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingPanelClosed) == 0x00025C, "Member 'AMyTownBuildingActor::OnMyTownBuildingPanelClosed' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingWorkersChanged) == 0x000268, "Member 'AMyTownBuildingActor::OnMyTownBuildingWorkersChanged' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingUpgradeStarted) == 0x000274, "Member 'AMyTownBuildingActor::OnMyTownBuildingUpgradeStarted' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingUpgradeFinished) == 0x000280, "Member 'AMyTownBuildingActor::OnMyTownBuildingUpgradeFinished' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, OnMyTownBuildingStateChanged) == 0x00028C, "Member 'AMyTownBuildingActor::OnMyTownBuildingStateChanged' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, UnbuiltMaterial) == 0x000298, "Member 'AMyTownBuildingActor::UnbuiltMaterial' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, ZoomScreenPosition) == 0x00029C, "Member 'AMyTownBuildingActor::ZoomScreenPosition' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, ZoomDistance) == 0x0002A4, "Member 'AMyTownBuildingActor::ZoomDistance' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, BuildingTemplateId) == 0x0002A8, "Member 'AMyTownBuildingActor::BuildingTemplateId' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, ProducedResourceType) == 0x0002B4, "Member 'AMyTownBuildingActor::ProducedResourceType' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, ParentBuildingTemplateId) == 0x0002B8, "Member 'AMyTownBuildingActor::ParentBuildingTemplateId' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, bIsSubBuilding) == 0x0002C4, "Member 'AMyTownBuildingActor::bIsSubBuilding' has a wrong offset!");
static_assert(offsetof(AMyTownBuildingActor, PreferredDispayState) == 0x0002CC, "Member 'AMyTownBuildingActor::PreferredDispayState' has a wrong offset!");

// Class FortniteGame.FortGameStateZone
// 0x00E8 (0x04B8 - 0x03D0)
class AFortGameStateZone : public AFortGameState
{
public:
	int32                                         PawnIDCount;                                       // 0x03D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaitingToLeaveZoneTimeLeft;                        // 0x03D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityMeterPercent;                             // 0x03D8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensityPercent;                                  // 0x03DC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsCap;                                    // 0x03E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsAllocated;                              // 0x03E4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalAI;                                        // 0x03E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterAI;                                    // 0x03EC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEncounterSP;                                    // 0x03F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x1C];                                     // 0x03F4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalPlayerStructures;                             // 0x0410(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxPlayerStructures;                               // 0x0414(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFortAbilitySystemComponent*>    GlobalGameplayEventListeners;                      // 0x0418(0x000C)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBuildingStructuralSupportSystem*       StructuralSupportSystem;                           // 0x0424(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ZoneDifficultyInfoRow;                             // 0x0428(0x000C)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bZoneDifficultyInfoRowManuallySet;                 // 0x0434(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortZoneTheme*                         ZoneTheme;                                         // 0x0438(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortThreatVisualsManager*              ThreatVisualsManager;                              // 0x043C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortThreatParticleActor*               ThreatParticleActor;                               // 0x0440(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawRunVariationDebug;                            // 0x0444(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortAIPawn*>                    PawnVariationList;                                 // 0x0448(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         VariationIndex;                                    // 0x0454(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GameDifficulty;                                    // 0x0458(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x10];                                     // 0x045C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerBuildableClassContainer         PlayerBuildableClasses[0x4];                       // 0x046C(0x000C)(Transient, Protected, NativeAccessSpecifierProtected)
	class AFortInGameMapManager*                  UIMapManager;                                      // 0x049C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScoringTableRowName;                               // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   TheaterName;                                       // 0x04A8(0x000C)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         TheaterSlot;                                       // 0x04B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AFortInGameMapManager* GetUIMapManager();
	void OnRep_PlayerStructuresChanged();
	void OnRep_TheaterNameUpdated();
	void OnRep_UIMapManager();
	void ServerFireAIDirectorEvent(EFortAIDirectorEvent Event, class UObject* EventSource, class UObject* EventTarget, float EventMultiplier);

	float GetGameDifficulty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateZone">();
	}
	static class AFortGameStateZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateZone>();
	}
};
static_assert(alignof(AFortGameStateZone) == 0x000004, "Wrong alignment on AFortGameStateZone");
static_assert(sizeof(AFortGameStateZone) == 0x0004B8, "Wrong size on AFortGameStateZone");
static_assert(offsetof(AFortGameStateZone, PawnIDCount) == 0x0003D0, "Member 'AFortGameStateZone::PawnIDCount' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, WaitingToLeaveZoneTimeLeft) == 0x0003D4, "Member 'AFortGameStateZone::WaitingToLeaveZoneTimeLeft' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, HostilityMeterPercent) == 0x0003D8, "Member 'AFortGameStateZone::HostilityMeterPercent' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, IntensityPercent) == 0x0003DC, "Member 'AFortGameStateZone::IntensityPercent' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, SpawnPointsCap) == 0x0003E0, "Member 'AFortGameStateZone::SpawnPointsCap' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, SpawnPointsAllocated) == 0x0003E4, "Member 'AFortGameStateZone::SpawnPointsAllocated' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxTotalAI) == 0x0003E8, "Member 'AFortGameStateZone::MaxTotalAI' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxEncounterAI) == 0x0003EC, "Member 'AFortGameStateZone::MaxEncounterAI' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxEncounterSP) == 0x0003F0, "Member 'AFortGameStateZone::MaxEncounterSP' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TotalPlayerStructures) == 0x000410, "Member 'AFortGameStateZone::TotalPlayerStructures' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, MaxPlayerStructures) == 0x000414, "Member 'AFortGameStateZone::MaxPlayerStructures' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GlobalGameplayEventListeners) == 0x000418, "Member 'AFortGameStateZone::GlobalGameplayEventListeners' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, StructuralSupportSystem) == 0x000424, "Member 'AFortGameStateZone::StructuralSupportSystem' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ZoneDifficultyInfoRow) == 0x000428, "Member 'AFortGameStateZone::ZoneDifficultyInfoRow' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bZoneDifficultyInfoRowManuallySet) == 0x000434, "Member 'AFortGameStateZone::bZoneDifficultyInfoRowManuallySet' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ZoneTheme) == 0x000438, "Member 'AFortGameStateZone::ZoneTheme' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ThreatVisualsManager) == 0x00043C, "Member 'AFortGameStateZone::ThreatVisualsManager' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ThreatParticleActor) == 0x000440, "Member 'AFortGameStateZone::ThreatParticleActor' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, bDrawRunVariationDebug) == 0x000444, "Member 'AFortGameStateZone::bDrawRunVariationDebug' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PawnVariationList) == 0x000448, "Member 'AFortGameStateZone::PawnVariationList' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, VariationIndex) == 0x000454, "Member 'AFortGameStateZone::VariationIndex' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, GameDifficulty) == 0x000458, "Member 'AFortGameStateZone::GameDifficulty' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, PlayerBuildableClasses) == 0x00046C, "Member 'AFortGameStateZone::PlayerBuildableClasses' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, UIMapManager) == 0x00049C, "Member 'AFortGameStateZone::UIMapManager' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, ScoringTableRowName) == 0x0004A0, "Member 'AFortGameStateZone::ScoringTableRowName' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TheaterName) == 0x0004A8, "Member 'AFortGameStateZone::TheaterName' has a wrong offset!");
static_assert(offsetof(AFortGameStateZone, TheaterSlot) == 0x0004B4, "Member 'AFortGameStateZone::TheaterSlot' has a wrong offset!");

// Class FortniteGame.FortGameStateOutpost
// 0x0004 (0x04BC - 0x04B8)
class AFortGameStateOutpost final : public AFortGameStateZone
{
public:
	bool                                          bOutpostDefenseActive;                             // 0x04B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateOutpost">();
	}
	static class AFortGameStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateOutpost>();
	}
};
static_assert(alignof(AFortGameStateOutpost) == 0x000004, "Wrong alignment on AFortGameStateOutpost");
static_assert(sizeof(AFortGameStateOutpost) == 0x0004BC, "Wrong size on AFortGameStateOutpost");
static_assert(offsetof(AFortGameStateOutpost, bOutpostDefenseActive) == 0x0004B8, "Member 'AFortGameStateOutpost::bOutpostDefenseActive' has a wrong offset!");

// Class FortniteGame.FortZoneRecord
// 0x00F0 (0x0128 - 0x0038)
class UFortZoneRecord final : public UFortGenericRecord
{
public:
	int32                                         WorldSaveCount;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WUID;                                              // 0x003C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneIndex;                                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentLevelName;                               // 0x004C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortLevelRecord>               SavedLevels;                                       // 0x0054(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSavedLevels;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneTileSeed;                                      // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortZoneStats                         Stats;                                             // 0x0068(0x00B4)(NativeAccessSpecifierPublic)
	TArray<struct FStatManagerPeriodRecord>       PlayerMapStatManagerPeriods;                       // 0x011C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortZoneRecord">();
	}
	static class UFortZoneRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortZoneRecord>();
	}
};
static_assert(alignof(UFortZoneRecord) == 0x000004, "Wrong alignment on UFortZoneRecord");
static_assert(sizeof(UFortZoneRecord) == 0x000128, "Wrong size on UFortZoneRecord");
static_assert(offsetof(UFortZoneRecord, WorldSaveCount) == 0x000038, "Member 'UFortZoneRecord::WorldSaveCount' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, WUID) == 0x00003C, "Member 'UFortZoneRecord::WUID' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, ZoneIndex) == 0x000048, "Member 'UFortZoneRecord::ZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, PersistentLevelName) == 0x00004C, "Member 'UFortZoneRecord::PersistentLevelName' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, SavedLevels) == 0x000054, "Member 'UFortZoneRecord::SavedLevels' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, NumSavedLevels) == 0x000060, "Member 'UFortZoneRecord::NumSavedLevels' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, ZoneTileSeed) == 0x000064, "Member 'UFortZoneRecord::ZoneTileSeed' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, Stats) == 0x000068, "Member 'UFortZoneRecord::Stats' has a wrong offset!");
static_assert(offsetof(UFortZoneRecord, PlayerMapStatManagerPeriods) == 0x00011C, "Member 'UFortZoneRecord::PlayerMapStatManagerPeriods' has a wrong offset!");

// Class FortniteGame.KeepHeart
// 0x0020 (0x0990 - 0x0970)
class AKeepHeart final : public AKeepHeartBase
{
public:
	class AActor*                                 DecorationRoomPlacement;                           // 0x0970(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            PermaniteHealEffect;                               // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteWallWeight;                               // 0x0978(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteFloorWeight;                              // 0x097C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteStairWeight;                              // 0x0980(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PermaniteRoofWeight;                               // 0x0984(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeepDefenseState                             DefenseState;                                      // 0x0988(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_989[0x7];                                      // 0x0989(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayedVoteSuccess();
	bool DestroyNonPermaniteStructures();
	float GetAveragePermaniteLevel();
	int32 GetPermaniteStructureLimit();
	int32 GetPermaniteStructureNumber();
	int32 GetUpgradeAllPermaniteCost(class AFortPlayerController* FortPC, bool bQuickUpgrade);
	float GetWorldStreamingInProgress();
	void HandleVoteComplete(bool bResult);
	bool IsWorldStreamedIn();
	bool IsWorldStreamingIn();
	void NotifyEncounterEnded(class UFortAIEncounterInfo* EndedEncounter);
	void NotifyEncounterStarted(class UFortAIEncounterInfo* StartedEncounter);
	void OnDefenseLevelChanged();
	void OnVoteComplete(bool bResult);
	void OnWorldStreamedIn();
	void ResetContainers();
	void RestoreContainers();
	void RestoreKeepHealth();
	void SetPermaniteAvailability(bool bAvailable);
	void StartVote(const class FText& VoteText, const class FText& YesText, const class FText& NoText, float PercentageToPass, bool bSkipIfOnePlayerOnly);
	void StreamInWorld();
	void StreamOutWorld();
	bool UpgradeAllPermaniteStructures(class AFortPlayerController* FortPC, bool bQuickUpgrade);

	int32 GetDefenseLevel() const;
	bool IsDefenseActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepHeart">();
	}
	static class AKeepHeart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKeepHeart>();
	}
};
static_assert(alignof(AKeepHeart) == 0x000004, "Wrong alignment on AKeepHeart");
static_assert(sizeof(AKeepHeart) == 0x000990, "Wrong size on AKeepHeart");
static_assert(offsetof(AKeepHeart, DecorationRoomPlacement) == 0x000970, "Member 'AKeepHeart::DecorationRoomPlacement' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteHealEffect) == 0x000974, "Member 'AKeepHeart::PermaniteHealEffect' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteWallWeight) == 0x000978, "Member 'AKeepHeart::PermaniteWallWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteFloorWeight) == 0x00097C, "Member 'AKeepHeart::PermaniteFloorWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteStairWeight) == 0x000980, "Member 'AKeepHeart::PermaniteStairWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, PermaniteRoofWeight) == 0x000984, "Member 'AKeepHeart::PermaniteRoofWeight' has a wrong offset!");
static_assert(offsetof(AKeepHeart, DefenseState) == 0x000988, "Member 'AKeepHeart::DefenseState' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CanActivate
// 0x0000 (0x009C - 0x009C)
class UFortBTDecorator_GameplayAbility_CanActivate final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanActivate">();
	}
	static class UFortBTDecorator_GameplayAbility_CanActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanActivate>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanActivate");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanActivate) == 0x00009C, "Wrong size on UFortBTDecorator_GameplayAbility_CanActivate");

// Class FortniteGame.HeartbeatManager
// 0x000C (0x0028 - 0x001C)
class UHeartbeatManager final : public UObject
{
public:
	uint8                                         Pad_1C[0xC];                                       // 0x001C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeartbeatManager">();
	}
	static class UHeartbeatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeartbeatManager>();
	}
};
static_assert(alignof(UHeartbeatManager) == 0x000004, "Wrong alignment on UHeartbeatManager");
static_assert(sizeof(UHeartbeatManager) == 0x000028, "Wrong size on UHeartbeatManager");

// Class FortniteGame.ManorHeart
// 0x0018 (0x0988 - 0x0970)
class AManorHeart final : public AKeepHeartBase
{
public:
	class AActor*                                 KeepIconActor;                                     // 0x0970(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ContainerNamesToDestroy;                           // 0x0974(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            InfiniteStaminaEffect;                             // 0x0980(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_984[0x4];                                      // 0x0984(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TravelToNewWorld(class UFortTheaterInfo* NewTheater);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManorHeart">();
	}
	static class AManorHeart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AManorHeart>();
	}
};
static_assert(alignof(AManorHeart) == 0x000004, "Wrong alignment on AManorHeart");
static_assert(sizeof(AManorHeart) == 0x000988, "Wrong size on AManorHeart");
static_assert(offsetof(AManorHeart, KeepIconActor) == 0x000970, "Member 'AManorHeart::KeepIconActor' has a wrong offset!");
static_assert(offsetof(AManorHeart, ContainerNamesToDestroy) == 0x000974, "Member 'AManorHeart::ContainerNamesToDestroy' has a wrong offset!");
static_assert(offsetof(AManorHeart, InfiniteStaminaEffect) == 0x000980, "Member 'AManorHeart::InfiniteStaminaEffect' has a wrong offset!");

// Class FortniteGame.FortHealthBarComponent
// 0x0024 (0x01D0 - 0x01AC)
class UFortHealthBarComponent final : public USceneComponent
{
public:
	class ABuildingActor*                         BuildingActorOwner;                                // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayText;                                       // 0x01B0(0x000C)(Edit, Net, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsHealthBarVisible;                               // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bClampToScreen;                                    // 0x01BD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      HealthBarColorCurve;                               // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0xC];                                      // 0x01C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DisplayText();
	void OnRep_IsVisible();
	void SetHealthBarDisplayText(const class FText& NewDisplayText);
	void SetHealthBarVisibility(bool bNewVisibleState);
	void SetHealthBarWidgetVisibility(bool bIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthBarComponent">();
	}
	static class UFortHealthBarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthBarComponent>();
	}
};
static_assert(alignof(UFortHealthBarComponent) == 0x000004, "Wrong alignment on UFortHealthBarComponent");
static_assert(sizeof(UFortHealthBarComponent) == 0x0001D0, "Wrong size on UFortHealthBarComponent");
static_assert(offsetof(UFortHealthBarComponent, BuildingActorOwner) == 0x0001AC, "Member 'UFortHealthBarComponent::BuildingActorOwner' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, DisplayText) == 0x0001B0, "Member 'UFortHealthBarComponent::DisplayText' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, bIsHealthBarVisible) == 0x0001BC, "Member 'UFortHealthBarComponent::bIsHealthBarVisible' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, bClampToScreen) == 0x0001BD, "Member 'UFortHealthBarComponent::bClampToScreen' has a wrong offset!");
static_assert(offsetof(UFortHealthBarComponent, HealthBarColorCurve) == 0x0001C0, "Member 'UFortHealthBarComponent::HealthBarColorCurve' has a wrong offset!");

// Class FortniteGame.FortDynamicBuilder
// 0x0044 (0x045C - 0x0418)
class AFortDynamicBuilder : public ABuildingActor
{
public:
	class UFortBuildingInstructions*              BuildingInstructions;                              // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectiveDestruction;                             // 0x041C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNoCollisionFail;                                  // 0x041D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMissionActors;                              // 0x041E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShrinkAndDestroyEffect;                           // 0x041F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawBounds;                                  // 0x0420(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUsePlayerBuildAnimations;                         // 0x0421(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_422[0x2];                                      // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildingConstructionTime;                          // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFDynamicBuildOrder                           BuildOrder;                                        // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseBuild;                                     // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x1E];                                     // 0x042A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIndex;                                      // 0x0448(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x10];                                     // 0x044C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDynamicBuilder">();
	}
	static class AFortDynamicBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDynamicBuilder>();
	}
};
static_assert(alignof(AFortDynamicBuilder) == 0x000004, "Wrong alignment on AFortDynamicBuilder");
static_assert(sizeof(AFortDynamicBuilder) == 0x00045C, "Wrong size on AFortDynamicBuilder");
static_assert(offsetof(AFortDynamicBuilder, BuildingInstructions) == 0x000418, "Member 'AFortDynamicBuilder::BuildingInstructions' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bSelectiveDestruction) == 0x00041C, "Member 'AFortDynamicBuilder::bSelectiveDestruction' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bNoCollisionFail) == 0x00041D, "Member 'AFortDynamicBuilder::bNoCollisionFail' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bIgnoreMissionActors) == 0x00041E, "Member 'AFortDynamicBuilder::bIgnoreMissionActors' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bShrinkAndDestroyEffect) == 0x00041F, "Member 'AFortDynamicBuilder::bShrinkAndDestroyEffect' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bDebugDrawBounds) == 0x000420, "Member 'AFortDynamicBuilder::bDebugDrawBounds' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bUsePlayerBuildAnimations) == 0x000421, "Member 'AFortDynamicBuilder::bUsePlayerBuildAnimations' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, BuildingConstructionTime) == 0x000424, "Member 'AFortDynamicBuilder::BuildingConstructionTime' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, BuildOrder) == 0x000428, "Member 'AFortDynamicBuilder::BuildOrder' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, bReverseBuild) == 0x000429, "Member 'AFortDynamicBuilder::bReverseBuild' has a wrong offset!");
static_assert(offsetof(AFortDynamicBuilder, CurrentIndex) == 0x000448, "Member 'AFortDynamicBuilder::CurrentIndex' has a wrong offset!");

// Class FortniteGame.FortBTService_ContextOverride
// 0x0000 (0x004C - 0x004C)
class UFortBTService_ContextOverride : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTService_ContextOverride">();
	}
	static class UFortBTService_ContextOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTService_ContextOverride>();
	}
};
static_assert(alignof(UFortBTService_ContextOverride) == 0x000004, "Wrong alignment on UFortBTService_ContextOverride");
static_assert(sizeof(UFortBTService_ContextOverride) == 0x00004C, "Wrong size on UFortBTService_ContextOverride");

// Class FortniteGame.FortBTContext_SuppressGoalUpdate
// 0x0004 (0x0050 - 0x004C)
class UFortBTContext_SuppressGoalUpdate final : public UFortBTService_ContextOverride
{
public:
	bool                                          bUnregisterFromGoalManager;                        // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_SuppressGoalUpdate">();
	}
	static class UFortBTContext_SuppressGoalUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_SuppressGoalUpdate>();
	}
};
static_assert(alignof(UFortBTContext_SuppressGoalUpdate) == 0x000004, "Wrong alignment on UFortBTContext_SuppressGoalUpdate");
static_assert(sizeof(UFortBTContext_SuppressGoalUpdate) == 0x000050, "Wrong size on UFortBTContext_SuppressGoalUpdate");
static_assert(offsetof(UFortBTContext_SuppressGoalUpdate, bUnregisterFromGoalManager) == 0x00004C, "Member 'UFortBTContext_SuppressGoalUpdate::bUnregisterFromGoalManager' has a wrong offset!");

// Class FortniteGame.VelocityGridData
// 0x0054 (0x0070 - 0x001C)
class UVelocityGridData final : public UObject
{
public:
	class UFortSpline*                            Spline;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      PointEnvelopeCurve;                                // 0x002C(0x0014)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      PointStrengthCurve;                                // 0x0040(0x0014)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      MiscCurve;                                         // 0x0054(0x0014)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MiscFloat;                                         // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugSpline;                                  // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDebugBool;                                        // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPoint(const struct FVector& SplinePoint, float PointEnvelope, float PointStrength);
	void RebuildData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelocityGridData">();
	}
	static class UVelocityGridData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelocityGridData>();
	}
};
static_assert(alignof(UVelocityGridData) == 0x000004, "Wrong alignment on UVelocityGridData");
static_assert(sizeof(UVelocityGridData) == 0x000070, "Wrong size on UVelocityGridData");
static_assert(offsetof(UVelocityGridData, Spline) == 0x00001C, "Member 'UVelocityGridData::Spline' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, Points) == 0x000020, "Member 'UVelocityGridData::Points' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, PointEnvelopeCurve) == 0x00002C, "Member 'UVelocityGridData::PointEnvelopeCurve' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, PointStrengthCurve) == 0x000040, "Member 'UVelocityGridData::PointStrengthCurve' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, MiscCurve) == 0x000054, "Member 'UVelocityGridData::MiscCurve' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, MiscFloat) == 0x000068, "Member 'UVelocityGridData::MiscFloat' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, bDrawDebugSpline) == 0x00006C, "Member 'UVelocityGridData::bDrawDebugSpline' has a wrong offset!");
static_assert(offsetof(UVelocityGridData, bDebugBool) == 0x00006D, "Member 'UVelocityGridData::bDebugBool' has a wrong offset!");

// Class FortniteGame.FortGameUserSettings
// 0x005C (0x00C8 - 0x006C)
class UFortGameUserSettings final : public UGameUserSettings
{
public:
	float                                         MouseSensitivity;                                  // 0x006C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicVolume;                                       // 0x0070(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundFXVolume;                                     // 0x0074(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DialogVolume;                                      // 0x0078(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChatVolume;                                        // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FortVersion;                                       // 0x0080(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x1C];                                      // 0x0084(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RememberMeCheckbox;                                // 0x00A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RememberMeToken;                                   // 0x00A4(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastLoginEmail;                                    // 0x00B0(0x000C)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlur;                                       // 0x00BC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShowFPS;                                          // 0x00BD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialBenchmarkState;                             // 0x00C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMouseAcceleration;                         // 0x00C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseMetal;                                         // 0x00C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameUserSettings">();
	}
	static class UFortGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameUserSettings>();
	}
};
static_assert(alignof(UFortGameUserSettings) == 0x000004, "Wrong alignment on UFortGameUserSettings");
static_assert(sizeof(UFortGameUserSettings) == 0x0000C8, "Wrong size on UFortGameUserSettings");
static_assert(offsetof(UFortGameUserSettings, MouseSensitivity) == 0x00006C, "Member 'UFortGameUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, MusicVolume) == 0x000070, "Member 'UFortGameUserSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, SoundFXVolume) == 0x000074, "Member 'UFortGameUserSettings::SoundFXVolume' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, DialogVolume) == 0x000078, "Member 'UFortGameUserSettings::DialogVolume' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, ChatVolume) == 0x00007C, "Member 'UFortGameUserSettings::ChatVolume' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, FortVersion) == 0x000080, "Member 'UFortGameUserSettings::FortVersion' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, RememberMeCheckbox) == 0x0000A0, "Member 'UFortGameUserSettings::RememberMeCheckbox' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, RememberMeToken) == 0x0000A4, "Member 'UFortGameUserSettings::RememberMeToken' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, LastLoginEmail) == 0x0000B0, "Member 'UFortGameUserSettings::LastLoginEmail' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bMotionBlur) == 0x0000BC, "Member 'UFortGameUserSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bShowFPS) == 0x0000BD, "Member 'UFortGameUserSettings::bShowFPS' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, InitialBenchmarkState) == 0x0000C0, "Member 'UFortGameUserSettings::InitialBenchmarkState' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bDisableMouseAcceleration) == 0x0000C4, "Member 'UFortGameUserSettings::bDisableMouseAcceleration' has a wrong offset!");
static_assert(offsetof(UFortGameUserSettings, bUseMetal) == 0x0000C5, "Member 'UFortGameUserSettings::bUseMetal' has a wrong offset!");

// Class FortniteGame.FortClientDynamicBuilder
// 0x0000 (0x045C - 0x045C)
class AFortClientDynamicBuilder final : public AFortDynamicBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientDynamicBuilder">();
	}
	static class AFortClientDynamicBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortClientDynamicBuilder>();
	}
};
static_assert(alignof(AFortClientDynamicBuilder) == 0x000004, "Wrong alignment on AFortClientDynamicBuilder");
static_assert(sizeof(AFortClientDynamicBuilder) == 0x00045C, "Wrong size on AFortClientDynamicBuilder");

// Class FortniteGame.FortEnemySpawn
// 0x0008 (0x0420 - 0x0418)
class AFortEnemySpawn final : public ABuildingActor
{
public:
	int32                                         OccupyCount;                                       // 0x0418(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClusterRadius;                                     // 0x041C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEnemySpawn">();
	}
	static class AFortEnemySpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEnemySpawn>();
	}
};
static_assert(alignof(AFortEnemySpawn) == 0x000004, "Wrong alignment on AFortEnemySpawn");
static_assert(sizeof(AFortEnemySpawn) == 0x000420, "Wrong size on AFortEnemySpawn");
static_assert(offsetof(AFortEnemySpawn, OccupyCount) == 0x000418, "Member 'AFortEnemySpawn::OccupyCount' has a wrong offset!");
static_assert(offsetof(AFortEnemySpawn, ClusterRadius) == 0x00041C, "Member 'AFortEnemySpawn::ClusterRadius' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsOnCooldown
// 0x0000 (0x009C - 0x009C)
class UFortBTDecorator_GameplayAbility_IsOnCooldown final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsOnCooldown">();
	}
	static class UFortBTDecorator_GameplayAbility_IsOnCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsOnCooldown>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsOnCooldown");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsOnCooldown) == 0x00009C, "Wrong size on UFortBTDecorator_GameplayAbility_IsOnCooldown");

// Class FortniteGame.FortWeap_BuildingToolBase
// 0x0018 (0x060C - 0x05F4)
class AFortWeap_BuildingToolBase : public AFortWeapon
{
public:
	class UStaticMeshComponent*                   PencilMeshComponent;                               // 0x05F4(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BlueprintPaperSocket;                              // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BlueprintPencilSocket;                             // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerController*                  InstigatorController;                              // 0x0608(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_BuildingToolBase">();
	}
	static class AFortWeap_BuildingToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_BuildingToolBase>();
	}
};
static_assert(alignof(AFortWeap_BuildingToolBase) == 0x000004, "Wrong alignment on AFortWeap_BuildingToolBase");
static_assert(sizeof(AFortWeap_BuildingToolBase) == 0x00060C, "Wrong size on AFortWeap_BuildingToolBase");
static_assert(offsetof(AFortWeap_BuildingToolBase, PencilMeshComponent) == 0x0005F4, "Member 'AFortWeap_BuildingToolBase::PencilMeshComponent' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, BlueprintPaperSocket) == 0x0005F8, "Member 'AFortWeap_BuildingToolBase::BlueprintPaperSocket' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, BlueprintPencilSocket) == 0x000600, "Member 'AFortWeap_BuildingToolBase::BlueprintPencilSocket' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingToolBase, InstigatorController) == 0x000608, "Member 'AFortWeap_BuildingToolBase::InstigatorController' has a wrong offset!");

// Class FortniteGame.FortGameplayTagVolumeInterface
// 0x0000 (0x001C - 0x001C)
class IFortGameplayTagVolumeInterface final : public IInterface
{
public:
	void ApplyTags();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagVolumeInterface">();
	}
	static class IFortGameplayTagVolumeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortGameplayTagVolumeInterface>();
	}
};
static_assert(alignof(IFortGameplayTagVolumeInterface) == 0x000004, "Wrong alignment on IFortGameplayTagVolumeInterface");
static_assert(sizeof(IFortGameplayTagVolumeInterface) == 0x00001C, "Wrong size on IFortGameplayTagVolumeInterface");

// Class FortniteGame.FortGameStateManor
// 0x004C (0x0504 - 0x04B8)
class AFortGameStateManor final : public AFortGameStateZone
{
public:
	uint8                                         Pad_4B8[0x4C];                                     // 0x04B8(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateManor">();
	}
	static class AFortGameStateManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateManor>();
	}
};
static_assert(alignof(AFortGameStateManor) == 0x000004, "Wrong alignment on AFortGameStateManor");
static_assert(sizeof(AFortGameStateManor) == 0x000504, "Wrong size on AFortGameStateManor");

// Class FortniteGame.FortGameplayTagBuildingActor
// 0x0030 (0x0448 - 0x0418)
class AFortGameplayTagBuildingActor final : public ABuildingActor
{
public:
	uint8                                         Pad_418[0x4];                                      // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutomaticallyGenerated;                           // 0x041C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  TagsToApplyOnSave;                                 // 0x0420(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         XGridCells;                                        // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         YGridCells;                                        // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZGridCells;                                        // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComponent;                                      // 0x0444(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayTagBuildingActor">();
	}
	static class AFortGameplayTagBuildingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayTagBuildingActor>();
	}
};
static_assert(alignof(AFortGameplayTagBuildingActor) == 0x000004, "Wrong alignment on AFortGameplayTagBuildingActor");
static_assert(sizeof(AFortGameplayTagBuildingActor) == 0x000448, "Wrong size on AFortGameplayTagBuildingActor");
static_assert(offsetof(AFortGameplayTagBuildingActor, bAutomaticallyGenerated) == 0x00041C, "Member 'AFortGameplayTagBuildingActor::bAutomaticallyGenerated' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, TagsToApplyOnSave) == 0x000420, "Member 'AFortGameplayTagBuildingActor::TagsToApplyOnSave' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, XGridCells) == 0x000438, "Member 'AFortGameplayTagBuildingActor::XGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, YGridCells) == 0x00043C, "Member 'AFortGameplayTagBuildingActor::YGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, ZGridCells) == 0x000440, "Member 'AFortGameplayTagBuildingActor::ZGridCells' has a wrong offset!");
static_assert(offsetof(AFortGameplayTagBuildingActor, BoxComponent) == 0x000444, "Member 'AFortGameplayTagBuildingActor::BoxComponent' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_HasGameplayAbility
// 0x0018 (0x0060 - 0x0048)
class UFortBTDecorator_GameplayAbility_HasGameplayAbility final : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_HasGameplayAbility">();
	}
	static class UFortBTDecorator_GameplayAbility_HasGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_HasGameplayAbility>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_HasGameplayAbility) == 0x000060, "Wrong size on UFortBTDecorator_GameplayAbility_HasGameplayAbility");
static_assert(offsetof(UFortBTDecorator_GameplayAbility_HasGameplayAbility, GameplayAbilityTag) == 0x000048, "Member 'UFortBTDecorator_GameplayAbility_HasGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.WorldMapPinManager
// 0x0014 (0x0254 - 0x0240)
class AWorldMapPinManager : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortStaticMeshActor*                   WorldMapMesh;                                      // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AWorldMapPin*>                   CurrentPins;                                       // 0x0248(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class AWorldMapPin* CreateWorldMapPin(int32 TheaterIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldMapPinManager">();
	}
	static class AWorldMapPinManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldMapPinManager>();
	}
};
static_assert(alignof(AWorldMapPinManager) == 0x000004, "Wrong alignment on AWorldMapPinManager");
static_assert(sizeof(AWorldMapPinManager) == 0x000254, "Wrong size on AWorldMapPinManager");
static_assert(offsetof(AWorldMapPinManager, WorldMapMesh) == 0x000244, "Member 'AWorldMapPinManager::WorldMapMesh' has a wrong offset!");
static_assert(offsetof(AWorldMapPinManager, CurrentPins) == 0x000248, "Member 'AWorldMapPinManager::CurrentPins' has a wrong offset!");

// Class FortniteGame.FortClientSettingsRecord
// 0x0060 (0x0098 - 0x0038)
class UFortClientSettingsRecord final : public UFortGenericRecord
{
public:
	uint8                                         Pad_38[0x1];                                       // 0x0038(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EFortInputPreset                              InputPreset;                                       // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortActionKeyMapping>          UserActionBindings;                                // 0x003C(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortActionKeyMapping>          DisabledActionBindings;                            // 0x0048(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bInvertedMouse;                                    // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bToggleSprint;                                     // 0x0055(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoEquipBetterItems;                             // 0x0056(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseFirstPersonCamera;                             // 0x0057(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EPartyType                                    LastPartyType;                                     // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderInvitesOnly;                            // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLastLeaderFriendsOnly;                            // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSaveToCloud : 1;                                  // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCloudIsBusy : 1;                                  // 0x005C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_5D[0x3B];                                      // 0x005D(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientSettingsRecord">();
	}
	static class UFortClientSettingsRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientSettingsRecord>();
	}
};
static_assert(alignof(UFortClientSettingsRecord) == 0x000004, "Wrong alignment on UFortClientSettingsRecord");
static_assert(sizeof(UFortClientSettingsRecord) == 0x000098, "Wrong size on UFortClientSettingsRecord");
static_assert(offsetof(UFortClientSettingsRecord, InputPreset) == 0x000039, "Member 'UFortClientSettingsRecord::InputPreset' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, UserActionBindings) == 0x00003C, "Member 'UFortClientSettingsRecord::UserActionBindings' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, DisabledActionBindings) == 0x000048, "Member 'UFortClientSettingsRecord::DisabledActionBindings' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bInvertedMouse) == 0x000054, "Member 'UFortClientSettingsRecord::bInvertedMouse' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bToggleSprint) == 0x000055, "Member 'UFortClientSettingsRecord::bToggleSprint' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bAutoEquipBetterItems) == 0x000056, "Member 'UFortClientSettingsRecord::bAutoEquipBetterItems' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bUseFirstPersonCamera) == 0x000057, "Member 'UFortClientSettingsRecord::bUseFirstPersonCamera' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, LastPartyType) == 0x000058, "Member 'UFortClientSettingsRecord::LastPartyType' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bLastLeaderInvitesOnly) == 0x000059, "Member 'UFortClientSettingsRecord::bLastLeaderInvitesOnly' has a wrong offset!");
static_assert(offsetof(UFortClientSettingsRecord, bLastLeaderFriendsOnly) == 0x00005A, "Member 'UFortClientSettingsRecord::bLastLeaderFriendsOnly' has a wrong offset!");

// Class FortniteGame.FortPlacementActor
// 0x0008 (0x0420 - 0x0418)
class AFortPlacementActor final : public ABuildingActor
{
public:
	TWeakObjectPtr<class AActor>                  OccupyingActor;                                    // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActor">();
	}
	static class AFortPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlacementActor>();
	}
};
static_assert(alignof(AFortPlacementActor) == 0x000004, "Wrong alignment on AFortPlacementActor");
static_assert(sizeof(AFortPlacementActor) == 0x000420, "Wrong size on AFortPlacementActor");
static_assert(offsetof(AFortPlacementActor, OccupyingActor) == 0x000418, "Member 'AFortPlacementActor::OccupyingActor' has a wrong offset!");

// Class FortniteGame.FortMiniMapPingIndicator
// 0x0068 (0x010C - 0x00A4)
class UFortMiniMapPingIndicator : public UFortMiniMapIndicator
{
public:
	uint8                                         Pad_A4[0x68];                                      // 0x00A4(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapPingIndicator">();
	}
	static class UFortMiniMapPingIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapPingIndicator>();
	}
};
static_assert(alignof(UFortMiniMapPingIndicator) == 0x000004, "Wrong alignment on UFortMiniMapPingIndicator");
static_assert(sizeof(UFortMiniMapPingIndicator) == 0x00010C, "Wrong size on UFortMiniMapPingIndicator");

// Class FortniteGame.FortDamageMiniMapIndicator
// 0x0000 (0x010C - 0x010C)
class UFortDamageMiniMapIndicator final : public UFortMiniMapPingIndicator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageMiniMapIndicator">();
	}
	static class UFortDamageMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageMiniMapIndicator>();
	}
};
static_assert(alignof(UFortDamageMiniMapIndicator) == 0x000004, "Wrong alignment on UFortDamageMiniMapIndicator");
static_assert(sizeof(UFortDamageMiniMapIndicator) == 0x00010C, "Wrong size on UFortDamageMiniMapIndicator");

// Class FortniteGame.BuildingActorEditorComponent
// 0x003C (0x0550 - 0x0514)
class UBuildingActorEditorComponent final : public UStaticMeshComponent
{
public:
	TSoftObjectPtr<class UMaterialInterface>      CurrentlySnappedMaterial;                          // 0x0514(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             CubeMesh;                                          // 0x052C(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CubeMeshDrawScale;                                 // 0x0544(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorEditorComponent">();
	}
	static class UBuildingActorEditorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorEditorComponent>();
	}
};
static_assert(alignof(UBuildingActorEditorComponent) == 0x000004, "Wrong alignment on UBuildingActorEditorComponent");
static_assert(sizeof(UBuildingActorEditorComponent) == 0x000550, "Wrong size on UBuildingActorEditorComponent");
static_assert(offsetof(UBuildingActorEditorComponent, CurrentlySnappedMaterial) == 0x000514, "Member 'UBuildingActorEditorComponent::CurrentlySnappedMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingActorEditorComponent, CubeMesh) == 0x00052C, "Member 'UBuildingActorEditorComponent::CubeMesh' has a wrong offset!");
static_assert(offsetof(UBuildingActorEditorComponent, CubeMeshDrawScale) == 0x000544, "Member 'UBuildingActorEditorComponent::CubeMeshDrawScale' has a wrong offset!");

// Class FortniteGame.FortBTTask_GameMoveTo
// 0x0034 (0x00A4 - 0x0070)
class UFortBTTask_GameMoveTo final : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 FocalPointWhileMoving;                             // 0x0070(0x0020)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDetectUnexpectedPathBlockingObstacles : 1;        // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBumpIntoSleepingReaction                     ActionOnBumpIntoSleeping;                          // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableSlowdownAtGoal : 1;                         // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bFinishMoveOnOverlap : 1;                          // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveTo">();
	}
	static class UFortBTTask_GameMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveTo>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveTo) == 0x000004, "Wrong alignment on UFortBTTask_GameMoveTo");
static_assert(sizeof(UFortBTTask_GameMoveTo) == 0x0000A4, "Wrong size on UFortBTTask_GameMoveTo");
static_assert(offsetof(UFortBTTask_GameMoveTo, FocalPointWhileMoving) == 0x000070, "Member 'UFortBTTask_GameMoveTo::FocalPointWhileMoving' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PathObstacleAction) == 0x000090, "Member 'UFortBTTask_GameMoveTo::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, ActionOnBumpIntoSleeping) == 0x000098, "Member 'UFortBTTask_GameMoveTo::ActionOnBumpIntoSleeping' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveTo, PushBumpedPawnClass) == 0x00009C, "Member 'UFortBTTask_GameMoveTo::PushBumpedPawnClass' has a wrong offset!");

// Class FortniteGame.FortHexMapMarkerBase
// 0x0014 (0x0254 - 0x0240)
class AFortHexMapMarkerBase : public AActor
{
public:
	TArray<class UMaterialInstanceDynamic*>       CurrentMIDs;                                       // 0x0240(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        IdleAnimation;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkelMeshComponent;                                 // 0x0250(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHexMapMarkerBase">();
	}
	static class AFortHexMapMarkerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHexMapMarkerBase>();
	}
};
static_assert(alignof(AFortHexMapMarkerBase) == 0x000004, "Wrong alignment on AFortHexMapMarkerBase");
static_assert(sizeof(AFortHexMapMarkerBase) == 0x000254, "Wrong size on AFortHexMapMarkerBase");
static_assert(offsetof(AFortHexMapMarkerBase, CurrentMIDs) == 0x000240, "Member 'AFortHexMapMarkerBase::CurrentMIDs' has a wrong offset!");
static_assert(offsetof(AFortHexMapMarkerBase, IdleAnimation) == 0x00024C, "Member 'AFortHexMapMarkerBase::IdleAnimation' has a wrong offset!");
static_assert(offsetof(AFortHexMapMarkerBase, SkelMeshComponent) == 0x000250, "Member 'AFortHexMapMarkerBase::SkelMeshComponent' has a wrong offset!");

// Class FortniteGame.BuildingActorHotSpotRenderingComponent
// 0x0004 (0x0430 - 0x042C)
class UBuildingActorHotSpotRenderingComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingActorHotSpotRenderingComponent">();
	}
	static class UBuildingActorHotSpotRenderingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingActorHotSpotRenderingComponent>();
	}
};
static_assert(alignof(UBuildingActorHotSpotRenderingComponent) == 0x000004, "Wrong alignment on UBuildingActorHotSpotRenderingComponent");
static_assert(sizeof(UBuildingActorHotSpotRenderingComponent) == 0x000430, "Wrong size on UBuildingActorHotSpotRenderingComponent");

// Class FortniteGame.BuildingConnectivityComponent
// 0x00A4 (0x0250 - 0x01AC)
class UBuildingConnectivityComponent final : public USceneComponent
{
public:
	TArray<struct FFortConnectionData>            Connections;                                       // 0x01AC(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           SocketNames;                                       // 0x01B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoConnectOnInitialize;                          // 0x01C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugData;                                    // 0x01C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C6[0x2];                                      // 0x01C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ABuildingSMActor*                       BuildingOwner;                                     // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingConnectivityEffect*>    ConnectionEffects;                                 // 0x01CC(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPowered;                                        // 0x01D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsProvidingPower;                                 // 0x01D9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAbleToProvidePower;                             // 0x01DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowConnections;                                 // 0x01DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowsPowerToPassThrough;                         // 0x01DC(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   AuthorityOnConnectedDelegate;                      // 0x01E0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnDisconnectedDelegate;                   // 0x01EC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnConnectedDelegate;                         // 0x01F8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnDisconnectedDelegate;                      // 0x0204(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnPoweredDelegate;                        // 0x0210(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   AuthorityOnUnpoweredDelegate;                      // 0x021C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnPoweredDelegate;                           // 0x0228(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   ClientOnUnpoweredDelegate;                         // 0x0234(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Connect(const struct FFortConnectionData& NewConnection);
	void Disconnect(const struct FFortConnectionData& NewDisconnection);
	void DisconnectAll();
	void DrawDebugData();
	bool K2_IsPowered();
	void OnPlaced();
	void OnRep_bIsPowered();
	void OnRep_bIsProvidingPower();
	void OnRep_Connections();
	void SetAllowConnections(bool bInAllowConnections);
	void SetIsProvidingPower(bool bNewIsProvidingPower);

	bool CanConnectTo(class ABuildingSMActor* TestActor) const;
	bool IsConnectedTo(class ABuildingSMActor* TestActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityComponent">();
	}
	static class UBuildingConnectivityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingConnectivityComponent>();
	}
};
static_assert(alignof(UBuildingConnectivityComponent) == 0x000004, "Wrong alignment on UBuildingConnectivityComponent");
static_assert(sizeof(UBuildingConnectivityComponent) == 0x000250, "Wrong size on UBuildingConnectivityComponent");
static_assert(offsetof(UBuildingConnectivityComponent, Connections) == 0x0001AC, "Member 'UBuildingConnectivityComponent::Connections' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, SocketNames) == 0x0001B8, "Member 'UBuildingConnectivityComponent::SocketNames' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAutoConnectOnInitialize) == 0x0001C4, "Member 'UBuildingConnectivityComponent::bAutoConnectOnInitialize' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bDrawDebugData) == 0x0001C5, "Member 'UBuildingConnectivityComponent::bDrawDebugData' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, BuildingOwner) == 0x0001C8, "Member 'UBuildingConnectivityComponent::BuildingOwner' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ConnectionEffects) == 0x0001CC, "Member 'UBuildingConnectivityComponent::ConnectionEffects' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsPowered) == 0x0001D8, "Member 'UBuildingConnectivityComponent::bIsPowered' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsProvidingPower) == 0x0001D9, "Member 'UBuildingConnectivityComponent::bIsProvidingPower' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bIsAbleToProvidePower) == 0x0001DA, "Member 'UBuildingConnectivityComponent::bIsAbleToProvidePower' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAllowConnections) == 0x0001DB, "Member 'UBuildingConnectivityComponent::bAllowConnections' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, bAllowsPowerToPassThrough) == 0x0001DC, "Member 'UBuildingConnectivityComponent::bAllowsPowerToPassThrough' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnConnectedDelegate) == 0x0001E0, "Member 'UBuildingConnectivityComponent::AuthorityOnConnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnDisconnectedDelegate) == 0x0001EC, "Member 'UBuildingConnectivityComponent::AuthorityOnDisconnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnConnectedDelegate) == 0x0001F8, "Member 'UBuildingConnectivityComponent::ClientOnConnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnDisconnectedDelegate) == 0x000204, "Member 'UBuildingConnectivityComponent::ClientOnDisconnectedDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnPoweredDelegate) == 0x000210, "Member 'UBuildingConnectivityComponent::AuthorityOnPoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, AuthorityOnUnpoweredDelegate) == 0x00021C, "Member 'UBuildingConnectivityComponent::AuthorityOnUnpoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnPoweredDelegate) == 0x000228, "Member 'UBuildingConnectivityComponent::ClientOnPoweredDelegate' has a wrong offset!");
static_assert(offsetof(UBuildingConnectivityComponent, ClientOnUnpoweredDelegate) == 0x000234, "Member 'UBuildingConnectivityComponent::ClientOnUnpoweredDelegate' has a wrong offset!");

// Class FortniteGame.BuildingConnectivityEffect
// 0x0030 (0x0270 - 0x0240)
class ABuildingConnectivityEffect final : public AActor
{
public:
	struct FFortConnectionData                    ConnectionData;                                    // 0x0240(0x002C)(NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnect(const struct FTransform& T1, const struct FTransform& T2);
	void OnDisconnect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityEffect">();
	}
	static class ABuildingConnectivityEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingConnectivityEffect>();
	}
};
static_assert(alignof(ABuildingConnectivityEffect) == 0x000004, "Wrong alignment on ABuildingConnectivityEffect");
static_assert(sizeof(ABuildingConnectivityEffect) == 0x000270, "Wrong size on ABuildingConnectivityEffect");
static_assert(offsetof(ABuildingConnectivityEffect, ConnectionData) == 0x000240, "Member 'ABuildingConnectivityEffect::ConnectionData' has a wrong offset!");
static_assert(offsetof(ABuildingConnectivityEffect, bDebugDraw) == 0x00026C, "Member 'ABuildingConnectivityEffect::bDebugDraw' has a wrong offset!");

// Class FortniteGame.FortPlayerInput
// 0x0010 (0x02F0 - 0x02E0)
class UFortPlayerInput final : public UPlayerInput
{
public:
	TArray<struct FInputActionKeyMapping>         ActionMappingsPreset1;                             // 0x02E0(0x000C)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	EFortInputPreset                              ActivePreset;                                      // 0x02EC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerInput">();
	}
	static class UFortPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerInput>();
	}
};
static_assert(alignof(UFortPlayerInput) == 0x000004, "Wrong alignment on UFortPlayerInput");
static_assert(sizeof(UFortPlayerInput) == 0x0002F0, "Wrong size on UFortPlayerInput");
static_assert(offsetof(UFortPlayerInput, ActionMappingsPreset1) == 0x0002E0, "Member 'UFortPlayerInput::ActionMappingsPreset1' has a wrong offset!");
static_assert(offsetof(UFortPlayerInput, ActivePreset) == 0x0002EC, "Member 'UFortPlayerInput::ActivePreset' has a wrong offset!");

// Class FortniteGame.BuildingConnectivityManager
// 0x000C (0x024C - 0x0240)
class ABuildingConnectivityManager final : public AActor
{
public:
	TArray<class ABuildingSMActor*>               ConnectivityActors;                                // 0x0240(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingConnectivityManager">();
	}
	static class ABuildingConnectivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingConnectivityManager>();
	}
};
static_assert(alignof(ABuildingConnectivityManager) == 0x000004, "Wrong alignment on ABuildingConnectivityManager");
static_assert(sizeof(ABuildingConnectivityManager) == 0x00024C, "Wrong size on ABuildingConnectivityManager");
static_assert(offsetof(ABuildingConnectivityManager, ConnectivityActors) == 0x000240, "Member 'ABuildingConnectivityManager::ConnectivityActors' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange
// 0x0000 (0x009C - 0x009C)
class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange">();
	}
	static class UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange) == 0x00009C, "Wrong size on UFortBTDecorator_GameplayAbility_IsWithinMaxTargetSelectionRange");

// Class FortniteGame.FortHomebaseBuildingStaticDataTable
// 0x000C (0x0068 - 0x005C)
class UFortHomebaseBuildingStaticDataTable final : public UDataTable
{
public:
	TArray<struct FHomebaseBuildingStaticEffectData> GameplayEffects;                                   // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBuildingStaticDataTable">();
	}
	static class UFortHomebaseBuildingStaticDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBuildingStaticDataTable>();
	}
};
static_assert(alignof(UFortHomebaseBuildingStaticDataTable) == 0x000004, "Wrong alignment on UFortHomebaseBuildingStaticDataTable");
static_assert(sizeof(UFortHomebaseBuildingStaticDataTable) == 0x000068, "Wrong size on UFortHomebaseBuildingStaticDataTable");
static_assert(offsetof(UFortHomebaseBuildingStaticDataTable, GameplayEffects) == 0x00005C, "Member 'UFortHomebaseBuildingStaticDataTable::GameplayEffects' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata
// 0x00C0 (0x00DC - 0x001C)
class UBuildingEditModeMetadata : public UDataAsset
{
public:
	bool                                          bHasNavigableOpening;                              // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ShapeGuid;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, DuplicateTransient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConnectivityCube                      ConnectivityCubeData;                              // 0x0034(0x00A8)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata">();
	}
	static class UBuildingEditModeMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata");
static_assert(sizeof(UBuildingEditModeMetadata) == 0x0000DC, "Wrong size on UBuildingEditModeMetadata");
static_assert(offsetof(UBuildingEditModeMetadata, bHasNavigableOpening) == 0x00001C, "Member 'UBuildingEditModeMetadata::bHasNavigableOpening' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeMetadata, ShapeGuid) == 0x000020, "Member 'UBuildingEditModeMetadata::ShapeGuid' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeMetadata, ConnectivityCubeData) == 0x000034, "Member 'UBuildingEditModeMetadata::ConnectivityCubeData' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_BinaryToggle
// 0x000C (0x00E8 - 0x00DC)
class UBuildingEditModeMetadata_BinaryToggle : public UBuildingEditModeMetadata
{
public:
	TArray<EBinaryToggleValues>                   TileData;                                          // 0x00DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_BinaryToggle">();
	}
	static class UBuildingEditModeMetadata_BinaryToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_BinaryToggle>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_BinaryToggle) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_BinaryToggle");
static_assert(sizeof(UBuildingEditModeMetadata_BinaryToggle) == 0x0000E8, "Wrong size on UBuildingEditModeMetadata_BinaryToggle");
static_assert(offsetof(UBuildingEditModeMetadata_BinaryToggle, TileData) == 0x0000DC, "Member 'UBuildingEditModeMetadata_BinaryToggle::TileData' has a wrong offset!");

// Class FortniteGame.FortBTTask_GameMoveDirectlyToward
// 0x0030 (0x0098 - 0x0068)
class UFortBTTask_GameMoveDirectlyToward final : public UBTTask_MoveDirectlyToward
{
public:
	struct FBlackboardKeySelector                 FocalPointWhileMoving;                             // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	EPathObstacleAction                           PathObstacleAction;                                // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDetectUnexpectedPathBlockingObstacles : 1;        // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBumpIntoSleepingReaction                     ActionOnBumpIntoSleeping;                          // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_GameMoveDirectlyToward">();
	}
	static class UFortBTTask_GameMoveDirectlyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_GameMoveDirectlyToward>();
	}
};
static_assert(alignof(UFortBTTask_GameMoveDirectlyToward) == 0x000004, "Wrong alignment on UFortBTTask_GameMoveDirectlyToward");
static_assert(sizeof(UFortBTTask_GameMoveDirectlyToward) == 0x000098, "Wrong size on UFortBTTask_GameMoveDirectlyToward");
static_assert(offsetof(UFortBTTask_GameMoveDirectlyToward, FocalPointWhileMoving) == 0x000068, "Member 'UFortBTTask_GameMoveDirectlyToward::FocalPointWhileMoving' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveDirectlyToward, PathObstacleAction) == 0x000088, "Member 'UFortBTTask_GameMoveDirectlyToward::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveDirectlyToward, ActionOnBumpIntoSleeping) == 0x000090, "Member 'UFortBTTask_GameMoveDirectlyToward::ActionOnBumpIntoSleeping' has a wrong offset!");
static_assert(offsetof(UFortBTTask_GameMoveDirectlyToward, PushBumpedPawnClass) == 0x000094, "Member 'UFortBTTask_GameMoveDirectlyToward::PushBumpedPawnClass' has a wrong offset!");

// Class FortniteGame.FortQueryContext_AllPlayers
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_AllPlayers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllPlayers">();
	}
	static class UFortQueryContext_AllPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllPlayers>();
	}
};
static_assert(alignof(UFortQueryContext_AllPlayers) == 0x000004, "Wrong alignment on UFortQueryContext_AllPlayers");
static_assert(sizeof(UFortQueryContext_AllPlayers) == 0x00001C, "Wrong size on UFortQueryContext_AllPlayers");

// Class FortniteGame.BuildingEditModeMetadata_Floor
// 0x0000 (0x00E8 - 0x00E8)
class UBuildingEditModeMetadata_Floor final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Floor">();
	}
	static class UBuildingEditModeMetadata_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Floor>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Floor) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_Floor");
static_assert(sizeof(UBuildingEditModeMetadata_Floor) == 0x0000E8, "Wrong size on UBuildingEditModeMetadata_Floor");

// Class FortniteGame.FortInGameMapManager
// 0x0110 (0x0350 - 0x0240)
class AFortInGameMapManager : public AActor
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenDispersions;                           // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FogResolution;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VisitedMaskResolution;                             // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExploredRadius;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExploredFalloffRadius;                             // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeenRadius;                                        // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeenFalloffRadius;                                 // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VisibilityMaxGradient;                             // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetZ;                                           // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapLayerSize;                                      // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                MapMargin;                                         // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         IconVisibilityFogThreshold;                        // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenMapDelayBetweenUpdates;                        // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASceneCapture2D>            SceneCaptureClass;                                 // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASceneCapture2D>            SceneCaptureBlurryClass;                           // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      MapMaterial;                                       // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   CloudBrightnessCurve;                              // 0x02A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   DesaturationFactorCurve;                           // 0x02B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         MapOpacityWhenWalking;                             // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASceneCapture2D*                        SceneCapture;                                      // 0x02C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASceneCapture2D*                        SceneCaptureBlurry;                                // 0x02C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x20];                                     // 0x02CC(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             FogMask;                                           // 0x02EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x60];                                     // 0x02F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplyShowFlags(class USceneCaptureComponent* SceneCaptureComponent);

	void PaintOnFog(const struct FVector& WorldCoords);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortInGameMapManager">();
	}
	static class AFortInGameMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortInGameMapManager>();
	}
};
static_assert(alignof(AFortInGameMapManager) == 0x000004, "Wrong alignment on AFortInGameMapManager");
static_assert(sizeof(AFortInGameMapManager) == 0x000350, "Wrong size on AFortInGameMapManager");
static_assert(offsetof(AFortInGameMapManager, DelayBetweenDispersions) == 0x000248, "Member 'AFortInGameMapManager::DelayBetweenDispersions' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, FogResolution) == 0x00024C, "Member 'AFortInGameMapManager::FogResolution' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, VisitedMaskResolution) == 0x000250, "Member 'AFortInGameMapManager::VisitedMaskResolution' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, ExploredRadius) == 0x000254, "Member 'AFortInGameMapManager::ExploredRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, ExploredFalloffRadius) == 0x000258, "Member 'AFortInGameMapManager::ExploredFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SeenRadius) == 0x00025C, "Member 'AFortInGameMapManager::SeenRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SeenFalloffRadius) == 0x000260, "Member 'AFortInGameMapManager::SeenFalloffRadius' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, VisibilityMaxGradient) == 0x000264, "Member 'AFortInGameMapManager::VisibilityMaxGradient' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, OffsetZ) == 0x000268, "Member 'AFortInGameMapManager::OffsetZ' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapLayerSize) == 0x00026C, "Member 'AFortInGameMapManager::MapLayerSize' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapMargin) == 0x000270, "Member 'AFortInGameMapManager::MapMargin' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, IconVisibilityFogThreshold) == 0x000280, "Member 'AFortInGameMapManager::IconVisibilityFogThreshold' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, OpenMapDelayBetweenUpdates) == 0x000284, "Member 'AFortInGameMapManager::OpenMapDelayBetweenUpdates' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureClass) == 0x000288, "Member 'AFortInGameMapManager::SceneCaptureClass' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureBlurryClass) == 0x00028C, "Member 'AFortInGameMapManager::SceneCaptureBlurryClass' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapMaterial) == 0x000290, "Member 'AFortInGameMapManager::MapMaterial' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, CloudBrightnessCurve) == 0x0002A8, "Member 'AFortInGameMapManager::CloudBrightnessCurve' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, DesaturationFactorCurve) == 0x0002B4, "Member 'AFortInGameMapManager::DesaturationFactorCurve' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, MapOpacityWhenWalking) == 0x0002C0, "Member 'AFortInGameMapManager::MapOpacityWhenWalking' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCapture) == 0x0002C4, "Member 'AFortInGameMapManager::SceneCapture' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, SceneCaptureBlurry) == 0x0002C8, "Member 'AFortInGameMapManager::SceneCaptureBlurry' has a wrong offset!");
static_assert(offsetof(AFortInGameMapManager, FogMask) == 0x0002EC, "Member 'AFortInGameMapManager::FogMask' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_Roof
// 0x000C (0x00F4 - 0x00E8)
class UBuildingEditModeMetadata_Roof final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	TArray<struct FAuxiliaryEditTileMeshData>     AuxEditTileMeshData;                               // 0x00E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Roof">();
	}
	static class UBuildingEditModeMetadata_Roof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Roof>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Roof) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_Roof");
static_assert(sizeof(UBuildingEditModeMetadata_Roof) == 0x0000F4, "Wrong size on UBuildingEditModeMetadata_Roof");
static_assert(offsetof(UBuildingEditModeMetadata_Roof, AuxEditTileMeshData) == 0x0000E8, "Member 'UBuildingEditModeMetadata_Roof::AuxEditTileMeshData' has a wrong offset!");

// Class FortniteGame.CustomPlayerComponent
// 0x0018 (0x0034 - 0x001C)
class UCustomPlayerComponent final : public UObject
{
public:
	uint8                                         Pad_1C[0x18];                                      // 0x001C(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPlayerComponent">();
	}
	static class UCustomPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPlayerComponent>();
	}
};
static_assert(alignof(UCustomPlayerComponent) == 0x000004, "Wrong alignment on UCustomPlayerComponent");
static_assert(sizeof(UCustomPlayerComponent) == 0x000034, "Wrong size on UCustomPlayerComponent");

// Class FortniteGame.FortSimpleMiniMapIndicator
// 0x0018 (0x00BC - 0x00A4)
class UFortSimpleMiniMapIndicator final : public UFortMiniMapIndicator
{
public:
	uint8                                         Pad_A4[0x18];                                      // 0x00A4(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSimpleMiniMapIndicator">();
	}
	static class UFortSimpleMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSimpleMiniMapIndicator>();
	}
};
static_assert(alignof(UFortSimpleMiniMapIndicator) == 0x000004, "Wrong alignment on UFortSimpleMiniMapIndicator");
static_assert(sizeof(UFortSimpleMiniMapIndicator) == 0x0000BC, "Wrong size on UFortSimpleMiniMapIndicator");

// Class FortniteGame.BuildingEditModeMetadata_Wall
// 0x0000 (0x00E8 - 0x00E8)
class UBuildingEditModeMetadata_Wall final : public UBuildingEditModeMetadata_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Wall">();
	}
	static class UBuildingEditModeMetadata_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Wall>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Wall) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_Wall");
static_assert(sizeof(UBuildingEditModeMetadata_Wall) == 0x0000E8, "Wrong size on UBuildingEditModeMetadata_Wall");

// Class FortniteGame.BuildingEditModeMetadata_Pillar
// 0x0000 (0x00DC - 0x00DC)
class UBuildingEditModeMetadata_Pillar final : public UBuildingEditModeMetadata
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Pillar">();
	}
	static class UBuildingEditModeMetadata_Pillar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Pillar>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Pillar) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_Pillar");
static_assert(sizeof(UBuildingEditModeMetadata_Pillar) == 0x0000DC, "Wrong size on UBuildingEditModeMetadata_Pillar");

// Class FortniteGame.FortBTTask_SetFrustrationDiscouragement
// 0x0004 (0x0044 - 0x0040)
class UFortBTTask_SetFrustrationDiscouragement final : public UBTTaskNode
{
public:
	float                                         DiscouragementDuration;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_SetFrustrationDiscouragement">();
	}
	static class UFortBTTask_SetFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_SetFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortBTTask_SetFrustrationDiscouragement) == 0x000004, "Wrong alignment on UFortBTTask_SetFrustrationDiscouragement");
static_assert(sizeof(UFortBTTask_SetFrustrationDiscouragement) == 0x000044, "Wrong size on UFortBTTask_SetFrustrationDiscouragement");
static_assert(offsetof(UFortBTTask_SetFrustrationDiscouragement, DiscouragementDuration) == 0x000040, "Member 'UFortBTTask_SetFrustrationDiscouragement::DiscouragementDuration' has a wrong offset!");

// Class FortniteGame.HomeBaseBuilding
// 0x004C (0x0068 - 0x001C)
class UHomeBaseBuilding : public UObject
{
public:
	UMulticastDelegateProperty_                   OnBuildingChanged;                                 // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBuildingUpgraded;                                // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLevel;                                          // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMyTownBuildingDefinitionData*          Definition;                                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMyTownBuildingItem>     ItemWeakPtr;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ClearBang();
	void OnBuildingChangedInternal(bool bItemChanged, bool bAmmoChanged, bool bIngredientsChanged);
	void Upgrade();

	class UFortAbilityKit* GetAbilityKitForLevel(int32 InLevel) const;
	void GetAbilityKits(TArray<class UFortAbilityKit*>* AbilityKits) const;
	TArray<class UBuildingLevelGameplayEffectInfo*> GetCurrentBonuses() const;
	class UMyTownBuildingItem* GetItem() const;
	TArray<class UBuildingLevelGameplayEffectInfo*> GetMaxLevelBonuses() const;
	TArray<class UBuildingLevelGameplayEffectInfo*> GetNextBonuses() const;
	int32 GetTeammatesRatingAddition(const struct FUniqueNetIdRepl& TeammatesAccountId) const;
	struct FBuildingUpgradeRequirementsForLevel GetUpgradeRequirements() const;
	bool ShouldShowBang() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseBuilding">();
	}
	static class UHomeBaseBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseBuilding>();
	}
};
static_assert(alignof(UHomeBaseBuilding) == 0x000004, "Wrong alignment on UHomeBaseBuilding");
static_assert(sizeof(UHomeBaseBuilding) == 0x000068, "Wrong size on UHomeBaseBuilding");
static_assert(offsetof(UHomeBaseBuilding, OnBuildingChanged) == 0x00001C, "Member 'UHomeBaseBuilding::OnBuildingChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseBuilding, OnBuildingUpgraded) == 0x000028, "Member 'UHomeBaseBuilding::OnBuildingUpgraded' has a wrong offset!");
static_assert(offsetof(UHomeBaseBuilding, Level) == 0x000034, "Member 'UHomeBaseBuilding::Level' has a wrong offset!");
static_assert(offsetof(UHomeBaseBuilding, MaxLevel) == 0x000038, "Member 'UHomeBaseBuilding::MaxLevel' has a wrong offset!");
static_assert(offsetof(UHomeBaseBuilding, Definition) == 0x00003C, "Member 'UHomeBaseBuilding::Definition' has a wrong offset!");
static_assert(offsetof(UHomeBaseBuilding, ItemWeakPtr) == 0x000060, "Member 'UHomeBaseBuilding::ItemWeakPtr' has a wrong offset!");

// Class FortniteGame.HomeBaseMainBuilding
// 0x0074 (0x00DC - 0x0068)
class UHomeBaseMainBuilding : public UHomeBaseBuilding
{
public:
	int32                                         Rating;                                            // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamRatingAddition;                                // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTeamRating;                                   // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseRating;                                        // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHomeBaseWorkers*                       Workers;                                           // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHomeBaseBuilding*>              SubBuildings;                                      // 0x007C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShouldShowChanged;                               // 0x0088(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x48];                                      // 0x0094(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuildingGameplayEffectsChanged();
	void OnSubBuildingChanged();
	void OnWorkersChangedInternal();

	TArray<class UAccumulatedGameplayEffectInfo*> GetEffects() const;
	bool ShouldShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseMainBuilding">();
	}
	static class UHomeBaseMainBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseMainBuilding>();
	}
};
static_assert(alignof(UHomeBaseMainBuilding) == 0x000004, "Wrong alignment on UHomeBaseMainBuilding");
static_assert(sizeof(UHomeBaseMainBuilding) == 0x0000DC, "Wrong size on UHomeBaseMainBuilding");
static_assert(offsetof(UHomeBaseMainBuilding, Rating) == 0x000068, "Member 'UHomeBaseMainBuilding::Rating' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, TeamRatingAddition) == 0x00006C, "Member 'UHomeBaseMainBuilding::TeamRatingAddition' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, TotalTeamRating) == 0x000070, "Member 'UHomeBaseMainBuilding::TotalTeamRating' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, BaseRating) == 0x000074, "Member 'UHomeBaseMainBuilding::BaseRating' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, Workers) == 0x000078, "Member 'UHomeBaseMainBuilding::Workers' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, SubBuildings) == 0x00007C, "Member 'UHomeBaseMainBuilding::SubBuildings' has a wrong offset!");
static_assert(offsetof(UHomeBaseMainBuilding, OnShouldShowChanged) == 0x000088, "Member 'UHomeBaseMainBuilding::OnShouldShowChanged' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadata_Stair
// 0x000C (0x00E8 - 0x00DC)
class UBuildingEditModeMetadata_Stair final : public UBuildingEditModeMetadata
{
public:
	TArray<int32>                                 TileData;                                          // 0x00DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadata_Stair">();
	}
	static class UBuildingEditModeMetadata_Stair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadata_Stair>();
	}
};
static_assert(alignof(UBuildingEditModeMetadata_Stair) == 0x000004, "Wrong alignment on UBuildingEditModeMetadata_Stair");
static_assert(sizeof(UBuildingEditModeMetadata_Stair) == 0x0000E8, "Wrong size on UBuildingEditModeMetadata_Stair");
static_assert(offsetof(UBuildingEditModeMetadata_Stair, TileData) == 0x0000DC, "Member 'UBuildingEditModeMetadata_Stair::TileData' has a wrong offset!");

// Class FortniteGame.FortHomebaseBuildingDataTable
// 0x0004 (0x0060 - 0x005C)
class UFortHomebaseBuildingDataTable final : public UDataTable
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseBuildingDataTable">();
	}
	static class UFortHomebaseBuildingDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseBuildingDataTable>();
	}
};
static_assert(alignof(UFortHomebaseBuildingDataTable) == 0x000004, "Wrong alignment on UFortHomebaseBuildingDataTable");
static_assert(sizeof(UFortHomebaseBuildingDataTable) == 0x000060, "Wrong size on UFortHomebaseBuildingDataTable");
static_assert(offsetof(UFortHomebaseBuildingDataTable, GameplayEffectClass) == 0x00005C, "Member 'UFortHomebaseBuildingDataTable::GameplayEffectClass' has a wrong offset!");

// Class FortniteGame.BuildingEditModeMetadataContainer
// 0x000C (0x0028 - 0x001C)
class UBuildingEditModeMetadataContainer final : public UDataAsset
{
public:
	TArray<class UBuildingEditModeMetadata*>      MetadataCollection;                                // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeMetadataContainer">();
	}
	static class UBuildingEditModeMetadataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeMetadataContainer>();
	}
};
static_assert(alignof(UBuildingEditModeMetadataContainer) == 0x000004, "Wrong alignment on UBuildingEditModeMetadataContainer");
static_assert(sizeof(UBuildingEditModeMetadataContainer) == 0x000028, "Wrong size on UBuildingEditModeMetadataContainer");
static_assert(offsetof(UBuildingEditModeMetadataContainer, MetadataCollection) == 0x00001C, "Member 'UBuildingEditModeMetadataContainer::MetadataCollection' has a wrong offset!");

// Class FortniteGame.FortSlateHUDIndicator
// 0x0018 (0x0064 - 0x004C)
class UFortSlateHUDIndicator : public UFortIndicator
{
public:
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bClampToScreen;                                    // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x13];                                      // 0x0051(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSlateHUDIndicator">();
	}
	static class UFortSlateHUDIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSlateHUDIndicator>();
	}
};
static_assert(alignof(UFortSlateHUDIndicator) == 0x000004, "Wrong alignment on UFortSlateHUDIndicator");
static_assert(sizeof(UFortSlateHUDIndicator) == 0x000064, "Wrong size on UFortSlateHUDIndicator");
static_assert(offsetof(UFortSlateHUDIndicator, bClampToScreen) == 0x000050, "Member 'UFortSlateHUDIndicator::bClampToScreen' has a wrong offset!");

// Class FortniteGame.FortMissionInfoIndicator
// 0x0020 (0x0084 - 0x0064)
class UFortMissionInfoIndicator final : public UFortSlateHUDIndicator
{
public:
	uint8                                         Pad_64[0x20];                                      // 0x0064(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInfoIndicator">();
	}
	static class UFortMissionInfoIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionInfoIndicator>();
	}
};
static_assert(alignof(UFortMissionInfoIndicator) == 0x000004, "Wrong alignment on UFortMissionInfoIndicator");
static_assert(sizeof(UFortMissionInfoIndicator) == 0x000084, "Wrong size on UFortMissionInfoIndicator");

// Class FortniteGame.BuildingEditModeSupport
// 0x01A0 (0x01BC - 0x001C)
class UBuildingEditModeSupport : public UObject
{
public:
	class ABuildingSMActor*                       OwnerBuilding;                                     // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerController*                  EditingController;                                 // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              PreviewMetadata;                                   // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              ScratchpadMetadata;                                // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBuildingEditModeMetadata>  ExpectedMetadataClass;                             // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ABuildingSMActor>>   PossibleEditClasses;                               // 0x0030(0x000C)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             EditTileMesh;                                      // 0x003C(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           EditTileMeshComponents;                            // 0x0054(0x000C)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      TileMaterialParent;                                // 0x0060(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ActiveTileTexture;                                 // 0x0078(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              InactiveTileTexture;                               // 0x0090(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LastInteractedComp;                                // 0x00A8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LastHighlightedComp;                               // 0x00AC(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PreviewComponent;                                  // 0x00B0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      PreviewMaterial;                                   // 0x00B4(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEditModeState                         PreviewEditModeState;                              // 0x00CC(0x000C)(Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             SuccessfulPatternMatchCurve;                       // 0x00D8(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              SuccessfulMatchInteractTimeline;                   // 0x00F0(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bCanMirrorMetadataToMatch : 1;                     // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bCanRotateMetadataToMatch : 1;                     // 0x0170(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bEditActionInProgress : 1;                         // 0x0170(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bInitializedTimelines : 1;                         // 0x0170(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_171[0x4B];                                     // 0x0171(0x004B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSuccessfulMatchInteractComplete();
	void OnSuccessfulMatchInteractParamUpdate(float NewInteractParamVal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport">();
	}
	static class UBuildingEditModeSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport>();
	}
};
static_assert(alignof(UBuildingEditModeSupport) == 0x000004, "Wrong alignment on UBuildingEditModeSupport");
static_assert(sizeof(UBuildingEditModeSupport) == 0x0001BC, "Wrong size on UBuildingEditModeSupport");
static_assert(offsetof(UBuildingEditModeSupport, OwnerBuilding) == 0x00001C, "Member 'UBuildingEditModeSupport::OwnerBuilding' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditingController) == 0x000020, "Member 'UBuildingEditModeSupport::EditingController' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewMetadata) == 0x000024, "Member 'UBuildingEditModeSupport::PreviewMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ScratchpadMetadata) == 0x000028, "Member 'UBuildingEditModeSupport::ScratchpadMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ExpectedMetadataClass) == 0x00002C, "Member 'UBuildingEditModeSupport::ExpectedMetadataClass' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PossibleEditClasses) == 0x000030, "Member 'UBuildingEditModeSupport::PossibleEditClasses' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditTileMesh) == 0x00003C, "Member 'UBuildingEditModeSupport::EditTileMesh' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, EditTileMeshComponents) == 0x000054, "Member 'UBuildingEditModeSupport::EditTileMeshComponents' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, TileMaterialParent) == 0x000060, "Member 'UBuildingEditModeSupport::TileMaterialParent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, ActiveTileTexture) == 0x000078, "Member 'UBuildingEditModeSupport::ActiveTileTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, InactiveTileTexture) == 0x000090, "Member 'UBuildingEditModeSupport::InactiveTileTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, LastInteractedComp) == 0x0000A8, "Member 'UBuildingEditModeSupport::LastInteractedComp' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, LastHighlightedComp) == 0x0000AC, "Member 'UBuildingEditModeSupport::LastHighlightedComp' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewComponent) == 0x0000B0, "Member 'UBuildingEditModeSupport::PreviewComponent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewMaterial) == 0x0000B4, "Member 'UBuildingEditModeSupport::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, PreviewEditModeState) == 0x0000CC, "Member 'UBuildingEditModeSupport::PreviewEditModeState' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, SuccessfulPatternMatchCurve) == 0x0000D8, "Member 'UBuildingEditModeSupport::SuccessfulPatternMatchCurve' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport, SuccessfulMatchInteractTimeline) == 0x0000F0, "Member 'UBuildingEditModeSupport::SuccessfulMatchInteractTimeline' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_BinaryToggle
// 0x0018 (0x01D4 - 0x01BC)
class UBuildingEditModeSupport_BinaryToggle : public UBuildingEditModeSupport
{
public:
	class UBuildingEditModeMetadata_BinaryToggle* BinaryTogglePreviewData;                           // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBinaryToggleValues                           CurToggleAction;                                   // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultBlueTileColor;                              // 0x01C4(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_BinaryToggle">();
	}
	static class UBuildingEditModeSupport_BinaryToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_BinaryToggle>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_BinaryToggle) == 0x000004, "Wrong alignment on UBuildingEditModeSupport_BinaryToggle");
static_assert(sizeof(UBuildingEditModeSupport_BinaryToggle) == 0x0001D4, "Wrong size on UBuildingEditModeSupport_BinaryToggle");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, BinaryTogglePreviewData) == 0x0001BC, "Member 'UBuildingEditModeSupport_BinaryToggle::BinaryTogglePreviewData' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, CurToggleAction) == 0x0001C0, "Member 'UBuildingEditModeSupport_BinaryToggle::CurToggleAction' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_BinaryToggle, DefaultBlueTileColor) == 0x0001C4, "Member 'UBuildingEditModeSupport_BinaryToggle::DefaultBlueTileColor' has a wrong offset!");

// Class FortniteGame.CustomColorSwatch
// 0x0004 (0x0020 - 0x001C)
class UCustomColorSwatch : public UDataAsset
{
public:
	EFortCustomGender                             GenderPermitted;                                   // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EColorSwatchType                              ColorSwatchType;                                   // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomColorSwatch">();
	}
	static class UCustomColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomColorSwatch>();
	}
};
static_assert(alignof(UCustomColorSwatch) == 0x000004, "Wrong alignment on UCustomColorSwatch");
static_assert(sizeof(UCustomColorSwatch) == 0x000020, "Wrong size on UCustomColorSwatch");
static_assert(offsetof(UCustomColorSwatch, GenderPermitted) == 0x00001C, "Member 'UCustomColorSwatch::GenderPermitted' has a wrong offset!");
static_assert(offsetof(UCustomColorSwatch, ColorSwatchType) == 0x00001D, "Member 'UCustomColorSwatch::ColorSwatchType' has a wrong offset!");

// Class FortniteGame.CustomDynamicColorSwatch
// 0x000C (0x002C - 0x0020)
class UCustomDynamicColorSwatch : public UCustomColorSwatch
{
public:
	TArray<struct FColorSwatchPair>               ColorPairs;                                        // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDynamicColorSwatch">();
	}
	static class UCustomDynamicColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDynamicColorSwatch>();
	}
};
static_assert(alignof(UCustomDynamicColorSwatch) == 0x000004, "Wrong alignment on UCustomDynamicColorSwatch");
static_assert(sizeof(UCustomDynamicColorSwatch) == 0x00002C, "Wrong size on UCustomDynamicColorSwatch");
static_assert(offsetof(UCustomDynamicColorSwatch, ColorPairs) == 0x000020, "Member 'UCustomDynamicColorSwatch::ColorPairs' has a wrong offset!");

// Class FortniteGame.CustomHairColorSwatch
// 0x0000 (0x002C - 0x002C)
class UCustomHairColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomHairColorSwatch">();
	}
	static class UCustomHairColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomHairColorSwatch>();
	}
};
static_assert(alignof(UCustomHairColorSwatch) == 0x000004, "Wrong alignment on UCustomHairColorSwatch");
static_assert(sizeof(UCustomHairColorSwatch) == 0x00002C, "Wrong size on UCustomHairColorSwatch");

// Class FortniteGame.FortQueryContext_Goal
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_Goal final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_Goal">();
	}
	static class UFortQueryContext_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_Goal>();
	}
};
static_assert(alignof(UFortQueryContext_Goal) == 0x000004, "Wrong alignment on UFortQueryContext_Goal");
static_assert(sizeof(UFortQueryContext_Goal) == 0x00001C, "Wrong size on UFortQueryContext_Goal");

// Class FortniteGame.BuildingEditModeSupport_Floor
// 0x0000 (0x01D4 - 0x01D4)
class UBuildingEditModeSupport_Floor final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Floor">();
	}
	static class UBuildingEditModeSupport_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Floor>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Floor) == 0x000004, "Wrong alignment on UBuildingEditModeSupport_Floor");
static_assert(sizeof(UBuildingEditModeSupport_Floor) == 0x0001D4, "Wrong size on UBuildingEditModeSupport_Floor");

// Class FortniteGame.FortCardPackItem
// 0x000C (0x008C - 0x0080)
class UFortCardPackItem final : public UFortAccountItem
{
public:
	TArray<struct FMcpLootEntry>                  Options;                                           // 0x0080(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCardPackItem">();
	}
	static class UFortCardPackItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCardPackItem>();
	}
};
static_assert(alignof(UFortCardPackItem) == 0x000004, "Wrong alignment on UFortCardPackItem");
static_assert(sizeof(UFortCardPackItem) == 0x00008C, "Wrong size on UFortCardPackItem");
static_assert(offsetof(UFortCardPackItem, Options) == 0x000080, "Member 'UFortCardPackItem::Options' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_Roof
// 0x001C (0x01F0 - 0x01D4)
class UBuildingEditModeSupport_Roof final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	TArray<struct FTileCompInterpData>            TileInterpData;                                    // 0x01D4(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Roof">();
	}
	static class UBuildingEditModeSupport_Roof* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Roof>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Roof) == 0x000004, "Wrong alignment on UBuildingEditModeSupport_Roof");
static_assert(sizeof(UBuildingEditModeSupport_Roof) == 0x0001F0, "Wrong size on UBuildingEditModeSupport_Roof");
static_assert(offsetof(UBuildingEditModeSupport_Roof, TileInterpData) == 0x0001D4, "Member 'UBuildingEditModeSupport_Roof::TileInterpData' has a wrong offset!");

// Class FortniteGame.FortAbilitySystemUI
// 0x003C (0x0058 - 0x001C)
class UFortAbilitySystemUI final : public UObject
{
public:
	uint8                                         Pad_1C[0x3C];                                      // 0x001C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemUI">();
	}
	static class UFortAbilitySystemUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemUI>();
	}
};
static_assert(alignof(UFortAbilitySystemUI) == 0x000004, "Wrong alignment on UFortAbilitySystemUI");
static_assert(sizeof(UFortAbilitySystemUI) == 0x000058, "Wrong size on UFortAbilitySystemUI");

// Class FortniteGame.FortIntensityCurveSequenceProgression
// 0x000C (0x0028 - 0x001C)
class UFortIntensityCurveSequenceProgression final : public UDataAsset
{
public:
	TArray<struct FFortInstensityCurveSequenceProgression> IntensityCurveSequences;                           // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequenceProgression">();
	}
	static class UFortIntensityCurveSequenceProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequenceProgression>();
	}
};
static_assert(alignof(UFortIntensityCurveSequenceProgression) == 0x000004, "Wrong alignment on UFortIntensityCurveSequenceProgression");
static_assert(sizeof(UFortIntensityCurveSequenceProgression) == 0x000028, "Wrong size on UFortIntensityCurveSequenceProgression");
static_assert(offsetof(UFortIntensityCurveSequenceProgression, IntensityCurveSequences) == 0x00001C, "Member 'UFortIntensityCurveSequenceProgression::IntensityCurveSequences' has a wrong offset!");

// Class FortniteGame.BuildingEditModeSupport_Wall
// 0x0000 (0x01D4 - 0x01D4)
class UBuildingEditModeSupport_Wall final : public UBuildingEditModeSupport_BinaryToggle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Wall">();
	}
	static class UBuildingEditModeSupport_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Wall>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Wall) == 0x000004, "Wrong alignment on UBuildingEditModeSupport_Wall");
static_assert(sizeof(UBuildingEditModeSupport_Wall) == 0x0001D4, "Wrong size on UBuildingEditModeSupport_Wall");

// Class FortniteGame.BuildingEditModeSupport_Stair
// 0x0080 (0x023C - 0x01BC)
class UBuildingEditModeSupport_Stair final : public UBuildingEditModeSupport
{
public:
	class UBuildingEditModeMetadata_Stair*        StairPreviewMetadata;                              // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata_Stair*        LastValidMetadataConfiguration;                    // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             AuxiliaryIndicatorMesh;                            // 0x01C4(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           AuxiliaryIndicatorComponents;                      // 0x01DC(0x000C)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   ActivatedAuxIndicatorComponent;                    // 0x01E8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialInterface>      AuxIndicatorComponentParentMaterial;               // 0x01EC(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              AuxIndicatorArrowTexture;                          // 0x0204(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              AuxIndicatorGridTexture;                           // 0x021C(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x8];                                      // 0x0234(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingEditModeSupport_Stair">();
	}
	static class UBuildingEditModeSupport_Stair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingEditModeSupport_Stair>();
	}
};
static_assert(alignof(UBuildingEditModeSupport_Stair) == 0x000004, "Wrong alignment on UBuildingEditModeSupport_Stair");
static_assert(sizeof(UBuildingEditModeSupport_Stair) == 0x00023C, "Wrong size on UBuildingEditModeSupport_Stair");
static_assert(offsetof(UBuildingEditModeSupport_Stair, StairPreviewMetadata) == 0x0001BC, "Member 'UBuildingEditModeSupport_Stair::StairPreviewMetadata' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, LastValidMetadataConfiguration) == 0x0001C0, "Member 'UBuildingEditModeSupport_Stair::LastValidMetadataConfiguration' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxiliaryIndicatorMesh) == 0x0001C4, "Member 'UBuildingEditModeSupport_Stair::AuxiliaryIndicatorMesh' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxiliaryIndicatorComponents) == 0x0001DC, "Member 'UBuildingEditModeSupport_Stair::AuxiliaryIndicatorComponents' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, ActivatedAuxIndicatorComponent) == 0x0001E8, "Member 'UBuildingEditModeSupport_Stair::ActivatedAuxIndicatorComponent' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorComponentParentMaterial) == 0x0001EC, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorComponentParentMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorArrowTexture) == 0x000204, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorArrowTexture' has a wrong offset!");
static_assert(offsetof(UBuildingEditModeSupport_Stair, AuxIndicatorGridTexture) == 0x00021C, "Member 'UBuildingEditModeSupport_Stair::AuxIndicatorGridTexture' has a wrong offset!");

// Class FortniteGame.FortPvPPlayerStart
// 0x000C (0x0268 - 0x025C)
class AFortPvPPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EFortTeam                                     Team;                                              // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDynamicStartLocation : 1;                         // 0x0264(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPPlayerStart">();
	}
	static class AFortPvPPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPPlayerStart>();
	}
};
static_assert(alignof(AFortPvPPlayerStart) == 0x000004, "Wrong alignment on AFortPvPPlayerStart");
static_assert(sizeof(AFortPvPPlayerStart) == 0x000268, "Wrong size on AFortPvPPlayerStart");
static_assert(offsetof(AFortPvPPlayerStart, Team) == 0x000260, "Member 'AFortPvPPlayerStart::Team' has a wrong offset!");

// Class FortniteGame.BuildingGroup
// 0x0034 (0x0050 - 0x001C)
class UBuildingGroup final : public UDataAsset
{
public:
	class FName                                   GroupName;                                         // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBuildingGroup*                         FallbackGroup;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingFoundationType                       FoundationType;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllBuildingLevelTags;                              // 0x002C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FFortMapData>                   BuildingLevelData;                                 // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingGroup">();
	}
	static class UBuildingGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingGroup>();
	}
};
static_assert(alignof(UBuildingGroup) == 0x000004, "Wrong alignment on UBuildingGroup");
static_assert(sizeof(UBuildingGroup) == 0x000050, "Wrong size on UBuildingGroup");
static_assert(offsetof(UBuildingGroup, GroupName) == 0x00001C, "Member 'UBuildingGroup::GroupName' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, FallbackGroup) == 0x000024, "Member 'UBuildingGroup::FallbackGroup' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, FoundationType) == 0x000028, "Member 'UBuildingGroup::FoundationType' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, AllBuildingLevelTags) == 0x00002C, "Member 'UBuildingGroup::AllBuildingLevelTags' has a wrong offset!");
static_assert(offsetof(UBuildingGroup, BuildingLevelData) == 0x000044, "Member 'UBuildingGroup::BuildingLevelData' has a wrong offset!");

// Class FortniteGame.FortHealthBarIndicator
// 0x0030 (0x0094 - 0x0064)
class UFortHealthBarIndicator final : public UFortSlateHUDIndicator
{
public:
	uint8                                         Pad_64[0x30];                                      // 0x0064(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealthBarIndicator">();
	}
	static class UFortHealthBarIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealthBarIndicator>();
	}
};
static_assert(alignof(UFortHealthBarIndicator) == 0x000004, "Wrong alignment on UFortHealthBarIndicator");
static_assert(sizeof(UFortHealthBarIndicator) == 0x000094, "Wrong size on UFortHealthBarIndicator");

// Class FortniteGame.BuildingStructuralSupportSystem
// 0x02B8 (0x02D4 - 0x001C)
class UBuildingStructuralSupportSystem final : public UObject
{
public:
	uint8                                         Pad_1C[0x2B8];                                     // 0x001C(0x02B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABuildingSMActor* GetBestBuildingTarget(class AActor* ObjectiveActor, class AActor* AttackerActor, const struct FBuildingValueRules& ValueRules);
	void GetLogicalBuildingGroundSupportedActors(int32 LogicalIndex, TArray<class ABuildingSMActor*>* LogicalBuildingGroundSupportedActors);
	void K2_GetLogicalBuildingActors(int32 LogicalIdx, TArray<class ABuildingSMActor*>* LogicalBuildingActors);

	struct FBuildingValueRules MakeBuildingValueRules(int32 CellsAbove, int32 CellsBelow, int32 CellHorizontalRadius, float DistanceFromObjectiveWeight, float AttackWeight, float StructuralWeight, float TrapWeight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingStructuralSupportSystem">();
	}
	static class UBuildingStructuralSupportSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingStructuralSupportSystem>();
	}
};
static_assert(alignof(UBuildingStructuralSupportSystem) == 0x000004, "Wrong alignment on UBuildingStructuralSupportSystem");
static_assert(sizeof(UBuildingStructuralSupportSystem) == 0x0002D4, "Wrong size on UBuildingStructuralSupportSystem");

// Class FortniteGame.CustomColorComponent
// 0x0008 (0x0024 - 0x001C)
class UCustomColorComponent final : public UObject
{
public:
	uint8                                         Pad_1C[0x8];                                       // 0x001C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomColorComponent">();
	}
	static class UCustomColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomColorComponent>();
	}
};
static_assert(alignof(UCustomColorComponent) == 0x000004, "Wrong alignment on UCustomColorComponent");
static_assert(sizeof(UCustomColorComponent) == 0x000024, "Wrong size on UCustomColorComponent");

// Class FortniteGame.FortAlterableItem
// 0x0024 (0x00A4 - 0x0080)
class UFortAlterableItem : public UFortAccountItem
{
public:
	TArray<struct FFortAlterationSlots>           AlterationSlots;                                   // 0x0080(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         Alterations;                                       // 0x008C(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortAlterationItemDefinition*>  AlterationInstances;                               // 0x0098(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetNumberOfSlotsForAlterationType(EFortAlteration AlterationType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterableItem">();
	}
	static class UFortAlterableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterableItem>();
	}
};
static_assert(alignof(UFortAlterableItem) == 0x000004, "Wrong alignment on UFortAlterableItem");
static_assert(sizeof(UFortAlterableItem) == 0x0000A4, "Wrong size on UFortAlterableItem");
static_assert(offsetof(UFortAlterableItem, AlterationSlots) == 0x000080, "Member 'UFortAlterableItem::AlterationSlots' has a wrong offset!");
static_assert(offsetof(UFortAlterableItem, Alterations) == 0x00008C, "Member 'UFortAlterableItem::Alterations' has a wrong offset!");
static_assert(offsetof(UFortAlterableItem, AlterationInstances) == 0x000098, "Member 'UFortAlterableItem::AlterationInstances' has a wrong offset!");

// Class FortniteGame.FortSchematicItem
// 0x0008 (0x00AC - 0x00A4)
class UFortSchematicItem final : public UFortAlterableItem
{
public:
	bool                                          bGrantedByAbility;                                 // 0x00A4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredTeamLevel;                                 // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetRequiredTeamLevelToCraft() const;
	int32 GetSchematicQuantityProduced() const;
	void GetSchematicRequirements(TArray<struct FSchematicRequirement>* Requirements) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSchematicItem">();
	}
	static class UFortSchematicItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSchematicItem>();
	}
};
static_assert(alignof(UFortSchematicItem) == 0x000004, "Wrong alignment on UFortSchematicItem");
static_assert(sizeof(UFortSchematicItem) == 0x0000AC, "Wrong size on UFortSchematicItem");
static_assert(offsetof(UFortSchematicItem, bGrantedByAbility) == 0x0000A4, "Member 'UFortSchematicItem::bGrantedByAbility' has a wrong offset!");
static_assert(offsetof(UFortSchematicItem, RequiredTeamLevel) == 0x0000A8, "Member 'UFortSchematicItem::RequiredTeamLevel' has a wrong offset!");

// Class FortniteGame.BuildingTextureData
// 0x0024 (0x0040 - 0x001C)
class UBuildingTextureData final : public UDataAsset
{
public:
	class UTexture2D*                             Diffuse;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Normal;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Specular;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTextureDataType                          Type;                                              // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             ResourceType;                                      // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResourceCost[0x4];                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTextureData">();
	}
	static class UBuildingTextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTextureData>();
	}
};
static_assert(alignof(UBuildingTextureData) == 0x000004, "Wrong alignment on UBuildingTextureData");
static_assert(sizeof(UBuildingTextureData) == 0x000040, "Wrong size on UBuildingTextureData");
static_assert(offsetof(UBuildingTextureData, Diffuse) == 0x00001C, "Member 'UBuildingTextureData::Diffuse' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Normal) == 0x000020, "Member 'UBuildingTextureData::Normal' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Specular) == 0x000024, "Member 'UBuildingTextureData::Specular' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, OverrideMaterial) == 0x000028, "Member 'UBuildingTextureData::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, Type) == 0x00002C, "Member 'UBuildingTextureData::Type' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, ResourceType) == 0x00002D, "Member 'UBuildingTextureData::ResourceType' has a wrong offset!");
static_assert(offsetof(UBuildingTextureData, ResourceCost) == 0x000030, "Member 'UBuildingTextureData::ResourceCost' has a wrong offset!");

// Class FortniteGame.BuildingTurretComponent
// 0x0034 (0x00C0 - 0x008C)
class UBuildingTurretComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnTurretTargetChanged;                             // 0x008C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           OnFireTagTrigger;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         FiringInterval;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetValidationInterval;                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPerformPeriodicValidationOnCurrentTarget : 1;     // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    TargetingOverlapComponent;                         // 0x00AC(0x0004)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OwnerASC;                                          // 0x00B0(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentTarget;                                     // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AttemptSetCurrentTarget(class AActor* NewTarget);
	void OnFiringTimer();
	void OnPerformTargetValidation();
	void OnRep_CurrentTarget(class AActor* OldTarget);
	void OnTargetingBeginOverlap(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnTargetingEndOverlap(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetTargetingOverlapComponent(class UPrimitiveComponent* NewTargetingOverlapComponent);

	class AActor* ChooseBestTarget(TArray<class AActor*>& InOutPotentialTargets) const;
	bool IsValidTarget(class AActor* InTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTurretComponent">();
	}
	static class UBuildingTurretComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTurretComponent>();
	}
};
static_assert(alignof(UBuildingTurretComponent) == 0x000004, "Wrong alignment on UBuildingTurretComponent");
static_assert(sizeof(UBuildingTurretComponent) == 0x0000C0, "Wrong size on UBuildingTurretComponent");
static_assert(offsetof(UBuildingTurretComponent, OnTurretTargetChanged) == 0x00008C, "Member 'UBuildingTurretComponent::OnTurretTargetChanged' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, OnFireTagTrigger) == 0x000098, "Member 'UBuildingTurretComponent::OnFireTagTrigger' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, FiringInterval) == 0x0000A0, "Member 'UBuildingTurretComponent::FiringInterval' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, CurrentTargetValidationInterval) == 0x0000A4, "Member 'UBuildingTurretComponent::CurrentTargetValidationInterval' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, TargetingOverlapComponent) == 0x0000AC, "Member 'UBuildingTurretComponent::TargetingOverlapComponent' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, OwnerASC) == 0x0000B0, "Member 'UBuildingTurretComponent::OwnerASC' has a wrong offset!");
static_assert(offsetof(UBuildingTurretComponent, CurrentTarget) == 0x0000B4, "Member 'UBuildingTurretComponent::CurrentTarget' has a wrong offset!");

// Class FortniteGame.FortAbilitySystemGlobals
// 0x0000 (0x0108 - 0x0108)
class UFortAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemGlobals">();
	}
	static class UFortAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemGlobals>();
	}
};
static_assert(alignof(UFortAbilitySystemGlobals) == 0x000004, "Wrong alignment on UFortAbilitySystemGlobals");
static_assert(sizeof(UFortAbilitySystemGlobals) == 0x000108, "Wrong size on UFortAbilitySystemGlobals");

// Class FortniteGame.FortQueryGenerator_Enemies
// 0x0020 (0x0054 - 0x0034)
class UFortQueryGenerator_Enemies final : public UEnvQueryGenerator
{
public:
	bool                                          bPerceivedEnemiesOnly;                             // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bSleepCapableAIUsePerceivedEnemiesOnly;            // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              MaxTimeSincePerceived;                             // 0x0038(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Enemies">();
	}
	static class UFortQueryGenerator_Enemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Enemies>();
	}
};
static_assert(alignof(UFortQueryGenerator_Enemies) == 0x000004, "Wrong alignment on UFortQueryGenerator_Enemies");
static_assert(sizeof(UFortQueryGenerator_Enemies) == 0x000054, "Wrong size on UFortQueryGenerator_Enemies");
static_assert(offsetof(UFortQueryGenerator_Enemies, bPerceivedEnemiesOnly) == 0x000034, "Member 'UFortQueryGenerator_Enemies::bPerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, bSleepCapableAIUsePerceivedEnemiesOnly) == 0x000035, "Member 'UFortQueryGenerator_Enemies::bSleepCapableAIUsePerceivedEnemiesOnly' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Enemies, MaxTimeSincePerceived) == 0x000038, "Member 'UFortQueryGenerator_Enemies::MaxTimeSincePerceived' has a wrong offset!");

// Class FortniteGame.BuildingTurretComponent_MOBA
// 0x000C (0x00CC - 0x00C0)
class UBuildingTurretComponent_MOBA final : public UBuildingTurretComponent
{
public:
	struct FMOBATurretPrioritySetting             TargetingPriority;                                 // 0x00C0(0x000C)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnAllyHarmed(class AActor* InAllyActor, class AActor* InHarmingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingTurretComponent_MOBA">();
	}
	static class UBuildingTurretComponent_MOBA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingTurretComponent_MOBA>();
	}
};
static_assert(alignof(UBuildingTurretComponent_MOBA) == 0x000004, "Wrong alignment on UBuildingTurretComponent_MOBA");
static_assert(sizeof(UBuildingTurretComponent_MOBA) == 0x0000CC, "Wrong size on UBuildingTurretComponent_MOBA");
static_assert(offsetof(UBuildingTurretComponent_MOBA, TargetingPriority) == 0x0000C0, "Member 'UBuildingTurretComponent_MOBA::TargetingPriority' has a wrong offset!");

// Class FortniteGame.FortCharacterCosmeticItemDefinition
// 0x0018 (0x0448 - 0x0430)
class UFortCharacterCosmeticItemDefinition final : public UFortAccountItemDefinition
{
public:
	EFortCharacterCosmetic                        Cosmetic_Type;                                     // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortHeroType*>                  Hero_Types_Allowed;                                // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bModifyColor;                                      // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomColorSwatch*                     ColorAlteration;                                   // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterCosmeticItemDefinition">();
	}
	static class UFortCharacterCosmeticItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterCosmeticItemDefinition>();
	}
};
static_assert(alignof(UFortCharacterCosmeticItemDefinition) == 0x000004, "Wrong alignment on UFortCharacterCosmeticItemDefinition");
static_assert(sizeof(UFortCharacterCosmeticItemDefinition) == 0x000448, "Wrong size on UFortCharacterCosmeticItemDefinition");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, Cosmetic_Type) == 0x000430, "Member 'UFortCharacterCosmeticItemDefinition::Cosmetic_Type' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, Hero_Types_Allowed) == 0x000434, "Member 'UFortCharacterCosmeticItemDefinition::Hero_Types_Allowed' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, bModifyColor) == 0x000440, "Member 'UFortCharacterCosmeticItemDefinition::bModifyColor' has a wrong offset!");
static_assert(offsetof(UFortCharacterCosmeticItemDefinition, ColorAlteration) == 0x000444, "Member 'UFortCharacterCosmeticItemDefinition::ColorAlteration' has a wrong offset!");

// Class FortniteGame.CustomCharacterPartAnimInstance
// 0x0010 (0x0320 - 0x0310)
class UCustomCharacterPartAnimInstance final : public UAnimInstance
{
public:
	uint8                                         bUsesDayPhaseChange : 1;                           // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRegisteredForDayPhaseChange : 1;                  // 0x0310(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFortCustomPartType                           PartType;                                          // 0x0314(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_315[0xB];                                      // 0x0315(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void PreDestruction();

	class AFortPlayerPawn* GetAssociatedPlayerPawn() const;
	const EFortCustomPartType GetCharacterPartType() const;
	class USkeletalMeshComponent* GetOwnerSkeletalMeshComponent() const;
	class USkeletalMeshComponent* GetPartSkeletalMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartAnimInstance">();
	}
	static class UCustomCharacterPartAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPartAnimInstance>();
	}
};
static_assert(alignof(UCustomCharacterPartAnimInstance) == 0x000004, "Wrong alignment on UCustomCharacterPartAnimInstance");
static_assert(sizeof(UCustomCharacterPartAnimInstance) == 0x000320, "Wrong size on UCustomCharacterPartAnimInstance");
static_assert(offsetof(UCustomCharacterPartAnimInstance, PartType) == 0x000314, "Member 'UCustomCharacterPartAnimInstance::PartType' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterPrimaryAssignmentGoals
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterPrimaryAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterPrimaryAssignmentGoals">();
	}
	static class UFortQueryContext_EncounterPrimaryAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterPrimaryAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterPrimaryAssignmentGoals");
static_assert(sizeof(UFortQueryContext_EncounterPrimaryAssignmentGoals) == 0x00001C, "Wrong size on UFortQueryContext_EncounterPrimaryAssignmentGoals");

// Class FortniteGame.FortAlterableItemDefinition
// 0x000C (0x043C - 0x0430)
class UFortAlterableItemDefinition : public UFortAccountItemDefinition
{
public:
	TArray<struct FFortAlterationSlots>           DefaultAlterationSlots;                            // 0x0430(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterableItemDefinition">();
	}
	static class UFortAlterableItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterableItemDefinition>();
	}
};
static_assert(alignof(UFortAlterableItemDefinition) == 0x000004, "Wrong alignment on UFortAlterableItemDefinition");
static_assert(sizeof(UFortAlterableItemDefinition) == 0x00043C, "Wrong size on UFortAlterableItemDefinition");
static_assert(offsetof(UFortAlterableItemDefinition, DefaultAlterationSlots) == 0x000430, "Member 'UFortAlterableItemDefinition::DefaultAlterationSlots' has a wrong offset!");

// Class FortniteGame.FortSchematicItemDefinition
// 0x0078 (0x04B4 - 0x043C)
class UFortSchematicItemDefinition final : public UFortAlterableItemDefinition
{
public:
	TArray<struct FSchematicRequirement>          Requirements;                                      // 0x043C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               Result;                                            // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantityProduced;                                  // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeOnUse;                                     // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x3];                                      // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              CraftingSuccessSound;                              // 0x0454(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CraftingPoints;                                    // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableCategoryHandle               LootLevelData;                                     // 0x0470(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveTable>             CraftingTimeTable;                                 // 0x0484(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CraftingTimeRowName;                               // 0x049C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSchematicDisplayName;                          // 0x04A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEvolutionRequirements>         EvolutionOptions;                                  // 0x04A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	float GetCraftingTime(int32 Level) const;
	float GetCraftingTimeForCharacter(int32 Level, const class AFortPlayerPawn* FortPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSchematicItemDefinition">();
	}
	static class UFortSchematicItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSchematicItemDefinition>();
	}
};
static_assert(alignof(UFortSchematicItemDefinition) == 0x000004, "Wrong alignment on UFortSchematicItemDefinition");
static_assert(sizeof(UFortSchematicItemDefinition) == 0x0004B4, "Wrong size on UFortSchematicItemDefinition");
static_assert(offsetof(UFortSchematicItemDefinition, Requirements) == 0x00043C, "Member 'UFortSchematicItemDefinition::Requirements' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, Result) == 0x000448, "Member 'UFortSchematicItemDefinition::Result' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, QuantityProduced) == 0x00044C, "Member 'UFortSchematicItemDefinition::QuantityProduced' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, bConsumeOnUse) == 0x000450, "Member 'UFortSchematicItemDefinition::bConsumeOnUse' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingSuccessSound) == 0x000454, "Member 'UFortSchematicItemDefinition::CraftingSuccessSound' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingPoints) == 0x00046C, "Member 'UFortSchematicItemDefinition::CraftingPoints' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, LootLevelData) == 0x000470, "Member 'UFortSchematicItemDefinition::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingTimeTable) == 0x000484, "Member 'UFortSchematicItemDefinition::CraftingTimeTable' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, CraftingTimeRowName) == 0x00049C, "Member 'UFortSchematicItemDefinition::CraftingTimeRowName' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, bUseSchematicDisplayName) == 0x0004A4, "Member 'UFortSchematicItemDefinition::bUseSchematicDisplayName' has a wrong offset!");
static_assert(offsetof(UFortSchematicItemDefinition, EvolutionOptions) == 0x0004A8, "Member 'UFortSchematicItemDefinition::EvolutionOptions' has a wrong offset!");

// Class FortniteGame.CustomCharacterPartData
// 0x0000 (0x001C - 0x001C)
class UCustomCharacterPartData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterPartData">();
	}
	static class UCustomCharacterPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterPartData>();
	}
};
static_assert(alignof(UCustomCharacterPartData) == 0x000004, "Wrong alignment on UCustomCharacterPartData");
static_assert(sizeof(UCustomCharacterPartData) == 0x00001C, "Wrong size on UCustomCharacterPartData");

// Class FortniteGame.FortAbilitySystemComponent
// 0x00A0 (0x0AA8 - 0x0A08)
class UFortAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_A08[0xA0];                                     // 0x0A08(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NetMulticast_RefreshActiveGameplayEffectCueEvents();

	struct FAttributeInfo FindAttributeInformation(const class FString& AttributeName) const;
	float GetAttributeMagnitude(const struct FAttributeInfo& Info) const;
	bool HasActiveAbilityWithAnyMatchingTag(const struct FGameplayTagContainer& Tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilitySystemComponent">();
	}
	static class UFortAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilitySystemComponent>();
	}
};
static_assert(alignof(UFortAbilitySystemComponent) == 0x000004, "Wrong alignment on UFortAbilitySystemComponent");
static_assert(sizeof(UFortAbilitySystemComponent) == 0x000AA8, "Wrong size on UFortAbilitySystemComponent");

// Class FortniteGame.CustomAccessoryColorSwatch
// 0x0030 (0x005C - 0x002C)
class UCustomAccessoryColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	struct FLinearColor                           AccessoryColors[0x3];                              // 0x002C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomAccessoryColorSwatch">();
	}
	static class UCustomAccessoryColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomAccessoryColorSwatch>();
	}
};
static_assert(alignof(UCustomAccessoryColorSwatch) == 0x000004, "Wrong alignment on UCustomAccessoryColorSwatch");
static_assert(sizeof(UCustomAccessoryColorSwatch) == 0x00005C, "Wrong size on UCustomAccessoryColorSwatch");
static_assert(offsetof(UCustomAccessoryColorSwatch, AccessoryColors) == 0x00002C, "Member 'UCustomAccessoryColorSwatch::AccessoryColors' has a wrong offset!");

// Class FortniteGame.CustomCharacterAccessoryData
// 0x0018 (0x0034 - 0x001C)
class UCustomCharacterAccessoryData : public UCustomCharacterPartData
{
public:
	class FName                                   AttachSocketName;                                  // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 AnimClass;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomAccessoryColorSwatch*            AccessoryColors;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterAccessoryData">();
	}
	static class UCustomCharacterAccessoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterAccessoryData>();
	}
};
static_assert(alignof(UCustomCharacterAccessoryData) == 0x000004, "Wrong alignment on UCustomCharacterAccessoryData");
static_assert(sizeof(UCustomCharacterAccessoryData) == 0x000034, "Wrong size on UCustomCharacterAccessoryData");
static_assert(offsetof(UCustomCharacterAccessoryData, AttachSocketName) == 0x00001C, "Member 'UCustomCharacterAccessoryData::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, PhysicsAsset) == 0x000024, "Member 'UCustomCharacterAccessoryData::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, AnimClass) == 0x000028, "Member 'UCustomCharacterAccessoryData::AnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterAccessoryData, AccessoryColors) == 0x00002C, "Member 'UCustomCharacterAccessoryData::AccessoryColors' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_CommitAccountCosts
// 0x0034 (0x0084 - 0x0050)
class UFortAbilityTask_CommitAccountCosts final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnCommitted;                                       // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWasCancellable;                                   // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bRequestPending;                                   // 0x0069(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bCommittedLocally;                                 // 0x006A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x006C(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AbilityName;                                       // 0x0078(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAbilityTask_CommitAccountCosts* CommitAccountCosts(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_CommitAccountCosts">();
	}
	static class UFortAbilityTask_CommitAccountCosts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_CommitAccountCosts>();
	}
};
static_assert(alignof(UFortAbilityTask_CommitAccountCosts) == 0x000004, "Wrong alignment on UFortAbilityTask_CommitAccountCosts");
static_assert(sizeof(UFortAbilityTask_CommitAccountCosts) == 0x000084, "Wrong size on UFortAbilityTask_CommitAccountCosts");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, OnCommitted) == 0x000050, "Member 'UFortAbilityTask_CommitAccountCosts::OnCommitted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, OnFailed) == 0x00005C, "Member 'UFortAbilityTask_CommitAccountCosts::OnFailed' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bWasCancellable) == 0x000068, "Member 'UFortAbilityTask_CommitAccountCosts::bWasCancellable' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bRequestPending) == 0x000069, "Member 'UFortAbilityTask_CommitAccountCosts::bRequestPending' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, bCommittedLocally) == 0x00006A, "Member 'UFortAbilityTask_CommitAccountCosts::bCommittedLocally' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, PlayerName) == 0x00006C, "Member 'UFortAbilityTask_CommitAccountCosts::PlayerName' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_CommitAccountCosts, AbilityName) == 0x000078, "Member 'UFortAbilityTask_CommitAccountCosts::AbilityName' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_SpecificAssignmentGoals
// 0x0028 (0x005C - 0x0034)
class UFortQueryGenerator_SpecificAssignmentGoals final : public UEnvQueryGenerator
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x0034(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFortAIGoalProvider>        GoalProvider;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_SpecificAssignmentGoals">();
	}
	static class UFortQueryGenerator_SpecificAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_SpecificAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x000004, "Wrong alignment on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(sizeof(UFortQueryGenerator_SpecificAssignmentGoals) == 0x00005C, "Wrong size on UFortQueryGenerator_SpecificAssignmentGoals");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentIdentifier) == 0x000034, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, AssignmentSettings) == 0x000054, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_SpecificAssignmentGoals, GoalProvider) == 0x000058, "Member 'UFortQueryGenerator_SpecificAssignmentGoals::GoalProvider' has a wrong offset!");

// Class FortniteGame.CustomCharacterBackpackData
// 0x0008 (0x003C - 0x0034)
class UCustomCharacterBackpackData final : public UCustomCharacterAccessoryData
{
public:
	class FName                                   LootSocketName;                                    // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterBackpackData">();
	}
	static class UCustomCharacterBackpackData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterBackpackData>();
	}
};
static_assert(alignof(UCustomCharacterBackpackData) == 0x000004, "Wrong alignment on UCustomCharacterBackpackData");
static_assert(sizeof(UCustomCharacterBackpackData) == 0x00003C, "Wrong size on UCustomCharacterBackpackData");
static_assert(offsetof(UCustomCharacterBackpackData, LootSocketName) == 0x000034, "Member 'UCustomCharacterBackpackData::LootSocketName' has a wrong offset!");

// Class FortniteGame.CustomCharacterCharmData
// 0x0004 (0x0038 - 0x0034)
class UCustomCharacterCharmData final : public UCustomCharacterAccessoryData
{
public:
	EFortCustomPartType                           PartAttachedToOverride;                            // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterCharmData">();
	}
	static class UCustomCharacterCharmData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterCharmData>();
	}
};
static_assert(alignof(UCustomCharacterCharmData) == 0x000004, "Wrong alignment on UCustomCharacterCharmData");
static_assert(sizeof(UCustomCharacterCharmData) == 0x000038, "Wrong size on UCustomCharacterCharmData");
static_assert(offsetof(UCustomCharacterCharmData, PartAttachedToOverride) == 0x000034, "Member 'UCustomCharacterCharmData::PartAttachedToOverride' has a wrong offset!");

// Class FortniteGame.FortActorIndicatorInterface
// 0x0000 (0x001C - 0x001C)
class IFortActorIndicatorInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortActorIndicatorInterface">();
	}
	static class IFortActorIndicatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortActorIndicatorInterface>();
	}
};
static_assert(alignof(IFortActorIndicatorInterface) == 0x000004, "Wrong alignment on IFortActorIndicatorInterface");
static_assert(sizeof(IFortActorIndicatorInterface) == 0x00001C, "Wrong size on IFortActorIndicatorInterface");

// Class FortniteGame.CustomCharacterFaceData
// 0x0004 (0x0038 - 0x0034)
class UCustomCharacterFaceData final : public UCustomCharacterAccessoryData
{
public:
	EFortCustomPartType                           PartAttachedToOverride;                            // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterFaceData">();
	}
	static class UCustomCharacterFaceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterFaceData>();
	}
};
static_assert(alignof(UCustomCharacterFaceData) == 0x000004, "Wrong alignment on UCustomCharacterFaceData");
static_assert(sizeof(UCustomCharacterFaceData) == 0x000038, "Wrong size on UCustomCharacterFaceData");
static_assert(offsetof(UCustomCharacterFaceData, PartAttachedToOverride) == 0x000034, "Member 'UCustomCharacterFaceData::PartAttachedToOverride' has a wrong offset!");

// Class FortniteGame.CustomCharacterHatData
// 0x0004 (0x0038 - 0x0034)
class UCustomCharacterHatData final : public UCustomCharacterAccessoryData
{
public:
	ECustomHatType                                HatType;                                           // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterHatData">();
	}
	static class UCustomCharacterHatData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterHatData>();
	}
};
static_assert(alignof(UCustomCharacterHatData) == 0x000004, "Wrong alignment on UCustomCharacterHatData");
static_assert(sizeof(UCustomCharacterHatData) == 0x000038, "Wrong size on UCustomCharacterHatData");
static_assert(offsetof(UCustomCharacterHatData, HatType) == 0x000034, "Member 'UCustomCharacterHatData::HatType' has a wrong offset!");

// Class FortniteGame.CustomCharacterBodyPartData
// 0x0008 (0x0024 - 0x001C)
class UCustomCharacterBodyPartData : public UCustomCharacterPartData
{
public:
	class UClass*                                 AnimClass;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomAccessoryColorSwatch*            AccessoryColors;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterBodyPartData">();
	}
	static class UCustomCharacterBodyPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterBodyPartData>();
	}
};
static_assert(alignof(UCustomCharacterBodyPartData) == 0x000004, "Wrong alignment on UCustomCharacterBodyPartData");
static_assert(sizeof(UCustomCharacterBodyPartData) == 0x000024, "Wrong size on UCustomCharacterBodyPartData");
static_assert(offsetof(UCustomCharacterBodyPartData, AnimClass) == 0x00001C, "Member 'UCustomCharacterBodyPartData::AnimClass' has a wrong offset!");
static_assert(offsetof(UCustomCharacterBodyPartData, AccessoryColors) == 0x000020, "Member 'UCustomCharacterBodyPartData::AccessoryColors' has a wrong offset!");

// Class FortniteGame.CustomCharacterHeadData
// 0x0038 (0x005C - 0x0024)
class UCustomCharacterHeadData final : public UCustomCharacterBodyPartData
{
public:
	class UCustomSkinColorSwatch*                 SkinColorSwatch;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomHairColorSwatch*                 HairColorSwatch;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           CapMorphTargets;                                   // 0x002C(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HelmetMorphTargets;                                // 0x0038(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MaskMorphTargets;                                  // 0x0044(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           HatMorphTargets;                                   // 0x0050(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCharacterHeadData">();
	}
	static class UCustomCharacterHeadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCharacterHeadData>();
	}
};
static_assert(alignof(UCustomCharacterHeadData) == 0x000004, "Wrong alignment on UCustomCharacterHeadData");
static_assert(sizeof(UCustomCharacterHeadData) == 0x00005C, "Wrong size on UCustomCharacterHeadData");
static_assert(offsetof(UCustomCharacterHeadData, SkinColorSwatch) == 0x000024, "Member 'UCustomCharacterHeadData::SkinColorSwatch' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HairColorSwatch) == 0x000028, "Member 'UCustomCharacterHeadData::HairColorSwatch' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, CapMorphTargets) == 0x00002C, "Member 'UCustomCharacterHeadData::CapMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HelmetMorphTargets) == 0x000038, "Member 'UCustomCharacterHeadData::HelmetMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, MaskMorphTargets) == 0x000044, "Member 'UCustomCharacterHeadData::MaskMorphTargets' has a wrong offset!");
static_assert(offsetof(UCustomCharacterHeadData, HatMorphTargets) == 0x000050, "Member 'UCustomCharacterHeadData::HatMorphTargets' has a wrong offset!");

// Class FortniteGame.FortLootLevel
// 0x0000 (0x05C0 - 0x05C0)
class UFortLootLevel final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLootLevel">();
	}
	static class UFortLootLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLootLevel>();
	}
};
static_assert(alignof(UFortLootLevel) == 0x000010, "Wrong alignment on UFortLootLevel");
static_assert(sizeof(UFortLootLevel) == 0x0005C0, "Wrong size on UFortLootLevel");

// Class FortniteGame.CustomClothingColorSwatch
// 0x0020 (0x0040 - 0x0020)
class UCustomClothingColorSwatch final : public UCustomColorSwatch
{
public:
	struct FLinearColor                           AccessoryColors[0x2];                              // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomClothingColorSwatch">();
	}
	static class UCustomClothingColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomClothingColorSwatch>();
	}
};
static_assert(alignof(UCustomClothingColorSwatch) == 0x000004, "Wrong alignment on UCustomClothingColorSwatch");
static_assert(sizeof(UCustomClothingColorSwatch) == 0x000040, "Wrong size on UCustomClothingColorSwatch");
static_assert(offsetof(UCustomClothingColorSwatch, AccessoryColors) == 0x000020, "Member 'UCustomClothingColorSwatch::AccessoryColors' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerFrontEnd
// 0x0048 (0x0C68 - 0x0C20)
class AFortPlayerControllerFrontEnd final : public AFortPlayerController
{
public:
	class UFortMenuInputHelper*                   InputHelper;                                       // 0x0C20(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCameraIsSetup;                                    // 0x0C24(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bTheaterDownloadInProgress;                        // 0x0C25(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C26[0x3E];                                     // 0x0C26(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnlockAllZones;                                   // 0x0C64(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C65[0x3];                                      // 0x0C65(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SkipTutorial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerFrontEnd">();
	}
	static class AFortPlayerControllerFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerFrontEnd>();
	}
};
static_assert(alignof(AFortPlayerControllerFrontEnd) == 0x000004, "Wrong alignment on AFortPlayerControllerFrontEnd");
static_assert(sizeof(AFortPlayerControllerFrontEnd) == 0x000C68, "Wrong size on AFortPlayerControllerFrontEnd");
static_assert(offsetof(AFortPlayerControllerFrontEnd, InputHelper) == 0x000C20, "Member 'AFortPlayerControllerFrontEnd::InputHelper' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerFrontEnd, bCameraIsSetup) == 0x000C24, "Member 'AFortPlayerControllerFrontEnd::bCameraIsSetup' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerFrontEnd, bTheaterDownloadInProgress) == 0x000C25, "Member 'AFortPlayerControllerFrontEnd::bTheaterDownloadInProgress' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerFrontEnd, bUnlockAllZones) == 0x000C64, "Member 'AFortPlayerControllerFrontEnd::bUnlockAllZones' has a wrong offset!");

// Class FortniteGame.CustomSkinColorSwatch
// 0x0000 (0x002C - 0x002C)
class UCustomSkinColorSwatch final : public UCustomDynamicColorSwatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomSkinColorSwatch">();
	}
	static class UCustomSkinColorSwatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomSkinColorSwatch>();
	}
};
static_assert(alignof(UCustomSkinColorSwatch) == 0x000004, "Wrong alignment on UCustomSkinColorSwatch");
static_assert(sizeof(UCustomSkinColorSwatch) == 0x00002C, "Wrong size on UCustomSkinColorSwatch");

// Class FortniteGame.FortPlayerControllerZone
// 0x0050 (0x0C70 - 0x0C20)
class AFortPlayerControllerZone : public AFortPlayerController
{
public:
	TArray<uint8>                                 FogOfWarMaskToReplicate;                           // 0x0C20(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FFortPlayerDeathReport                 PlayerDeathReport;                                 // 0x0C2C(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C44[0x2C];                                     // 0x0C44(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyFogOfWarReplicationStart();
	void ClientOnPawnDied(const struct FFortPlayerDeathReport& DeathReport);
	void ClientReceiveFogOfWarBunch(int32 Offset, int32 TotalSize, const TArray<uint8>& BunchData);
	void ServerRequestFogOfWarBunch(int32 Offset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerZone">();
	}
	static class AFortPlayerControllerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerZone>();
	}
};
static_assert(alignof(AFortPlayerControllerZone) == 0x000004, "Wrong alignment on AFortPlayerControllerZone");
static_assert(sizeof(AFortPlayerControllerZone) == 0x000C70, "Wrong size on AFortPlayerControllerZone");
static_assert(offsetof(AFortPlayerControllerZone, FogOfWarMaskToReplicate) == 0x000C20, "Member 'AFortPlayerControllerZone::FogOfWarMaskToReplicate' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZone, PlayerDeathReport) == 0x000C2C, "Member 'AFortPlayerControllerZone::PlayerDeathReport' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerPvP
// 0x0000 (0x0C70 - 0x0C70)
class AFortPlayerControllerPvP : public AFortPlayerControllerZone
{
public:
	void ClientReceiveKillNotification(class AFortPlayerStateZone* Killer, class AFortPlayerStateZone* Killed);
	void ClientShowGameOverWidget(EFortPvPGameResult GameResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerPvP">();
	}
	static class AFortPlayerControllerPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerPvP>();
	}
};
static_assert(alignof(AFortPlayerControllerPvP) == 0x000004, "Wrong alignment on AFortPlayerControllerPvP");
static_assert(sizeof(AFortPlayerControllerPvP) == 0x000C70, "Wrong size on AFortPlayerControllerPvP");

// Class FortniteGame.FortPlayerControllerPvPBaseDestruction
// 0x0000 (0x0C70 - 0x0C70)
class AFortPlayerControllerPvPBaseDestruction : public AFortPlayerControllerPvP
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerPvPBaseDestruction">();
	}
	static class AFortPlayerControllerPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortPlayerControllerPvPBaseDestruction) == 0x000004, "Wrong alignment on AFortPlayerControllerPvPBaseDestruction");
static_assert(sizeof(AFortPlayerControllerPvPBaseDestruction) == 0x000C70, "Wrong size on AFortPlayerControllerPvPBaseDestruction");

// Class FortniteGame.FortPlayerControllerPvPFake
// 0x0064 (0x0CD4 - 0x0C70)
class AFortPlayerControllerPvPFake final : public AFortPlayerControllerPvPBaseDestruction
{
public:
	float                                         LastRandomTurnTime;                                // 0x0C70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickLootTime;                                  // 0x0C74(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyTime;                                 // 0x0C78(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyLastSeenTime;                                 // 0x0C7C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastGoodInteraction;                               // 0x0C80(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x0C84(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastQuickbarTime;                                  // 0x0C88(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBuildOrCraftTime;                              // 0x0C8C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRespawnAttemptTime;                            // 0x0C90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBuildPending;                                  // 0x0C94(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasBuildFirePending;                              // 0x0C95(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsBuildingFloor;                                  // 0x0C96(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C97[0x1];                                      // 0x0C97(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildWaitTime;                                     // 0x0C98(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             PickedBuildingMaterial;                            // 0x0C9C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9D[0x3];                                      // 0x0C9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastJumpTime;                                      // 0x0CA0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLookInput;                                     // 0x0CA4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIPawn*                            EnemyTarget;                                       // 0x0CA8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPickup*                            PickupTarget;                                      // 0x0CAC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     LootTarget;                                        // 0x0CB0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     SearchTarget;                                      // 0x0CB4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPawnHealth;                                    // 0x0CB8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHadPawn;                                       // 0x0CBC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBD[0x3];                                      // 0x0CBD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0CC0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AFortPlayerPawn*                        MyPawn;                                            // 0x0CCC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD0[0x4];                                      // 0x0CD0(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerPvPFake">();
	}
	static class AFortPlayerControllerPvPFake* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerPvPFake>();
	}
};
static_assert(alignof(AFortPlayerControllerPvPFake) == 0x000004, "Wrong alignment on AFortPlayerControllerPvPFake");
static_assert(sizeof(AFortPlayerControllerPvPFake) == 0x000CD4, "Wrong size on AFortPlayerControllerPvPFake");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastRandomTurnTime) == 0x000C70, "Member 'AFortPlayerControllerPvPFake::LastRandomTurnTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastPickLootTime) == 0x000C74, "Member 'AFortPlayerControllerPvPFake::LastPickLootTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastPickEnemyTime) == 0x000C78, "Member 'AFortPlayerControllerPvPFake::LastPickEnemyTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, EnemyLastSeenTime) == 0x000C7C, "Member 'AFortPlayerControllerPvPFake::EnemyLastSeenTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastGoodInteraction) == 0x000C80, "Member 'AFortPlayerControllerPvPFake::LastGoodInteraction' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastCheckGoodTarget) == 0x000C84, "Member 'AFortPlayerControllerPvPFake::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastQuickbarTime) == 0x000C88, "Member 'AFortPlayerControllerPvPFake::LastQuickbarTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastBuildOrCraftTime) == 0x000C8C, "Member 'AFortPlayerControllerPvPFake::LastBuildOrCraftTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastRespawnAttemptTime) == 0x000C90, "Member 'AFortPlayerControllerPvPFake::LastRespawnAttemptTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, bHasBuildPending) == 0x000C94, "Member 'AFortPlayerControllerPvPFake::bHasBuildPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, bHasBuildFirePending) == 0x000C95, "Member 'AFortPlayerControllerPvPFake::bHasBuildFirePending' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, bIsBuildingFloor) == 0x000C96, "Member 'AFortPlayerControllerPvPFake::bIsBuildingFloor' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, BuildWaitTime) == 0x000C98, "Member 'AFortPlayerControllerPvPFake::BuildWaitTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, PickedBuildingMaterial) == 0x000C9C, "Member 'AFortPlayerControllerPvPFake::PickedBuildingMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastJumpTime) == 0x000CA0, "Member 'AFortPlayerControllerPvPFake::LastJumpTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastLookInput) == 0x000CA4, "Member 'AFortPlayerControllerPvPFake::LastLookInput' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, EnemyTarget) == 0x000CA8, "Member 'AFortPlayerControllerPvPFake::EnemyTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, PickupTarget) == 0x000CAC, "Member 'AFortPlayerControllerPvPFake::PickupTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LootTarget) == 0x000CB0, "Member 'AFortPlayerControllerPvPFake::LootTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, SearchTarget) == 0x000CB4, "Member 'AFortPlayerControllerPvPFake::SearchTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, LastPawnHealth) == 0x000CB8, "Member 'AFortPlayerControllerPvPFake::LastPawnHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, bHasHadPawn) == 0x000CBC, "Member 'AFortPlayerControllerPvPFake::bHasHadPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, ViewLocation) == 0x000CC0, "Member 'AFortPlayerControllerPvPFake::ViewLocation' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerPvPFake, MyPawn) == 0x000CCC, "Member 'AFortPlayerControllerPvPFake::MyPawn' has a wrong offset!");

// Class FortniteGame.FortItemPropertyLookupTable
// 0x05A4 (0x05C0 - 0x001C)
class UFortItemPropertyLookupTable final : public UDataAsset
{
public:
	struct FFortItemPropertyValue                 ItemPropertyValueTemplates[0x13];                  // 0x001C(0x004C)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemPropertyLookupTable">();
	}
	static class UFortItemPropertyLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemPropertyLookupTable>();
	}
};
static_assert(alignof(UFortItemPropertyLookupTable) == 0x000004, "Wrong alignment on UFortItemPropertyLookupTable");
static_assert(sizeof(UFortItemPropertyLookupTable) == 0x0005C0, "Wrong size on UFortItemPropertyLookupTable");
static_assert(offsetof(UFortItemPropertyLookupTable, ItemPropertyValueTemplates) == 0x00001C, "Member 'UFortItemPropertyLookupTable::ItemPropertyValueTemplates' has a wrong offset!");

// Class FortniteGame.FortPlayerCameraBase
// 0x0038 (0x127C - 0x1244)
class AFortPlayerCameraBase : public APlayerCameraManager
{
public:
	TArray<struct FActiveFortCamera>              CameraBlendStack;                                  // 0x1244(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortCameraInstanceEntry>       CameraInstances;                                   // 0x1250(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class UFortCameraMode>            Base3PClass;                                       // 0x125C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            Targeting3PClass;                                  // 0x1260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            OverrideCameraClass;                               // 0x1264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCinematicCamera>       CinematicCameraClass;                              // 0x1268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortCameraMode>            DeathCameraClass;                                  // 0x126C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortCameraPrototype>           CameraPrototypes;                                  // 0x1270(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerCameraBase">();
	}
	static class AFortPlayerCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerCameraBase>();
	}
};
static_assert(alignof(AFortPlayerCameraBase) == 0x000004, "Wrong alignment on AFortPlayerCameraBase");
static_assert(sizeof(AFortPlayerCameraBase) == 0x00127C, "Wrong size on AFortPlayerCameraBase");
static_assert(offsetof(AFortPlayerCameraBase, CameraBlendStack) == 0x001244, "Member 'AFortPlayerCameraBase::CameraBlendStack' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CameraInstances) == 0x001250, "Member 'AFortPlayerCameraBase::CameraInstances' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, Base3PClass) == 0x00125C, "Member 'AFortPlayerCameraBase::Base3PClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, Targeting3PClass) == 0x001260, "Member 'AFortPlayerCameraBase::Targeting3PClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, OverrideCameraClass) == 0x001264, "Member 'AFortPlayerCameraBase::OverrideCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CinematicCameraClass) == 0x001268, "Member 'AFortPlayerCameraBase::CinematicCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, DeathCameraClass) == 0x00126C, "Member 'AFortPlayerCameraBase::DeathCameraClass' has a wrong offset!");
static_assert(offsetof(AFortPlayerCameraBase, CameraPrototypes) == 0x001270, "Member 'AFortPlayerCameraBase::CameraPrototypes' has a wrong offset!");

// Class FortniteGame.FortFrontEndCameraManager
// 0x0044 (0x12C0 - 0x127C)
class AFortFrontEndCameraManager final : public AFortPlayerCameraBase
{
public:
	EFrontEndCamera                               CurrentCamera;                                     // 0x127C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127D[0x3];                                     // 0x127D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AFrontEndSettings*                      FrontEndSettings;                                  // 0x1280(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1284[0x3C];                                    // 0x1284(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCamera(EFrontEndCamera NewCamera);

	EFrontEndCamera GetCamera() const;
	class AFortCameraBase* GetCameraActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFrontEndCameraManager">();
	}
	static class AFortFrontEndCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFrontEndCameraManager>();
	}
};
static_assert(alignof(AFortFrontEndCameraManager) == 0x000004, "Wrong alignment on AFortFrontEndCameraManager");
static_assert(sizeof(AFortFrontEndCameraManager) == 0x0012C0, "Wrong size on AFortFrontEndCameraManager");
static_assert(offsetof(AFortFrontEndCameraManager, CurrentCamera) == 0x00127C, "Member 'AFortFrontEndCameraManager::CurrentCamera' has a wrong offset!");
static_assert(offsetof(AFortFrontEndCameraManager, FrontEndSettings) == 0x001280, "Member 'AFortFrontEndCameraManager::FrontEndSettings' has a wrong offset!");

// Class FortniteGame.FortPathFollowingComponent
// 0x00AC (0x02C4 - 0x0218)
class UFortPathFollowingComponent final : public UCrowdFollowingComponent
{
public:
	class AFortAIController*                      MyAI;                                              // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x10];                                     // 0x021C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementBlockBumpFrustration;                      // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementBlockFrustrationCooldownSpeed;             // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MovementBlockFrustrationThreshold;                 // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x8C];                                     // 0x0238(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPathFollowingComponent">();
	}
	static class UFortPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPathFollowingComponent>();
	}
};
static_assert(alignof(UFortPathFollowingComponent) == 0x000004, "Wrong alignment on UFortPathFollowingComponent");
static_assert(sizeof(UFortPathFollowingComponent) == 0x0002C4, "Wrong size on UFortPathFollowingComponent");
static_assert(offsetof(UFortPathFollowingComponent, MyAI) == 0x000218, "Member 'UFortPathFollowingComponent::MyAI' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockBumpFrustration) == 0x00022C, "Member 'UFortPathFollowingComponent::MovementBlockBumpFrustration' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockFrustrationCooldownSpeed) == 0x000230, "Member 'UFortPathFollowingComponent::MovementBlockFrustrationCooldownSpeed' has a wrong offset!");
static_assert(offsetof(UFortPathFollowingComponent, MovementBlockFrustrationThreshold) == 0x000234, "Member 'UFortPathFollowingComponent::MovementBlockFrustrationThreshold' has a wrong offset!");

// Class FortniteGame.FortPlayerStateZone
// 0x014C (0x0760 - 0x0614)
class AFortPlayerStateZone : public AFortPlayerState
{
public:
	uint8                                         Pad_614[0x1C];                                     // 0x0614(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedStatValues                  RS_Zone_Old[0x21];                                 // 0x0630(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	class AFortCarriedObject*                     CarriedObject;                                     // 0x0738(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OldTotalScoreStat;                                 // 0x073C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvincibleDueToUI;                                // 0x0740(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasInitializedHomebaseBuffs;                      // 0x0741(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_742[0x2];                                      // 0x0742(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentHealth;                                     // 0x0744(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0748(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentShield;                                     // 0x074C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxShield;                                         // 0x0750(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccumulatedItemEntry>          AccumulatedItems;                                  // 0x0754(0x000C)(Net, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateZone">();
	}
	static class AFortPlayerStateZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateZone>();
	}
};
static_assert(alignof(AFortPlayerStateZone) == 0x000004, "Wrong alignment on AFortPlayerStateZone");
static_assert(sizeof(AFortPlayerStateZone) == 0x000760, "Wrong size on AFortPlayerStateZone");
static_assert(offsetof(AFortPlayerStateZone, RS_Zone_Old) == 0x000630, "Member 'AFortPlayerStateZone::RS_Zone_Old' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CarriedObject) == 0x000738, "Member 'AFortPlayerStateZone::CarriedObject' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, OldTotalScoreStat) == 0x00073C, "Member 'AFortPlayerStateZone::OldTotalScoreStat' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, bInvincibleDueToUI) == 0x000740, "Member 'AFortPlayerStateZone::bInvincibleDueToUI' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, bHasInitializedHomebaseBuffs) == 0x000741, "Member 'AFortPlayerStateZone::bHasInitializedHomebaseBuffs' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CurrentHealth) == 0x000744, "Member 'AFortPlayerStateZone::CurrentHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, MaxHealth) == 0x000748, "Member 'AFortPlayerStateZone::MaxHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, CurrentShield) == 0x00074C, "Member 'AFortPlayerStateZone::CurrentShield' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, MaxShield) == 0x000750, "Member 'AFortPlayerStateZone::MaxShield' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateZone, AccumulatedItems) == 0x000754, "Member 'AFortPlayerStateZone::AccumulatedItems' has a wrong offset!");

// Class FortniteGame.FortPlayerStateKeep
// 0x0000 (0x0760 - 0x0760)
class AFortPlayerStateKeep final : public AFortPlayerStateZone
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateKeep">();
	}
	static class AFortPlayerStateKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateKeep>();
	}
};
static_assert(alignof(AFortPlayerStateKeep) == 0x000004, "Wrong alignment on AFortPlayerStateKeep");
static_assert(sizeof(AFortPlayerStateKeep) == 0x000760, "Wrong size on AFortPlayerStateKeep");

// Class FortniteGame.FortAbilityTask_DirectedMovement
// 0x0060 (0x00B0 - 0x0050)
class UFortAbilityTask_DirectedMovement final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnMovementComplete;                                // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMovementCancelled;                               // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x1C];                                      // 0x0068(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocation;                                    // 0x0084(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        TargetComponent;                                   // 0x0090(0x0004)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementDistance;                                  // 0x0094(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdealArrivalDistance;                              // 0x0098(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOfMovement;                                // 0x009C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModifyZ;                                          // 0x00A0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCancelOnFalling;                                  // 0x00A1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x00A4(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_DirectedMovement* DirectedMovement(class UObject* WorldContextObject, const struct FVector& MovementDirection, EFortDirectedMovementSpace MovementSpaceType, float MovementDistance_0, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToActor(class UObject* WorldContextObject, class AActor* TargetActor, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToComponent(class UObject* WorldContextObject, class USceneComponent* TargetComponent_0, float MaxMovementDistance, float MovementDuration, float IdealDistance, bool ModifyZ, bool bCancelOnFalling_0);
	static class UFortAbilityTask_DirectedMovement* DirectedMovementToLocation(class UObject* WorldContextObject, const struct FVector& MovementTargetLocation, EFortDirectedMovementSpace MovementSpaceType, float MovementDuration, float CloseEnoughDistance, bool ModifyZ, bool bCancelOnFalling_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_DirectedMovement">();
	}
	static class UFortAbilityTask_DirectedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_DirectedMovement>();
	}
};
static_assert(alignof(UFortAbilityTask_DirectedMovement) == 0x000004, "Wrong alignment on UFortAbilityTask_DirectedMovement");
static_assert(sizeof(UFortAbilityTask_DirectedMovement) == 0x0000B0, "Wrong size on UFortAbilityTask_DirectedMovement");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, OnMovementComplete) == 0x000050, "Member 'UFortAbilityTask_DirectedMovement::OnMovementComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, OnMovementCancelled) == 0x00005C, "Member 'UFortAbilityTask_DirectedMovement::OnMovementCancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, TargetLocation) == 0x000084, "Member 'UFortAbilityTask_DirectedMovement::TargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, TargetComponent) == 0x000090, "Member 'UFortAbilityTask_DirectedMovement::TargetComponent' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, MovementDistance) == 0x000094, "Member 'UFortAbilityTask_DirectedMovement::MovementDistance' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, IdealArrivalDistance) == 0x000098, "Member 'UFortAbilityTask_DirectedMovement::IdealArrivalDistance' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, DurationOfMovement) == 0x00009C, "Member 'UFortAbilityTask_DirectedMovement::DurationOfMovement' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, bModifyZ) == 0x0000A0, "Member 'UFortAbilityTask_DirectedMovement::bModifyZ' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, bCancelOnFalling) == 0x0000A1, "Member 'UFortAbilityTask_DirectedMovement::bCancelOnFalling' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_DirectedMovement, MovementComponent) == 0x0000A4, "Member 'UFortAbilityTask_DirectedMovement::MovementComponent' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_MoveAI
// 0x0040 (0x0090 - 0x0050)
class UFortAbilityTask_MoveAI final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupted;                                     // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCancelled;                                       // 0x0068(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x1C];                                      // 0x0074(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_MoveAI* CreateMoveAITask(class UObject* WorldContextObject, class FName TaskInstanceName, class AActor* MoveActor, const struct FVector& MoveLocation, EPawnActionMoveMode MoveMode, EPathObstacleAction PathObstacleAction, bool bStopAtEnd, bool bFinishOnPlayerCollision, float AcceptableRadius, TSubclassOf<class AFortPawn> PushBumpedPawnClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_MoveAI">();
	}
	static class UFortAbilityTask_MoveAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_MoveAI>();
	}
};
static_assert(alignof(UFortAbilityTask_MoveAI) == 0x000004, "Wrong alignment on UFortAbilityTask_MoveAI");
static_assert(sizeof(UFortAbilityTask_MoveAI) == 0x000090, "Wrong size on UFortAbilityTask_MoveAI");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnComplete) == 0x000050, "Member 'UFortAbilityTask_MoveAI::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnInterrupted) == 0x00005C, "Member 'UFortAbilityTask_MoveAI::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_MoveAI, OnCancelled) == 0x000068, "Member 'UFortAbilityTask_MoveAI::OnCancelled' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerManor
// 0x0024 (0x0C94 - 0x0C70)
class AFortPlayerControllerManor final : public AFortPlayerControllerZone
{
public:
	uint8                                         Pad_C70[0x24];                                     // 0x0C70(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOpenManorPortalUnlockMenu(class AManorPortal* ManorPortal);
	void ServerOnManorChoiceCompleted(int32 ChosenItem);
	void ServerOnUnlockPortalComplete(class AManorPortal* ManorPortal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerManor">();
	}
	static class AFortPlayerControllerManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerManor>();
	}
};
static_assert(alignof(AFortPlayerControllerManor) == 0x000004, "Wrong alignment on AFortPlayerControllerManor");
static_assert(sizeof(AFortPlayerControllerManor) == 0x000C94, "Wrong size on AFortPlayerControllerManor");

// Class FortniteGame.FortAbilityTask_WaitTargetSelection
// 0x0034 (0x0084 - 0x0050)
class UFortAbilityTask_WaitTargetSelection final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   Targeted;                                          // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Cancelled;                                         // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceTargetingOnServer;                           // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           InstantTargetTag;                                  // 0x006C(0x0008)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x10];                                      // 0x0074(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_WaitTargetSelection* WaitTargetSelection(class UObject* WorldContextObject, class FName TaskInstanceName, const struct FGameplayTag& InApplicationTag, bool bForceTargetingOnServer_0);

	void OnTargetDataCancelledCallback();
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& TargetData, const struct FGameplayTag& ApplicationTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_WaitTargetSelection">();
	}
	static class UFortAbilityTask_WaitTargetSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_WaitTargetSelection>();
	}
};
static_assert(alignof(UFortAbilityTask_WaitTargetSelection) == 0x000004, "Wrong alignment on UFortAbilityTask_WaitTargetSelection");
static_assert(sizeof(UFortAbilityTask_WaitTargetSelection) == 0x000084, "Wrong size on UFortAbilityTask_WaitTargetSelection");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, Targeted) == 0x000050, "Member 'UFortAbilityTask_WaitTargetSelection::Targeted' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, Cancelled) == 0x00005C, "Member 'UFortAbilityTask_WaitTargetSelection::Cancelled' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, ConfirmationType) == 0x000068, "Member 'UFortAbilityTask_WaitTargetSelection::ConfirmationType' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, bForceTargetingOnServer) == 0x000069, "Member 'UFortAbilityTask_WaitTargetSelection::bForceTargetingOnServer' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_WaitTargetSelection, InstantTargetTag) == 0x00006C, "Member 'UFortAbilityTask_WaitTargetSelection::InstantTargetTag' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_SetNextMontageSectionAndWait
// 0x0024 (0x0074 - 0x0050)
class UFortAbilityTask_SetNextMontageSectionAndWait final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnComplete;                                        // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupted;                                     // 0x005C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0xC];                                       // 0x0068(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAbilityTask_SetNextMontageSectionAndWait* SetNextMontageSectionAndWait(class UObject* WorldContextObject, class UAnimMontage* PlayingMontage, class FName NextMontageSection);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_SetNextMontageSectionAndWait">();
	}
	static class UFortAbilityTask_SetNextMontageSectionAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_SetNextMontageSectionAndWait>();
	}
};
static_assert(alignof(UFortAbilityTask_SetNextMontageSectionAndWait) == 0x000004, "Wrong alignment on UFortAbilityTask_SetNextMontageSectionAndWait");
static_assert(sizeof(UFortAbilityTask_SetNextMontageSectionAndWait) == 0x000074, "Wrong size on UFortAbilityTask_SetNextMontageSectionAndWait");
static_assert(offsetof(UFortAbilityTask_SetNextMontageSectionAndWait, OnComplete) == 0x000050, "Member 'UFortAbilityTask_SetNextMontageSectionAndWait::OnComplete' has a wrong offset!");
static_assert(offsetof(UFortAbilityTask_SetNextMontageSectionAndWait, OnInterrupted) == 0x00005C, "Member 'UFortAbilityTask_SetNextMontageSectionAndWait::OnInterrupted' has a wrong offset!");

// Class FortniteGame.FortMetaNavArea
// 0x000C (0x0040 - 0x0034)
class UFortMetaNavArea : public UNavAreaMeta
{
public:
	TArray<struct FNavAgentData>                  AgentData;                                         // 0x0034(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea">();
	}
	static class UFortMetaNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea>();
	}
};
static_assert(alignof(UFortMetaNavArea) == 0x000004, "Wrong alignment on UFortMetaNavArea");
static_assert(sizeof(UFortMetaNavArea) == 0x000040, "Wrong size on UFortMetaNavArea");
static_assert(offsetof(UFortMetaNavArea, AgentData) == 0x000034, "Member 'UFortMetaNavArea::AgentData' has a wrong offset!");

// Class FortniteGame.FortAbilityTask_Sprint
// 0x000C (0x005C - 0x0050)
class UFortAbilityTask_Sprint final : public UAbilityTask
{
public:
	UMulticastDelegateProperty_                   OnTargetLocationReached;                           // 0x0050(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityTask_Sprint">();
	}
	static class UFortAbilityTask_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityTask_Sprint>();
	}
};
static_assert(alignof(UFortAbilityTask_Sprint) == 0x000004, "Wrong alignment on UFortAbilityTask_Sprint");
static_assert(sizeof(UFortAbilityTask_Sprint) == 0x00005C, "Wrong size on UFortAbilityTask_Sprint");
static_assert(offsetof(UFortAbilityTask_Sprint, OnTargetLocationReached) == 0x000050, "Member 'UFortAbilityTask_Sprint::OnTargetLocationReached' has a wrong offset!");

// Class FortniteGame.FortAIAssignmentSettings
// 0x0048 (0x0064 - 0x001C)
class UFortAIAssignmentSettings final : public UDataAsset
{
public:
	TArray<struct FGoalSelectionQueryInfo>        GoalSelectionQueryInfos;                           // 0x001C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bAllowsUndermining;                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bGoalLocationsAlwaysKnown;                         // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bIsEnemyAssignment;                                // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x002C(0x0018)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ProhibitedTags;                                    // 0x0044(0x0018)(Edit, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedForAssignment;                         // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAIAllowedPerGoal;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignmentSettings">();
	}
	static class UFortAIAssignmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignmentSettings>();
	}
};
static_assert(alignof(UFortAIAssignmentSettings) == 0x000004, "Wrong alignment on UFortAIAssignmentSettings");
static_assert(sizeof(UFortAIAssignmentSettings) == 0x000064, "Wrong size on UFortAIAssignmentSettings");
static_assert(offsetof(UFortAIAssignmentSettings, GoalSelectionQueryInfos) == 0x00001C, "Member 'UFortAIAssignmentSettings::GoalSelectionQueryInfos' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bAllowsUndermining) == 0x000028, "Member 'UFortAIAssignmentSettings::bAllowsUndermining' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bGoalLocationsAlwaysKnown) == 0x000029, "Member 'UFortAIAssignmentSettings::bGoalLocationsAlwaysKnown' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, bIsEnemyAssignment) == 0x00002A, "Member 'UFortAIAssignmentSettings::bIsEnemyAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, RequiredTags) == 0x00002C, "Member 'UFortAIAssignmentSettings::RequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, ProhibitedTags) == 0x000044, "Member 'UFortAIAssignmentSettings::ProhibitedTags' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedForAssignment) == 0x00005C, "Member 'UFortAIAssignmentSettings::MaxAIAllowedForAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignmentSettings, MaxAIAllowedPerGoal) == 0x000060, "Member 'UFortAIAssignmentSettings::MaxAIAllowedPerGoal' has a wrong offset!");

// Class FortniteGame.FortAIAssignment
// 0x007C (0x0098 - 0x001C)
class UFortAIAssignment final : public UObject
{
public:
	struct FFortAIAssignmentIdentifier            AssignmentIdentifier;                              // 0x001C(0x0020)(Protected, NativeAccessSpecifierProtected)
	class UFortAIAssignmentSettings*              AssignmentSettings;                                // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIGoalProvider*                    GoalProvider;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortAIController*>              ControllersOnAssignment;                           // 0x0044(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x3C];                                      // 0x0050(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortAIGoal>                    Goals;                                             // 0x008C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAssignment">();
	}
	static class UFortAIAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAssignment>();
	}
};
static_assert(alignof(UFortAIAssignment) == 0x000004, "Wrong alignment on UFortAIAssignment");
static_assert(sizeof(UFortAIAssignment) == 0x000098, "Wrong size on UFortAIAssignment");
static_assert(offsetof(UFortAIAssignment, AssignmentIdentifier) == 0x00001C, "Member 'UFortAIAssignment::AssignmentIdentifier' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, AssignmentSettings) == 0x00003C, "Member 'UFortAIAssignment::AssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, GoalProvider) == 0x000040, "Member 'UFortAIAssignment::GoalProvider' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, ControllersOnAssignment) == 0x000044, "Member 'UFortAIAssignment::ControllersOnAssignment' has a wrong offset!");
static_assert(offsetof(UFortAIAssignment, Goals) == 0x00008C, "Member 'UFortAIAssignment::Goals' has a wrong offset!");

// Class FortniteGame.FortMissionLibrary
// 0x0000 (0x001C - 0x001C)
class UFortMissionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CreateDynamicBuildingDeconstructor(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& BoxExtent, bool bIgnoreMissionActors, bool bShrinkAndDestroy);
	static struct FFortMissionEvent CreateMissionEvent(class UObject* WorldContextObject, class FName EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static void ExecuteMissionEvent(class UObject* WorldContextObject, class FName EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static void ExecuteMissionEventEx(class UObject* WorldContextObject, const struct FFortMissionEventName& EventType, const struct FGuid& MissionGuid, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static TArray<class ABuildingActor*> FindActorsWithTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& Tags);
	static class AFortPlacementActor* FindOriginatingPlacementActor(class ABuildingActor* BuildingActor);
	static TArray<class AFortMission*> GetAllLoadedMissions(class UObject* WorldContextObject);
	static class AFortBluGloManager* GetBluGloManager(class UObject* WorldContextObject);
	static class AFortMission* GetMissionFromGuid(class UObject* WorldContextObject, const struct FGuid& MissionGuid);
	static void GiveMissionRewardsToPlayer(class UObject* WorldContextObject, const struct FGuid& EventGuid, class AFortPlayerController* PlayerController, const class FText& TitleText, const class FText& DescriptionText, class FName LootTierGroup, int32 LootTier, float RewardDisplayTime);
	static void GiveMissionRewardsToPlayerAsPickups(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class AFortPlayerController* PlayerController, const struct FVector& StartPosition, float Radius, class FName LootTierGroup, int32 LootTier);
	static bool GiveMissionSchematicItemDirectlyToPlayer(class UObject* WorldContextObject, class AFortPlayerController* TargetPlayer, const struct FGuid& MissionGuid, class UFortSchematicItemDefinition* SchematicDefinition);
	static bool HasTags(const struct FGameplayTagContainer& ContainerToCheck, const struct FGameplayTagContainer& TagsToCheck, bool bRequireAll, bool bCountEmptyAsMatch);
	static bool IsUsingNewMissionGeneration(class UObject* WorldContextObject);
	static void LoadMission(class UObject* WorldContextObject, class UFortMissionInfo* MissionInfo);
	static int32 NumBluGloFromPlayerPawn(class AFortPlayerPawn* PlayerPawn);
	static int32 NumBluGloFromPlayerState(class AFortPlayerStateZone* PlayerState);
	static void PingMinimap(class UObject* WorldContextObject, const struct FVector& WorldLocation, const struct FLinearColor& PingColor);
	static int32 PollActorsInVolume(class UObject* WorldContextObject, class UBoxComponent* VolumeBoxComponent, EPollActorsInVolumeTypes PollBuildingTypes, TSubclassOf<class AActor> ActorClassToPoll);
	static bool RegisterForMissionEvents(class AActor* ActorToRegister, const struct FGuid& MissionGuid);
	static void RegisterMissionInfoUIActor(class AActor* AttachmentActor, const struct FGuid& MissionGuid, const struct FVector& AttachementOffset, float MaxVisibleDistance);
	static void SetOnlinePresenceDoNotDisturb(class UObject* WorldContextObject, bool bDoNotDisturb, class AFortPlayerController* SpecificPlayer);
	static bool ShouldUseAlternateAIDirectorBalance();
	static TArray<class AActor*> SpawnAtPlacementActorsHelper(class UObject* WorldContextObject, class UClass* Entries, bool* bSucceeded);
	static class ABuildingActor* SpawnBuildingActorAtTransform(class UObject* WorldContextObject, const struct FGuid& MissionGuid, TSubclassOf<class ABuildingActor> BuildingClass, const struct FTransform& Transform);
	static class AFortPickup* SpawnMissionItemPickup(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class UFortMissionItemDefinition* MissionItemDefinition, const struct FVector& StartPosition, class AFortPawn* TargetPawn);
	static class AFortPickup* SpawnMissionItemPickupInWorld(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToSpawn, const struct FVector& Position, const struct FVector& Direction, int32 OverrideMaxStackCount);
	static class UFortAIEncounterInfo* StartAIEncounter(class UObject* WorldContextObject, class FString* AssociatedMissionName, TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	static class UFortAIEncounterInfo* StartAIEncounterWithEnvironmentQuery(class UObject* WorldContextObject, class FString* AssociatedMissionName, TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, class AActor* TargetActor, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	static void StartNotification(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class AFortClientNotification> Notification, class AFortPlayerController* SpecificPlayer, const class FText& OverrideTitleText, const class FText& OverrideDisplayText, float OverrideDisplayTime, class AFortPlayerPawn* OptionalPlayerPawn1, class AFortPlayerPawn* OptionalPlayerPawn2, class FName OptionalActionName, const class USoundBase* OptionalSound, bool bPlaySoundAsFeedback, bool bTreatAsUnique, bool bCancelActiveNotification, bool bWaitForClients);
	static void StartPlayingMission(class UObject* WorldContextObject, const struct FGuid& MissionGuid, class UFortMissionEventParams* Params_0, class UObject* EventFocus, class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags);
	static void StartTutorialNotification(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSubclassOf<class AFortClientNotification> Notification, class AFortPlayerController* SpecificPlayer, class AFortPlayerPawn* OptionalPlayerPawn1, class AFortPlayerPawn* OptionalPlayerPawn2, const class FText& OverrideTitleText, const class FText& OverrideDisplayText, const class FText& OverrideSystemText, const class FText& OverrideNameText, float OverrideDisplayTime, bool bOverrideButtonEnabled, bool bOverrideLightboxEnabled, bool bOverrideLightboxDisableInputOnly, EVerticalAlignment OverrideVAlign, EHorizontalAlignment OverrideHAlign, const struct FMargin& OverridePadding, const class USoundBase* OptionalSound, bool bWaitForClients);
	static void StopAIEncounter(class UObject* WorldContextObject, class UFortAIEncounterInfo* ActiveEncounter);
	static void StopAIEncounterAgainstActor(class UObject* WorldContextObject, class AActor* TargetActor);
	static void TeleportPawnNearLocation(class AFortPawn* Pawn, const struct FVector& DestLocation);
	static void TeleportPlayerPawn(class AFortPlayerPawn* PlayerPawn, const struct FVector& DestLocation, const struct FRotator& DestRotation);
	static bool UnregisterForMissionEvents(class AActor* ActorToUnregister, const struct FGuid& MissionGuid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionLibrary">();
	}
	static class UFortMissionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionLibrary>();
	}
};
static_assert(alignof(UFortMissionLibrary) == 0x000004, "Wrong alignment on UFortMissionLibrary");
static_assert(sizeof(UFortMissionLibrary) == 0x00001C, "Wrong size on UFortMissionLibrary");

// Class FortniteGame.FortAIController
// 0x0098 (0x0368 - 0x02D0)
class AFortAIController final : public AAIController
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUsingNavMesh : 1;                                 // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysNotifyBumpWall : 1;                         // 0x02D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bInstantRotation : 1;                              // 0x02D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTurnTransitionsEnabled : 1;                       // 0x02D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortPathFollowingComponent*            FortPathFollowingComp;                             // 0x02DC(0x0004)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIHotSpotSlotInfo                     CurrentHotSpot;                                    // 0x02EC(0x0008)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         GoalInfoUpdateRate;                                // 0x02F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x02F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GoalVisibilityPersistanceTime;                     // 0x02FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x58];                                     // 0x0300(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            MyFortPawn;                                        // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0xC];                                      // 0x035C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsIgnoringProximity(class AFortAIController* FortAIController);

	bool CreateBuildingActor(TSubclassOf<class ABuildingSMActor> BuildingClass, const struct FVector& BuildLoc, const struct FRotator& BuildRot, bool bMirrored);
	struct FVector GetBestKnownActorLocation(class AActor* ActorInQuestion, float* LastStimulusAge);
	class ABuildingSMActor* GetClosestSupportingBuildingActor(class ABuildingSMActor* BuildingSMActor);
	class AActor* GetTargetActor();
	void IgnoreProximityForDuration(float DurationToIgnore);
	bool IsAllowedToSleep();
	void LockBehaviorResource();
	void LockMovementResource();
	void OnBuildingActorGoalDestroyed();
	void SendAnimNotification(const class FString& EventName);
	void SetAlwaysGameplayRelevant(bool bInAlwaysGameplayRelevant);
	void SetGoalActor(class AActor* InActor, bool bLocationAlwaysKnown);
	void SetIsSleeping(bool bNewSleepStatus);
	void SetPawnAIType(EFortressAIType NewAIType, class AActor* SpawnSpot);
	void SetTeam(EFortTeam InTeam);
	void SetupCustomVIM(class UClass* VIM);
	void UnlockBehaviorResource();
	void UnlockMovementResource();
	void UnregisterForGoalDetection();
	void WakeUp();

	class AActor* GetGoalActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIController">();
	}
	static class AFortAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIController>();
	}
};
static_assert(alignof(AFortAIController) == 0x000004, "Wrong alignment on AFortAIController");
static_assert(sizeof(AFortAIController) == 0x000368, "Wrong size on AFortAIController");
static_assert(offsetof(AFortAIController, FortPathFollowingComp) == 0x0002DC, "Member 'AFortAIController::FortPathFollowingComp' has a wrong offset!");
static_assert(offsetof(AFortAIController, TargetActor) == 0x0002E8, "Member 'AFortAIController::TargetActor' has a wrong offset!");
static_assert(offsetof(AFortAIController, CurrentHotSpot) == 0x0002EC, "Member 'AFortAIController::CurrentHotSpot' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalInfoUpdateRate) == 0x0002F4, "Member 'AFortAIController::GoalInfoUpdateRate' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalActor) == 0x0002F8, "Member 'AFortAIController::GoalActor' has a wrong offset!");
static_assert(offsetof(AFortAIController, GoalVisibilityPersistanceTime) == 0x0002FC, "Member 'AFortAIController::GoalVisibilityPersistanceTime' has a wrong offset!");
static_assert(offsetof(AFortAIController, MyFortPawn) == 0x000358, "Member 'AFortAIController::MyFortPawn' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_Ability
// 0x0038 (0x0054 - 0x001C)
class UFortAIDataProvider_Ability : public UAIDataProvider
{
public:
	struct FGameplayTagContainer                  AbilityTag;                                        // 0x001C(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityBehaviorDistanceTag;                        // 0x0034(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         BehaviorDistance;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetSelectionRange;                           // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_Ability">();
	}
	static class UFortAIDataProvider_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_Ability>();
	}
};
static_assert(alignof(UFortAIDataProvider_Ability) == 0x000004, "Wrong alignment on UFortAIDataProvider_Ability");
static_assert(sizeof(UFortAIDataProvider_Ability) == 0x000054, "Wrong size on UFortAIDataProvider_Ability");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityTag) == 0x00001C, "Member 'UFortAIDataProvider_Ability::AbilityTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, AbilityBehaviorDistanceTag) == 0x000034, "Member 'UFortAIDataProvider_Ability::AbilityBehaviorDistanceTag' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, BehaviorDistance) == 0x00004C, "Member 'UFortAIDataProvider_Ability::BehaviorDistance' has a wrong offset!");
static_assert(offsetof(UFortAIDataProvider_Ability, MaxTargetSelectionRange) == 0x000050, "Member 'UFortAIDataProvider_Ability::MaxTargetSelectionRange' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_GoalProviderAbility
// 0x0000 (0x0054 - 0x0054)
class UFortAIDataProvider_GoalProviderAbility final : public UFortAIDataProvider_Ability
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_GoalProviderAbility">();
	}
	static class UFortAIDataProvider_GoalProviderAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_GoalProviderAbility>();
	}
};
static_assert(alignof(UFortAIDataProvider_GoalProviderAbility) == 0x000004, "Wrong alignment on UFortAIDataProvider_GoalProviderAbility");
static_assert(sizeof(UFortAIDataProvider_GoalProviderAbility) == 0x000054, "Wrong size on UFortAIDataProvider_GoalProviderAbility");

// Class FortniteGame.FortMcpProfileWorld
// 0x0068 (0x0198 - 0x0130)
class UFortMcpProfileWorld final : public UFortMcpProfile
{
public:
	struct FFortWorldPlayerLoadout                CachedPlayerLoadout;                               // 0x0130(0x0054)(Protected, NativeAccessSpecifierProtected)
	class AFortInventory*                         FortInventory;                                     // 0x0184(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortWorldProfileUpdateRequest> UpdateRequests;                                    // 0x0188(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPendingReset;                                     // 0x0194(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortDisintegration(struct FDedicatedServerUrlContext* Context);
	void BatchUpdateInventory(const struct FMcpProfileChangeRequest& BatchUpdate, struct FDedicatedServerUrlContext* Context);
	void CreateOrUpgradeOutpostItem(const class FString& TemplateId, struct FDedicatedServerUrlContext* Context);
	void DepositPostResources(const TArray<class FString>& itemsToDepositIds, const TArray<int32>& itemCountsToDeposit, struct FDedicatedServerUrlContext* Context);
	void DisintegrateItems(const TArray<class FString>& itemsToDisintegrateIds, const TArray<int32>& itemCountsToDisintegrate, struct FDedicatedServerUrlContext* Context);
	void FabricateItem(const class FString& TemplateId, struct FDedicatedServerUrlContext* Context);
	void IncreaseOutpostPrestige(struct FDedicatedServerUrlContext* Context);
	void InitializeTheater(const class FString& TheaterGuid, struct FDedicatedServerUrlContext* Context);
	void MarkOutpostDefended(struct FDedicatedServerUrlContext* Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMcpProfileWorld">();
	}
	static class UFortMcpProfileWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMcpProfileWorld>();
	}
};
static_assert(alignof(UFortMcpProfileWorld) == 0x000004, "Wrong alignment on UFortMcpProfileWorld");
static_assert(sizeof(UFortMcpProfileWorld) == 0x000198, "Wrong size on UFortMcpProfileWorld");
static_assert(offsetof(UFortMcpProfileWorld, CachedPlayerLoadout) == 0x000130, "Member 'UFortMcpProfileWorld::CachedPlayerLoadout' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, FortInventory) == 0x000184, "Member 'UFortMcpProfileWorld::FortInventory' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, UpdateRequests) == 0x000188, "Member 'UFortMcpProfileWorld::UpdateRequests' has a wrong offset!");
static_assert(offsetof(UFortMcpProfileWorld, bPendingReset) == 0x000194, "Member 'UFortMcpProfileWorld::bPendingReset' has a wrong offset!");

// Class FortniteGame.FortAIDataProvider_AIDirector
// 0x0004 (0x0020 - 0x001C)
class UFortAIDataProvider_AIDirector final : public UAIDataProvider
{
public:
	float                                         AIRelevantDistanceToPlayer;                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDataProvider_AIDirector">();
	}
	static class UFortAIDataProvider_AIDirector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIDataProvider_AIDirector>();
	}
};
static_assert(alignof(UFortAIDataProvider_AIDirector) == 0x000004, "Wrong alignment on UFortAIDataProvider_AIDirector");
static_assert(sizeof(UFortAIDataProvider_AIDirector) == 0x000020, "Wrong size on UFortAIDataProvider_AIDirector");
static_assert(offsetof(UFortAIDataProvider_AIDirector, AIRelevantDistanceToPlayer) == 0x00001C, "Member 'UFortAIDataProvider_AIDirector::AIRelevantDistanceToPlayer' has a wrong offset!");

// Class FortniteGame.FortMission
// 0x0164 (0x03A8 - 0x0244)
class AFortMission : public AFortMissionState
{
public:
	uint8                                         Pad_244[0x8];                                      // 0x0244(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMissionInfo*                       MissionInfo;                                       // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortMissionGenerator*                  MissionGenerator;                                  // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionGenerationCategory                    MissionCategory;                                   // 0x0254(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIIndex;                                           // 0x0258(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionEventName>          MissionEventNames;                                 // 0x025C(0x000C)(ZeroConstructor, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	bool                                          bLoadedFromRecord;                                 // 0x0268(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MissionActivationTime;                             // 0x026C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSilentDestroyNextFrame;                           // 0x0270(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortObjectiveBase*>             ActiveObjectives;                                  // 0x0274(0x000C)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EFortMissionStatus                            MissionStatus;                                     // 0x0280(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ObjectiveCompletionTags;                           // 0x0284(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UFortBadgeItemDefinition*>       AwardedBadges;                                     // 0x029C(0x000C)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsMissionVisible;                                 // 0x02A8(0x0001)(Net, ZeroConstructor, SaveGame, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentObjectiveBlockIndex;                        // 0x02AC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMissionVisibleOverride;                         // 0x02B0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MissionGuid;                                       // 0x02B4(0x0010)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         StartingDay;                                       // 0x02C4(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMissionTimerComponent*             TimerComponent;                                    // 0x02C8(0x0004)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChosenRewardIdx;                                   // 0x02D0(0x0004)(Net, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x94];                                     // 0x02D4(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGeneratedDifficultyOptions        GeneratedMissionOptions;                           // 0x0368(0x0034)(Protected, NativeAccessSpecifierProtected)
	struct FFortMissionInstancedConfigData        ConfigData;                                        // 0x039C(0x000C)(Transient, NativeAccessSpecifierPrivate)

public:
	static TArray<class AActor*> SpawnAtPlacementActorsAsArray(class AFortMission* Mission, bool* bSucceeded);

	void AddGoalsToAssignment(class UFortAIAssignment* Assignment, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	void AddGoalsToEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	void AddGoalToAssignment(class UFortAIAssignment* Assignment, const struct FFortAIGoalInfo& GoalInfo);
	void AddGoalToEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const struct FFortAIGoalInfo& GoalInfo);
	void AttemptMissionSave(const class FString& OptionalSaveName);
	void BlueprintCustomHandleMissionEvent(const struct FGuid& MissionGuid_0, const struct FGameplayTagContainer& ObjectiveHandle, class UFortMissionEventParams* Params_0, bool DO_NOT_USE_THIS_OR_VARIABLES_BELOW, class UObject* EventFocus, const class UDataAsset* EventContent, class AActor* EventInstigator, int32 GenericInt, float GenericFloat, const class FText& GenericText, const struct FGameplayTagContainer& GameplayTags, const struct FFortMissionEvent& MissionEvent);
	void BlueprintHandleMissionEventNoReply(const struct FFortMissionEvent& MissionEvent);
	void BlueprintOnActivated(const struct FFortMissionEvent& MissionEvent);
	void BlueprintOnMissionEnd(EFortMissionStatus Status);
	void BlueprintOnStartPlaying(const struct FFortMissionEvent& MissionEvent);
	void BlueprintPostMissionLoad();
	struct FFortMissionWeightedReward ChooseRandomReward();
	EAssignmentCreationResult CreateEncounterAssignment(const struct FGameplayTagContainer& AssignmentTags, const class UFortAIEncounterInfo*& Encounter, class UFortAIAssignmentSettings* AssignmentSettings, TSubclassOf<class UFortAIGoalProvider> GoalProvider, struct FFortAIAssignmentIdentifier* AssignmentIdentifier);
	class UFortAIEncounterSequence* CreateEncounterSequence(const struct FGameplayTagContainer& SequenceTags);
	void FindGoalLocationsForEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, TArray<struct FVector>* OutGoalLocations);
	void FocusThisMission(bool bTemporaryFocus);
	class UFortMissionConfigData* GetConfigData(const struct FGameplayTag& InBucketTag);
	void GrantRewardsByTag(const struct FGameplayTag& RewardTag, EFortRewardType RewardType);
	void OnMatchStarted();
	void OnRep_bIsMissionVisible();
	void OnRep_UIIndex();
	void OnWorldReady();
	void RemoveEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter);
	void RemoveGoalFromEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const struct FFortAIGoalInfo& GoalInfo);
	void RemoveGoalsFromEncounterAssignment(const struct FFortAIAssignmentIdentifier& AssignmentIdentifier, const class UFortAIEncounterInfo*& Encounter, const TArray<struct FFortAIGoalInfo>& GoalInfos);
	void SetToSilentDestroy();
	void SetUiVisibility(bool bInIsMissionVisible);
	class UFortAIEncounterInfo* StartMissionAIEncounter(TSubclassOf<class UFortAIEncounterInfo> EncounterTemplate, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	class UFortAIEncounterInfo* StartMissionAIEncounterFromGeneratedProfile(int32 GeneratedEncounterProfileIndex, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& EnvironmentQueryInfo, class AActor* QueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	void StartMissionNotification(const struct FLatentActionInfo& LatentInfo, TSubclassOf<class AFortClientNotification> Notification, class AFortPlayerController* SpecificPlayer, const class FText& OverrideDisplayText, class AFortPlayerPawn* OptionalPlayerPawn1, class AFortPlayerPawn* OptionalPlayerPawn2, class FName OptionalActionName, const class USoundBase* OptionalSound, bool bTreatAsUnique, bool bCancelActiveNotification, bool bWaitForClients);
	void StopEncounterSequence(class UFortAIEncounterSequence* SequenceToStop);
	void StopMissionAIEncounter(class UFortAIEncounterInfo* EncounterToStop);

	int32 GetBuildingDamageLootTier(class AFortPlayerController* PlayerController) const;
	int32 GetCurrentBluGloRewards() const;
	void GetDefaultAssignmentForEncounter(class UFortAIEncounterInfo* Encounter, class UFortAIAssignment** DefaultAssignment) const;
	float GetExpectedCompletionTime() const;
	TArray<class AFortPlayerController*> GetMissionFortPlayerControllers() const;
	struct FGuid GetMissionGuid() const;
	class AFortObjectiveBase* GetObjectiveByHandle(const struct FGameplayTagContainer& ObjectiveHandle) const;
	EFortObjectiveStatus GetObjectiveStatusByHandle(const struct FGameplayTagContainer& ObjectiveHandle) const;
	int32 GetPawnDamageLootTier(class AFortPlayerController* PlayerController) const;
	float GetPlayerBuildingDamage(class AFortPlayerController* PlayerController) const;
	float GetPlayerPawnDamage(class AFortPlayerController* PlayerController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMission">();
	}
	static class AFortMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMission>();
	}
};
static_assert(alignof(AFortMission) == 0x000004, "Wrong alignment on AFortMission");
static_assert(sizeof(AFortMission) == 0x0003A8, "Wrong size on AFortMission");
static_assert(offsetof(AFortMission, MissionInfo) == 0x00024C, "Member 'AFortMission::MissionInfo' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionGenerator) == 0x000250, "Member 'AFortMission::MissionGenerator' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionCategory) == 0x000254, "Member 'AFortMission::MissionCategory' has a wrong offset!");
static_assert(offsetof(AFortMission, UIIndex) == 0x000258, "Member 'AFortMission::UIIndex' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionEventNames) == 0x00025C, "Member 'AFortMission::MissionEventNames' has a wrong offset!");
static_assert(offsetof(AFortMission, bLoadedFromRecord) == 0x000268, "Member 'AFortMission::bLoadedFromRecord' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionActivationTime) == 0x00026C, "Member 'AFortMission::MissionActivationTime' has a wrong offset!");
static_assert(offsetof(AFortMission, bSilentDestroyNextFrame) == 0x000270, "Member 'AFortMission::bSilentDestroyNextFrame' has a wrong offset!");
static_assert(offsetof(AFortMission, ActiveObjectives) == 0x000274, "Member 'AFortMission::ActiveObjectives' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionStatus) == 0x000280, "Member 'AFortMission::MissionStatus' has a wrong offset!");
static_assert(offsetof(AFortMission, ObjectiveCompletionTags) == 0x000284, "Member 'AFortMission::ObjectiveCompletionTags' has a wrong offset!");
static_assert(offsetof(AFortMission, AwardedBadges) == 0x00029C, "Member 'AFortMission::AwardedBadges' has a wrong offset!");
static_assert(offsetof(AFortMission, bIsMissionVisible) == 0x0002A8, "Member 'AFortMission::bIsMissionVisible' has a wrong offset!");
static_assert(offsetof(AFortMission, CurrentObjectiveBlockIndex) == 0x0002AC, "Member 'AFortMission::CurrentObjectiveBlockIndex' has a wrong offset!");
static_assert(offsetof(AFortMission, bIsMissionVisibleOverride) == 0x0002B0, "Member 'AFortMission::bIsMissionVisibleOverride' has a wrong offset!");
static_assert(offsetof(AFortMission, MissionGuid) == 0x0002B4, "Member 'AFortMission::MissionGuid' has a wrong offset!");
static_assert(offsetof(AFortMission, StartingDay) == 0x0002C4, "Member 'AFortMission::StartingDay' has a wrong offset!");
static_assert(offsetof(AFortMission, TimerComponent) == 0x0002C8, "Member 'AFortMission::TimerComponent' has a wrong offset!");
static_assert(offsetof(AFortMission, ChosenRewardIdx) == 0x0002D0, "Member 'AFortMission::ChosenRewardIdx' has a wrong offset!");
static_assert(offsetof(AFortMission, GeneratedMissionOptions) == 0x000368, "Member 'AFortMission::GeneratedMissionOptions' has a wrong offset!");
static_assert(offsetof(AFortMission, ConfigData) == 0x00039C, "Member 'AFortMission::ConfigData' has a wrong offset!");

// Class FortniteGame.FortPvPMission
// 0x0008 (0x03B0 - 0x03A8)
class AFortPvPMission : public AFortMission
{
public:
	class AFortPlayerStatePvP*                    WinningPlayerState;                                // 0x03A8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortTeamInfo*                          WinningTeam;                                       // 0x03AC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission">();
	}
	static class AFortPvPMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission>();
	}
};
static_assert(alignof(AFortPvPMission) == 0x000004, "Wrong alignment on AFortPvPMission");
static_assert(sizeof(AFortPvPMission) == 0x0003B0, "Wrong size on AFortPvPMission");
static_assert(offsetof(AFortPvPMission, WinningPlayerState) == 0x0003A8, "Member 'AFortPvPMission::WinningPlayerState' has a wrong offset!");
static_assert(offsetof(AFortPvPMission, WinningTeam) == 0x0003AC, "Member 'AFortPvPMission::WinningTeam' has a wrong offset!");

// Class FortniteGame.FortPvPMission_EnemyBaseDestruction
// 0x0000 (0x03B0 - 0x03B0)
class AFortPvPMission_EnemyBaseDestruction final : public AFortPvPMission
{
public:
	class AFortPvPBaseCornerstone* GetCornerstoneForTeam(EFortTeam InTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_EnemyBaseDestruction">();
	}
	static class AFortPvPMission_EnemyBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_EnemyBaseDestruction>();
	}
};
static_assert(alignof(AFortPvPMission_EnemyBaseDestruction) == 0x000004, "Wrong alignment on AFortPvPMission_EnemyBaseDestruction");
static_assert(sizeof(AFortPvPMission_EnemyBaseDestruction) == 0x0003B0, "Wrong size on AFortPvPMission_EnemyBaseDestruction");

// Class FortniteGame.FortPatrolWardInterface
// 0x0000 (0x001C - 0x001C)
class IFortPatrolWardInterface final : public IInterface
{
public:
	float GetAffectingDistance() const;
	EWardAffectType GetAffectingType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPatrolWardInterface">();
	}
	static class IFortPatrolWardInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPatrolWardInterface>();
	}
};
static_assert(alignof(IFortPatrolWardInterface) == 0x000004, "Wrong alignment on IFortPatrolWardInterface");
static_assert(sizeof(IFortPatrolWardInterface) == 0x00001C, "Wrong size on IFortPatrolWardInterface");

// Class FortniteGame.FortAIDirectorDataManager
// 0x00B4 (0x02F4 - 0x0240)
class AFortAIDirectorDataManager final : public AActor
{
public:
	class UObject*                                OwnerObject;                                       // 0x0240(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAIDirectorEventData>           EventsToTrack;                                     // 0x0244(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAIDirectorFactorData>      FactorsToTrack;                                    // 0x0250(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x78];                                     // 0x025C(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFortAIDirectorEvent>                  EventsBeingTracked;                                // 0x02D4(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<EFortAIDirectorFactor>                 FactorsBeingTracked;                               // 0x02E0(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x8];                                      // 0x02EC(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerEvent(const struct FFortAIDirectorEvent& TriggeredEvent);

	float GetAIDirectorFactorValue(EFortAIDirectorFactor AIDirectorFactor) const;
	float GetGetAIDirectorEventValue(EFortAIDirectorEvent Event) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorDataManager">();
	}
	static class AFortAIDirectorDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorDataManager>();
	}
};
static_assert(alignof(AFortAIDirectorDataManager) == 0x000004, "Wrong alignment on AFortAIDirectorDataManager");
static_assert(sizeof(AFortAIDirectorDataManager) == 0x0002F4, "Wrong size on AFortAIDirectorDataManager");
static_assert(offsetof(AFortAIDirectorDataManager, OwnerObject) == 0x000240, "Member 'AFortAIDirectorDataManager::OwnerObject' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, EventsToTrack) == 0x000244, "Member 'AFortAIDirectorDataManager::EventsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsToTrack) == 0x000250, "Member 'AFortAIDirectorDataManager::FactorsToTrack' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, EventsBeingTracked) == 0x0002D4, "Member 'AFortAIDirectorDataManager::EventsBeingTracked' has a wrong offset!");
static_assert(offsetof(AFortAIDirectorDataManager, FactorsBeingTracked) == 0x0002E0, "Member 'AFortAIDirectorDataManager::FactorsBeingTracked' has a wrong offset!");

// Class FortniteGame.FortMissionGenerator
// 0x043C (0x0458 - 0x001C)
class UFortMissionGenerator final : public UDataAsset
{
public:
	float                                         MissionGenerationChance[0x3];                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionEntry>              MissionList;                                       // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortMissionEntry>              AlwaysLoadedMissions;                              // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortMissionInfo>        PrimaryMissionInfo;                                // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortPossibleMission>           SecondaryMissionList;                              // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortPossibleMission>           TertiaryMissionList;                               // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   MissionName;                                       // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   MissionDescription;                                // 0x007C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MissionIcon;                                       // 0x0088(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortMultiSizeBrush                    MissionIcons;                                      // 0x00FC(0x02B8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FZoneLoadingScreenConfig               LoadingScreenConfig;                               // 0x03B4(0x0070)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortMissionInfo>        MissionInfo;                                       // 0x0424(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortMissionInfoOption>         MissionInfoList;                                   // 0x043C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsRequiredForVictoryTile;                         // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CostAndAvailability;                               // 0x044C(0x000C)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerator">();
	}
	static class UFortMissionGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionGenerator>();
	}
};
static_assert(alignof(UFortMissionGenerator) == 0x000004, "Wrong alignment on UFortMissionGenerator");
static_assert(sizeof(UFortMissionGenerator) == 0x000458, "Wrong size on UFortMissionGenerator");
static_assert(offsetof(UFortMissionGenerator, MissionGenerationChance) == 0x00001C, "Member 'UFortMissionGenerator::MissionGenerationChance' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionList) == 0x000028, "Member 'UFortMissionGenerator::MissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, AlwaysLoadedMissions) == 0x000034, "Member 'UFortMissionGenerator::AlwaysLoadedMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, PrimaryMissionInfo) == 0x000040, "Member 'UFortMissionGenerator::PrimaryMissionInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, SecondaryMissionList) == 0x000058, "Member 'UFortMissionGenerator::SecondaryMissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, TertiaryMissionList) == 0x000064, "Member 'UFortMissionGenerator::TertiaryMissionList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionName) == 0x000070, "Member 'UFortMissionGenerator::MissionName' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionDescription) == 0x00007C, "Member 'UFortMissionGenerator::MissionDescription' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionIcon) == 0x000088, "Member 'UFortMissionGenerator::MissionIcon' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionIcons) == 0x0000FC, "Member 'UFortMissionGenerator::MissionIcons' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, LoadingScreenConfig) == 0x0003B4, "Member 'UFortMissionGenerator::LoadingScreenConfig' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionInfo) == 0x000424, "Member 'UFortMissionGenerator::MissionInfo' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, MissionInfoList) == 0x00043C, "Member 'UFortMissionGenerator::MissionInfoList' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, bIsRequiredForVictoryTile) == 0x000448, "Member 'UFortMissionGenerator::bIsRequiredForVictoryTile' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerator, CostAndAvailability) == 0x00044C, "Member 'UFortMissionGenerator::CostAndAvailability' has a wrong offset!");

// Class FortniteGame.FortAIDirectorEventManager
// 0x003C (0x027C - 0x0240)
class AFortAIDirectorEventManager final : public AActor
{
public:
	uint8                                         Pad_240[0x3C];                                     // 0x0240(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIDirectorEventManager">();
	}
	static class AFortAIDirectorEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAIDirectorEventManager>();
	}
};
static_assert(alignof(AFortAIDirectorEventManager) == 0x000004, "Wrong alignment on AFortAIDirectorEventManager");
static_assert(sizeof(AFortAIDirectorEventManager) == 0x00027C, "Wrong size on AFortAIDirectorEventManager");

// Class FortniteGame.FortSpawnContextObjectInterface
// 0x0000 (0x001C - 0x001C)
class IFortSpawnContextObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnContextObjectInterface">();
	}
	static class IFortSpawnContextObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortSpawnContextObjectInterface>();
	}
};
static_assert(alignof(IFortSpawnContextObjectInterface) == 0x000004, "Wrong alignment on IFortSpawnContextObjectInterface");
static_assert(sizeof(IFortSpawnContextObjectInterface) == 0x00001C, "Wrong size on IFortSpawnContextObjectInterface");

// Class FortniteGame.FortAISpawnerInterface
// 0x0000 (0x001C - 0x001C)
class IFortAISpawnerInterface final : public IInterface
{
public:
	bool IsReadyToReceiveNewSpawnGroup();
	bool OnReceiveSpawnGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnerInterface">();
	}
	static class IFortAISpawnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAISpawnerInterface>();
	}
};
static_assert(alignof(IFortAISpawnerInterface) == 0x000004, "Wrong alignment on IFortAISpawnerInterface");
static_assert(sizeof(IFortAISpawnerInterface) == 0x00001C, "Wrong size on IFortAISpawnerInterface");

// Class FortniteGame.FortIntensityCurveSequence
// 0x0010 (0x002C - 0x001C)
class UFortIntensityCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            IntensityCurves;                                   // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIntensityCurveSequence">();
	}
	static class UFortIntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIntensityCurveSequence>();
	}
};
static_assert(alignof(UFortIntensityCurveSequence) == 0x000004, "Wrong alignment on UFortIntensityCurveSequence");
static_assert(sizeof(UFortIntensityCurveSequence) == 0x00002C, "Wrong size on UFortIntensityCurveSequence");
static_assert(offsetof(UFortIntensityCurveSequence, IntensityCurves) == 0x00001C, "Member 'UFortIntensityCurveSequence::IntensityCurves' has a wrong offset!");
static_assert(offsetof(UFortIntensityCurveSequence, SequenceType) == 0x000028, "Member 'UFortIntensityCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteGame.FortAIEncounterInfo
// 0x07DC (0x07F8 - 0x001C)
class UFortAIEncounterInfo final : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAISpawnGroupProgressionInfo*       SpawnGroupProgressionInfo;                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSpawnPointsPercentageCurveSequenceInstanceInfo SpawnPointsPercentageCurveSequence;                // 0x0024(0x0008)(Protected, NativeAccessSpecifierProtected)
	struct FFortIntensityCurveSequenceInstanceInfo IntensityCurveSequence;                            // 0x002C(0x0008)(Protected, NativeAccessSpecifierProtected)
	float                                         BurstSpawnPointsPercentage;                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnPointsMultiplier;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBreathers;                                     // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   LowPlayerPerformanceBreatherTimeSecondsCurve;      // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   NormalPlayerPerformanceBreatherTimeSecondsCurve;   // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HighPlayerPerformanceBreatherTimeSecondsCurve;     // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         EncounterTimeSeconds;                              // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUtilityTypeFloatPair>          LockedUtilityValues;                               // 0x0068(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumFreeUtilities;                                  // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UtilityAdjustmentPeriodSeconds;                    // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpawnDistance;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDistance;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumDirections;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeDirectionsOnRest;                           // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPointsPercentageLimit;                        // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PawnNumberLimit;                                   // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortEncounterPawnNumberCaps           PawnNumberCaps;                                    // 0x0094(0x0010)(Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnEncounterSpawnDirectionsChosen;                  // 0x00A4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnGroupCapsProfile  EncounterSpawnGroupCapsProfile;                    // 0x00B0(0x0024)(NativeAccessSpecifierPublic)
	struct FFortAIEncounterSpawnPointsProfile     EncounterSpawnPointsProfile;                       // 0x00D4(0x0030)(NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   DesiredHostilityCurve;                             // 0x0104(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFortIntensityCurveSequenceProgression* IntensitySequenceProgression;                      // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x58];                                     // 0x0114(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AliveMultiplier;                                   // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterSpawnLimitType                  SpawnLimitType;                                    // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnLimit;                                        // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnNumberLimitProgress;                           // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPointsLimitProgress;                          // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLimitReached;                                // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasSpawnedAllBurstSpawnAI;                        // 0x0181(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideAliveCounts;                              // 0x0182(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_183[0x1];                                      // 0x0183(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinAliveOverride;                                  // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveOverride;                                  // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityThreshold;                                // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeakTimeSeconds;                                   // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreatherTimeSeconds;                               // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRampTimeSeconds;                                // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenBreathesSeconds;                     // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFadeTimeSeconds;                                // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndIntensity;                                  // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndRemainingSpawnPointsPercentage;             // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompletionPercentageToDisableBreathers;            // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterAllEnemiesKilled;                       // 0x01B0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterEnemySpawned;                           // 0x01BC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterCompleted;                              // 0x01C8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x3];                                      // 0x01D4(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisplayThreatVisuals;                             // 0x01D7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x4];                                      // 0x01D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseDesiredUtilities[0x10];                        // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  UtilitiesRequiredTags[0x10];                       // 0x021C(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InjectedTagForUtilityCheck;                        // 0x039C(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLargeSpawnGroupDiscountInterval;                // 0x03B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSelectionToSpawningDelay;                       // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x3C];                                     // 0x03C0(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUtilityTypeFloatPair>          CurrentDesiredUtilities;                           // 0x03FC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UtilityRecentSelectionPenalties[0x10];             // 0x0408(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessMeasurements[0x10];            // 0x0448(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   UtilityEffectivenessMultiplierCurve;               // 0x0488(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         UtilityEffectivenessInfluenceCap;                  // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUtilityTypeFloatPair>          CurrentTopUtilityPercentages;                      // 0x0498(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EFortAIUtility>                        UsedTopUtilities;                                  // 0x04A4(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         NumUtilitiesConsidered;                            // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactivityPercentage;                              // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustUtilitiesDuringRest;                        // 0x04B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDespawnAIsDuringRest;                             // 0x04B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BA[0x2];                                      // 0x04BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPlayerCombatFactorUpdateTime;                  // 0x04BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUtilityAdjustTime;                             // 0x04C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSpawnPointAdjustmentTime;                      // 0x04C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLargeGroupSpawnTime;                           // 0x04C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIEncounterSpawnGroupWeights>  EnemySpawnData;                                    // 0x04CC(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FFortAIEncounterPIDController          EncounterPIDController;                            // 0x04D8(0x0058)(NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsCap;                             // 0x0530(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSpawnPointsUsed;                            // 0x0534(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FailSafeMinSpawnPoints;                            // 0x0540(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnGroupInstanceInfo>        ActiveSpawnGroups;                                 // 0x0544(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EncounterEngagementDistance;                       // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRelevantBuildingDamagedDistance;                // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRelevantBuildingDamagedDistance;                // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x10];                                     // 0x055C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CurrentGroupSpawnPoint;                            // 0x056C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterState                           EncounterState;                                    // 0x0570(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortEncounterPacingState                     PacingState;                                       // 0x0571(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPacingStateTransitionTime;                     // 0x0574(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortAIEncounterWaveProgressEstimation WaveProgressEstimate;                              // 0x0578(0x001C)(NativeAccessSpecifierPublic)
	float                                         DesiredDifficultyLevel;                            // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyLevelOverride;                           // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIDirector*                        MyAIDirector;                                      // 0x059C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortGoalActorEncounterDataManagerPair> DataManagers;                                      // 0x05A0(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetObjective;                                   // 0x05AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyActiveAtNight;                                // 0x05B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumRiftsToUse;                                     // 0x05B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRiftsToUse;                                     // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRiftsUsed;                                      // 0x05BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortEncounterSettings                 EncounterSettings;                                 // 0x05C0(0x0030)(NativeAccessSpecifierPublic)
	float                                         EncounterStartTime;                                // 0x05F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityCurveStartTime;                           // 0x05F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         DefaultEnvironmentQueryInfo;                       // 0x05F8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         FallbackEnvironmentQueryInfo;                      // 0x0614(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         OverrideEnvironmentQueryInfo;                      // 0x0630(0x001C)(NativeAccessSpecifierPublic)
	struct FEncounterEnvironmentQueryInfo         CurrentEnvironmentQueryInfo;                       // 0x064C(0x001C)(NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtDaybreak;                              // 0x0668(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterEnd;                          // 0x0669(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNukeWavesAtEncounterDeactivation;                 // 0x066A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_66B[0x1];                                      // 0x066B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObjectiveSafeRadius;                               // 0x066C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveEnemyCap;                                    // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHostilityLevel;                             // 0x0674(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HostilityScalePerPlayerCount[0x4];                 // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterRampStarted;                            // 0x0688(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterPeakStarted;                            // 0x0694(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterFadeStarted;                            // 0x06A0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEncounterRestStarted;                            // 0x06AC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class ABuildingRift>              RiftClassTemplate;                                 // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeActive;                                      // 0x06C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C1[0x3];                                      // 0x06C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class AActor>, struct FFortAISpawnerData> ExternalAISpawners;                                // 0x06C4(0x003C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFortAIEncounterRiftManager*            RiftManager;                                       // 0x0700(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AssociatedMissionName;                             // 0x0704(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_710[0x4];                                      // 0x0710(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortAIAssignment*>              EncounterAssignments;                              // 0x0714(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UFortAIAssignmentSettings*              DefaultEncounterAssignmentSettings;                // 0x0720(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_724[0x18];                                     // 0x0724(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxActiveAlive;                                    // 0x073C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnPointsUsed;                                // 0x0740(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            OverrideSpawnPointsCurve;                          // 0x0744(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x94];                                     // 0x0748(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseAILifespans;                                   // 0x07DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DD[0x3];                                      // 0x07DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ModifierTags;                                      // 0x07E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UFortAIAssignment* CreateEncounterAssignment(class UFortAIAssignmentSettings* AssignmentSettings, class AActor* GoalActor);
	bool EnemySpawnerGroupHasAIRemainingToSpawn(class AActor* EnemySpawner);
	class AFortAIDirectorDataManager* GetEncounterDataManager();
	float GetEncounterTimeSeconds();
	bool GroupHasAIRemainingToSpawn(const struct FFortAISpawnerData& FortAISpawnerData);
	void OnFadeStarted();
	void OnGoalTakeDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);
	void OnPeakStarted();
	void OnRampStarted();
	void OnRestStarted();
	void RegisterAISpawner(class AActor* InAISpawner);
	void RequestActivation(int32 ActivationDelay);
	bool ReserveNextAIPawn(const struct FFortAISpawnerData& FortAISpawnerData, struct FFortSpawnAIRequest* FortAISpawnRequest);
	void SetEncounterActivationState(bool bEncounterActivityState);
	void SpawnAIGroup(const class UFortAISpawnGroup* SpawnGroupToSpawn, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* SpawnSource, const TArray<class UFortAbilitySet*>& AbilitySetsToGrantOnSpawn, bool bAllowAssigningToExternalSpawners, float SecondsBetweenSpawns);
	class AFortAIPawn* SpawnAIPawnReservedForEnemySpawner(class AActor* EnemySpawner, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void UnRegisterAISpawner(class AActor* InAISpawner);

	bool EncounterHasReservedSpawnRequestForEnemySpawner(class AActor* EnemySpawner) const;
	bool GetCurrentSpawnAreaDirections(TArray<EFortEncounterDirection>* OutDirections) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterInfo">();
	}
	static class UFortAIEncounterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterInfo>();
	}
};
static_assert(alignof(UFortAIEncounterInfo) == 0x000004, "Wrong alignment on UFortAIEncounterInfo");
static_assert(sizeof(UFortAIEncounterInfo) == 0x0007F8, "Wrong size on UFortAIEncounterInfo");
static_assert(offsetof(UFortAIEncounterInfo, SpawnGroupProgressionInfo) == 0x000020, "Member 'UFortAIEncounterInfo::SpawnGroupProgressionInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageCurveSequence) == 0x000024, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensityCurveSequence) == 0x00002C, "Member 'UFortAIEncounterInfo::IntensityCurveSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BurstSpawnPointsPercentage) == 0x000034, "Member 'UFortAIEncounterInfo::BurstSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsMultiplier) == 0x000038, "Member 'UFortAIEncounterInfo::SpawnPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseBreathers) == 0x00003C, "Member 'UFortAIEncounterInfo::bUseBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LowPlayerPerformanceBreatherTimeSecondsCurve) == 0x000040, "Member 'UFortAIEncounterInfo::LowPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NormalPlayerPerformanceBreatherTimeSecondsCurve) == 0x00004C, "Member 'UFortAIEncounterInfo::NormalPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HighPlayerPerformanceBreatherTimeSecondsCurve) == 0x000058, "Member 'UFortAIEncounterInfo::HighPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterTimeSeconds) == 0x000064, "Member 'UFortAIEncounterInfo::EncounterTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LockedUtilityValues) == 0x000068, "Member 'UFortAIEncounterInfo::LockedUtilityValues' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumFreeUtilities) == 0x000074, "Member 'UFortAIEncounterInfo::NumFreeUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityAdjustmentPeriodSeconds) == 0x000078, "Member 'UFortAIEncounterInfo::UtilityAdjustmentPeriodSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinSpawnDistance) == 0x00007C, "Member 'UFortAIEncounterInfo::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnDistance) == 0x000080, "Member 'UFortAIEncounterInfo::MaxSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumDirections) == 0x000084, "Member 'UFortAIEncounterInfo::NumDirections' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bChangeDirectionsOnRest) == 0x000088, "Member 'UFortAIEncounterInfo::bChangeDirectionsOnRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsPercentageLimit) == 0x00008C, "Member 'UFortAIEncounterInfo::SpawnPointsPercentageLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimit) == 0x000090, "Member 'UFortAIEncounterInfo::PawnNumberLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberCaps) == 0x000094, "Member 'UFortAIEncounterInfo::PawnNumberCaps' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterSpawnDirectionsChosen) == 0x0000A4, "Member 'UFortAIEncounterInfo::OnEncounterSpawnDirectionsChosen' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnGroupCapsProfile) == 0x0000B0, "Member 'UFortAIEncounterInfo::EncounterSpawnGroupCapsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSpawnPointsProfile) == 0x0000D4, "Member 'UFortAIEncounterInfo::EncounterSpawnPointsProfile' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredHostilityCurve) == 0x000104, "Member 'UFortAIEncounterInfo::DesiredHostilityCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, IntensitySequenceProgression) == 0x000110, "Member 'UFortAIEncounterInfo::IntensitySequenceProgression' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AliveMultiplier) == 0x00016C, "Member 'UFortAIEncounterInfo::AliveMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimitType) == 0x000170, "Member 'UFortAIEncounterInfo::SpawnLimitType' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnLimit) == 0x000174, "Member 'UFortAIEncounterInfo::SpawnLimit' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PawnNumberLimitProgress) == 0x000178, "Member 'UFortAIEncounterInfo::PawnNumberLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, SpawnPointsLimitProgress) == 0x00017C, "Member 'UFortAIEncounterInfo::SpawnPointsLimitProgress' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bSpawnLimitReached) == 0x000180, "Member 'UFortAIEncounterInfo::bSpawnLimitReached' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bHasSpawnedAllBurstSpawnAI) == 0x000181, "Member 'UFortAIEncounterInfo::bHasSpawnedAllBurstSpawnAI' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOverrideAliveCounts) == 0x000182, "Member 'UFortAIEncounterInfo::bOverrideAliveCounts' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinAliveOverride) == 0x000184, "Member 'UFortAIEncounterInfo::MinAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxAliveOverride) == 0x000188, "Member 'UFortAIEncounterInfo::MaxAliveOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityThreshold) == 0x00018C, "Member 'UFortAIEncounterInfo::HostilityThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PeakTimeSeconds) == 0x000190, "Member 'UFortAIEncounterInfo::PeakTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BreatherTimeSeconds) == 0x000194, "Member 'UFortAIEncounterInfo::BreatherTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRampTimeSeconds) == 0x000198, "Member 'UFortAIEncounterInfo::MaxRampTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinTimeBetweenBreathesSeconds) == 0x00019C, "Member 'UFortAIEncounterInfo::MinTimeBetweenBreathesSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxFadeTimeSeconds) == 0x0001A0, "Member 'UFortAIEncounterInfo::MaxFadeTimeSeconds' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndIntensity) == 0x0001A4, "Member 'UFortAIEncounterInfo::FadeEndIntensity' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FadeEndRemainingSpawnPointsPercentage) == 0x0001A8, "Member 'UFortAIEncounterInfo::FadeEndRemainingSpawnPointsPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CompletionPercentageToDisableBreathers) == 0x0001AC, "Member 'UFortAIEncounterInfo::CompletionPercentageToDisableBreathers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterAllEnemiesKilled) == 0x0001B0, "Member 'UFortAIEncounterInfo::OnEncounterAllEnemiesKilled' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterEnemySpawned) == 0x0001BC, "Member 'UFortAIEncounterInfo::OnEncounterEnemySpawned' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterCompleted) == 0x0001C8, "Member 'UFortAIEncounterInfo::OnEncounterCompleted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDisplayThreatVisuals) == 0x0001D7, "Member 'UFortAIEncounterInfo::bDisplayThreatVisuals' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, BaseDesiredUtilities) == 0x0001DC, "Member 'UFortAIEncounterInfo::BaseDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilitiesRequiredTags) == 0x00021C, "Member 'UFortAIEncounterInfo::UtilitiesRequiredTags' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, InjectedTagForUtilityCheck) == 0x00039C, "Member 'UFortAIEncounterInfo::InjectedTagForUtilityCheck' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxLargeSpawnGroupDiscountInterval) == 0x0003B8, "Member 'UFortAIEncounterInfo::MaxLargeSpawnGroupDiscountInterval' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSelectionToSpawningDelay) == 0x0003BC, "Member 'UFortAIEncounterInfo::MaxSelectionToSpawningDelay' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentDesiredUtilities) == 0x0003FC, "Member 'UFortAIEncounterInfo::CurrentDesiredUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityRecentSelectionPenalties) == 0x000408, "Member 'UFortAIEncounterInfo::UtilityRecentSelectionPenalties' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMeasurements) == 0x000448, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMeasurements' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessMultiplierCurve) == 0x000488, "Member 'UFortAIEncounterInfo::UtilityEffectivenessMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UtilityEffectivenessInfluenceCap) == 0x000494, "Member 'UFortAIEncounterInfo::UtilityEffectivenessInfluenceCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentTopUtilityPercentages) == 0x000498, "Member 'UFortAIEncounterInfo::CurrentTopUtilityPercentages' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, UsedTopUtilities) == 0x0004A4, "Member 'UFortAIEncounterInfo::UsedTopUtilities' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumUtilitiesConsidered) == 0x0004B0, "Member 'UFortAIEncounterInfo::NumUtilitiesConsidered' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ReactivityPercentage) == 0x0004B4, "Member 'UFortAIEncounterInfo::ReactivityPercentage' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bAdjustUtilitiesDuringRest) == 0x0004B8, "Member 'UFortAIEncounterInfo::bAdjustUtilitiesDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bDespawnAIsDuringRest) == 0x0004B9, "Member 'UFortAIEncounterInfo::bDespawnAIsDuringRest' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPlayerCombatFactorUpdateTime) == 0x0004BC, "Member 'UFortAIEncounterInfo::LastPlayerCombatFactorUpdateTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastUtilityAdjustTime) == 0x0004C0, "Member 'UFortAIEncounterInfo::LastUtilityAdjustTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastSpawnPointAdjustmentTime) == 0x0004C4, "Member 'UFortAIEncounterInfo::LastSpawnPointAdjustmentTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastLargeGroupSpawnTime) == 0x0004C8, "Member 'UFortAIEncounterInfo::LastLargeGroupSpawnTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EnemySpawnData) == 0x0004CC, "Member 'UFortAIEncounterInfo::EnemySpawnData' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterPIDController) == 0x0004D8, "Member 'UFortAIEncounterInfo::EncounterPIDController' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsCap) == 0x000530, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentSpawnPointsUsed) == 0x000534, "Member 'UFortAIEncounterInfo::CurrentSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FailSafeMinSpawnPoints) == 0x000540, "Member 'UFortAIEncounterInfo::FailSafeMinSpawnPoints' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveSpawnGroups) == 0x000544, "Member 'UFortAIEncounterInfo::ActiveSpawnGroups' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterEngagementDistance) == 0x000550, "Member 'UFortAIEncounterInfo::EncounterEngagementDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRelevantBuildingDamagedDistance) == 0x000554, "Member 'UFortAIEncounterInfo::MinRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxRelevantBuildingDamagedDistance) == 0x000558, "Member 'UFortAIEncounterInfo::MaxRelevantBuildingDamagedDistance' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentGroupSpawnPoint) == 0x00056C, "Member 'UFortAIEncounterInfo::CurrentGroupSpawnPoint' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterState) == 0x000570, "Member 'UFortAIEncounterInfo::EncounterState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, PacingState) == 0x000571, "Member 'UFortAIEncounterInfo::PacingState' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, LastPacingStateTransitionTime) == 0x000574, "Member 'UFortAIEncounterInfo::LastPacingStateTransitionTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, WaveProgressEstimate) == 0x000578, "Member 'UFortAIEncounterInfo::WaveProgressEstimate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DesiredDifficultyLevel) == 0x000594, "Member 'UFortAIEncounterInfo::DesiredDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DifficultyLevelOverride) == 0x000598, "Member 'UFortAIEncounterInfo::DifficultyLevelOverride' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MyAIDirector) == 0x00059C, "Member 'UFortAIEncounterInfo::MyAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DataManagers) == 0x0005A0, "Member 'UFortAIEncounterInfo::DataManagers' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, TargetObjective) == 0x0005AC, "Member 'UFortAIEncounterInfo::TargetObjective' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bOnlyActiveAtNight) == 0x0005B0, "Member 'UFortAIEncounterInfo::bOnlyActiveAtNight' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsToUse) == 0x0005B4, "Member 'UFortAIEncounterInfo::NumRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MinRiftsToUse) == 0x0005B8, "Member 'UFortAIEncounterInfo::MinRiftsToUse' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, NumRiftsUsed) == 0x0005BC, "Member 'UFortAIEncounterInfo::NumRiftsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterSettings) == 0x0005C0, "Member 'UFortAIEncounterInfo::EncounterSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterStartTime) == 0x0005F0, "Member 'UFortAIEncounterInfo::EncounterStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityCurveStartTime) == 0x0005F4, "Member 'UFortAIEncounterInfo::HostilityCurveStartTime' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEnvironmentQueryInfo) == 0x0005F8, "Member 'UFortAIEncounterInfo::DefaultEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, FallbackEnvironmentQueryInfo) == 0x000614, "Member 'UFortAIEncounterInfo::FallbackEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideEnvironmentQueryInfo) == 0x000630, "Member 'UFortAIEncounterInfo::OverrideEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentEnvironmentQueryInfo) == 0x00064C, "Member 'UFortAIEncounterInfo::CurrentEnvironmentQueryInfo' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtDaybreak) == 0x000668, "Member 'UFortAIEncounterInfo::bNukeWavesAtDaybreak' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterEnd) == 0x000669, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterEnd' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bNukeWavesAtEncounterDeactivation) == 0x00066A, "Member 'UFortAIEncounterInfo::bNukeWavesAtEncounterDeactivation' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ObjectiveSafeRadius) == 0x00066C, "Member 'UFortAIEncounterInfo::ObjectiveSafeRadius' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ActiveEnemyCap) == 0x000670, "Member 'UFortAIEncounterInfo::ActiveEnemyCap' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, CurrentHostilityLevel) == 0x000674, "Member 'UFortAIEncounterInfo::CurrentHostilityLevel' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, HostilityScalePerPlayerCount) == 0x000678, "Member 'UFortAIEncounterInfo::HostilityScalePerPlayerCount' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRampStarted) == 0x000688, "Member 'UFortAIEncounterInfo::OnEncounterRampStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterPeakStarted) == 0x000694, "Member 'UFortAIEncounterInfo::OnEncounterPeakStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterFadeStarted) == 0x0006A0, "Member 'UFortAIEncounterInfo::OnEncounterFadeStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OnEncounterRestStarted) == 0x0006AC, "Member 'UFortAIEncounterInfo::OnEncounterRestStarted' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftClassTemplate) == 0x0006B8, "Member 'UFortAIEncounterInfo::RiftClassTemplate' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bCanBeActive) == 0x0006C0, "Member 'UFortAIEncounterInfo::bCanBeActive' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ExternalAISpawners) == 0x0006C4, "Member 'UFortAIEncounterInfo::ExternalAISpawners' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, RiftManager) == 0x000700, "Member 'UFortAIEncounterInfo::RiftManager' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, AssociatedMissionName) == 0x000704, "Member 'UFortAIEncounterInfo::AssociatedMissionName' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, EncounterAssignments) == 0x000714, "Member 'UFortAIEncounterInfo::EncounterAssignments' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, DefaultEncounterAssignmentSettings) == 0x000720, "Member 'UFortAIEncounterInfo::DefaultEncounterAssignmentSettings' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxActiveAlive) == 0x00073C, "Member 'UFortAIEncounterInfo::MaxActiveAlive' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, MaxSpawnPointsUsed) == 0x000740, "Member 'UFortAIEncounterInfo::MaxSpawnPointsUsed' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, OverrideSpawnPointsCurve) == 0x000744, "Member 'UFortAIEncounterInfo::OverrideSpawnPointsCurve' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, bUseAILifespans) == 0x0007DC, "Member 'UFortAIEncounterInfo::bUseAILifespans' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterInfo, ModifierTags) == 0x0007E0, "Member 'UFortAIEncounterInfo::ModifierTags' has a wrong offset!");

// Class FortniteGame.ThreatCloud
// 0x01BC (0x03FC - 0x0240)
class AThreatCloud final : public AActor
{
public:
	TArray<class UBoxComponent*>                  LightningSourceAreas;                              // 0x0240(0x000C)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x024C(0x0074)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         MiniMapIconPercent;                                // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            MiniMapFarOffIconBrush;                            // 0x02C4(0x0074)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FLinearColor                           ActiveTint;                                        // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FLinearColor                           InActiveTint;                                      // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         ActiveTransitionTime;                              // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35C[0x8];                                      // 0x035C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapFarOffIconDegreesOfArc;                     // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x4];                                      // 0x0368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AThreatCloud>>    NeighboringClouds;                                 // 0x036C(0x000C)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FThreatCloudInfluenceInfo>      CloudInfluenceInfos;                               // 0x0378(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         NumHorizontalAndVerticalNeighbors;                 // 0x0384(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumDiagonalNeighbors;                              // 0x0388(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumSecondaryNeighbors;                             // 0x038C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   ThreatBoxVolume;                                   // 0x0390(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         RandomFloats[0x4];                                 // 0x03AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumberOfInfluencingClouds;                         // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x24];                                     // 0x03C0(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CloudBuildUpPercentage;                            // 0x03E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudBuildUpTime;                                  // 0x03E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudBuildUpStartTime;                             // 0x03EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GoalActorLocations;                                // 0x03F0(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void GetRelevantCloudMeshes(class UStaticMeshComponent* SourceCloudMeshComponent, float BoundingBoxPadding, TArray<class UStaticMeshComponent*>* OutInfluencingCloudMeshComponents);
	void OnBeginDeath();
	void OnCloudActivated();
	void OnCloudDeactivated(EFortThreatDeactivationType DeactivationType, float DeactivationDuration);
	void OnCloudInfluenceCalculated();
	void OnCloudScaleChanged(class UStaticMeshComponent* MeshInfluenced, class UMaterialInstanceDynamic* MIDInfluenced, class UStaticMeshComponent* MeshInfluencer, const struct FVector& InfluencerScale, float InfluencerScalePercentage, int32 InfluencerIndex);
	void OnCloudStart();
	void OnLightningStrike(const struct FVector& StartLocation, const struct FVector& EndLocation, class ABuildingRift* Rift, bool bLightningStruckRift);
	void OnNeighborChanged(int32 NeighborIndex);
	void OnNeighborsChanged(bool bPrimaryNeighborsChanged, bool bSecondaryNeighborsChanged, const TArray<int32>& IndicesOfNewImmediateNeighbors, const TArray<int32>& IndicesOfDyingImmediateNeighbors);
	void OnNumSecondaryNeighborsChanged();
	void OnThreatVolumeChanged();
	void SetCloudInfluenceInfo(const TArray<class UStaticMeshComponent*>& CloudStaticMeshComponents, const TArray<struct FVector>& FinalCloudScales, const TArray<class UMaterialInstanceDynamic*>& CloudMIDs, float BoundingBoxPadding);
	void SetCloudMeshAndScaleValues(const TArray<class UStaticMeshComponent*>& CloudStaticMeshComponents, bool bIncludeNegativeValues, const TArray<struct FVector>& FinalCloudScales);
	void SetCloudMeshScale(class UStaticMeshComponent* CloudStaticMesh, const struct FVector& Scale);
	float UpdateCloudBuildUp();

	float GetCloudBuildUpPercentage() const;
	void GetGoalActorLocations(TArray<struct FVector>* OutGoalActorLocations) const;
	void GetNeighborCloudIndices(TArray<int32>* NeighborCloudIndices) const;
	void GetNeighborClouds(TArray<class AThreatCloud*>* NeighborClouds) const;
	int32 GetNumberOfImmediateNeighbors(bool bHorizontalAndVertical, bool bDiagonal) const;
	int32 GetNumberOfSecondaryNeighbors() const;
	float GetRandomFloat1() const;
	float GetRandomFloat2() const;
	float GetRandomFloat3() const;
	float GetRandomFloat4() const;
	struct FBox GetThreatVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatCloud">();
	}
	static class AThreatCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThreatCloud>();
	}
};
static_assert(alignof(AThreatCloud) == 0x000004, "Wrong alignment on AThreatCloud");
static_assert(sizeof(AThreatCloud) == 0x0003FC, "Wrong size on AThreatCloud");
static_assert(offsetof(AThreatCloud, LightningSourceAreas) == 0x000240, "Member 'AThreatCloud::LightningSourceAreas' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconBrush) == 0x00024C, "Member 'AThreatCloud::MiniMapIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapIconPercent) == 0x0002C0, "Member 'AThreatCloud::MiniMapIconPercent' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconBrush) == 0x0002C4, "Member 'AThreatCloud::MiniMapFarOffIconBrush' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTint) == 0x000338, "Member 'AThreatCloud::ActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, InActiveTint) == 0x000348, "Member 'AThreatCloud::InActiveTint' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ActiveTransitionTime) == 0x000358, "Member 'AThreatCloud::ActiveTransitionTime' has a wrong offset!");
static_assert(offsetof(AThreatCloud, MiniMapFarOffIconDegreesOfArc) == 0x000364, "Member 'AThreatCloud::MiniMapFarOffIconDegreesOfArc' has a wrong offset!");
static_assert(offsetof(AThreatCloud, NeighboringClouds) == 0x00036C, "Member 'AThreatCloud::NeighboringClouds' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudInfluenceInfos) == 0x000378, "Member 'AThreatCloud::CloudInfluenceInfos' has a wrong offset!");
static_assert(offsetof(AThreatCloud, NumHorizontalAndVerticalNeighbors) == 0x000384, "Member 'AThreatCloud::NumHorizontalAndVerticalNeighbors' has a wrong offset!");
static_assert(offsetof(AThreatCloud, NumDiagonalNeighbors) == 0x000388, "Member 'AThreatCloud::NumDiagonalNeighbors' has a wrong offset!");
static_assert(offsetof(AThreatCloud, NumSecondaryNeighbors) == 0x00038C, "Member 'AThreatCloud::NumSecondaryNeighbors' has a wrong offset!");
static_assert(offsetof(AThreatCloud, ThreatBoxVolume) == 0x000390, "Member 'AThreatCloud::ThreatBoxVolume' has a wrong offset!");
static_assert(offsetof(AThreatCloud, RandomFloats) == 0x0003AC, "Member 'AThreatCloud::RandomFloats' has a wrong offset!");
static_assert(offsetof(AThreatCloud, NumberOfInfluencingClouds) == 0x0003BC, "Member 'AThreatCloud::NumberOfInfluencingClouds' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudBuildUpPercentage) == 0x0003E4, "Member 'AThreatCloud::CloudBuildUpPercentage' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudBuildUpTime) == 0x0003E8, "Member 'AThreatCloud::CloudBuildUpTime' has a wrong offset!");
static_assert(offsetof(AThreatCloud, CloudBuildUpStartTime) == 0x0003EC, "Member 'AThreatCloud::CloudBuildUpStartTime' has a wrong offset!");
static_assert(offsetof(AThreatCloud, GoalActorLocations) == 0x0003F0, "Member 'AThreatCloud::GoalActorLocations' has a wrong offset!");

// Class FortniteGame.FortGameplayEffectDeliveryActor
// 0x0150 (0x0390 - 0x0240)
class AFortGameplayEffectDeliveryActor : public AActor
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnTouch;                 // 0x0250(0x0064)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bKillOnExplode;                                    // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortGameplayEffectContainerSpec       EffectContainerSpecToApplyOnExplode;               // 0x02B8(0x0064)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LifespanAfterKill;                                 // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchingActorsEffectApplicationUpdateTime;         // 0x0320(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingKilled;                                    // 0x0324(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIgnoreInstigatorCollision;                        // 0x0325(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_326[0x2];                                      // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    CollisionComponent;                                // 0x0328(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortSpawnContext                      SpawnContext;                                      // 0x032C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x38];                                     // 0x0348(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDoExplosionReentrancyGuard : 1;                   // 0x0380(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_381[0xF];                                      // 0x0381(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastExplosion(const TArray<class AActor*>& HitActors, const TArray<struct FHitResult>& HitResults);
	void DoExplosion();
	void Kill();
	void KillTimerExpired();
	void OnComponentOverlap(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentTouch(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnExploded(const TArray<class AActor*>& HitActors, const TArray<struct FHitResult>& HitResults);
	void OnRep_IsBeingKilled();
	void OnTouched(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& HitResult);
	void SetCollisionComponent(class UPrimitiveComponent* NewCollisionComponent);
	void SetIgnoreInstigatorCollision(bool bShouldIgnore);

	class UPrimitiveComponent* GetCollisionComponent() const;
	bool IsBeingKilled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectDeliveryActor">();
	}
	static class AFortGameplayEffectDeliveryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayEffectDeliveryActor>();
	}
};
static_assert(alignof(AFortGameplayEffectDeliveryActor) == 0x000004, "Wrong alignment on AFortGameplayEffectDeliveryActor");
static_assert(sizeof(AFortGameplayEffectDeliveryActor) == 0x000390, "Wrong size on AFortGameplayEffectDeliveryActor");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, EffectContainerSpecToApplyOnTouch) == 0x000250, "Member 'AFortGameplayEffectDeliveryActor::EffectContainerSpecToApplyOnTouch' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, bKillOnExplode) == 0x0002B4, "Member 'AFortGameplayEffectDeliveryActor::bKillOnExplode' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, EffectContainerSpecToApplyOnExplode) == 0x0002B8, "Member 'AFortGameplayEffectDeliveryActor::EffectContainerSpecToApplyOnExplode' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, LifespanAfterKill) == 0x00031C, "Member 'AFortGameplayEffectDeliveryActor::LifespanAfterKill' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, TouchingActorsEffectApplicationUpdateTime) == 0x000320, "Member 'AFortGameplayEffectDeliveryActor::TouchingActorsEffectApplicationUpdateTime' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, bIsBeingKilled) == 0x000324, "Member 'AFortGameplayEffectDeliveryActor::bIsBeingKilled' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, bIgnoreInstigatorCollision) == 0x000325, "Member 'AFortGameplayEffectDeliveryActor::bIgnoreInstigatorCollision' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, CollisionComponent) == 0x000328, "Member 'AFortGameplayEffectDeliveryActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AFortGameplayEffectDeliveryActor, SpawnContext) == 0x00032C, "Member 'AFortGameplayEffectDeliveryActor::SpawnContext' has a wrong offset!");

// Class FortniteGame.FortProjectileBase
// 0x0088 (0x0418 - 0x0390)
class AFortProjectileBase : public AFortGameplayEffectDeliveryActor
{
public:
	uint8                                         Pad_390[0x4];                                      // 0x0390(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   VerticleFireOffset;                                // 0x0394(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   InitialSpeed;                                      // 0x03A0(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSpeed;                                          // 0x03AC(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ReplicatedMaxSpeed;                                // 0x03B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x03BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargePercent;                                     // 0x03C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MomentumTransfer;                                  // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddOwnerVelocity;                                 // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x03CC(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x03D0(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopSimulatingOnHit;                              // 0x03D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x7];                                      // 0x03D5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	EFortBaseWeaponDamage                         WeaponResponseType;                                // 0x03DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DD[0x3B];                                     // 0x03DD(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasStoppedMoving();
	void OnBounce(const struct FHitResult& Hit);
	void OnBounceCallback(const struct FHitResult& Hit, const struct FVector& ImpactVelocity);
	void OnRep_GravityScale();
	void OnRep_ReplicatedMaxSpeed();
	void OnStop(const struct FHitResult& Hit);
	void OnStopCallback(const struct FHitResult& Hit);
	void SetGravityScale(float InitialGravityScale);

	float GetGravityScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectileBase">();
	}
	static class AFortProjectileBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectileBase>();
	}
};
static_assert(alignof(AFortProjectileBase) == 0x000004, "Wrong alignment on AFortProjectileBase");
static_assert(sizeof(AFortProjectileBase) == 0x000418, "Wrong size on AFortProjectileBase");
static_assert(offsetof(AFortProjectileBase, VerticleFireOffset) == 0x000394, "Member 'AFortProjectileBase::VerticleFireOffset' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, InitialSpeed) == 0x0003A0, "Member 'AFortProjectileBase::InitialSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, MaxSpeed) == 0x0003AC, "Member 'AFortProjectileBase::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ReplicatedMaxSpeed) == 0x0003B8, "Member 'AFortProjectileBase::ReplicatedMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, GravityScale) == 0x0003BC, "Member 'AFortProjectileBase::GravityScale' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ChargePercent) == 0x0003C0, "Member 'AFortProjectileBase::ChargePercent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, MomentumTransfer) == 0x0003C4, "Member 'AFortProjectileBase::MomentumTransfer' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, bAddOwnerVelocity) == 0x0003C8, "Member 'AFortProjectileBase::bAddOwnerVelocity' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, CapsuleComponent) == 0x0003CC, "Member 'AFortProjectileBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, ProjectileMovementComponent) == 0x0003D0, "Member 'AFortProjectileBase::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, bStopSimulatingOnHit) == 0x0003D4, "Member 'AFortProjectileBase::bStopSimulatingOnHit' has a wrong offset!");
static_assert(offsetof(AFortProjectileBase, WeaponResponseType) == 0x0003DC, "Member 'AFortProjectileBase::WeaponResponseType' has a wrong offset!");

// Class FortniteGame.FortProjectile_MOBATurret
// 0x000C (0x0424 - 0x0418)
class AFortProjectile_MOBATurret final : public AFortProjectileBase
{
public:
	TArray<struct FHitResult>                     ForcedHitResults;                                  // 0x0418(0x000C)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnHomingTargetDied(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, class AActor* DamageCauser, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, class FName BoneName, const struct FVector& Momentum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectile_MOBATurret">();
	}
	static class AFortProjectile_MOBATurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectile_MOBATurret>();
	}
};
static_assert(alignof(AFortProjectile_MOBATurret) == 0x000004, "Wrong alignment on AFortProjectile_MOBATurret");
static_assert(sizeof(AFortProjectile_MOBATurret) == 0x000424, "Wrong size on AFortProjectile_MOBATurret");
static_assert(offsetof(AFortProjectile_MOBATurret, ForcedHitResults) == 0x000418, "Member 'AFortProjectile_MOBATurret::ForcedHitResults' has a wrong offset!");

// Class FortniteGame.FortThreatVisualsManager
// 0x00BC (0x02FC - 0x0240)
class AFortThreatVisualsManager final : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThreatCloud>               CloudBlueprint;                                    // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudRadius;                                       // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeTopPadding;                         // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThreatBoxVolumeBottomPadding;                      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudBuildUpPercentageForNeighborConsideration;    // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloudBuildUpTickInterval;                          // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FThreatLocationArray                   ThreatLocations;                                   // 0x025C(0x008C)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        GoalActorLocations;                                // 0x02E8(0x000C)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x8];                                      // 0x02F4(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateThreatClouds(const TArray<struct FThreatGridIndex>& GridIndices);
	void BeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& ThreatLocation);
	void DeactivateThreatClouds(EFortThreatDeactivationType DeactivationType, const TArray<struct FThreatGridIndex>& GridIndices, float DeactivationDuration);
	void OnBeginThreatVisualsPrecursor(class AActor* SourceActor, const struct FVector& EndLocation);
	void OnRep_GoalActorLocations();
	void OnRep_ThreatLocations();
	void OnThreatCloudsChanged(const TArray<struct FThreatLocationInfo>& ThreatLocationInfo);
	void UpdateCloudBuildUp();

	class AThreatCloud* GetThreatCloud(const struct FThreatLocationInfo& ThreatLocInfo) const;
	const TArray<struct FThreatLocationInfo> GetThreatClouds() const;
	bool StormsExist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortThreatVisualsManager">();
	}
	static class AFortThreatVisualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortThreatVisualsManager>();
	}
};
static_assert(alignof(AFortThreatVisualsManager) == 0x000004, "Wrong alignment on AFortThreatVisualsManager");
static_assert(sizeof(AFortThreatVisualsManager) == 0x0002FC, "Wrong size on AFortThreatVisualsManager");
static_assert(offsetof(AFortThreatVisualsManager, CloudBlueprint) == 0x000244, "Member 'AFortThreatVisualsManager::CloudBlueprint' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudRadius) == 0x000248, "Member 'AFortThreatVisualsManager::CloudRadius' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeTopPadding) == 0x00024C, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeTopPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatBoxVolumeBottomPadding) == 0x000250, "Member 'AFortThreatVisualsManager::ThreatBoxVolumeBottomPadding' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudBuildUpPercentageForNeighborConsideration) == 0x000254, "Member 'AFortThreatVisualsManager::CloudBuildUpPercentageForNeighborConsideration' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, CloudBuildUpTickInterval) == 0x000258, "Member 'AFortThreatVisualsManager::CloudBuildUpTickInterval' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, ThreatLocations) == 0x00025C, "Member 'AFortThreatVisualsManager::ThreatLocations' has a wrong offset!");
static_assert(offsetof(AFortThreatVisualsManager, GoalActorLocations) == 0x0002E8, "Member 'AFortThreatVisualsManager::GoalActorLocations' has a wrong offset!");

// Class FortniteGame.FortAIEncounterSequence
// 0x0034 (0x0050 - 0x001C)
class UFortAIEncounterSequence final : public UObject
{
public:
	struct FFortGeneratedEncounterSequence        GeneratedEncounterSequence;                        // 0x001C(0x0024)(Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentEncounterIndexInSequence;                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAIEncounterInfo*                   CurrentEncounter;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIDirector*                        AssociatedAIDirector;                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           AssociatedMission;                                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EFortEncounterSequenceResult Next();
	EFortEncounterSequenceResult Previous();
	class UFortAIEncounterInfo* StartCurrentEncounter(EFortEncounterSequenceResult* OutRequestResult, const TArray<class AActor*>& TargetActors, class UFortAIAssignmentSettings* AssignmentSettings, const struct FEncounterEnvironmentQueryInfo& OverrideEnvironmentQueryInfo, class AActor* OptionalQueryActor, const struct FGameplayTagContainer& InjectedTags, const struct FFortEncounterSettings& EncounterSettings, int32 ActivationDelay);
	void StopCurrentEncounter();

	bool EncounterBelongsToSequence(class UFortAIEncounterInfo* InEncounter) const;
	class UFortAIEncounterInfo* GetCurrentEncounter() const;
	int32 GetEncounterIndexInSequence() const;
	int32 GetNumEncountersInSequence() const;
	bool HasEncounter() const;
	bool IsOnFinalIndexInSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIEncounterSequence">();
	}
	static class UFortAIEncounterSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIEncounterSequence>();
	}
};
static_assert(alignof(UFortAIEncounterSequence) == 0x000004, "Wrong alignment on UFortAIEncounterSequence");
static_assert(sizeof(UFortAIEncounterSequence) == 0x000050, "Wrong size on UFortAIEncounterSequence");
static_assert(offsetof(UFortAIEncounterSequence, GeneratedEncounterSequence) == 0x00001C, "Member 'UFortAIEncounterSequence::GeneratedEncounterSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounterIndexInSequence) == 0x000040, "Member 'UFortAIEncounterSequence::CurrentEncounterIndexInSequence' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, CurrentEncounter) == 0x000044, "Member 'UFortAIEncounterSequence::CurrentEncounter' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedAIDirector) == 0x000048, "Member 'UFortAIEncounterSequence::AssociatedAIDirector' has a wrong offset!");
static_assert(offsetof(UFortAIEncounterSequence, AssociatedMission) == 0x00004C, "Member 'UFortAIEncounterSequence::AssociatedMission' has a wrong offset!");

// Class FortniteGame.FortAIFunctionLibrary
// 0x0000 (0x001C - 0x001C)
class UFortAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MakeNoiseEvent(class AActor* NoiseMaker, float MaxRange);
	static void MakeNoiseEventAtLocation(class AActor* NoiseMaker, float MaxRange, const struct FVector& NoiseLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFunctionLibrary">();
	}
	static class UFortAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFunctionLibrary>();
	}
};
static_assert(alignof(UFortAIFunctionLibrary) == 0x000004, "Wrong alignment on UFortAIFunctionLibrary");
static_assert(sizeof(UFortAIFunctionLibrary) == 0x00001C, "Wrong size on UFortAIFunctionLibrary");

// Class FortniteGame.FortNavArea
// 0x0004 (0x0038 - 0x0034)
class UFortNavArea : public UNavArea
{
public:
	uint8                                         bObstacle : 1;                                     // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bSmashable : 1;                                    // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea">();
	}
	static class UFortNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea>();
	}
};
static_assert(alignof(UFortNavArea) == 0x000004, "Wrong alignment on UFortNavArea");
static_assert(sizeof(UFortNavArea) == 0x000038, "Wrong size on UFortNavArea");

// Class FortniteGame.FortNavArea_ClosedDoors
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_ClosedDoors final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_ClosedDoors">();
	}
	static class UFortNavArea_ClosedDoors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_ClosedDoors>();
	}
};
static_assert(alignof(UFortNavArea_ClosedDoors) == 0x000004, "Wrong alignment on UFortNavArea_ClosedDoors");
static_assert(sizeof(UFortNavArea_ClosedDoors) == 0x000038, "Wrong size on UFortNavArea_ClosedDoors");

// Class FortniteGame.FortAIRootAssignmentProviderInterface
// 0x0000 (0x001C - 0x001C)
class IFortAIRootAssignmentProviderInterface final : public IInterface
{
public:
	const struct FFortAIAssignmentIdentifier GetRootAssignmentIdentifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIRootAssignmentProviderInterface">();
	}
	static class IFortAIRootAssignmentProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIRootAssignmentProviderInterface>();
	}
};
static_assert(alignof(IFortAIRootAssignmentProviderInterface) == 0x000004, "Wrong alignment on IFortAIRootAssignmentProviderInterface");
static_assert(sizeof(IFortAIRootAssignmentProviderInterface) == 0x00001C, "Wrong size on IFortAIRootAssignmentProviderInterface");

// Class FortniteGame.FortDamageFormulaExecutionCalculation
// 0x0000 (0x002C - 0x002C)
class UFortDamageFormulaExecutionCalculation final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageFormulaExecutionCalculation">();
	}
	static class UFortDamageFormulaExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageFormulaExecutionCalculation>();
	}
};
static_assert(alignof(UFortDamageFormulaExecutionCalculation) == 0x000004, "Wrong alignment on UFortDamageFormulaExecutionCalculation");
static_assert(sizeof(UFortDamageFormulaExecutionCalculation) == 0x00002C, "Wrong size on UFortDamageFormulaExecutionCalculation");

// Class FortniteGame.FortAIObjectiveInterface
// 0x0000 (0x001C - 0x001C)
class IFortAIObjectiveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIObjectiveInterface">();
	}
	static class IFortAIObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortAIObjectiveInterface>();
	}
};
static_assert(alignof(IFortAIObjectiveInterface) == 0x000004, "Wrong alignment on IFortAIObjectiveInterface");
static_assert(sizeof(IFortAIObjectiveInterface) == 0x00001C, "Wrong size on IFortAIObjectiveInterface");

// Class FortniteGame.FortAIPerceptionComponent
// 0x0008 (0x0140 - 0x0138)
class UFortAIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	float                                         LosingSightRadiusBump;                             // 0x0138(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionComponent">();
	}
	static class UFortAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionComponent>();
	}
};
static_assert(alignof(UFortAIPerceptionComponent) == 0x000004, "Wrong alignment on UFortAIPerceptionComponent");
static_assert(sizeof(UFortAIPerceptionComponent) == 0x000140, "Wrong size on UFortAIPerceptionComponent");
static_assert(offsetof(UFortAIPerceptionComponent, LosingSightRadiusBump) == 0x000138, "Member 'UFortAIPerceptionComponent::LosingSightRadiusBump' has a wrong offset!");

// Class FortniteGame.FortAIPerceptionSystem
// 0x0000 (0x00DC - 0x00DC)
class UFortAIPerceptionSystem final : public UAIPerceptionSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIPerceptionSystem">();
	}
	static class UFortAIPerceptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIPerceptionSystem>();
	}
};
static_assert(alignof(UFortAIPerceptionSystem) == 0x000004, "Wrong alignment on UFortAIPerceptionSystem");
static_assert(sizeof(UFortAIPerceptionSystem) == 0x0000DC, "Wrong size on UFortAIPerceptionSystem");

// Class FortniteGame.FortAISpawnGroup
// 0x0084 (0x00A0 - 0x001C)
class UFortAISpawnGroup final : public UDataAsset
{
public:
	float                                         EnemyUtilities[0x10];                              // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnGroupEnemy>               EnemiesToSpawn;                                    // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPrototype;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsValidForEnemySpawners;                          // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsLargeSpawnGroup;                                // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B[0x1];                                       // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDiscountRatio;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   MaxGroupCategoryPopulationDensityCurve;            // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortSpawnGroupEncounterTypeData> EncounterTypeData;                                 // 0x007C(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SpawnGroupGameplayTags;                            // 0x0088(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class UFortAIPawnVariant> GetEnemy(int32 EnemyIndex) const;
	int32 GetNumberOfEnemies() const;
	bool IsLargeSpawnGroup() const;
	bool IsPrototype() const;
	bool IsValidForEnemySpawners() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroup">();
	}
	static class UFortAISpawnGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroup>();
	}
};
static_assert(alignof(UFortAISpawnGroup) == 0x000004, "Wrong alignment on UFortAISpawnGroup");
static_assert(sizeof(UFortAISpawnGroup) == 0x0000A0, "Wrong size on UFortAISpawnGroup");
static_assert(offsetof(UFortAISpawnGroup, EnemyUtilities) == 0x00001C, "Member 'UFortAISpawnGroup::EnemyUtilities' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EnemiesToSpawn) == 0x00005C, "Member 'UFortAISpawnGroup::EnemiesToSpawn' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsPrototype) == 0x000068, "Member 'UFortAISpawnGroup::bIsPrototype' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsValidForEnemySpawners) == 0x000069, "Member 'UFortAISpawnGroup::bIsValidForEnemySpawners' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, bIsLargeSpawnGroup) == 0x00006A, "Member 'UFortAISpawnGroup::bIsLargeSpawnGroup' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxDiscountRatio) == 0x00006C, "Member 'UFortAISpawnGroup::MaxDiscountRatio' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, MaxGroupCategoryPopulationDensityCurve) == 0x000070, "Member 'UFortAISpawnGroup::MaxGroupCategoryPopulationDensityCurve' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, EncounterTypeData) == 0x00007C, "Member 'UFortAISpawnGroup::EncounterTypeData' has a wrong offset!");
static_assert(offsetof(UFortAISpawnGroup, SpawnGroupGameplayTags) == 0x000088, "Member 'UFortAISpawnGroup::SpawnGroupGameplayTags' has a wrong offset!");

// Class FortniteGame.FortAISpawnGroupProgressionInfo
// 0x000C (0x0028 - 0x001C)
class UFortAISpawnGroupProgressionInfo final : public UDataAsset
{
public:
	TArray<struct FSpawnGroupProgression>         SpawnGroups;                                       // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISpawnGroupProgressionInfo">();
	}
	static class UFortAISpawnGroupProgressionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISpawnGroupProgressionInfo>();
	}
};
static_assert(alignof(UFortAISpawnGroupProgressionInfo) == 0x000004, "Wrong alignment on UFortAISpawnGroupProgressionInfo");
static_assert(sizeof(UFortAISpawnGroupProgressionInfo) == 0x000028, "Wrong size on UFortAISpawnGroupProgressionInfo");
static_assert(offsetof(UFortAISpawnGroupProgressionInfo, SpawnGroups) == 0x00001C, "Member 'UFortAISpawnGroupProgressionInfo::SpawnGroups' has a wrong offset!");

// Class FortniteGame.FortAISystem
// 0x0004 (0x00C4 - 0x00C0)
class UFortAISystem final : public UAISystem
{
public:
	class UFortNavGraph*                          NavGraph;                                          // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsInCone2D(const struct FVector& ConeOrigin, const struct FVector& ConeDirection, float HalfAngle, const struct FVector& LocationToCheck);
	static void RequestNumberofBTDrivenAIPawns(class UObject* WorldContext, int32 NumberOfPawns);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAISystem">();
	}
	static class UFortAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAISystem>();
	}
};
static_assert(alignof(UFortAISystem) == 0x000004, "Wrong alignment on UFortAISystem");
static_assert(sizeof(UFortAISystem) == 0x0000C4, "Wrong size on UFortAISystem");
static_assert(offsetof(UFortAISystem, NavGraph) == 0x0000C0, "Member 'UFortAISystem::NavGraph' has a wrong offset!");

// Class FortniteGame.Stat
// 0x0038 (0x0054 - 0x001C)
class UStat final : public UObject
{
public:
	class FName                                   StatName;                                          // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatRecordingPeriod                          HighestPeriodToTrack;                              // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StatDataByPeriod;                                  // 0x0028(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AbsoluteMaxValue;                                  // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x1C];                                      // 0x0038(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Stat">();
	}
	static class UStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStat>();
	}
};
static_assert(alignof(UStat) == 0x000004, "Wrong alignment on UStat");
static_assert(sizeof(UStat) == 0x000054, "Wrong size on UStat");
static_assert(offsetof(UStat, StatName) == 0x00001C, "Member 'UStat::StatName' has a wrong offset!");
static_assert(offsetof(UStat, HighestPeriodToTrack) == 0x000024, "Member 'UStat::HighestPeriodToTrack' has a wrong offset!");
static_assert(offsetof(UStat, StatDataByPeriod) == 0x000028, "Member 'UStat::StatDataByPeriod' has a wrong offset!");
static_assert(offsetof(UStat, AbsoluteMaxValue) == 0x000034, "Member 'UStat::AbsoluteMaxValue' has a wrong offset!");

// Class FortniteGame.FortOutpostAnalytics
// 0x0000 (0x001C - 0x001C)
class UFortOutpostAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireAnalyticsEvent_OutpostAttackWaveCompleted(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumMissionsCompleted, const bool Succeeded, const class FString& Direction);
	static void FireAnalyticsEvent_OutpostBuildingActivated(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumMissionsCompleted);
	static void FireAnalyticsEvent_OutpostBuildingDefended(const class UObject* SourceBp, const class FString& BuildingType, const int32 NumMissionsCompleted);
	static void FireAnalyticsEvent_OutpostSupplyDropPickedUp(const class UObject* SourceBp, const TArray<struct FFortAnalyticsEventAttribute>& Resourcees);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostAnalytics">();
	}
	static class UFortOutpostAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostAnalytics>();
	}
};
static_assert(alignof(UFortOutpostAnalytics) == 0x000004, "Wrong alignment on UFortOutpostAnalytics");
static_assert(sizeof(UFortOutpostAnalytics) == 0x00001C, "Wrong size on UFortOutpostAnalytics");

// Class FortniteGame.FortOnboardingAnalytics
// 0x0000 (0x001C - 0x001C)
class UFortOnboardingAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void FireAnalyticsEvent_CinematicSkipped(const class UObject* SourceBp);
	static void FireAnalyticsEvent_VinderTipPlayed(const class UObject* SourceBp, const class FString& VinderTipTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnboardingAnalytics">();
	}
	static class UFortOnboardingAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnboardingAnalytics>();
	}
};
static_assert(alignof(UFortOnboardingAnalytics) == 0x000004, "Wrong alignment on UFortOnboardingAnalytics");
static_assert(sizeof(UFortOnboardingAnalytics) == 0x00001C, "Wrong size on UFortOnboardingAnalytics");

// Class FortniteGame.FortAnalytics
// 0x0000 (0x001C - 0x001C)
class UFortAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static struct FFortAnalyticsEventAttribute ConstructAnalyticsAttribute(const class FString& AttributeName, const class FString& StringValue, const struct FGuid& FGuidValue, const int32 IntValue, const float FloatValue, const bool BoolValue);
	static void FireAnalyticsEvent_Blueprint(const class UObject* SourceBp, const class FString& EventName, const struct FFortAnalyticsEventAttribute& Attribute);
	static void FireAnalyticsEvent_BlueprintArray(const class UObject* SourceBp, const class FString& EventName, const TArray<struct FFortAnalyticsEventAttribute>& Attributes);
	static void FireMissionAnalyticsEvent_Blueprint(const class UObject* SourceBp, const class FString& EventName, const struct FFortAnalyticsEventAttribute& Attribute);
	static void FireMissionAnalyticsEvent_BlueprintArray(const class UObject* SourceBp, const class FString& EventName, const TArray<struct FFortAnalyticsEventAttribute>& Attributes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnalytics">();
	}
	static class UFortAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnalytics>();
	}
};
static_assert(alignof(UFortAnalytics) == 0x000004, "Wrong alignment on UFortAnalytics");
static_assert(sizeof(UFortAnalytics) == 0x00001C, "Wrong size on UFortAnalytics");

// Class FortniteGame.FortAnimInstance
// 0x0130 (0x0440 - 0x0310)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAnimInstance : public UAnimInstance
{
public:
	float                                         VelocityLerpAlpha;                                 // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PawnVelocity;                                      // 0x0314(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinSpeed2DThreshold;                               // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnSpeed2D;                                       // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnVelocityZ;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnMovementDirectionAzimuth;                      // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnMovementDirectionElevation;                    // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PawnDeltaRotation;                                 // 0x0334(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PawnLastRotation;                                  // 0x0340(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsJumping;                                        // 0x034C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x034D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldPredictLanding;                             // 0x034E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLandingPredicted;                                 // 0x034F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PredictedFallTimeLeft;                             // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallLookAheadSubStepping;                          // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FallLookAheadMaxIterations;                        // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugLandPrediction;                              // 0x035C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimPitch;                                          // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYaw;                                            // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimPitchAdjustment;                                // 0x0368(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYawAdjustment;                                  // 0x036C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAimYawAdjustment;                               // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYaw;                                            // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReticleAimDistance;                                // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAdjustmentInterpSpeed;                          // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimTwistCorrectionExponent;                        // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WeaponAimingFreezeInterpScale;                     // 0x0388(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAimWeaponTowardsReticle;                          // 0x0394(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponAimingCurveName;                             // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAimingFreezeCurveName;                       // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugWeaponAiming;                                // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastFramePawnTransform;                            // 0x03B0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bCachedPawnTransform;                              // 0x03E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bHasValidWeaponMuzzleSocket;                       // 0x03E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E2[0x2];                                      // 0x03E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadTrackingReticleSocketName;                     // 0x03E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         HeadTrackingReticleSocketLookAtAxis;               // 0x03EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadTrackingReticleInterpSpeed;                    // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadTrackingReticleAdjustment;                     // 0x03F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HeadTrackingReticlePitchAlpha;                     // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadTrackingReticleAimDistance;                    // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadTrackingReticleAimDistanceDownsights;          // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeForRecentlyFired;                              // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToReachRelaxedLevel1;                          // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToReachRelaxedLevel2;                          // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecentlyFired;                                    // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsRelaxedLevel1;                                  // 0x0419(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsRelaxedLevel2;                                  // 0x041A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_41B[0x1];                                      // 0x041B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelaxedLevelTimeCounter;                           // 0x041C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SavedWeaponLastFireTime;                           // 0x0420(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordJumpPositions;                              // 0x0424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsRecordingJump;                                  // 0x0425(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_426[0x2];                                      // 0x0426(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecordJumpFrameCount;                              // 0x0428(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RecordJumpInitialJumpLocation;                     // 0x042C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AnimNotify_LeftFootStep(const class UAnimNotify* Notify);
	void AnimNotify_RightFootStep(const class UAnimNotify* Notify);
	class AFortAIPawn* TryGetFortAIPawn();
	class AFortPawn* TryGetFortPawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimInstance">();
	}
	static class UFortAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAnimInstance) == 0x000010, "Wrong alignment on UFortAnimInstance");
static_assert(sizeof(UFortAnimInstance) == 0x000440, "Wrong size on UFortAnimInstance");
static_assert(offsetof(UFortAnimInstance, VelocityLerpAlpha) == 0x000310, "Member 'UFortAnimInstance::VelocityLerpAlpha' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnVelocity) == 0x000314, "Member 'UFortAnimInstance::PawnVelocity' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, MinSpeed2DThreshold) == 0x000320, "Member 'UFortAnimInstance::MinSpeed2DThreshold' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnSpeed2D) == 0x000324, "Member 'UFortAnimInstance::PawnSpeed2D' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnVelocityZ) == 0x000328, "Member 'UFortAnimInstance::PawnVelocityZ' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnMovementDirectionAzimuth) == 0x00032C, "Member 'UFortAnimInstance::PawnMovementDirectionAzimuth' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnMovementDirectionElevation) == 0x000330, "Member 'UFortAnimInstance::PawnMovementDirectionElevation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnDeltaRotation) == 0x000334, "Member 'UFortAnimInstance::PawnDeltaRotation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PawnLastRotation) == 0x000340, "Member 'UFortAnimInstance::PawnLastRotation' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsJumping) == 0x00034C, "Member 'UFortAnimInstance::bIsJumping' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsFalling) == 0x00034D, "Member 'UFortAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bShouldPredictLanding) == 0x00034E, "Member 'UFortAnimInstance::bShouldPredictLanding' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bLandingPredicted) == 0x00034F, "Member 'UFortAnimInstance::bLandingPredicted' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, PredictedFallTimeLeft) == 0x000350, "Member 'UFortAnimInstance::PredictedFallTimeLeft' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, FallLookAheadSubStepping) == 0x000354, "Member 'UFortAnimInstance::FallLookAheadSubStepping' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, FallLookAheadMaxIterations) == 0x000358, "Member 'UFortAnimInstance::FallLookAheadMaxIterations' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bDebugLandPrediction) == 0x00035C, "Member 'UFortAnimInstance::bDebugLandPrediction' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimPitch) == 0x000360, "Member 'UFortAnimInstance::AimPitch' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimYaw) == 0x000364, "Member 'UFortAnimInstance::AimYaw' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimPitchAdjustment) == 0x000368, "Member 'UFortAnimInstance::AimPitchAdjustment' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimYawAdjustment) == 0x00036C, "Member 'UFortAnimInstance::AimYawAdjustment' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, MaxAimYawAdjustment) == 0x000370, "Member 'UFortAnimInstance::MaxAimYawAdjustment' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, MaxPitch) == 0x000374, "Member 'UFortAnimInstance::MaxPitch' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, MaxYaw) == 0x000378, "Member 'UFortAnimInstance::MaxYaw' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, ReticleAimDistance) == 0x00037C, "Member 'UFortAnimInstance::ReticleAimDistance' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimAdjustmentInterpSpeed) == 0x000380, "Member 'UFortAnimInstance::AimAdjustmentInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, AimTwistCorrectionExponent) == 0x000384, "Member 'UFortAnimInstance::AimTwistCorrectionExponent' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, WeaponAimingFreezeInterpScale) == 0x000388, "Member 'UFortAnimInstance::WeaponAimingFreezeInterpScale' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bAimWeaponTowardsReticle) == 0x000394, "Member 'UFortAnimInstance::bAimWeaponTowardsReticle' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, WeaponAimingCurveName) == 0x000398, "Member 'UFortAnimInstance::WeaponAimingCurveName' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, WeaponAimingFreezeCurveName) == 0x0003A0, "Member 'UFortAnimInstance::WeaponAimingFreezeCurveName' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bDebugWeaponAiming) == 0x0003A8, "Member 'UFortAnimInstance::bDebugWeaponAiming' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, LastFramePawnTransform) == 0x0003B0, "Member 'UFortAnimInstance::LastFramePawnTransform' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bCachedPawnTransform) == 0x0003E0, "Member 'UFortAnimInstance::bCachedPawnTransform' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bHasValidWeaponMuzzleSocket) == 0x0003E1, "Member 'UFortAnimInstance::bHasValidWeaponMuzzleSocket' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleSocketName) == 0x0003E4, "Member 'UFortAnimInstance::HeadTrackingReticleSocketName' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleSocketLookAtAxis) == 0x0003EC, "Member 'UFortAnimInstance::HeadTrackingReticleSocketLookAtAxis' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleInterpSpeed) == 0x0003F0, "Member 'UFortAnimInstance::HeadTrackingReticleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleAdjustment) == 0x0003F4, "Member 'UFortAnimInstance::HeadTrackingReticleAdjustment' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticlePitchAlpha) == 0x000400, "Member 'UFortAnimInstance::HeadTrackingReticlePitchAlpha' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleAimDistance) == 0x000404, "Member 'UFortAnimInstance::HeadTrackingReticleAimDistance' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, HeadTrackingReticleAimDistanceDownsights) == 0x000408, "Member 'UFortAnimInstance::HeadTrackingReticleAimDistanceDownsights' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeForRecentlyFired) == 0x00040C, "Member 'UFortAnimInstance::TimeForRecentlyFired' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeToReachRelaxedLevel1) == 0x000410, "Member 'UFortAnimInstance::TimeToReachRelaxedLevel1' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, TimeToReachRelaxedLevel2) == 0x000414, "Member 'UFortAnimInstance::TimeToReachRelaxedLevel2' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bRecentlyFired) == 0x000418, "Member 'UFortAnimInstance::bRecentlyFired' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRelaxedLevel1) == 0x000419, "Member 'UFortAnimInstance::bIsRelaxedLevel1' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRelaxedLevel2) == 0x00041A, "Member 'UFortAnimInstance::bIsRelaxedLevel2' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RelaxedLevelTimeCounter) == 0x00041C, "Member 'UFortAnimInstance::RelaxedLevelTimeCounter' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, SavedWeaponLastFireTime) == 0x000420, "Member 'UFortAnimInstance::SavedWeaponLastFireTime' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bRecordJumpPositions) == 0x000424, "Member 'UFortAnimInstance::bRecordJumpPositions' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, bIsRecordingJump) == 0x000425, "Member 'UFortAnimInstance::bIsRecordingJump' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RecordJumpFrameCount) == 0x000428, "Member 'UFortAnimInstance::RecordJumpFrameCount' has a wrong offset!");
static_assert(offsetof(UFortAnimInstance, RecordJumpInitialJumpLocation) == 0x00042C, "Member 'UFortAnimInstance::RecordJumpInitialJumpLocation' has a wrong offset!");

// Class FortniteGame.FortAIAnimInstance
// 0x0020 (0x0460 - 0x0440)
class UFortAIAnimInstance : public UFortAnimInstance
{
public:
	float                                         Speed;                                             // 0x0438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardVelocity;                                    // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementDirection;                                 // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyCurrentWeight;                            // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunVariation;                                      // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WalkVariation;                                     // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortMovementStyle                            MovementStyle;                                     // 0x0450(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockGetUp;                                        // 0x0451(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsStunned;                                        // 0x0452(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSleeping;                                       // 0x0453(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAdditiveHitReactLoop;                             // 0x0454(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAltSleepAnim;                                  // 0x0455(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldUseMovementLocomotion;                      // 0x0456(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          HideHead;                                          // 0x0457(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIAnimInstance">();
	}
	static class UFortAIAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIAnimInstance>();
	}
};
static_assert(alignof(UFortAIAnimInstance) == 0x000010, "Wrong alignment on UFortAIAnimInstance");
static_assert(sizeof(UFortAIAnimInstance) == 0x000460, "Wrong size on UFortAIAnimInstance");
static_assert(offsetof(UFortAIAnimInstance, Speed) == 0x000438, "Member 'UFortAIAnimInstance::Speed' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, UpwardVelocity) == 0x00043C, "Member 'UFortAIAnimInstance::UpwardVelocity' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, MovementDirection) == 0x000440, "Member 'UFortAIAnimInstance::MovementDirection' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, LowerBodyCurrentWeight) == 0x000444, "Member 'UFortAIAnimInstance::LowerBodyCurrentWeight' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, RunVariation) == 0x000448, "Member 'UFortAIAnimInstance::RunVariation' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, WalkVariation) == 0x00044C, "Member 'UFortAIAnimInstance::WalkVariation' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, MovementStyle) == 0x000450, "Member 'UFortAIAnimInstance::MovementStyle' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, BlockGetUp) == 0x000451, "Member 'UFortAIAnimInstance::BlockGetUp' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, bIsStunned) == 0x000452, "Member 'UFortAIAnimInstance::bIsStunned' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, bIsSleeping) == 0x000453, "Member 'UFortAIAnimInstance::bIsSleeping' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, bAdditiveHitReactLoop) == 0x000454, "Member 'UFortAIAnimInstance::bAdditiveHitReactLoop' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, bUseAltSleepAnim) == 0x000455, "Member 'UFortAIAnimInstance::bUseAltSleepAnim' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, bShouldUseMovementLocomotion) == 0x000456, "Member 'UFortAIAnimInstance::bShouldUseMovementLocomotion' has a wrong offset!");
static_assert(offsetof(UFortAIAnimInstance, HideHead) == 0x000457, "Member 'UFortAIAnimInstance::HideHead' has a wrong offset!");

// Class FortniteGame.FortPlayerAnimGraphInstance
// 0x0000 (0x0440 - 0x0440)
class UFortPlayerAnimGraphInstance : public UFortAnimInstance
{
public:
	void AnimNotify_PlayFireFX(const class UAnimNotify* Notify);
	void AnimNotify_PlaySecondaryFireFX(const class UAnimNotify* Notify);
	void AnimNotify_StopFireFX(const class UAnimNotify* Notify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerAnimGraphInstance">();
	}
	static class UFortPlayerAnimGraphInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlayerAnimGraphInstance>();
	}
};
static_assert(alignof(UFortPlayerAnimGraphInstance) == 0x000010, "Wrong alignment on UFortPlayerAnimGraphInstance");
static_assert(sizeof(UFortPlayerAnimGraphInstance) == 0x000440, "Wrong size on UFortPlayerAnimGraphInstance");

// Class FortniteGame.FortAnimNotify_TriggerGameplayAbility
// 0x0010 (0x0030 - 0x0020)
class UFortAnimNotify_TriggerGameplayAbility final : public UAnimNotify
{
public:
	struct FGameplayTag                           ApplicationTag;                                    // 0x0020(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   MontageSectionIfBlocked;                           // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotify_TriggerGameplayAbility">();
	}
	static class UFortAnimNotify_TriggerGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotify_TriggerGameplayAbility>();
	}
};
static_assert(alignof(UFortAnimNotify_TriggerGameplayAbility) == 0x000004, "Wrong alignment on UFortAnimNotify_TriggerGameplayAbility");
static_assert(sizeof(UFortAnimNotify_TriggerGameplayAbility) == 0x000030, "Wrong size on UFortAnimNotify_TriggerGameplayAbility");
static_assert(offsetof(UFortAnimNotify_TriggerGameplayAbility, ApplicationTag) == 0x000020, "Member 'UFortAnimNotify_TriggerGameplayAbility::ApplicationTag' has a wrong offset!");
static_assert(offsetof(UFortAnimNotify_TriggerGameplayAbility, MontageSectionIfBlocked) == 0x000028, "Member 'UFortAnimNotify_TriggerGameplayAbility::MontageSectionIfBlocked' has a wrong offset!");

// Class FortniteGame.FortAnimNotifyState_AbilityDecisionWindow
// 0x003C (0x0058 - 0x001C)
class UFortAnimNotifyState_AbilityDecisionWindow final : public UAnimNotifyState
{
public:
	struct FFortMontageInputAction                PrimaryInput;                                      // 0x001C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortMontageInputAction                SecondaryInput;                                    // 0x0030(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   DefaultNextSection;                                // 0x0044(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryInputStrikeAngle;                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryInputStrikeAngle;                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboCounter;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_AbilityDecisionWindow">();
	}
	static class UFortAnimNotifyState_AbilityDecisionWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_AbilityDecisionWindow>();
	}
};
static_assert(alignof(UFortAnimNotifyState_AbilityDecisionWindow) == 0x000004, "Wrong alignment on UFortAnimNotifyState_AbilityDecisionWindow");
static_assert(sizeof(UFortAnimNotifyState_AbilityDecisionWindow) == 0x000058, "Wrong size on UFortAnimNotifyState_AbilityDecisionWindow");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, PrimaryInput) == 0x00001C, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::PrimaryInput' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, SecondaryInput) == 0x000030, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::SecondaryInput' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, DefaultNextSection) == 0x000044, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::DefaultNextSection' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, PrimaryInputStrikeAngle) == 0x00004C, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::PrimaryInputStrikeAngle' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, SecondaryInputStrikeAngle) == 0x000050, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::SecondaryInputStrikeAngle' has a wrong offset!");
static_assert(offsetof(UFortAnimNotifyState_AbilityDecisionWindow, ComboCounter) == 0x000054, "Member 'UFortAnimNotifyState_AbilityDecisionWindow::ComboCounter' has a wrong offset!");

// Class FortniteGame.FortAnimNotifyState_AllowBlockedActions
// 0x0000 (0x001C - 0x001C)
class UFortAnimNotifyState_AllowBlockedActions final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_AllowBlockedActions">();
	}
	static class UFortAnimNotifyState_AllowBlockedActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_AllowBlockedActions>();
	}
};
static_assert(alignof(UFortAnimNotifyState_AllowBlockedActions) == 0x000004, "Wrong alignment on UFortAnimNotifyState_AllowBlockedActions");
static_assert(sizeof(UFortAnimNotifyState_AllowBlockedActions) == 0x00001C, "Wrong size on UFortAnimNotifyState_AllowBlockedActions");

// Class FortniteGame.FortProjectileExplosiveBase
// 0x0000 (0x0418 - 0x0418)
class AFortProjectileExplosiveBase : public AFortProjectileBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProjectileExplosiveBase">();
	}
	static class AFortProjectileExplosiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProjectileExplosiveBase>();
	}
};
static_assert(alignof(AFortProjectileExplosiveBase) == 0x000004, "Wrong alignment on AFortProjectileExplosiveBase");
static_assert(sizeof(AFortProjectileExplosiveBase) == 0x000418, "Wrong size on AFortProjectileExplosiveBase");

// Class FortniteGame.FortAnimNotifyState_RootMotionInterrupt
// 0x0008 (0x0024 - 0x001C)
class UFortAnimNotifyState_RootMotionInterrupt final : public UAnimNotifyState
{
public:
	EMontageInterrupt                             MontageInterrupt;                                  // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAllowMoveInput : 1;                               // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAnimNotifyState_RootMotionInterrupt">();
	}
	static class UFortAnimNotifyState_RootMotionInterrupt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAnimNotifyState_RootMotionInterrupt>();
	}
};
static_assert(alignof(UFortAnimNotifyState_RootMotionInterrupt) == 0x000004, "Wrong alignment on UFortAnimNotifyState_RootMotionInterrupt");
static_assert(sizeof(UFortAnimNotifyState_RootMotionInterrupt) == 0x000024, "Wrong size on UFortAnimNotifyState_RootMotionInterrupt");
static_assert(offsetof(UFortAnimNotifyState_RootMotionInterrupt, MontageInterrupt) == 0x00001C, "Member 'UFortAnimNotifyState_RootMotionInterrupt::MontageInterrupt' has a wrong offset!");

// Class FortniteGame.FortAsyncAction_SendQuestStatEvent
// 0x0080 (0x009C - 0x001C)
class UFortAsyncAction_SendQuestStatEvent final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnIgnored;                                         // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailure;                                         // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFortQuestManager*                      QuestManager;                                      // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    ObjectiveStat;                                     // 0x0044(0x000C)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0050(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0068(0x0018)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0080(0x0018)(Transient, NativeAccessSpecifierPrivate)
	int32                                         Count;                                             // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UFortAsyncAction_SendQuestStatEvent* SendClientStatEvent(class UFortQuestManager* QuestManager_0, const struct FDataTableRowHandle& ObjectiveStat_0, int32 Count_0);
	static class UFortAsyncAction_SendQuestStatEvent* SendClientStatEventWithTags(class UFortQuestManager* QuestManager_0, const struct FGameplayTagContainer& TargetTags_0, const struct FGameplayTagContainer& SourceTags_0, const struct FGameplayTagContainer& ContextTags_0, int32 Count_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_SendQuestStatEvent">();
	}
	static class UFortAsyncAction_SendQuestStatEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_SendQuestStatEvent>();
	}
};
static_assert(alignof(UFortAsyncAction_SendQuestStatEvent) == 0x000004, "Wrong alignment on UFortAsyncAction_SendQuestStatEvent");
static_assert(sizeof(UFortAsyncAction_SendQuestStatEvent) == 0x00009C, "Wrong size on UFortAsyncAction_SendQuestStatEvent");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnSuccess) == 0x00001C, "Member 'UFortAsyncAction_SendQuestStatEvent::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnIgnored) == 0x000028, "Member 'UFortAsyncAction_SendQuestStatEvent::OnIgnored' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, OnFailure) == 0x000034, "Member 'UFortAsyncAction_SendQuestStatEvent::OnFailure' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, QuestManager) == 0x000040, "Member 'UFortAsyncAction_SendQuestStatEvent::QuestManager' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, ObjectiveStat) == 0x000044, "Member 'UFortAsyncAction_SendQuestStatEvent::ObjectiveStat' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, TargetTags) == 0x000050, "Member 'UFortAsyncAction_SendQuestStatEvent::TargetTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, SourceTags) == 0x000068, "Member 'UFortAsyncAction_SendQuestStatEvent::SourceTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, ContextTags) == 0x000080, "Member 'UFortAsyncAction_SendQuestStatEvent::ContextTags' has a wrong offset!");
static_assert(offsetof(UFortAsyncAction_SendQuestStatEvent, Count) == 0x000098, "Member 'UFortAsyncAction_SendQuestStatEvent::Count' has a wrong offset!");

// Class FortniteGame.FortAttributeCategory
// 0x000C (0x0028 - 0x001C)
class UFortAttributeCategory final : public UDataAsset
{
public:
	TArray<struct FMyFortCategoryData>            Categories;                                        // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeCategory">();
	}
	static class UFortAttributeCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeCategory>();
	}
};
static_assert(alignof(UFortAttributeCategory) == 0x000004, "Wrong alignment on UFortAttributeCategory");
static_assert(sizeof(UFortAttributeCategory) == 0x000028, "Wrong size on UFortAttributeCategory");
static_assert(offsetof(UFortAttributeCategory, Categories) == 0x00001C, "Member 'UFortAttributeCategory::Categories' has a wrong offset!");

// Class FortniteGame.FortDamageSet
// 0x0028 (0x0048 - 0x0020)
class UFortDamageSet final : public UFortAttributeSet
{
public:
	float                                         OutgoingBaseDamage;                                // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutgoingBaseEnvironmentalDamage;                   // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutgoingAbilityDamage;                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneCritMultiplier;                                // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiceCritChance;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiceCritMultiplier;                                // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackMagnitude;                                // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackZAngle;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlStrength;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlResistance;                                 // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDamageSet">();
	}
	static class UFortDamageSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDamageSet>();
	}
};
static_assert(alignof(UFortDamageSet) == 0x000004, "Wrong alignment on UFortDamageSet");
static_assert(sizeof(UFortDamageSet) == 0x000048, "Wrong size on UFortDamageSet");
static_assert(offsetof(UFortDamageSet, OutgoingBaseDamage) == 0x000020, "Member 'UFortDamageSet::OutgoingBaseDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingBaseEnvironmentalDamage) == 0x000024, "Member 'UFortDamageSet::OutgoingBaseEnvironmentalDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, OutgoingAbilityDamage) == 0x000028, "Member 'UFortDamageSet::OutgoingAbilityDamage' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, ZoneCritMultiplier) == 0x00002C, "Member 'UFortDamageSet::ZoneCritMultiplier' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, DiceCritChance) == 0x000030, "Member 'UFortDamageSet::DiceCritChance' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, DiceCritMultiplier) == 0x000034, "Member 'UFortDamageSet::DiceCritMultiplier' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, KnockbackMagnitude) == 0x000038, "Member 'UFortDamageSet::KnockbackMagnitude' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, KnockbackZAngle) == 0x00003C, "Member 'UFortDamageSet::KnockbackZAngle' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, ControlStrength) == 0x000040, "Member 'UFortDamageSet::ControlStrength' has a wrong offset!");
static_assert(offsetof(UFortDamageSet, ControlResistance) == 0x000044, "Member 'UFortDamageSet::ControlResistance' has a wrong offset!");

// Class FortniteGame.FortObjectiveInterface
// 0x0000 (0x001C - 0x001C)
class IFortObjectiveInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortObjectiveInterface">();
	}
	static class IFortObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortObjectiveInterface>();
	}
};
static_assert(alignof(IFortObjectiveInterface) == 0x000004, "Wrong alignment on IFortObjectiveInterface");
static_assert(sizeof(IFortObjectiveInterface) == 0x00001C, "Wrong size on IFortObjectiveInterface");

// Class FortniteGame.FortBuildingTrapSet
// 0x004C (0x0144 - 0x00F8)
class UFortBuildingTrapSet final : public UFortBuildingActorSet
{
public:
	float                                         Durability;                                        // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDurability;                                     // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurabilityCostPerFire;                             // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmTime;                                           // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x38];                                     // 0x010C(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Durability();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingTrapSet">();
	}
	static class UFortBuildingTrapSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingTrapSet>();
	}
};
static_assert(alignof(UFortBuildingTrapSet) == 0x000004, "Wrong alignment on UFortBuildingTrapSet");
static_assert(sizeof(UFortBuildingTrapSet) == 0x000144, "Wrong size on UFortBuildingTrapSet");
static_assert(offsetof(UFortBuildingTrapSet, Durability) == 0x0000F8, "Member 'UFortBuildingTrapSet::Durability' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, MaxDurability) == 0x0000FC, "Member 'UFortBuildingTrapSet::MaxDurability' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, DurabilityCostPerFire) == 0x000100, "Member 'UFortBuildingTrapSet::DurabilityCostPerFire' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, ArmTime) == 0x000104, "Member 'UFortBuildingTrapSet::ArmTime' has a wrong offset!");
static_assert(offsetof(UFortBuildingTrapSet, ReloadTime) == 0x000108, "Member 'UFortBuildingTrapSet::ReloadTime' has a wrong offset!");

// Class FortniteGame.FortHealing
// 0x0000 (0x002C - 0x002C)
class UFortHealing final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHealing">();
	}
	static class UFortHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHealing>();
	}
};
static_assert(alignof(UFortHealing) == 0x000004, "Wrong alignment on UFortHealing");
static_assert(sizeof(UFortHealing) == 0x00002C, "Wrong size on UFortHealing");

// Class FortniteGame.FortHomebaseSet
// 0x03D0 (0x03F0 - 0x0020)
class UFortHomebaseSet final : public UFortAttributeSet
{
public:
	float                                         Dojo_Level;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_Rating;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_TotalRating;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_WorkerSlots;                                  // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_ManagerSlots;                                 // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_ElderHut_Level;                               // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_GunpowderFoundry_Level;                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_NinjaForge_Level;                             // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_TargetDummies_Level;                          // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dojo_ZenGardens_Level;                             // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_Level;                                  // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_Rating;                                 // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_TotalRating;                            // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_WorkerSlots;                            // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_ManagerSlots;                           // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_SubBuildingOne_Level;                   // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_SubBuildingTwo_Level;                   // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_SubBuildingThree_Level;                 // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_SubBuildingFour_Level;                  // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MilitaryHQ_SubBuildingFive_Level;                  // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_Level;                              // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_Rating;                             // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_TotalRating;                        // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_WorkerSlots;                        // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_ManagerSlots;                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_SubBuildingOne_Level;               // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_SubBuildingTwo_Level;               // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_SubBuildingThree_Level;             // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_SubBuildingFour_Level;              // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivalBunker_SubBuildingFive_Level;              // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_Level;                                     // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_Rating;                                    // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_TotalRating;                               // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_WorkerSlots;                               // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_ManagerSlots;                              // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_SubBuildingOne_Level;                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_SubBuildingTwo_Level;                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_SubBuildingThree_Level;                    // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_SubBuildingFour_Level;                     // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TechLab_SubBuildingFive_Level;                     // 0x00BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Barracks_Level;                                    // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Barracks_Rating;                                   // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Barracks_TotalRating;                              // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Barracks_WorkerSlots;                              // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Barracks_ManagerSlots;                             // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_Level;                               // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_Rating;                              // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_TotalRating;                         // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_WorkerSlots;                         // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_ManagerSlots;                        // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_Warehouse_Level;                     // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_ExpeditionTeam_Level;                // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_Farm_Level;                          // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_ManufacturingPlant_Level;            // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CommandCenter_PowerStation_Level;                  // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Library_Level;                                     // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Library_Rating;                                    // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Library_TotalRating;                               // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Library_WorkerSlots;                               // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Library_ManagerSlots;                              // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainingGrounds_Level;                             // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainingGrounds_Rating;                            // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainingGrounds_TotalRating;                       // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainingGrounds_WorkerSlots;                       // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainingGrounds_ManagerSlots;                      // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blacksmith_Level;                                  // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blacksmith_Rating;                                 // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blacksmith_TotalRating;                            // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blacksmith_WorkerSlots;                            // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blacksmith_ManagerSlots;                           // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gunsmith_Level;                                    // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gunsmith_Rating;                                   // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gunsmith_TotalRating;                              // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gunsmith_WorkerSlots;                              // 0x0144(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gunsmith_ManagerSlots;                             // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScienceLab_Level;                                  // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScienceLab_Rating;                                 // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScienceLab_TotalRating;                            // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScienceLab_WorkerSlots;                            // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScienceLab_ManagerSlots;                           // 0x015C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Workshop_Level;                                    // 0x0160(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Workshop_Rating;                                   // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Workshop_TotalRating;                              // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Workshop_WorkerSlots;                              // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Workshop_ManagerSlots;                             // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Level;                                        // 0x0174(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Rating;                                       // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_WorkerSlots;                                  // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_ManagerSlots;                                 // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_AmmoStash_Level;                              // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Armory_Level;                                 // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Medical_Level;                                // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Storage_Level;                                // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_Workshop_Level;                               // 0x0194(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_StructureCap;                                 // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Keep_PermaniteCap;                                 // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manor_Level;                                       // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manor_Rating;                                      // 0x01A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manor_WorkerSlots;                                 // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manor_ManagerSlots;                                // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Manor_StructureCap;                                // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_Level;                           // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_Rating;                          // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_TotalRating;                     // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_WorkerSlots;                     // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_ManagerSlots;                    // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_SubBuildingOne_Level;            // 0x01C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_SubBuildingTwo_Level;            // 0x01CC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_SubBuildingThree_Level;          // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_SubBuildingFour_Level;           // 0x01D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineeringSchool_SubBuildingFive_Level;           // 0x01D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_Level;                              // 0x01DC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_Rating;                             // 0x01E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_TotalRating;                        // 0x01E4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_WorkerSlots;                        // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_ManagerSlots;                       // 0x01EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_SubBuildingOne_Level;               // 0x01F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_SubBuildingTwo_Level;               // 0x01F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_SubBuildingThree_Level;             // 0x01F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_SubBuildingFour_Level;              // 0x01FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorersGuild_SubBuildingFive_Level;              // 0x0200(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_Level;                                 // 0x0204(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_Rating;                                // 0x0208(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_TotalRating;                           // 0x020C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_WorkerSlots;                           // 0x0210(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_ManagerSlots;                          // 0x0214(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_SubBuildingOne_Level;                  // 0x0218(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_SubBuildingTwo_Level;                  // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_SubBuildingThree_Level;                // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_SubBuildingFour_Level;                 // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringRange_SubBuildingFive_Level;                 // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_Level;                              // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_Rating;                             // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_TotalRating;                        // 0x0234(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_WorkerSlots;                        // 0x0238(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_ManagerSlots;                       // 0x023C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_SubBuildingOne_Level;               // 0x0240(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_SubBuildingTwo_Level;               // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_SubBuildingThree_Level;             // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_SubBuildingFour_Level;              // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GadgetWorkshop_SubBuildingFive_Level;              // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_Level;                                         // 0x0254(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_Rating;                                        // 0x0258(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_TotalRating;                                   // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_WorkerSlots;                                   // 0x0260(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_ManagerSlots;                                  // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_SubBuildingOne_Level;                          // 0x0268(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_SubBuildingTwo_Level;                          // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_SubBuildingThree_Level;                        // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_SubBuildingFour_Level;                         // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gym_SubBuildingFive_Level;                         // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_Level;                                    // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_Rating;                                   // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_TotalRating;                              // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_WorkerSlots;                              // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_ManagerSlots;                             // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_SubBuildingOne_Level;                     // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_SubBuildingTwo_Level;                     // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_SubBuildingThree_Level;                   // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_SubBuildingFour_Level;                    // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hospital_SubBuildingFive_Level;                    // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_Level;                          // 0x02A4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_Rating;                         // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_TotalRating;                    // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_WorkerSlots;                    // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_ManagerSlots;                   // 0x02B4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_SubBuildingOne_Level;           // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_SubBuildingTwo_Level;           // 0x02BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_SubBuildingThree_Level;         // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_SubBuildingFour_Level;          // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MartialArtsAcademy_SubBuildingFive_Level;          // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_Level;                            // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_Rating;                           // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_TotalRating;                      // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_WorkerSlots;                      // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_ManagerSlots;                     // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_SubBuildingOne_Level;             // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_SubBuildingTwo_Level;             // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_SubBuildingThree_Level;           // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_SubBuildingFour_Level;            // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroneManufactory_SubBuildingFive_Level;            // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_Level;                             // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_Rating;                            // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_TotalRating;                       // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_WorkerSlots;                       // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_ManagerSlots;                      // 0x0304(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_SubBuildingOne_Level;              // 0x0308(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_SubBuildingTwo_Level;              // 0x030C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_SubBuildingThree_Level;            // 0x0310(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_SubBuildingFour_Level;             // 0x0314(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingOne_SubBuildingFive_Level;             // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_Level;                             // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_Rating;                            // 0x0320(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_TotalRating;                       // 0x0324(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_WorkerSlots;                       // 0x0328(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_ManagerSlots;                      // 0x032C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_SubBuildingOne_Level;              // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_SubBuildingTwo_Level;              // 0x0334(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_SubBuildingThree_Level;            // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_SubBuildingFour_Level;             // 0x033C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestBuildingTwo_SubBuildingFive_Level;             // 0x0340(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroSlots;                                         // 0x0344(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InventorySizeBonus;                                // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldInventorySizeBonus;                           // 0x034C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Global;                              // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Schematics;                          // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Schematics_Ranged;                   // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Schematics_Melee;                    // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Schematics_Traps;                    // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Personnel;                           // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevelBonus_Alterations;                         // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_MaxCapacity_Food;                         // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_MaxCapacity_ManufacturingParts;           // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_MaxCapacity_Power;                        // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_MaxCapacity_Supplies;                     // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_Production_Food;                          // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_Production_ManufacturingParts;            // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_Production_Power;                         // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resource_Production_Supplies;                      // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupplyDrop_Magnitude;                              // 0x038C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupplyDrop_Level;                                  // 0x0390(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x5C];                                     // 0x0394(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_HomebaseAttr();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomebaseSet">();
	}
	static class UFortHomebaseSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHomebaseSet>();
	}
};
static_assert(alignof(UFortHomebaseSet) == 0x000004, "Wrong alignment on UFortHomebaseSet");
static_assert(sizeof(UFortHomebaseSet) == 0x0003F0, "Wrong size on UFortHomebaseSet");
static_assert(offsetof(UFortHomebaseSet, Dojo_Level) == 0x000020, "Member 'UFortHomebaseSet::Dojo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_Rating) == 0x000024, "Member 'UFortHomebaseSet::Dojo_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_TotalRating) == 0x000028, "Member 'UFortHomebaseSet::Dojo_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_WorkerSlots) == 0x00002C, "Member 'UFortHomebaseSet::Dojo_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_ManagerSlots) == 0x000030, "Member 'UFortHomebaseSet::Dojo_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_ElderHut_Level) == 0x000034, "Member 'UFortHomebaseSet::Dojo_ElderHut_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_GunpowderFoundry_Level) == 0x000038, "Member 'UFortHomebaseSet::Dojo_GunpowderFoundry_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_NinjaForge_Level) == 0x00003C, "Member 'UFortHomebaseSet::Dojo_NinjaForge_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_TargetDummies_Level) == 0x000040, "Member 'UFortHomebaseSet::Dojo_TargetDummies_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Dojo_ZenGardens_Level) == 0x000044, "Member 'UFortHomebaseSet::Dojo_ZenGardens_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_Level) == 0x000048, "Member 'UFortHomebaseSet::MilitaryHQ_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_Rating) == 0x00004C, "Member 'UFortHomebaseSet::MilitaryHQ_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_TotalRating) == 0x000050, "Member 'UFortHomebaseSet::MilitaryHQ_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_WorkerSlots) == 0x000054, "Member 'UFortHomebaseSet::MilitaryHQ_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_ManagerSlots) == 0x000058, "Member 'UFortHomebaseSet::MilitaryHQ_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_SubBuildingOne_Level) == 0x00005C, "Member 'UFortHomebaseSet::MilitaryHQ_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_SubBuildingTwo_Level) == 0x000060, "Member 'UFortHomebaseSet::MilitaryHQ_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_SubBuildingThree_Level) == 0x000064, "Member 'UFortHomebaseSet::MilitaryHQ_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_SubBuildingFour_Level) == 0x000068, "Member 'UFortHomebaseSet::MilitaryHQ_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MilitaryHQ_SubBuildingFive_Level) == 0x00006C, "Member 'UFortHomebaseSet::MilitaryHQ_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_Level) == 0x000070, "Member 'UFortHomebaseSet::SurvivalBunker_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_Rating) == 0x000074, "Member 'UFortHomebaseSet::SurvivalBunker_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_TotalRating) == 0x000078, "Member 'UFortHomebaseSet::SurvivalBunker_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_WorkerSlots) == 0x00007C, "Member 'UFortHomebaseSet::SurvivalBunker_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_ManagerSlots) == 0x000080, "Member 'UFortHomebaseSet::SurvivalBunker_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_SubBuildingOne_Level) == 0x000084, "Member 'UFortHomebaseSet::SurvivalBunker_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_SubBuildingTwo_Level) == 0x000088, "Member 'UFortHomebaseSet::SurvivalBunker_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_SubBuildingThree_Level) == 0x00008C, "Member 'UFortHomebaseSet::SurvivalBunker_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_SubBuildingFour_Level) == 0x000090, "Member 'UFortHomebaseSet::SurvivalBunker_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SurvivalBunker_SubBuildingFive_Level) == 0x000094, "Member 'UFortHomebaseSet::SurvivalBunker_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_Level) == 0x000098, "Member 'UFortHomebaseSet::TechLab_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_Rating) == 0x00009C, "Member 'UFortHomebaseSet::TechLab_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_TotalRating) == 0x0000A0, "Member 'UFortHomebaseSet::TechLab_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_WorkerSlots) == 0x0000A4, "Member 'UFortHomebaseSet::TechLab_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_ManagerSlots) == 0x0000A8, "Member 'UFortHomebaseSet::TechLab_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_SubBuildingOne_Level) == 0x0000AC, "Member 'UFortHomebaseSet::TechLab_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_SubBuildingTwo_Level) == 0x0000B0, "Member 'UFortHomebaseSet::TechLab_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_SubBuildingThree_Level) == 0x0000B4, "Member 'UFortHomebaseSet::TechLab_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_SubBuildingFour_Level) == 0x0000B8, "Member 'UFortHomebaseSet::TechLab_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TechLab_SubBuildingFive_Level) == 0x0000BC, "Member 'UFortHomebaseSet::TechLab_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Barracks_Level) == 0x0000C0, "Member 'UFortHomebaseSet::Barracks_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Barracks_Rating) == 0x0000C4, "Member 'UFortHomebaseSet::Barracks_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Barracks_TotalRating) == 0x0000C8, "Member 'UFortHomebaseSet::Barracks_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Barracks_WorkerSlots) == 0x0000CC, "Member 'UFortHomebaseSet::Barracks_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Barracks_ManagerSlots) == 0x0000D0, "Member 'UFortHomebaseSet::Barracks_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_Level) == 0x0000D4, "Member 'UFortHomebaseSet::CommandCenter_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_Rating) == 0x0000D8, "Member 'UFortHomebaseSet::CommandCenter_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_TotalRating) == 0x0000DC, "Member 'UFortHomebaseSet::CommandCenter_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_WorkerSlots) == 0x0000E0, "Member 'UFortHomebaseSet::CommandCenter_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_ManagerSlots) == 0x0000E4, "Member 'UFortHomebaseSet::CommandCenter_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_Warehouse_Level) == 0x0000E8, "Member 'UFortHomebaseSet::CommandCenter_Warehouse_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_ExpeditionTeam_Level) == 0x0000EC, "Member 'UFortHomebaseSet::CommandCenter_ExpeditionTeam_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_Farm_Level) == 0x0000F0, "Member 'UFortHomebaseSet::CommandCenter_Farm_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_ManufacturingPlant_Level) == 0x0000F4, "Member 'UFortHomebaseSet::CommandCenter_ManufacturingPlant_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, CommandCenter_PowerStation_Level) == 0x0000F8, "Member 'UFortHomebaseSet::CommandCenter_PowerStation_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Library_Level) == 0x0000FC, "Member 'UFortHomebaseSet::Library_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Library_Rating) == 0x000100, "Member 'UFortHomebaseSet::Library_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Library_TotalRating) == 0x000104, "Member 'UFortHomebaseSet::Library_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Library_WorkerSlots) == 0x000108, "Member 'UFortHomebaseSet::Library_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Library_ManagerSlots) == 0x00010C, "Member 'UFortHomebaseSet::Library_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TrainingGrounds_Level) == 0x000110, "Member 'UFortHomebaseSet::TrainingGrounds_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TrainingGrounds_Rating) == 0x000114, "Member 'UFortHomebaseSet::TrainingGrounds_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TrainingGrounds_TotalRating) == 0x000118, "Member 'UFortHomebaseSet::TrainingGrounds_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TrainingGrounds_WorkerSlots) == 0x00011C, "Member 'UFortHomebaseSet::TrainingGrounds_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TrainingGrounds_ManagerSlots) == 0x000120, "Member 'UFortHomebaseSet::TrainingGrounds_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Blacksmith_Level) == 0x000124, "Member 'UFortHomebaseSet::Blacksmith_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Blacksmith_Rating) == 0x000128, "Member 'UFortHomebaseSet::Blacksmith_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Blacksmith_TotalRating) == 0x00012C, "Member 'UFortHomebaseSet::Blacksmith_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Blacksmith_WorkerSlots) == 0x000130, "Member 'UFortHomebaseSet::Blacksmith_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Blacksmith_ManagerSlots) == 0x000134, "Member 'UFortHomebaseSet::Blacksmith_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gunsmith_Level) == 0x000138, "Member 'UFortHomebaseSet::Gunsmith_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gunsmith_Rating) == 0x00013C, "Member 'UFortHomebaseSet::Gunsmith_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gunsmith_TotalRating) == 0x000140, "Member 'UFortHomebaseSet::Gunsmith_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gunsmith_WorkerSlots) == 0x000144, "Member 'UFortHomebaseSet::Gunsmith_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gunsmith_ManagerSlots) == 0x000148, "Member 'UFortHomebaseSet::Gunsmith_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ScienceLab_Level) == 0x00014C, "Member 'UFortHomebaseSet::ScienceLab_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ScienceLab_Rating) == 0x000150, "Member 'UFortHomebaseSet::ScienceLab_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ScienceLab_TotalRating) == 0x000154, "Member 'UFortHomebaseSet::ScienceLab_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ScienceLab_WorkerSlots) == 0x000158, "Member 'UFortHomebaseSet::ScienceLab_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ScienceLab_ManagerSlots) == 0x00015C, "Member 'UFortHomebaseSet::ScienceLab_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Workshop_Level) == 0x000160, "Member 'UFortHomebaseSet::Workshop_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Workshop_Rating) == 0x000164, "Member 'UFortHomebaseSet::Workshop_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Workshop_TotalRating) == 0x000168, "Member 'UFortHomebaseSet::Workshop_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Workshop_WorkerSlots) == 0x00016C, "Member 'UFortHomebaseSet::Workshop_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Workshop_ManagerSlots) == 0x000170, "Member 'UFortHomebaseSet::Workshop_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Level) == 0x000174, "Member 'UFortHomebaseSet::Keep_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Rating) == 0x000178, "Member 'UFortHomebaseSet::Keep_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_WorkerSlots) == 0x00017C, "Member 'UFortHomebaseSet::Keep_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_ManagerSlots) == 0x000180, "Member 'UFortHomebaseSet::Keep_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_AmmoStash_Level) == 0x000184, "Member 'UFortHomebaseSet::Keep_AmmoStash_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Armory_Level) == 0x000188, "Member 'UFortHomebaseSet::Keep_Armory_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Medical_Level) == 0x00018C, "Member 'UFortHomebaseSet::Keep_Medical_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Storage_Level) == 0x000190, "Member 'UFortHomebaseSet::Keep_Storage_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_Workshop_Level) == 0x000194, "Member 'UFortHomebaseSet::Keep_Workshop_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_StructureCap) == 0x000198, "Member 'UFortHomebaseSet::Keep_StructureCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Keep_PermaniteCap) == 0x00019C, "Member 'UFortHomebaseSet::Keep_PermaniteCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_Level) == 0x0001A0, "Member 'UFortHomebaseSet::Manor_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_Rating) == 0x0001A4, "Member 'UFortHomebaseSet::Manor_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_WorkerSlots) == 0x0001A8, "Member 'UFortHomebaseSet::Manor_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_ManagerSlots) == 0x0001AC, "Member 'UFortHomebaseSet::Manor_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Manor_StructureCap) == 0x0001B0, "Member 'UFortHomebaseSet::Manor_StructureCap' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_Level) == 0x0001B4, "Member 'UFortHomebaseSet::EngineeringSchool_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_Rating) == 0x0001B8, "Member 'UFortHomebaseSet::EngineeringSchool_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_TotalRating) == 0x0001BC, "Member 'UFortHomebaseSet::EngineeringSchool_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_WorkerSlots) == 0x0001C0, "Member 'UFortHomebaseSet::EngineeringSchool_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_ManagerSlots) == 0x0001C4, "Member 'UFortHomebaseSet::EngineeringSchool_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_SubBuildingOne_Level) == 0x0001C8, "Member 'UFortHomebaseSet::EngineeringSchool_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_SubBuildingTwo_Level) == 0x0001CC, "Member 'UFortHomebaseSet::EngineeringSchool_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_SubBuildingThree_Level) == 0x0001D0, "Member 'UFortHomebaseSet::EngineeringSchool_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_SubBuildingFour_Level) == 0x0001D4, "Member 'UFortHomebaseSet::EngineeringSchool_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, EngineeringSchool_SubBuildingFive_Level) == 0x0001D8, "Member 'UFortHomebaseSet::EngineeringSchool_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_Level) == 0x0001DC, "Member 'UFortHomebaseSet::ExplorersGuild_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_Rating) == 0x0001E0, "Member 'UFortHomebaseSet::ExplorersGuild_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_TotalRating) == 0x0001E4, "Member 'UFortHomebaseSet::ExplorersGuild_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_WorkerSlots) == 0x0001E8, "Member 'UFortHomebaseSet::ExplorersGuild_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_ManagerSlots) == 0x0001EC, "Member 'UFortHomebaseSet::ExplorersGuild_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_SubBuildingOne_Level) == 0x0001F0, "Member 'UFortHomebaseSet::ExplorersGuild_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_SubBuildingTwo_Level) == 0x0001F4, "Member 'UFortHomebaseSet::ExplorersGuild_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_SubBuildingThree_Level) == 0x0001F8, "Member 'UFortHomebaseSet::ExplorersGuild_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_SubBuildingFour_Level) == 0x0001FC, "Member 'UFortHomebaseSet::ExplorersGuild_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, ExplorersGuild_SubBuildingFive_Level) == 0x000200, "Member 'UFortHomebaseSet::ExplorersGuild_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_Level) == 0x000204, "Member 'UFortHomebaseSet::FiringRange_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_Rating) == 0x000208, "Member 'UFortHomebaseSet::FiringRange_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_TotalRating) == 0x00020C, "Member 'UFortHomebaseSet::FiringRange_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_WorkerSlots) == 0x000210, "Member 'UFortHomebaseSet::FiringRange_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_ManagerSlots) == 0x000214, "Member 'UFortHomebaseSet::FiringRange_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_SubBuildingOne_Level) == 0x000218, "Member 'UFortHomebaseSet::FiringRange_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_SubBuildingTwo_Level) == 0x00021C, "Member 'UFortHomebaseSet::FiringRange_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_SubBuildingThree_Level) == 0x000220, "Member 'UFortHomebaseSet::FiringRange_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_SubBuildingFour_Level) == 0x000224, "Member 'UFortHomebaseSet::FiringRange_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, FiringRange_SubBuildingFive_Level) == 0x000228, "Member 'UFortHomebaseSet::FiringRange_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_Level) == 0x00022C, "Member 'UFortHomebaseSet::GadgetWorkshop_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_Rating) == 0x000230, "Member 'UFortHomebaseSet::GadgetWorkshop_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_TotalRating) == 0x000234, "Member 'UFortHomebaseSet::GadgetWorkshop_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_WorkerSlots) == 0x000238, "Member 'UFortHomebaseSet::GadgetWorkshop_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_ManagerSlots) == 0x00023C, "Member 'UFortHomebaseSet::GadgetWorkshop_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_SubBuildingOne_Level) == 0x000240, "Member 'UFortHomebaseSet::GadgetWorkshop_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_SubBuildingTwo_Level) == 0x000244, "Member 'UFortHomebaseSet::GadgetWorkshop_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_SubBuildingThree_Level) == 0x000248, "Member 'UFortHomebaseSet::GadgetWorkshop_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_SubBuildingFour_Level) == 0x00024C, "Member 'UFortHomebaseSet::GadgetWorkshop_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, GadgetWorkshop_SubBuildingFive_Level) == 0x000250, "Member 'UFortHomebaseSet::GadgetWorkshop_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_Level) == 0x000254, "Member 'UFortHomebaseSet::Gym_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_Rating) == 0x000258, "Member 'UFortHomebaseSet::Gym_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_TotalRating) == 0x00025C, "Member 'UFortHomebaseSet::Gym_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_WorkerSlots) == 0x000260, "Member 'UFortHomebaseSet::Gym_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_ManagerSlots) == 0x000264, "Member 'UFortHomebaseSet::Gym_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_SubBuildingOne_Level) == 0x000268, "Member 'UFortHomebaseSet::Gym_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_SubBuildingTwo_Level) == 0x00026C, "Member 'UFortHomebaseSet::Gym_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_SubBuildingThree_Level) == 0x000270, "Member 'UFortHomebaseSet::Gym_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_SubBuildingFour_Level) == 0x000274, "Member 'UFortHomebaseSet::Gym_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Gym_SubBuildingFive_Level) == 0x000278, "Member 'UFortHomebaseSet::Gym_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_Level) == 0x00027C, "Member 'UFortHomebaseSet::Hospital_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_Rating) == 0x000280, "Member 'UFortHomebaseSet::Hospital_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_TotalRating) == 0x000284, "Member 'UFortHomebaseSet::Hospital_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_WorkerSlots) == 0x000288, "Member 'UFortHomebaseSet::Hospital_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_ManagerSlots) == 0x00028C, "Member 'UFortHomebaseSet::Hospital_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_SubBuildingOne_Level) == 0x000290, "Member 'UFortHomebaseSet::Hospital_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_SubBuildingTwo_Level) == 0x000294, "Member 'UFortHomebaseSet::Hospital_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_SubBuildingThree_Level) == 0x000298, "Member 'UFortHomebaseSet::Hospital_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_SubBuildingFour_Level) == 0x00029C, "Member 'UFortHomebaseSet::Hospital_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Hospital_SubBuildingFive_Level) == 0x0002A0, "Member 'UFortHomebaseSet::Hospital_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_Level) == 0x0002A4, "Member 'UFortHomebaseSet::MartialArtsAcademy_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_Rating) == 0x0002A8, "Member 'UFortHomebaseSet::MartialArtsAcademy_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_TotalRating) == 0x0002AC, "Member 'UFortHomebaseSet::MartialArtsAcademy_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_WorkerSlots) == 0x0002B0, "Member 'UFortHomebaseSet::MartialArtsAcademy_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_ManagerSlots) == 0x0002B4, "Member 'UFortHomebaseSet::MartialArtsAcademy_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_SubBuildingOne_Level) == 0x0002B8, "Member 'UFortHomebaseSet::MartialArtsAcademy_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_SubBuildingTwo_Level) == 0x0002BC, "Member 'UFortHomebaseSet::MartialArtsAcademy_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_SubBuildingThree_Level) == 0x0002C0, "Member 'UFortHomebaseSet::MartialArtsAcademy_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_SubBuildingFour_Level) == 0x0002C4, "Member 'UFortHomebaseSet::MartialArtsAcademy_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MartialArtsAcademy_SubBuildingFive_Level) == 0x0002C8, "Member 'UFortHomebaseSet::MartialArtsAcademy_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_Level) == 0x0002CC, "Member 'UFortHomebaseSet::DroneManufactory_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_Rating) == 0x0002D0, "Member 'UFortHomebaseSet::DroneManufactory_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_TotalRating) == 0x0002D4, "Member 'UFortHomebaseSet::DroneManufactory_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_WorkerSlots) == 0x0002D8, "Member 'UFortHomebaseSet::DroneManufactory_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_ManagerSlots) == 0x0002DC, "Member 'UFortHomebaseSet::DroneManufactory_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_SubBuildingOne_Level) == 0x0002E0, "Member 'UFortHomebaseSet::DroneManufactory_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_SubBuildingTwo_Level) == 0x0002E4, "Member 'UFortHomebaseSet::DroneManufactory_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_SubBuildingThree_Level) == 0x0002E8, "Member 'UFortHomebaseSet::DroneManufactory_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_SubBuildingFour_Level) == 0x0002EC, "Member 'UFortHomebaseSet::DroneManufactory_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, DroneManufactory_SubBuildingFive_Level) == 0x0002F0, "Member 'UFortHomebaseSet::DroneManufactory_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_Level) == 0x0002F4, "Member 'UFortHomebaseSet::TestBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_Rating) == 0x0002F8, "Member 'UFortHomebaseSet::TestBuildingOne_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_TotalRating) == 0x0002FC, "Member 'UFortHomebaseSet::TestBuildingOne_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_WorkerSlots) == 0x000300, "Member 'UFortHomebaseSet::TestBuildingOne_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_ManagerSlots) == 0x000304, "Member 'UFortHomebaseSet::TestBuildingOne_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_SubBuildingOne_Level) == 0x000308, "Member 'UFortHomebaseSet::TestBuildingOne_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_SubBuildingTwo_Level) == 0x00030C, "Member 'UFortHomebaseSet::TestBuildingOne_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_SubBuildingThree_Level) == 0x000310, "Member 'UFortHomebaseSet::TestBuildingOne_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_SubBuildingFour_Level) == 0x000314, "Member 'UFortHomebaseSet::TestBuildingOne_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingOne_SubBuildingFive_Level) == 0x000318, "Member 'UFortHomebaseSet::TestBuildingOne_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_Level) == 0x00031C, "Member 'UFortHomebaseSet::TestBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_Rating) == 0x000320, "Member 'UFortHomebaseSet::TestBuildingTwo_Rating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_TotalRating) == 0x000324, "Member 'UFortHomebaseSet::TestBuildingTwo_TotalRating' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_WorkerSlots) == 0x000328, "Member 'UFortHomebaseSet::TestBuildingTwo_WorkerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_ManagerSlots) == 0x00032C, "Member 'UFortHomebaseSet::TestBuildingTwo_ManagerSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_SubBuildingOne_Level) == 0x000330, "Member 'UFortHomebaseSet::TestBuildingTwo_SubBuildingOne_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_SubBuildingTwo_Level) == 0x000334, "Member 'UFortHomebaseSet::TestBuildingTwo_SubBuildingTwo_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_SubBuildingThree_Level) == 0x000338, "Member 'UFortHomebaseSet::TestBuildingTwo_SubBuildingThree_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_SubBuildingFour_Level) == 0x00033C, "Member 'UFortHomebaseSet::TestBuildingTwo_SubBuildingFour_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, TestBuildingTwo_SubBuildingFive_Level) == 0x000340, "Member 'UFortHomebaseSet::TestBuildingTwo_SubBuildingFive_Level' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, HeroSlots) == 0x000344, "Member 'UFortHomebaseSet::HeroSlots' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, InventorySizeBonus) == 0x000348, "Member 'UFortHomebaseSet::InventorySizeBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, WorldInventorySizeBonus) == 0x00034C, "Member 'UFortHomebaseSet::WorldInventorySizeBonus' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Global) == 0x000350, "Member 'UFortHomebaseSet::MaxLevelBonus_Global' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics) == 0x000354, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Ranged) == 0x000358, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Ranged' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Melee) == 0x00035C, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Melee' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Schematics_Traps) == 0x000360, "Member 'UFortHomebaseSet::MaxLevelBonus_Schematics_Traps' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Personnel) == 0x000364, "Member 'UFortHomebaseSet::MaxLevelBonus_Personnel' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, MaxLevelBonus_Alterations) == 0x000368, "Member 'UFortHomebaseSet::MaxLevelBonus_Alterations' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_MaxCapacity_Food) == 0x00036C, "Member 'UFortHomebaseSet::Resource_MaxCapacity_Food' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_MaxCapacity_ManufacturingParts) == 0x000370, "Member 'UFortHomebaseSet::Resource_MaxCapacity_ManufacturingParts' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_MaxCapacity_Power) == 0x000374, "Member 'UFortHomebaseSet::Resource_MaxCapacity_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_MaxCapacity_Supplies) == 0x000378, "Member 'UFortHomebaseSet::Resource_MaxCapacity_Supplies' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_Production_Food) == 0x00037C, "Member 'UFortHomebaseSet::Resource_Production_Food' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_Production_ManufacturingParts) == 0x000380, "Member 'UFortHomebaseSet::Resource_Production_ManufacturingParts' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_Production_Power) == 0x000384, "Member 'UFortHomebaseSet::Resource_Production_Power' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, Resource_Production_Supplies) == 0x000388, "Member 'UFortHomebaseSet::Resource_Production_Supplies' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SupplyDrop_Magnitude) == 0x00038C, "Member 'UFortHomebaseSet::SupplyDrop_Magnitude' has a wrong offset!");
static_assert(offsetof(UFortHomebaseSet, SupplyDrop_Level) == 0x000390, "Member 'UFortHomebaseSet::SupplyDrop_Level' has a wrong offset!");

// Class FortniteGame.FortMovementSet
// 0x001C (0x003C - 0x0020)
class UFortMovementSet final : public UFortAttributeSet
{
public:
	float                                         WalkSpeed;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeed;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardSpeedMultiplier;                           // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpHeight;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityZScale;                                     // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_SpeedMultiplier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementSet">();
	}
	static class UFortMovementSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementSet>();
	}
};
static_assert(alignof(UFortMovementSet) == 0x000004, "Wrong alignment on UFortMovementSet");
static_assert(sizeof(UFortMovementSet) == 0x00003C, "Wrong size on UFortMovementSet");
static_assert(offsetof(UFortMovementSet, WalkSpeed) == 0x000020, "Member 'UFortMovementSet::WalkSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, RunSpeed) == 0x000024, "Member 'UFortMovementSet::RunSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, SprintSpeed) == 0x000028, "Member 'UFortMovementSet::SprintSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, BackwardSpeedMultiplier) == 0x00002C, "Member 'UFortMovementSet::BackwardSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, JumpHeight) == 0x000030, "Member 'UFortMovementSet::JumpHeight' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, GravityZScale) == 0x000034, "Member 'UFortMovementSet::GravityZScale' has a wrong offset!");
static_assert(offsetof(UFortMovementSet, SpeedMultiplier) == 0x000038, "Member 'UFortMovementSet::SpeedMultiplier' has a wrong offset!");

// Class FortniteGame.FortAttributeTemplate
// 0x000C (0x0028 - 0x001C)
class UFortAttributeTemplate final : public UDataAsset
{
public:
	TArray<EFortItemPropertyType>                 ItemProperties;                                    // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAttributeTemplate">();
	}
	static class UFortAttributeTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAttributeTemplate>();
	}
};
static_assert(alignof(UFortAttributeTemplate) == 0x000004, "Wrong alignment on UFortAttributeTemplate");
static_assert(sizeof(UFortAttributeTemplate) == 0x000028, "Wrong size on UFortAttributeTemplate");
static_assert(offsetof(UFortAttributeTemplate, ItemProperties) == 0x00001C, "Member 'UFortAttributeTemplate::ItemProperties' has a wrong offset!");

// Class FortniteGame.FortPackPersonality
// 0x0070 (0x008C - 0x001C)
class UFortPackPersonality final : public UDataAsset
{
public:
	class USoundCue*                              TickleVOSound;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              TickleSFXSound;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HoverVOSound;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BuySFXSound;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGenericVO_Sound;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGenericSFX_Sound;                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeSilverVO_Sound;                             // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeSilverSFX_Sound;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenSilverVO_Sound;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenSilverSFX_Sound;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeGoldVO_Sound;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              UpgradeGoldSFX_Sound;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGoldVO_Sound;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenGoldSFX_Sound;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGenericVO_Sound;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetAxeVO_Sound;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetBaseballBatVO_Sound;                          // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGardenHoeVO_Sound;                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetGardenRakeVO_Sound;                           // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetHockeyStickVO_Sound;                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetPickAxeVO_Sound;                              // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetPitchforkVO_Sound;                            // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetScytheVO_Sound;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetSledgehammerVO_Sound;                         // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              GreetSwordVO_Sound;                                // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PreHitVO_Sound;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DropMusic_Sound;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OpenMusic_Sound;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPackPersonality">();
	}
	static class UFortPackPersonality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPackPersonality>();
	}
};
static_assert(alignof(UFortPackPersonality) == 0x000004, "Wrong alignment on UFortPackPersonality");
static_assert(sizeof(UFortPackPersonality) == 0x00008C, "Wrong size on UFortPackPersonality");
static_assert(offsetof(UFortPackPersonality, TickleVOSound) == 0x00001C, "Member 'UFortPackPersonality::TickleVOSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, TickleSFXSound) == 0x000020, "Member 'UFortPackPersonality::TickleSFXSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, HoverVOSound) == 0x000024, "Member 'UFortPackPersonality::HoverVOSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, BuySFXSound) == 0x000028, "Member 'UFortPackPersonality::BuySFXSound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGenericVO_Sound) == 0x00002C, "Member 'UFortPackPersonality::OpenGenericVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGenericSFX_Sound) == 0x000030, "Member 'UFortPackPersonality::OpenGenericSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeSilverVO_Sound) == 0x000034, "Member 'UFortPackPersonality::UpgradeSilverVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeSilverSFX_Sound) == 0x000038, "Member 'UFortPackPersonality::UpgradeSilverSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenSilverVO_Sound) == 0x00003C, "Member 'UFortPackPersonality::OpenSilverVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenSilverSFX_Sound) == 0x000040, "Member 'UFortPackPersonality::OpenSilverSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeGoldVO_Sound) == 0x000044, "Member 'UFortPackPersonality::UpgradeGoldVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, UpgradeGoldSFX_Sound) == 0x000048, "Member 'UFortPackPersonality::UpgradeGoldSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGoldVO_Sound) == 0x00004C, "Member 'UFortPackPersonality::OpenGoldVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenGoldSFX_Sound) == 0x000050, "Member 'UFortPackPersonality::OpenGoldSFX_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGenericVO_Sound) == 0x000054, "Member 'UFortPackPersonality::GreetGenericVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetAxeVO_Sound) == 0x000058, "Member 'UFortPackPersonality::GreetAxeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetBaseballBatVO_Sound) == 0x00005C, "Member 'UFortPackPersonality::GreetBaseballBatVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGardenHoeVO_Sound) == 0x000060, "Member 'UFortPackPersonality::GreetGardenHoeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetGardenRakeVO_Sound) == 0x000064, "Member 'UFortPackPersonality::GreetGardenRakeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetHockeyStickVO_Sound) == 0x000068, "Member 'UFortPackPersonality::GreetHockeyStickVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetPickAxeVO_Sound) == 0x00006C, "Member 'UFortPackPersonality::GreetPickAxeVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetPitchforkVO_Sound) == 0x000070, "Member 'UFortPackPersonality::GreetPitchforkVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetScytheVO_Sound) == 0x000074, "Member 'UFortPackPersonality::GreetScytheVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetSledgehammerVO_Sound) == 0x000078, "Member 'UFortPackPersonality::GreetSledgehammerVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, GreetSwordVO_Sound) == 0x00007C, "Member 'UFortPackPersonality::GreetSwordVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, PreHitVO_Sound) == 0x000080, "Member 'UFortPackPersonality::PreHitVO_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, DropMusic_Sound) == 0x000084, "Member 'UFortPackPersonality::DropMusic_Sound' has a wrong offset!");
static_assert(offsetof(UFortPackPersonality, OpenMusic_Sound) == 0x000088, "Member 'UFortPackPersonality::OpenMusic_Sound' has a wrong offset!");

// Class FortniteGame.FortBluGloManager
// 0x0078 (0x02B8 - 0x0240)
class AFortBluGloManager final : public AActor
{
public:
	float                                         BluGloPerMinute;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BluGloIcon;                                        // 0x0244(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBluGloManager">();
	}
	static class AFortBluGloManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortBluGloManager>();
	}
};
static_assert(alignof(AFortBluGloManager) == 0x000004, "Wrong alignment on AFortBluGloManager");
static_assert(sizeof(AFortBluGloManager) == 0x0002B8, "Wrong size on AFortBluGloManager");
static_assert(offsetof(AFortBluGloManager, BluGloPerMinute) == 0x000240, "Member 'AFortBluGloManager::BluGloPerMinute' has a wrong offset!");
static_assert(offsetof(AFortBluGloManager, BluGloIcon) == 0x000244, "Member 'AFortBluGloManager::BluGloIcon' has a wrong offset!");

// Class FortniteGame.FortNotificationManager
// 0x0078 (0x02B8 - 0x0240)
class AFortNotificationManager final : public AActor
{
public:
	TArray<struct FFortClientNotificationData>    Notifications;                                     // 0x0240(0x000C)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x6C];                                     // 0x024C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Notifications();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationManager">();
	}
	static class AFortNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNotificationManager>();
	}
};
static_assert(alignof(AFortNotificationManager) == 0x000004, "Wrong alignment on AFortNotificationManager");
static_assert(sizeof(AFortNotificationManager) == 0x0002B8, "Wrong size on AFortNotificationManager");
static_assert(offsetof(AFortNotificationManager, Notifications) == 0x000240, "Member 'AFortNotificationManager::Notifications' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_DistanceBetween
// 0x0054 (0x009C - 0x0048)
class UFortBTDecorator_DistanceBetween final : public UBTDecorator
{
public:
	EArithmeticKeyOperation                       Operator;                                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKeyA;                                    // 0x004C(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BlackboardKeyB;                                    // 0x006C(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpecifiedDistance;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x4];                                       // 0x0090(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseSelf : 1;                                      // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCalculateAs2D : 1;                                // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCalculationUpdateRate;                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_DistanceBetween">();
	}
	static class UFortBTDecorator_DistanceBetween* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_DistanceBetween>();
	}
};
static_assert(alignof(UFortBTDecorator_DistanceBetween) == 0x000004, "Wrong alignment on UFortBTDecorator_DistanceBetween");
static_assert(sizeof(UFortBTDecorator_DistanceBetween) == 0x00009C, "Wrong size on UFortBTDecorator_DistanceBetween");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, Operator) == 0x000048, "Member 'UFortBTDecorator_DistanceBetween::Operator' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyA) == 0x00004C, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyA' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, BlackboardKeyB) == 0x00006C, "Member 'UFortBTDecorator_DistanceBetween::BlackboardKeyB' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, SpecifiedDistance) == 0x00008C, "Member 'UFortBTDecorator_DistanceBetween::SpecifiedDistance' has a wrong offset!");
static_assert(offsetof(UFortBTDecorator_DistanceBetween, DistanceCalculationUpdateRate) == 0x000098, "Member 'UFortBTDecorator_DistanceBetween::DistanceCalculationUpdateRate' has a wrong offset!");

// Class FortniteGame.FortPartyMemberState
// 0x0044 (0x0084 - 0x0040)
class UFortPartyMemberState final : public UPartyMemberState
{
public:
	struct FFortPartyMemberRepState               MemberState;                                       // 0x0040(0x0040)(Transient, NativeAccessSpecifierPrivate)
	class UFortHeroType*                          HeroType;                                          // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyMemberState">();
	}
	static class UFortPartyMemberState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyMemberState>();
	}
};
static_assert(alignof(UFortPartyMemberState) == 0x000004, "Wrong alignment on UFortPartyMemberState");
static_assert(sizeof(UFortPartyMemberState) == 0x000084, "Wrong size on UFortPartyMemberState");
static_assert(offsetof(UFortPartyMemberState, MemberState) == 0x000040, "Member 'UFortPartyMemberState::MemberState' has a wrong offset!");
static_assert(offsetof(UFortPartyMemberState, HeroType) == 0x000080, "Member 'UFortPartyMemberState::HeroType' has a wrong offset!");

// Class FortniteGame.FortBTDecorator_GameplayAbility_CanHitTarget
// 0x0004 (0x00A0 - 0x009C)
class UFortBTDecorator_GameplayAbility_CanHitTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	uint8                                         UseIdealYawRotationToTarget : 1;                   // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_CanHitTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_CanHitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_CanHitTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_CanHitTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_CanHitTarget) == 0x0000A0, "Wrong size on UFortBTDecorator_GameplayAbility_CanHitTarget");

// Class FortniteGame.FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags
// 0x0000 (0x009C - 0x009C)
class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags">();
	}
	static class UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags) == 0x00009C, "Wrong size on UFortBTDecorator_GameplayAbility_DoesTargetHaveProhibitedTags");

// Class FortniteGame.FortOnlineSessionClient
// 0x0000 (0x00FC - 0x00FC)
class UFortOnlineSessionClient final : public UOnlineSessionClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineSessionClient">();
	}
	static class UFortOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnlineSessionClient>();
	}
};
static_assert(alignof(UFortOnlineSessionClient) == 0x000004, "Wrong alignment on UFortOnlineSessionClient");
static_assert(sizeof(UFortOnlineSessionClient) == 0x0000FC, "Wrong size on UFortOnlineSessionClient");

// Class FortniteGame.FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget
// 0x0000 (0x009C - 0x009C)
class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget final : public UFortBTDecorator_QueryGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTDecorator_GameplayAbility_IsRotatedToAttackTarget">();
	}
	static class UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget>();
	}
};
static_assert(alignof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x000004, "Wrong alignment on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");
static_assert(sizeof(UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget) == 0x00009C, "Wrong size on UFortBTDecorator_GameplayAbility_IsRotatedToAttackTarget");

// Class FortniteGame.FortPawnAction_Move
// 0x002C (0x00C4 - 0x0098)
class UFortPawnAction_Move : public UPawnAction_Move
{
public:
	class UFortPathFollowingComponent*            FortPathFollowingComponent;                        // 0x0098(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABuildingSMActor*                       FallbackMoveGoal;                                  // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortAIHotSpot_Building*                PathObstacleHotspot;                               // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPathObstacleAction                           PathObstacleAction;                                // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBumpIntoSleepingReaction                     BumpSleepingReaction;                              // 0x00A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIOptionFlag                                 DoPathOffsetting;                                  // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIOptionFlag                                 DoSteering;                                        // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIOptionFlag                                 DoObstacleAvoidance;                               // 0x00AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FocusTarget;                                       // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FocalPoint;                                        // 0x00B4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDetectUnexpectedPathBlockingObstacles : 1;        // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bDetectBlockedByPlayer : 1;                        // 0x00C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bEnableSlowdownAtGoal : 1;                         // 0x00C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bStopMovementOnFinish : 1;                         // 0x00C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bForceWalkingMode : 1;                             // 0x00C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bHasFocalPoint : 1;                                // 0x00C0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnAction_Move">();
	}
	static class UFortPawnAction_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnAction_Move>();
	}
};
static_assert(alignof(UFortPawnAction_Move) == 0x000004, "Wrong alignment on UFortPawnAction_Move");
static_assert(sizeof(UFortPawnAction_Move) == 0x0000C4, "Wrong size on UFortPawnAction_Move");
static_assert(offsetof(UFortPawnAction_Move, FortPathFollowingComponent) == 0x000098, "Member 'UFortPawnAction_Move::FortPathFollowingComponent' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, FallbackMoveGoal) == 0x00009C, "Member 'UFortPawnAction_Move::FallbackMoveGoal' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, PathObstacleHotspot) == 0x0000A0, "Member 'UFortPawnAction_Move::PathObstacleHotspot' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, PathObstacleAction) == 0x0000A4, "Member 'UFortPawnAction_Move::PathObstacleAction' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, BumpSleepingReaction) == 0x0000A5, "Member 'UFortPawnAction_Move::BumpSleepingReaction' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, PushBumpedPawnClass) == 0x0000A8, "Member 'UFortPawnAction_Move::PushBumpedPawnClass' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, DoPathOffsetting) == 0x0000AC, "Member 'UFortPawnAction_Move::DoPathOffsetting' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, DoSteering) == 0x0000AD, "Member 'UFortPawnAction_Move::DoSteering' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, DoObstacleAvoidance) == 0x0000AE, "Member 'UFortPawnAction_Move::DoObstacleAvoidance' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, FocusTarget) == 0x0000B0, "Member 'UFortPawnAction_Move::FocusTarget' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_Move, FocalPoint) == 0x0000B4, "Member 'UFortPawnAction_Move::FocalPoint' has a wrong offset!");

// Class FortniteGame.FortBTContext_MoveUrgency
// 0x0004 (0x0050 - 0x004C)
class UFortBTContext_MoveUrgency final : public UFortBTService_ContextOverride
{
public:
	EFortMovementUrgency                          MoveUrgency;                                       // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTContext_MoveUrgency">();
	}
	static class UFortBTContext_MoveUrgency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTContext_MoveUrgency>();
	}
};
static_assert(alignof(UFortBTContext_MoveUrgency) == 0x000004, "Wrong alignment on UFortBTContext_MoveUrgency");
static_assert(sizeof(UFortBTContext_MoveUrgency) == 0x000050, "Wrong size on UFortBTContext_MoveUrgency");
static_assert(offsetof(UFortBTContext_MoveUrgency, MoveUrgency) == 0x00004C, "Member 'UFortBTContext_MoveUrgency::MoveUrgency' has a wrong offset!");

// Class FortniteGame.FortPartyBeaconClient
// 0x0044 (0x02F8 - 0x02B4)
class AFortPartyBeaconClient final : public APartyBeaconClient
{
public:
	struct FEmptyServerReservation                PendingEmptyReservation;                           // 0x02B4(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x10];                                     // 0x02DC(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReconnectionInitialTimeout;                        // 0x02EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReconnectionTimeout;                               // 0x02F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasReconnected;                                   // 0x02F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAllowedToProceedFromReservation();
	void ClientAllowedToProceedFromReservationTimeout();
	void ClientReconnectResponse(EPartyReservationResult ReservationResponse);
	void ServerEmptyServerReservationRequest(const class FString& InSessionId, const struct FEmptyServerReservation& ReservationData, const struct FPartyReservation& Reservation);
	void ServerReconnectExistingReservation(const class FString& InSessionId, const struct FUniqueNetIdRepl& RequestingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconClient">();
	}
	static class AFortPartyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPartyBeaconClient>();
	}
};
static_assert(alignof(AFortPartyBeaconClient) == 0x000004, "Wrong alignment on AFortPartyBeaconClient");
static_assert(sizeof(AFortPartyBeaconClient) == 0x0002F8, "Wrong size on AFortPartyBeaconClient");
static_assert(offsetof(AFortPartyBeaconClient, PendingEmptyReservation) == 0x0002B4, "Member 'AFortPartyBeaconClient::PendingEmptyReservation' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, ReconnectionInitialTimeout) == 0x0002EC, "Member 'AFortPartyBeaconClient::ReconnectionInitialTimeout' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, ReconnectionTimeout) == 0x0002F0, "Member 'AFortPartyBeaconClient::ReconnectionTimeout' has a wrong offset!");
static_assert(offsetof(AFortPartyBeaconClient, bHasReconnected) == 0x0002F4, "Member 'AFortPartyBeaconClient::bHasReconnected' has a wrong offset!");

// Class FortniteGame.FortBTTask_ExecuteGameplayAbility
// 0x0018 (0x0058 - 0x0040)
class UFortBTTask_ExecuteGameplayAbility final : public UBTTask_PawnActionBase
{
public:
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0040(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_ExecuteGameplayAbility">();
	}
	static class UFortBTTask_ExecuteGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_ExecuteGameplayAbility>();
	}
};
static_assert(alignof(UFortBTTask_ExecuteGameplayAbility) == 0x000004, "Wrong alignment on UFortBTTask_ExecuteGameplayAbility");
static_assert(sizeof(UFortBTTask_ExecuteGameplayAbility) == 0x000058, "Wrong size on UFortBTTask_ExecuteGameplayAbility");
static_assert(offsetof(UFortBTTask_ExecuteGameplayAbility, GameplayAbilityTag) == 0x000040, "Member 'UFortBTTask_ExecuteGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.FortConsumableItemDefinition
// 0x0010 (0x05D0 - 0x05C0)
class UFortConsumableItemDefinition final : public UFortWorldItemDefinition
{
public:
	TArray<struct FConsumeEffectData>             ConsumeEffects;                                    // 0x05B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseAnimation;                                      // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseTime;                                           // 0x05C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresMissingHealth;                            // 0x05CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeItem(const struct FGameplayEventData& EventData);

	float GetAnimPlayRate() const;
	float GetHealthRestored(int32 ItemLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsumableItemDefinition">();
	}
	static class UFortConsumableItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsumableItemDefinition>();
	}
};
static_assert(alignof(UFortConsumableItemDefinition) == 0x000010, "Wrong alignment on UFortConsumableItemDefinition");
static_assert(sizeof(UFortConsumableItemDefinition) == 0x0005D0, "Wrong size on UFortConsumableItemDefinition");
static_assert(offsetof(UFortConsumableItemDefinition, ConsumeEffects) == 0x0005B8, "Member 'UFortConsumableItemDefinition::ConsumeEffects' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, UseAnimation) == 0x0005C4, "Member 'UFortConsumableItemDefinition::UseAnimation' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, UseTime) == 0x0005C8, "Member 'UFortConsumableItemDefinition::UseTime' has a wrong offset!");
static_assert(offsetof(UFortConsumableItemDefinition, bRequiresMissingHealth) == 0x0005CC, "Member 'UFortConsumableItemDefinition::bRequiresMissingHealth' has a wrong offset!");

// Class FortniteGame.FortBTTask_RequestUndermining
// 0x0000 (0x0040 - 0x0040)
class UFortBTTask_RequestUndermining final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_RequestUndermining">();
	}
	static class UFortBTTask_RequestUndermining* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_RequestUndermining>();
	}
};
static_assert(alignof(UFortBTTask_RequestUndermining) == 0x000004, "Wrong alignment on UFortBTTask_RequestUndermining");
static_assert(sizeof(UFortBTTask_RequestUndermining) == 0x000040, "Wrong size on UFortBTTask_RequestUndermining");

// Class FortniteGame.FortPawn_FeedbackAnnouncer
// 0x0000 (0x0860 - 0x0860)
class AFortPawn_FeedbackAnnouncer : public AFortPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_FeedbackAnnouncer">();
	}
	static class AFortPawn_FeedbackAnnouncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_FeedbackAnnouncer>();
	}
};
static_assert(alignof(AFortPawn_FeedbackAnnouncer) == 0x000010, "Wrong alignment on AFortPawn_FeedbackAnnouncer");
static_assert(sizeof(AFortPawn_FeedbackAnnouncer) == 0x000860, "Wrong size on AFortPawn_FeedbackAnnouncer");

// Class FortniteGame.FortBTTask_TriggerVOEvent
// 0x0020 (0x0060 - 0x0040)
class UFortBTTask_TriggerVOEvent final : public UBTTaskNode
{
public:
	uint8                                         bUseFeedbackBank : 1;                              // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomEventName;                                   // 0x0044(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedEvent;                                     // 0x0050(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortFeedbackBank*                      FeedbackBank;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBTTask_TriggerVOEvent">();
	}
	static class UFortBTTask_TriggerVOEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBTTask_TriggerVOEvent>();
	}
};
static_assert(alignof(UFortBTTask_TriggerVOEvent) == 0x000004, "Wrong alignment on UFortBTTask_TriggerVOEvent");
static_assert(sizeof(UFortBTTask_TriggerVOEvent) == 0x000060, "Wrong size on UFortBTTask_TriggerVOEvent");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, CustomEventName) == 0x000044, "Member 'UFortBTTask_TriggerVOEvent::CustomEventName' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, SelectedEvent) == 0x000050, "Member 'UFortBTTask_TriggerVOEvent::SelectedEvent' has a wrong offset!");
static_assert(offsetof(UFortBTTask_TriggerVOEvent, FeedbackBank) == 0x00005C, "Member 'UFortBTTask_TriggerVOEvent::FeedbackBank' has a wrong offset!");

// Class FortniteGame.FortBuildingInstructions
// 0x003C (0x0058 - 0x001C)
class UFortBuildingInstructions final : public UDataAsset
{
public:
	class FString                                 MapName;                                           // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortBuildingInstruction>       Instructions;                                      // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, SaveGame, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0034(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumOfPiecesToSpawnAtOnce;                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenSpawns;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingInstructions">();
	}
	static class UFortBuildingInstructions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingInstructions>();
	}
};
static_assert(alignof(UFortBuildingInstructions) == 0x000004, "Wrong alignment on UFortBuildingInstructions");
static_assert(sizeof(UFortBuildingInstructions) == 0x000058, "Wrong size on UFortBuildingInstructions");
static_assert(offsetof(UFortBuildingInstructions, MapName) == 0x00001C, "Member 'UFortBuildingInstructions::MapName' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, Instructions) == 0x000028, "Member 'UFortBuildingInstructions::Instructions' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, Bounds) == 0x000034, "Member 'UFortBuildingInstructions::Bounds' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, NumOfPiecesToSpawnAtOnce) == 0x000050, "Member 'UFortBuildingInstructions::NumOfPiecesToSpawnAtOnce' has a wrong offset!");
static_assert(offsetof(UFortBuildingInstructions, TimeBetweenSpawns) == 0x000054, "Member 'UFortBuildingInstructions::TimeBetweenSpawns' has a wrong offset!");

// Class FortniteGame.FortHexMapPlayerMarker
// 0x006C (0x02C0 - 0x0254)
class AFortHexMapPlayerMarker final : public AFortHexMapMarkerBase
{
public:
	class UCustomColorComponent*                  AccessoryColorSwatchHandler[0x6];                  // 0x0254(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 CharacterPartSkeletalMeshComponents[0x6];          // 0x026C(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomCharacterPart*                   PreviousCharacterParts[0x6];                       // 0x0284(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACustomCharacterPartModifier*           CharacterPartModifiers[0x6];                       // 0x029C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortPlayerState*                       PlayerState;                                       // 0x02B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHexMapPlayerMarker">();
	}
	static class AFortHexMapPlayerMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortHexMapPlayerMarker>();
	}
};
static_assert(alignof(AFortHexMapPlayerMarker) == 0x000004, "Wrong alignment on AFortHexMapPlayerMarker");
static_assert(sizeof(AFortHexMapPlayerMarker) == 0x0002C0, "Wrong size on AFortHexMapPlayerMarker");
static_assert(offsetof(AFortHexMapPlayerMarker, AccessoryColorSwatchHandler) == 0x000254, "Member 'AFortHexMapPlayerMarker::AccessoryColorSwatchHandler' has a wrong offset!");
static_assert(offsetof(AFortHexMapPlayerMarker, CharacterPartSkeletalMeshComponents) == 0x00026C, "Member 'AFortHexMapPlayerMarker::CharacterPartSkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(AFortHexMapPlayerMarker, PreviousCharacterParts) == 0x000284, "Member 'AFortHexMapPlayerMarker::PreviousCharacterParts' has a wrong offset!");
static_assert(offsetof(AFortHexMapPlayerMarker, CharacterPartModifiers) == 0x00029C, "Member 'AFortHexMapPlayerMarker::CharacterPartModifiers' has a wrong offset!");
static_assert(offsetof(AFortHexMapPlayerMarker, PlayerState) == 0x0002B4, "Member 'AFortHexMapPlayerMarker::PlayerState' has a wrong offset!");
static_assert(offsetof(AFortHexMapPlayerMarker, SkeletalMesh) == 0x0002B8, "Member 'AFortHexMapPlayerMarker::SkeletalMesh' has a wrong offset!");

// Class FortniteGame.FortTheaterCamera
// 0x0000 (0x0608 - 0x0608)
class AFortTheaterCamera : public AFortCameraBase
{
public:
	void SetTileFocus(class AFortTheaterMapTile* TargetTile);

	struct FVector LimitToTheater(const struct FVector& DesiredPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterCamera">();
	}
	static class AFortTheaterCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterCamera>();
	}
};
static_assert(alignof(AFortTheaterCamera) == 0x000004, "Wrong alignment on AFortTheaterCamera");
static_assert(sizeof(AFortTheaterCamera) == 0x000608, "Wrong size on AFortTheaterCamera");

// Class FortniteGame.FortGameStatePvP
// 0x00A0 (0x0558 - 0x04B8)
class AFortGameStatePvP : public AFortGameStateZone
{
public:
	int32                                         RoundTimeLimit;                                    // 0x04B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeAccumulated;                              // 0x04BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x4];                                      // 0x04C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundTimeCriticalThreshold;                        // 0x04C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundTimeRemaining;                                // 0x04C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StalemateTimeLimit;                                // 0x04CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StalemateTimeRemaining;                            // 0x04D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RestartTimeRemaining;                              // 0x04D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              RoundTimeExpiringSound;                            // 0x04D8(0x0018)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USoundBase>              StalemateTimeExpiringSound;                        // 0x04F0(0x0018)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABuildingCapturePointActor*>     CapturePoints;                                     // 0x0508(0x000C)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABuildingItemCollectorActor*            ItemCollector;                                     // 0x0514(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartMatchDelayTimer;                              // 0x0518(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bGateCraftingOnTeamLevel : 1;                      // 0x051C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_51D[0x1F];                                     // 0x051D(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MatchLevelCurve;                                   // 0x053C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MatchLevel;                                        // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleMatchLevelChanged;                         // 0x0544(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalHomebaseRating;                               // 0x0550(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AverageHomebaseRating;                             // 0x0554(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class ABuildingItemCollectorActor* GetItemCollector();
	void OnRep_ItemCollector();
	void OnRep_MatchLevel();
	void OnRep_RoundTimeRemaining();
	void OnRep_StalemateTimeRemaining();
	void SetGameDifficultyRow(const struct FDataTableRowHandle& GameDifficultyInfo);
	void SetMatchLevel(int32 InMatchLevel);

	int32 GetAverageHomebaseRating() const;
	int32 GetMatchLevel() const;
	int32 GetRoundTimeAccumulated() const;
	int32 GetTotalHomebaseRating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStatePvP">();
	}
	static class AFortGameStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStatePvP>();
	}
};
static_assert(alignof(AFortGameStatePvP) == 0x000004, "Wrong alignment on AFortGameStatePvP");
static_assert(sizeof(AFortGameStatePvP) == 0x000558, "Wrong size on AFortGameStatePvP");
static_assert(offsetof(AFortGameStatePvP, RoundTimeLimit) == 0x0004B8, "Member 'AFortGameStatePvP::RoundTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeAccumulated) == 0x0004BC, "Member 'AFortGameStatePvP::RoundTimeAccumulated' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeCriticalThreshold) == 0x0004C4, "Member 'AFortGameStatePvP::RoundTimeCriticalThreshold' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeRemaining) == 0x0004C8, "Member 'AFortGameStatePvP::RoundTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeLimit) == 0x0004CC, "Member 'AFortGameStatePvP::StalemateTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeRemaining) == 0x0004D0, "Member 'AFortGameStatePvP::StalemateTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RestartTimeRemaining) == 0x0004D4, "Member 'AFortGameStatePvP::RestartTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, RoundTimeExpiringSound) == 0x0004D8, "Member 'AFortGameStatePvP::RoundTimeExpiringSound' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StalemateTimeExpiringSound) == 0x0004F0, "Member 'AFortGameStatePvP::StalemateTimeExpiringSound' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, CapturePoints) == 0x000508, "Member 'AFortGameStatePvP::CapturePoints' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, ItemCollector) == 0x000514, "Member 'AFortGameStatePvP::ItemCollector' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, StartMatchDelayTimer) == 0x000518, "Member 'AFortGameStatePvP::StartMatchDelayTimer' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, MatchLevelCurve) == 0x00053C, "Member 'AFortGameStatePvP::MatchLevelCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, MatchLevel) == 0x000540, "Member 'AFortGameStatePvP::MatchLevel' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, OnHandleMatchLevelChanged) == 0x000544, "Member 'AFortGameStatePvP::OnHandleMatchLevelChanged' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, TotalHomebaseRating) == 0x000550, "Member 'AFortGameStatePvP::TotalHomebaseRating' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvP, AverageHomebaseRating) == 0x000554, "Member 'AFortGameStatePvP::AverageHomebaseRating' has a wrong offset!");

// Class FortniteGame.Fort3PCam_Targeting
// 0x0000 (0x0110 - 0x0110)
class UFort3PCam_Targeting : public UFort3PCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fort3PCam_Targeting">();
	}
	static class UFort3PCam_Targeting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFort3PCam_Targeting>();
	}
};
static_assert(alignof(UFort3PCam_Targeting) == 0x000004, "Wrong alignment on UFort3PCam_Targeting");
static_assert(sizeof(UFort3PCam_Targeting) == 0x000110, "Wrong size on UFort3PCam_Targeting");

// Class FortniteGame.FortCinematicCamera
// 0x0000 (0x003C - 0x003C)
class UFortCinematicCamera : public UFortCameraMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCinematicCamera">();
	}
	static class UFortCinematicCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCinematicCamera>();
	}
};
static_assert(alignof(UFortCinematicCamera) == 0x000004, "Wrong alignment on UFortCinematicCamera");
static_assert(sizeof(UFortCinematicCamera) == 0x00003C, "Wrong size on UFortCinematicCamera");

// Class FortniteGame.FortVolumeMiniMapIndicator
// 0x0030 (0x00D4 - 0x00A4)
class UFortVolumeMiniMapIndicator final : public UFortMiniMapIndicator
{
public:
	uint8                                         Pad_A4[0x30];                                      // 0x00A4(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVolumeMiniMapIndicator">();
	}
	static class UFortVolumeMiniMapIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortVolumeMiniMapIndicator>();
	}
};
static_assert(alignof(UFortVolumeMiniMapIndicator) == 0x000004, "Wrong alignment on UFortVolumeMiniMapIndicator");
static_assert(sizeof(UFortVolumeMiniMapIndicator) == 0x0000D4, "Wrong size on UFortVolumeMiniMapIndicator");

// Class FortniteGame.FortCarriedObjectInterface
// 0x0000 (0x001C - 0x001C)
class IFortCarriedObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCarriedObjectInterface">();
	}
	static class IFortCarriedObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortCarriedObjectInterface>();
	}
};
static_assert(alignof(IFortCarriedObjectInterface) == 0x000004, "Wrong alignment on IFortCarriedObjectInterface");
static_assert(sizeof(IFortCarriedObjectInterface) == 0x00001C, "Wrong size on IFortCarriedObjectInterface");

// Class FortniteGame.FortFlag
// 0x0008 (0x0368 - 0x0360)
class AFortFlag final : public AFortCarriedObject
{
public:
	class UStaticMeshComponent*                   FlagMeshComp;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0364(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFlag">();
	}
	static class AFortFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortFlag>();
	}
};
static_assert(alignof(AFortFlag) == 0x000004, "Wrong alignment on AFortFlag");
static_assert(sizeof(AFortFlag) == 0x000368, "Wrong size on AFortFlag");
static_assert(offsetof(AFortFlag, FlagMeshComp) == 0x000360, "Member 'AFortFlag::FlagMeshComp' has a wrong offset!");
static_assert(offsetof(AFortFlag, CollisionComp) == 0x000364, "Member 'AFortFlag::CollisionComp' has a wrong offset!");

// Class FortniteGame.FortGlobalAbilityTargetingActor
// 0x0000 (0x0240 - 0x0240)
class AFortGlobalAbilityTargetingActor : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobalAbilityTargetingActor">();
	}
	static class AFortGlobalAbilityTargetingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGlobalAbilityTargetingActor>();
	}
};
static_assert(alignof(AFortGlobalAbilityTargetingActor) == 0x000004, "Wrong alignment on AFortGlobalAbilityTargetingActor");
static_assert(sizeof(AFortGlobalAbilityTargetingActor) == 0x000240, "Wrong size on AFortGlobalAbilityTargetingActor");

// Class FortniteGame.FortPersistentResourceItemDefinition
// 0x0008 (0x0438 - 0x0430)
class UFortPersistentResourceItemDefinition final : public UFortAccountItemDefinition
{
public:
	float                                         WidgetVisibilityThreshold;                         // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortPersistentResources                      PersistentResourceType;                            // 0x0434(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPersistentResourceItemDefinition">();
	}
	static class UFortPersistentResourceItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPersistentResourceItemDefinition>();
	}
};
static_assert(alignof(UFortPersistentResourceItemDefinition) == 0x000004, "Wrong alignment on UFortPersistentResourceItemDefinition");
static_assert(sizeof(UFortPersistentResourceItemDefinition) == 0x000438, "Wrong size on UFortPersistentResourceItemDefinition");
static_assert(offsetof(UFortPersistentResourceItemDefinition, WidgetVisibilityThreshold) == 0x000430, "Member 'UFortPersistentResourceItemDefinition::WidgetVisibilityThreshold' has a wrong offset!");
static_assert(offsetof(UFortPersistentResourceItemDefinition, PersistentResourceType) == 0x000434, "Member 'UFortPersistentResourceItemDefinition::PersistentResourceType' has a wrong offset!");

// Class FortniteGame.FortClientBotManager
// 0x00CC (0x00E8 - 0x001C)
class UFortClientBotManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasMatchmade;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastRandomTurnTime;                                // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickLootTime;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyTime;                                 // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEnemyKilledTime;                               // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBuildingKilledTime;                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyLastSeenTime;                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BuildingLastSeenTime;                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastGoodInteraction;                               // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIPawn*                            EnemyTarget;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPickup*                            PickupTarget;                                      // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     LootTarget;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     SearchTarget;                                      // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingActor*                         BuildingTarget;                                    // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x78];                                      // 0x005C(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasHadPawn;                                       // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x00D8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AFortPlayerPawn*                        MyPawn;                                            // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientBotManager">();
	}
	static class UFortClientBotManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortClientBotManager>();
	}
};
static_assert(alignof(UFortClientBotManager) == 0x000004, "Wrong alignment on UFortClientBotManager");
static_assert(sizeof(UFortClientBotManager) == 0x0000E8, "Wrong size on UFortClientBotManager");
static_assert(offsetof(UFortClientBotManager, bHasMatchmade) == 0x000020, "Member 'UFortClientBotManager::bHasMatchmade' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastRandomTurnTime) == 0x000024, "Member 'UFortClientBotManager::LastRandomTurnTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastPickLootTime) == 0x000028, "Member 'UFortClientBotManager::LastPickLootTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastPickEnemyTime) == 0x00002C, "Member 'UFortClientBotManager::LastPickEnemyTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastEnemyKilledTime) == 0x000030, "Member 'UFortClientBotManager::LastEnemyKilledTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastBuildingKilledTime) == 0x000034, "Member 'UFortClientBotManager::LastBuildingKilledTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, EnemyLastSeenTime) == 0x000038, "Member 'UFortClientBotManager::EnemyLastSeenTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, BuildingLastSeenTime) == 0x00003C, "Member 'UFortClientBotManager::BuildingLastSeenTime' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastGoodInteraction) == 0x000040, "Member 'UFortClientBotManager::LastGoodInteraction' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LastCheckGoodTarget) == 0x000044, "Member 'UFortClientBotManager::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, EnemyTarget) == 0x000048, "Member 'UFortClientBotManager::EnemyTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, PickupTarget) == 0x00004C, "Member 'UFortClientBotManager::PickupTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, LootTarget) == 0x000050, "Member 'UFortClientBotManager::LootTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, SearchTarget) == 0x000054, "Member 'UFortClientBotManager::SearchTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, BuildingTarget) == 0x000058, "Member 'UFortClientBotManager::BuildingTarget' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, bHasHadPawn) == 0x0000D4, "Member 'UFortClientBotManager::bHasHadPawn' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, ViewLocation) == 0x0000D8, "Member 'UFortClientBotManager::ViewLocation' has a wrong offset!");
static_assert(offsetof(UFortClientBotManager, MyPawn) == 0x0000E4, "Member 'UFortClientBotManager::MyPawn' has a wrong offset!");

// Class FortniteGame.FortClientEventInterface
// 0x0000 (0x001C - 0x001C)
class IFortClientEventInterface final : public IInterface
{
public:
	void BlueprintCustomHandleClientEvent(class UObject* EventSource, class UObject* EventFocus, const struct FFortClientEvent& ClientEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortClientEventInterface">();
	}
	static class IFortClientEventInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortClientEventInterface>();
	}
};
static_assert(alignof(IFortClientEventInterface) == 0x000004, "Wrong alignment on IFortClientEventInterface");
static_assert(sizeof(IFortClientEventInterface) == 0x00001C, "Wrong size on IFortClientEventInterface");

// Class FortniteGame.FortHomeTeleporterInterface
// 0x0000 (0x001C - 0x001C)
class IFortHomeTeleporterInterface final : public IInterface
{
public:
	void OnHomeTeleporterBound(class AFortPlayerPawn* PlayerPawn, const class AActor* OldHomeActor);
	void OnHomeTeleporterBoundServer(class AFortPlayerPawn* PlayerPawn, const class AActor* OldHomeActor);
	void OnHomeTeleporterUnbound(class AFortPlayerPawn* PlayerPawn, const class AActor* NewHomeActor);
	void OnHomeTeleporterUnboundServer(class AFortPlayerPawn* PlayerPawn, const class AActor* NewHomeActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHomeTeleporterInterface">();
	}
	static class IFortHomeTeleporterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortHomeTeleporterInterface>();
	}
};
static_assert(alignof(IFortHomeTeleporterInterface) == 0x000004, "Wrong alignment on IFortHomeTeleporterInterface");
static_assert(sizeof(IFortHomeTeleporterInterface) == 0x00001C, "Wrong size on IFortHomeTeleporterInterface");

// Class FortniteGame.FortAmmoItemDefinition
// 0x0340 (0x0900 - 0x05C0)
class UFortAmmoItemDefinition final : public UFortWorldItemDefinition
{
public:
	struct FCanvasIcon                            ReticleIcon;                                       // 0x05B8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ClipIconBrush;                                     // 0x05CC(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsConsumed;                                       // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenCooldown;                                     // 0x0644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortMultiSizeBrush                    AmmoIconBrush;                                     // 0x0648(0x02B8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAmmoItemDefinition">();
	}
	static class UFortAmmoItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAmmoItemDefinition>();
	}
};
static_assert(alignof(UFortAmmoItemDefinition) == 0x000010, "Wrong alignment on UFortAmmoItemDefinition");
static_assert(sizeof(UFortAmmoItemDefinition) == 0x000900, "Wrong size on UFortAmmoItemDefinition");
static_assert(offsetof(UFortAmmoItemDefinition, ReticleIcon) == 0x0005B8, "Member 'UFortAmmoItemDefinition::ReticleIcon' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, ClipIconBrush) == 0x0005CC, "Member 'UFortAmmoItemDefinition::ClipIconBrush' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, bIsConsumed) == 0x000640, "Member 'UFortAmmoItemDefinition::bIsConsumed' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, RegenCooldown) == 0x000644, "Member 'UFortAmmoItemDefinition::RegenCooldown' has a wrong offset!");
static_assert(offsetof(UFortAmmoItemDefinition, AmmoIconBrush) == 0x000648, "Member 'UFortAmmoItemDefinition::AmmoIconBrush' has a wrong offset!");

// Class FortniteGame.FortMissionCompleteNotification
// 0x0000 (0x041C - 0x041C)
class AFortMissionCompleteNotification final : public AFortClientNotification
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionCompleteNotification">();
	}
	static class AFortMissionCompleteNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionCompleteNotification>();
	}
};
static_assert(alignof(AFortMissionCompleteNotification) == 0x000004, "Wrong alignment on AFortMissionCompleteNotification");
static_assert(sizeof(AFortMissionCompleteNotification) == 0x00041C, "Wrong size on AFortMissionCompleteNotification");

// Class FortniteGame.FortTutorialNotification
// 0x01C0 (0x05DC - 0x041C)
class AFortTutorialNotification : public AFortClientNotification
{
public:
	struct FFortTutorialNotificationData          TutorialData;                                      // 0x041C(0x0144)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   StartingNameText;                                  // 0x0560(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   StartingSystemText;                                // 0x056C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bStartingButtonEnabled;                            // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStartingLightboxEnabled;                          // 0x0579(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bStartingLightboxDisableInputOnly;                 // 0x057A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_57B[0x1];                                      // 0x057B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                StartingPadding;                                   // 0x057C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EVerticalAlignment                            StartingVAlign;                                    // 0x058C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          StartingHAlign;                                    // 0x058D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58E[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoContinueDelay;                                 // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x48];                                     // 0x0594(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideTutorialScreen();
	void OnNotificationContinue(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName EventName);
	void SetButtonEnabled(bool bButtonEnabled, bool bForce);
	void SetHAlign(EHorizontalAlignment HAlign, bool bForce);
	void SetLightboxDisableInputOnly(bool bLightboxDisableInputOnly, bool bForce);
	void SetLightboxEnabled(bool bLightboxEnabled, bool bForce);
	void SetNameText(const class FText& NameText, bool bForce);
	void SetPadding(const struct FMargin& Padding, bool bForce);
	void SetSystemText(const class FText& SystemText, bool bForce);
	void SetVAlign(EVerticalAlignment VAlign, bool bForce);
	void ShowTutorialScreen(class UTexture2D* TutorialImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTutorialNotification">();
	}
	static class AFortTutorialNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTutorialNotification>();
	}
};
static_assert(alignof(AFortTutorialNotification) == 0x000004, "Wrong alignment on AFortTutorialNotification");
static_assert(sizeof(AFortTutorialNotification) == 0x0005DC, "Wrong size on AFortTutorialNotification");
static_assert(offsetof(AFortTutorialNotification, TutorialData) == 0x00041C, "Member 'AFortTutorialNotification::TutorialData' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, StartingNameText) == 0x000560, "Member 'AFortTutorialNotification::StartingNameText' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, StartingSystemText) == 0x00056C, "Member 'AFortTutorialNotification::StartingSystemText' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, bStartingButtonEnabled) == 0x000578, "Member 'AFortTutorialNotification::bStartingButtonEnabled' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, bStartingLightboxEnabled) == 0x000579, "Member 'AFortTutorialNotification::bStartingLightboxEnabled' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, bStartingLightboxDisableInputOnly) == 0x00057A, "Member 'AFortTutorialNotification::bStartingLightboxDisableInputOnly' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, StartingPadding) == 0x00057C, "Member 'AFortTutorialNotification::StartingPadding' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, StartingVAlign) == 0x00058C, "Member 'AFortTutorialNotification::StartingVAlign' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, StartingHAlign) == 0x00058D, "Member 'AFortTutorialNotification::StartingHAlign' has a wrong offset!");
static_assert(offsetof(AFortTutorialNotification, AutoContinueDelay) == 0x000590, "Member 'AFortTutorialNotification::AutoContinueDelay' has a wrong offset!");

// Class FortniteGame.FortCharacterCosmeticItem
// 0x000C (0x008C - 0x0080)
class UFortCharacterCosmeticItem final : public UFortAccountItem
{
public:
	class FString                                 Equipped_Character_Id;                             // 0x0080(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterCosmeticItem">();
	}
	static class UFortCharacterCosmeticItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterCosmeticItem>();
	}
};
static_assert(alignof(UFortCharacterCosmeticItem) == 0x000004, "Wrong alignment on UFortCharacterCosmeticItem");
static_assert(sizeof(UFortCharacterCosmeticItem) == 0x00008C, "Wrong size on UFortCharacterCosmeticItem");
static_assert(offsetof(UFortCharacterCosmeticItem, Equipped_Character_Id) == 0x000080, "Member 'UFortCharacterCosmeticItem::Equipped_Character_Id' has a wrong offset!");

// Class FortniteGame.FortEmoteItemDefinition
// 0x0010 (0x05D0 - 0x05C0)
class UFortEmoteItemDefinition final : public UFortWorldItemDefinition
{
public:
	class FText                                   CommandName;                                       // 0x05B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortGameplayAbility>       GameplayAbility;                                   // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEmoteItemDefinition">();
	}
	static class UFortEmoteItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEmoteItemDefinition>();
	}
};
static_assert(alignof(UFortEmoteItemDefinition) == 0x000010, "Wrong alignment on UFortEmoteItemDefinition");
static_assert(sizeof(UFortEmoteItemDefinition) == 0x0005D0, "Wrong size on UFortEmoteItemDefinition");
static_assert(offsetof(UFortEmoteItemDefinition, CommandName) == 0x0005B8, "Member 'UFortEmoteItemDefinition::CommandName' has a wrong offset!");
static_assert(offsetof(UFortEmoteItemDefinition, GameplayAbility) == 0x0005C4, "Member 'UFortEmoteItemDefinition::GameplayAbility' has a wrong offset!");

// Class FortniteGame.FortCinematicNotification
// 0x0000 (0x041C - 0x041C)
class AFortCinematicNotification final : public AFortUIBypassNotification
{
public:
	void OnPlayerSkippedCutscene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCinematicNotification">();
	}
	static class AFortCinematicNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCinematicNotification>();
	}
};
static_assert(alignof(AFortCinematicNotification) == 0x000004, "Wrong alignment on AFortCinematicNotification");
static_assert(sizeof(AFortCinematicNotification) == 0x00041C, "Wrong size on AFortCinematicNotification");

// Class FortniteGame.FortSpottedActorIndicator
// 0x0004 (0x0068 - 0x0064)
class UFortSpottedActorIndicator final : public UFortSlateHUDIndicator
{
public:
	class AFortPlayerController*                  OwnerPC;                                           // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpottedActorIndicator">();
	}
	static class UFortSpottedActorIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpottedActorIndicator>();
	}
};
static_assert(alignof(UFortSpottedActorIndicator) == 0x000004, "Wrong alignment on UFortSpottedActorIndicator");
static_assert(sizeof(UFortSpottedActorIndicator) == 0x000068, "Wrong size on UFortSpottedActorIndicator");
static_assert(offsetof(UFortSpottedActorIndicator, OwnerPC) == 0x000064, "Member 'UFortSpottedActorIndicator::OwnerPC' has a wrong offset!");

// Class FortniteGame.FortLootPackage
// 0x0000 (0x05C0 - 0x05C0)
class UFortLootPackage final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLootPackage">();
	}
	static class UFortLootPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLootPackage>();
	}
};
static_assert(alignof(UFortLootPackage) == 0x000010, "Wrong alignment on UFortLootPackage");
static_assert(sizeof(UFortLootPackage) == 0x0005C0, "Wrong size on UFortLootPackage");

// Class FortniteGame.FortCombatManager
// 0x0704 (0x0944 - 0x0240)
class AFortCombatManager : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedCombatEventHeat[0x16];                   // 0x0244(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatEventHeat[0x16];                             // 0x029C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatFactors[0xC];                                // 0x02F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTotalHeat;                                  // 0x0324(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumTotalHeat;                                  // 0x0328(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHeatEver;                                       // 0x032C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombatEventData                       Events[0x16];                                      // 0x0340(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCombatFactorData                      Factors[0xC];                                      // 0x06B0(0x002C)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C0[0x4];                                      // 0x08C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombatThresholdData                   Thresholds[0x4];                                   // 0x08C4(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	float GetCombatFactorValue(EFortCombatFactors CombatFactor);
	float GetCurrentMaxHeatPercent();
	float GetEventHeatPercent(EFortCombatEvents CombatEvent);
	float GetEventHeatPercentTotal(EFortCombatEvents CombatEvent);
	void OnRep_CombatEventHeat();
	void OnThresholdChange(EFortCombatThresholds OldThreshold, EFortCombatThresholds NewThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCombatManager">();
	}
	static class AFortCombatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCombatManager>();
	}
};
static_assert(alignof(AFortCombatManager) == 0x000004, "Wrong alignment on AFortCombatManager");
static_assert(sizeof(AFortCombatManager) == 0x000944, "Wrong size on AFortCombatManager");
static_assert(offsetof(AFortCombatManager, ReplicatedCombatEventHeat) == 0x000244, "Member 'AFortCombatManager::ReplicatedCombatEventHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CombatEventHeat) == 0x00029C, "Member 'AFortCombatManager::CombatEventHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CombatFactors) == 0x0002F4, "Member 'AFortCombatManager::CombatFactors' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, CurrentTotalHeat) == 0x000324, "Member 'AFortCombatManager::CurrentTotalHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, MaximumTotalHeat) == 0x000328, "Member 'AFortCombatManager::MaximumTotalHeat' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, MaxHeatEver) == 0x00032C, "Member 'AFortCombatManager::MaxHeatEver' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Events) == 0x000340, "Member 'AFortCombatManager::Events' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Factors) == 0x0006B0, "Member 'AFortCombatManager::Factors' has a wrong offset!");
static_assert(offsetof(AFortCombatManager, Thresholds) == 0x0008C4, "Member 'AFortCombatManager::Thresholds' has a wrong offset!");

// Class FortniteGame.FortConsole
// 0x0000 (0x00B8 - 0x00B8)
class UFortConsole final : public UConsole
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortConsole">();
	}
	static class UFortConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortConsole>();
	}
};
static_assert(alignof(UFortConsole) == 0x000004, "Wrong alignment on UFortConsole");
static_assert(sizeof(UFortConsole) == 0x0000B8, "Wrong size on UFortConsole");

// Class FortniteGame.FortAlterationItem
// 0x0000 (0x0080 - 0x0080)
class UFortAlterationItem final : public UFortAccountItem
{
public:
	class UFortAlterationItemDefinition* GetAlterationDefinitionBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAlterationItem">();
	}
	static class UFortAlterationItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAlterationItem>();
	}
};
static_assert(alignof(UFortAlterationItem) == 0x000004, "Wrong alignment on UFortAlterationItem");
static_assert(sizeof(UFortAlterationItem) == 0x000080, "Wrong size on UFortAlterationItem");

// Class FortniteGame.FortDecoItemDefinition
// 0x0020 (0x06E0 - 0x06C0)
class UFortDecoItemDefinition : public UFortWeaponItemDefinition
{
public:
	TSubclassOf<class ABuildingActor>             BlueprintClass;                                    // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortDecoPreview>           PlacementPreviewClass;                             // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSnapSizeOverride;                              // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAngleIncrement;                            // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlacementType                                PlacementTypeOverride;                             // 0x06C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C9[0x3];                                      // 0x06C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceIgnoreOverlapTest : 1;                       // 0x06CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableLocationLerpWhilePlacing : 1;              // 0x06CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableRotationLerpWhilePlacing : 1;              // 0x06CC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableScaleLerpWhilePlacing : 1;                 // 0x06CC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAttachWhenPlacing : 1;                            // 0x06CC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAllowPlacementOnWorldGeometry : 1;                // 0x06CC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bConsumeWhenPlaced : 1;                            // 0x06CC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCancelToolWhenPlaced : 1;                         // 0x06CC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bRequiresPlayerPlaceableAttachmentActors : 1;      // 0x06CD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseRelativeCameraRotation : 1;                    // 0x06CD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAllowStairsWhenAttachingToFloors : 1;             // 0x06CD(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_6CE[0x2];                                      // 0x06CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBuildingEditModeMetadata*>      AllowedShapes;                                     // 0x06D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxPlacementDistance;                              // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoItemDefinition">();
	}
	static class UFortDecoItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDecoItemDefinition>();
	}
};
static_assert(alignof(UFortDecoItemDefinition) == 0x000010, "Wrong alignment on UFortDecoItemDefinition");
static_assert(sizeof(UFortDecoItemDefinition) == 0x0006E0, "Wrong size on UFortDecoItemDefinition");
static_assert(offsetof(UFortDecoItemDefinition, BlueprintClass) == 0x0006B8, "Member 'UFortDecoItemDefinition::BlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, PlacementPreviewClass) == 0x0006BC, "Member 'UFortDecoItemDefinition::PlacementPreviewClass' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, GridSnapSizeOverride) == 0x0006C0, "Member 'UFortDecoItemDefinition::GridSnapSizeOverride' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, RotationAngleIncrement) == 0x0006C4, "Member 'UFortDecoItemDefinition::RotationAngleIncrement' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, PlacementTypeOverride) == 0x0006C8, "Member 'UFortDecoItemDefinition::PlacementTypeOverride' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, AllowedShapes) == 0x0006D0, "Member 'UFortDecoItemDefinition::AllowedShapes' has a wrong offset!");
static_assert(offsetof(UFortDecoItemDefinition, MaxPlacementDistance) == 0x0006DC, "Member 'UFortDecoItemDefinition::MaxPlacementDistance' has a wrong offset!");

// Class FortniteGame.FortTrapItemDefinition
// 0x0010 (0x06F0 - 0x06E0)
class UFortTrapItemDefinition final : public UFortDecoItemDefinition
{
public:
	struct FRotator                               KnockbackDirOverride;                              // 0x06E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bKnockBackUsingPawnDir;                            // 0x06EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6ED[0x3];                                      // 0x06ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapItemDefinition">();
	}
	static class UFortTrapItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrapItemDefinition>();
	}
};
static_assert(alignof(UFortTrapItemDefinition) == 0x000010, "Wrong alignment on UFortTrapItemDefinition");
static_assert(sizeof(UFortTrapItemDefinition) == 0x0006F0, "Wrong size on UFortTrapItemDefinition");
static_assert(offsetof(UFortTrapItemDefinition, KnockbackDirOverride) == 0x0006E0, "Member 'UFortTrapItemDefinition::KnockbackDirOverride' has a wrong offset!");
static_assert(offsetof(UFortTrapItemDefinition, bKnockBackUsingPawnDir) == 0x0006EC, "Member 'UFortTrapItemDefinition::bKnockBackUsingPawnDir' has a wrong offset!");

// Class FortniteGame.FortCrowdManager
// 0x0000 (0x00A8 - 0x00A8)
class UFortCrowdManager final : public UCrowdManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCrowdManager">();
	}
	static class UFortCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCrowdManager>();
	}
};
static_assert(alignof(UFortCrowdManager) == 0x000004, "Wrong alignment on UFortCrowdManager");
static_assert(sizeof(UFortCrowdManager) == 0x0000A8, "Wrong size on UFortCrowdManager");

// Class FortniteGame.FortDayNightLightingAndFog
// 0x06F0 (0x0930 - 0x0240)
class AFortDayNightLightingAndFog : public AInfo
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOfDay;                                         // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDayReplicated;                               // 0x0248(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortDayPhase                                 CurrentDayNightPhase;                              // 0x024C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortDayPhase                                 TransitionFromPhase;                               // 0x024D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortDayPhase                                 TransitionToPhase;                                 // 0x024E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionBlendPercent;                            // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTimeOfDaySpeed;                             // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimeOfDayInGame;                              // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDaySpeed;                                    // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeOfDayAccumulationFactor;                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDayAccumulator;                              // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BasePostProcessMaterial;                           // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               PostProcessMaterialMID;                            // 0x026C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSkipNight : 1;                                    // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bHasClonedPPVs : 1;                                // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTimeStarted : 1;                                  // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bHeightFogEnabled : 1;                             // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SunriseDirectionalLightRotation;                   // 0x0274(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SunsetDirectionalLightRotation;                    // 0x0280(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionalLightRotation;                          // 0x028C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SunriseSunObjectRotation;                          // 0x0298(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SunsetSunObjectRotation;                           // 0x02A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SunObjectDivergencePower;                          // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToSunOrMoon;                               // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             DirectionalLightComponent;                         // 0x02B8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExponentialHeightFogComponent*         ActiveHeightFogComponent;                          // 0x02BC(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortDayPhaseChangeParams*              DayPhaseChangeEventParams;                         // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDayPhaseChangeEvent;                             // 0x02C4(0x000C)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDayPhaseInfo                          LightAndFogPhaseSettings[0x4];                     // 0x02D0(0x014C)(Edit, NativeAccessSpecifierPublic)
	class APostProcessVolume*                     ZoomPostProcessVolume;                             // 0x0800(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogValues            CurrentTimeOfDayFogValues;                         // 0x0804(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           CurrentTimeOfDayDirectionalLightColor;             // 0x083C(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MaterialParameterCollection;                       // 0x084C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RainParticleSystemRelativeOffset;                  // 0x0850(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SunMesh;                                           // 0x085C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            MoonMesh;                                          // 0x0860(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             SunMaterialOverrides;                              // 0x0864(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             MoonMaterialOverrides;                             // 0x0870(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SunScale;                                          // 0x087C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonScale;                                         // 0x0880(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     StarMapMaterial;                                   // 0x0884(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      StormMaterialInst;                                 // 0x0888(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CloudMaskTexture;                                  // 0x088C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogValues            StormFogValues;                                    // 0x0890(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColor;                                    // 0x08C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           StormLightColor;                                   // 0x08D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USkyLightComponent*                     SkyLightComp;                                      // 0x08E8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               RainParticleSystemComp;                            // 0x08EC(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SunOrMoonMeshComp;                                 // 0x08F0(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   SkyDomeMeshComp;                                   // 0x08F4(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StarMapMeshComp;                                   // 0x08F8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ActiveSkyBoxMat;                                   // 0x08FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               StarMapMID;                                        // 0x0900(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_904[0x2C];                                     // 0x0904(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BreakExponentialHeightFogValues(const struct FExponentialHeightFogValues& HeightFogValues, float* FogDensity, float* FogHeightFalloff, float* FogMaxOpacity, float* StartDistance, float* DirectionalInscatteringExponent, float* DirectionalInscatteringStartDistance, struct FLinearColor* DirectionalInscatteringColor, struct FLinearColor* FogInscatteringColor);
	static struct FExponentialHeightFogValues MakeExponentialHeightFogValues(float FogDensity, float FogHeightFalloff, float FogMaxOpacity, float StartDistance, float DirectionalInscatteringExponent, float DirectionalInscatteringStartDistance, const struct FLinearColor& DirectionalInscatteringColor, const struct FLinearColor& FogInscatteringColor);

	void FFToTimeOfDay(float FastForwardTime, float FastForwardSpeed);
	EFortDayPhase GetPreviousDayPhase();
	void OnDayPhaseChange();
	void OnRep_HeightFogEnabled();
	void OnRep_TimeOfDay();
	void OnRep_TimeOfDayInit();
	void OnStormEnd();
	void OnStormStart();
	void OnUpdateDirectionalLightForTimeOfDay(const struct FLinearColor& AboutToApplyDirectionalLightColor);
	void OnUpdateHeightFogForTimeOfDay(const struct FExponentialHeightFogValues& AboutToApplyFogValues);
	void SetDayPhase(const class FString& DayPhase);
	void SetDirectionalLightColorMultiplier(float NewDirectionalLightColorMultiplier);
	void SetFogDirectionalInscatteringMultiplier(float NewFogDirectionalInscatteringMultiplier);
	void SetLightningColorAlpha(float NewLightningColorAlpha);
	void SetStormStrength(float NewStormStrength);
	void SetTimeOfDay(const class FString& NewTimeOfDay);
	void SetTimeOfDayAbsoluteSpeed(float NewTimeOfDaySpeed);
	void SetTimeOfDayFloat(float TimeOfDayInHours);
	void SetTimeOfDayInHours(float TimeOfDayInHours);
	void SetTimeOfDaySpeed(float TimeOfDaySpeedFactor);
	void SetTimeOfDaySpeedFloat(float InTimeOfDaySpeed);
	void ToggleDebugForceStormEffects();
	void ToggleSkipNight();

	class FString GetDayPhaseStartAnnouncementString() const;
	float GetStormStrength() const;
	TArray<struct FThreatLocationInfo> GetThreatClouds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDayNightLightingAndFog">();
	}
	static class AFortDayNightLightingAndFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDayNightLightingAndFog>();
	}
};
static_assert(alignof(AFortDayNightLightingAndFog) == 0x000004, "Wrong alignment on AFortDayNightLightingAndFog");
static_assert(sizeof(AFortDayNightLightingAndFog) == 0x000930, "Wrong size on AFortDayNightLightingAndFog");
static_assert(offsetof(AFortDayNightLightingAndFog, TimeOfDay) == 0x000244, "Member 'AFortDayNightLightingAndFog::TimeOfDay' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TimeOfDayReplicated) == 0x000248, "Member 'AFortDayNightLightingAndFog::TimeOfDayReplicated' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, CurrentDayNightPhase) == 0x00024C, "Member 'AFortDayNightLightingAndFog::CurrentDayNightPhase' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TransitionFromPhase) == 0x00024D, "Member 'AFortDayNightLightingAndFog::TransitionFromPhase' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TransitionToPhase) == 0x00024E, "Member 'AFortDayNightLightingAndFog::TransitionToPhase' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TransitionBlendPercent) == 0x000250, "Member 'AFortDayNightLightingAndFog::TransitionBlendPercent' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, DefaultTimeOfDaySpeed) == 0x000254, "Member 'AFortDayNightLightingAndFog::DefaultTimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StartTimeOfDayInGame) == 0x000258, "Member 'AFortDayNightLightingAndFog::StartTimeOfDayInGame' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TimeOfDaySpeed) == 0x00025C, "Member 'AFortDayNightLightingAndFog::TimeOfDaySpeed' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, MaxTimeOfDayAccumulationFactor) == 0x000260, "Member 'AFortDayNightLightingAndFog::MaxTimeOfDayAccumulationFactor' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, TimeOfDayAccumulator) == 0x000264, "Member 'AFortDayNightLightingAndFog::TimeOfDayAccumulator' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, BasePostProcessMaterial) == 0x000268, "Member 'AFortDayNightLightingAndFog::BasePostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, PostProcessMaterialMID) == 0x00026C, "Member 'AFortDayNightLightingAndFog::PostProcessMaterialMID' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunriseDirectionalLightRotation) == 0x000274, "Member 'AFortDayNightLightingAndFog::SunriseDirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunsetDirectionalLightRotation) == 0x000280, "Member 'AFortDayNightLightingAndFog::SunsetDirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, DirectionalLightRotation) == 0x00028C, "Member 'AFortDayNightLightingAndFog::DirectionalLightRotation' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunriseSunObjectRotation) == 0x000298, "Member 'AFortDayNightLightingAndFog::SunriseSunObjectRotation' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunsetSunObjectRotation) == 0x0002A4, "Member 'AFortDayNightLightingAndFog::SunsetSunObjectRotation' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunObjectDivergencePower) == 0x0002B0, "Member 'AFortDayNightLightingAndFog::SunObjectDivergencePower' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, DistanceToSunOrMoon) == 0x0002B4, "Member 'AFortDayNightLightingAndFog::DistanceToSunOrMoon' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, DirectionalLightComponent) == 0x0002B8, "Member 'AFortDayNightLightingAndFog::DirectionalLightComponent' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, ActiveHeightFogComponent) == 0x0002BC, "Member 'AFortDayNightLightingAndFog::ActiveHeightFogComponent' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, DayPhaseChangeEventParams) == 0x0002C0, "Member 'AFortDayNightLightingAndFog::DayPhaseChangeEventParams' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, OnDayPhaseChangeEvent) == 0x0002C4, "Member 'AFortDayNightLightingAndFog::OnDayPhaseChangeEvent' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, LightAndFogPhaseSettings) == 0x0002D0, "Member 'AFortDayNightLightingAndFog::LightAndFogPhaseSettings' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, ZoomPostProcessVolume) == 0x000800, "Member 'AFortDayNightLightingAndFog::ZoomPostProcessVolume' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, CurrentTimeOfDayFogValues) == 0x000804, "Member 'AFortDayNightLightingAndFog::CurrentTimeOfDayFogValues' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, CurrentTimeOfDayDirectionalLightColor) == 0x00083C, "Member 'AFortDayNightLightingAndFog::CurrentTimeOfDayDirectionalLightColor' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, MaterialParameterCollection) == 0x00084C, "Member 'AFortDayNightLightingAndFog::MaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, RainParticleSystemRelativeOffset) == 0x000850, "Member 'AFortDayNightLightingAndFog::RainParticleSystemRelativeOffset' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunMesh) == 0x00085C, "Member 'AFortDayNightLightingAndFog::SunMesh' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, MoonMesh) == 0x000860, "Member 'AFortDayNightLightingAndFog::MoonMesh' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunMaterialOverrides) == 0x000864, "Member 'AFortDayNightLightingAndFog::SunMaterialOverrides' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, MoonMaterialOverrides) == 0x000870, "Member 'AFortDayNightLightingAndFog::MoonMaterialOverrides' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunScale) == 0x00087C, "Member 'AFortDayNightLightingAndFog::SunScale' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, MoonScale) == 0x000880, "Member 'AFortDayNightLightingAndFog::MoonScale' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StarMapMaterial) == 0x000884, "Member 'AFortDayNightLightingAndFog::StarMapMaterial' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StormMaterialInst) == 0x000888, "Member 'AFortDayNightLightingAndFog::StormMaterialInst' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, CloudMaskTexture) == 0x00088C, "Member 'AFortDayNightLightingAndFog::CloudMaskTexture' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StormFogValues) == 0x000890, "Member 'AFortDayNightLightingAndFog::StormFogValues' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, LightningColor) == 0x0008C8, "Member 'AFortDayNightLightingAndFog::LightningColor' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StormLightColor) == 0x0008D8, "Member 'AFortDayNightLightingAndFog::StormLightColor' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SkyLightComp) == 0x0008E8, "Member 'AFortDayNightLightingAndFog::SkyLightComp' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, RainParticleSystemComp) == 0x0008EC, "Member 'AFortDayNightLightingAndFog::RainParticleSystemComp' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SunOrMoonMeshComp) == 0x0008F0, "Member 'AFortDayNightLightingAndFog::SunOrMoonMeshComp' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, SkyDomeMeshComp) == 0x0008F4, "Member 'AFortDayNightLightingAndFog::SkyDomeMeshComp' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StarMapMeshComp) == 0x0008F8, "Member 'AFortDayNightLightingAndFog::StarMapMeshComp' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, ActiveSkyBoxMat) == 0x0008FC, "Member 'AFortDayNightLightingAndFog::ActiveSkyBoxMat' has a wrong offset!");
static_assert(offsetof(AFortDayNightLightingAndFog, StarMapMID) == 0x000900, "Member 'AFortDayNightLightingAndFog::StarMapMID' has a wrong offset!");

// Class FortniteGame.FortDecoHelper
// 0x0140 (0x0380 - 0x0240)
class AFortDecoHelper final : public AActor
{
public:
	class AFortDecoPreview*                       DecoPreview;                                       // 0x0240(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABuildingActor>             PlacementActorClass;                               // 0x0244(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AFortDecoTool>           DecoTool;                                          // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DecoToolReach;                                     // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecoToolFallbackReach;                             // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuildingAttachmentType                       CurrentAttachmentType;                             // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlacementType                                CurrentPlacementType;                              // 0x0259(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A[0x2];                                      // 0x025A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortDecoItemDefinition*                DecoItemDefinition;                                // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationData[0x2];                                 // 0x0260(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               RelativeRotationData[0x2];                         // 0x0278(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               AbsoluteRotationData[0x2];                         // 0x0290(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ScaleData[0x2];                                    // 0x02A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDecoPlacementState                    PlacementInfo;                                     // 0x02B0(0x0080)(Protected, NativeAccessSpecifierProtected)
	bool                                          bInFallbackPosition;                               // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallbackTinyScale;                                 // 0x0334(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortDecoPlacementQueryResults                CanPlaceState;                                     // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CustomPlacementText;                               // 0x033C(0x000C)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         DesiredRelativeRotation;                           // 0x0348(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DirectionChange;                                   // 0x034C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GridSnapSize;                                      // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FreeFloorPlacementRelativeRotationOffset;          // 0x035C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoHelper">();
	}
	static class AFortDecoHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoHelper>();
	}
};
static_assert(alignof(AFortDecoHelper) == 0x000010, "Wrong alignment on AFortDecoHelper");
static_assert(sizeof(AFortDecoHelper) == 0x000380, "Wrong size on AFortDecoHelper");
static_assert(offsetof(AFortDecoHelper, DecoPreview) == 0x000240, "Member 'AFortDecoHelper::DecoPreview' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, PlacementActorClass) == 0x000244, "Member 'AFortDecoHelper::PlacementActorClass' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoTool) == 0x000248, "Member 'AFortDecoHelper::DecoTool' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoToolReach) == 0x000250, "Member 'AFortDecoHelper::DecoToolReach' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoToolFallbackReach) == 0x000254, "Member 'AFortDecoHelper::DecoToolFallbackReach' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CurrentAttachmentType) == 0x000258, "Member 'AFortDecoHelper::CurrentAttachmentType' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CurrentPlacementType) == 0x000259, "Member 'AFortDecoHelper::CurrentPlacementType' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DecoItemDefinition) == 0x00025C, "Member 'AFortDecoHelper::DecoItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, LocationData) == 0x000260, "Member 'AFortDecoHelper::LocationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, RelativeRotationData) == 0x000278, "Member 'AFortDecoHelper::RelativeRotationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, AbsoluteRotationData) == 0x000290, "Member 'AFortDecoHelper::AbsoluteRotationData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, ScaleData) == 0x0002A8, "Member 'AFortDecoHelper::ScaleData' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, PlacementInfo) == 0x0002B0, "Member 'AFortDecoHelper::PlacementInfo' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, bInFallbackPosition) == 0x000330, "Member 'AFortDecoHelper::bInFallbackPosition' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, FallbackTinyScale) == 0x000334, "Member 'AFortDecoHelper::FallbackTinyScale' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CanPlaceState) == 0x000338, "Member 'AFortDecoHelper::CanPlaceState' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, CustomPlacementText) == 0x00033C, "Member 'AFortDecoHelper::CustomPlacementText' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DesiredRelativeRotation) == 0x000348, "Member 'AFortDecoHelper::DesiredRelativeRotation' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, DirectionChange) == 0x00034C, "Member 'AFortDecoHelper::DirectionChange' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, GridSnapSize) == 0x000358, "Member 'AFortDecoHelper::GridSnapSize' has a wrong offset!");
static_assert(offsetof(AFortDecoHelper, FreeFloorPlacementRelativeRotationOffset) == 0x00035C, "Member 'AFortDecoHelper::FreeFloorPlacementRelativeRotationOffset' has a wrong offset!");

// Class FortniteGame.FortDecoPreview
// 0x011C (0x035C - 0x0240)
class AFortDecoPreview : public AActor
{
public:
	EBuildingAttachmentType                       FallbackAttachmentType;                            // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlacementType                                FallbackPlacementType;                             // 0x0241(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242[0x2];                                      // 0x0242(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      PreviewPlacementMaterial;                          // 0x0244(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             MotionBounceCurve;                                 // 0x025C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CanBePlacedMaterialScalarParam;                    // 0x0274(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValidPlacementScalarParam;                         // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InvalidPlacementScalarParam;                       // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InverseMovementVectorMaterialParam;                // 0x0284(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementEffectScale;                               // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InverseOuterScaleVectorParam;                      // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   InverseInnerScaleVectorParam;                      // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WorldSpacePivotVectorParam;                        // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiffuseTextureParam;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FreePlacementOffset;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              BounceTimeline;                                    // 0x02B4(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       PreviewMIDs;                                       // 0x0334(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DirectionChange;                                   // 0x0340(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                WorldSpacePivot;                                   // 0x034C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AFortDecoHelper*                        ParentDecoHelper;                                  // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UMaterialInstanceDynamic* CreatePreviewMID(class UMaterialInterface* OverrideParentMaterial);
	class UTexture* GetTextureParameterValueFromMeshComponent(class UMeshComponent* MeshComp, int32 ElementIdx, class FName ParamName);
	void OnBounceMotionUpdate(float VectorScale);
	void OnInitializeDecoPreview(const class ABuildingActor* NewBuildingActor, const class UFortDecoItemDefinition* NewDecoItemDefinition);
	void OnUpdateScale(float Scale, const struct FVector& InWorldSpacePivot);
	void OnUpdateVisuals(float DeltaSeconds, bool bSafeToPlace);
	void SetDiffuseTextureParameterOnMID(class UMaterialInstanceDynamic* Mid, class UTexture* Texture);
	void SetScalarParameterValueOnAllPreviewMIDs(class FName ParamName, float ParamValue);
	void SetVectorParameterValueOnAllPreviewMIDs(class FName ParamName, const struct FLinearColor& ParamValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview">();
	}
	static class AFortDecoPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview>();
	}
};
static_assert(alignof(AFortDecoPreview) == 0x000004, "Wrong alignment on AFortDecoPreview");
static_assert(sizeof(AFortDecoPreview) == 0x00035C, "Wrong size on AFortDecoPreview");
static_assert(offsetof(AFortDecoPreview, FallbackAttachmentType) == 0x000240, "Member 'AFortDecoPreview::FallbackAttachmentType' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, FallbackPlacementType) == 0x000241, "Member 'AFortDecoPreview::FallbackPlacementType' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, PreviewPlacementMaterial) == 0x000244, "Member 'AFortDecoPreview::PreviewPlacementMaterial' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, MotionBounceCurve) == 0x00025C, "Member 'AFortDecoPreview::MotionBounceCurve' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, CanBePlacedMaterialScalarParam) == 0x000274, "Member 'AFortDecoPreview::CanBePlacedMaterialScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, ValidPlacementScalarParam) == 0x00027C, "Member 'AFortDecoPreview::ValidPlacementScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InvalidPlacementScalarParam) == 0x000280, "Member 'AFortDecoPreview::InvalidPlacementScalarParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseMovementVectorMaterialParam) == 0x000284, "Member 'AFortDecoPreview::InverseMovementVectorMaterialParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, MovementEffectScale) == 0x00028C, "Member 'AFortDecoPreview::MovementEffectScale' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseOuterScaleVectorParam) == 0x000290, "Member 'AFortDecoPreview::InverseOuterScaleVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, InverseInnerScaleVectorParam) == 0x000298, "Member 'AFortDecoPreview::InverseInnerScaleVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, WorldSpacePivotVectorParam) == 0x0002A0, "Member 'AFortDecoPreview::WorldSpacePivotVectorParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, DiffuseTextureParam) == 0x0002A8, "Member 'AFortDecoPreview::DiffuseTextureParam' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, FreePlacementOffset) == 0x0002B0, "Member 'AFortDecoPreview::FreePlacementOffset' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, BounceTimeline) == 0x0002B4, "Member 'AFortDecoPreview::BounceTimeline' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, PreviewMIDs) == 0x000334, "Member 'AFortDecoPreview::PreviewMIDs' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, DirectionChange) == 0x000340, "Member 'AFortDecoPreview::DirectionChange' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, WorldSpacePivot) == 0x00034C, "Member 'AFortDecoPreview::WorldSpacePivot' has a wrong offset!");
static_assert(offsetof(AFortDecoPreview, ParentDecoHelper) == 0x000358, "Member 'AFortDecoPreview::ParentDecoHelper' has a wrong offset!");

// Class FortniteGame.FortDecoPreview_ComponentHarvester
// 0x0000 (0x035C - 0x035C)
class AFortDecoPreview_ComponentHarvester : public AFortDecoPreview
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_ComponentHarvester">();
	}
	static class AFortDecoPreview_ComponentHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_ComponentHarvester>();
	}
};
static_assert(alignof(AFortDecoPreview_ComponentHarvester) == 0x000004, "Wrong alignment on AFortDecoPreview_ComponentHarvester");
static_assert(sizeof(AFortDecoPreview_ComponentHarvester) == 0x00035C, "Wrong size on AFortDecoPreview_ComponentHarvester");

// Class FortniteGame.FortDecoPreview_MeshHarvester
// 0x0000 (0x035C - 0x035C)
class AFortDecoPreview_MeshHarvester final : public AFortDecoPreview_ComponentHarvester
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_MeshHarvester">();
	}
	static class AFortDecoPreview_MeshHarvester* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_MeshHarvester>();
	}
};
static_assert(alignof(AFortDecoPreview_MeshHarvester) == 0x000004, "Wrong alignment on AFortDecoPreview_MeshHarvester");
static_assert(sizeof(AFortDecoPreview_MeshHarvester) == 0x00035C, "Wrong size on AFortDecoPreview_MeshHarvester");

// Class FortniteGame.FortDecoPreview_GenericBuildingSMActor
// 0x0004 (0x0360 - 0x035C)
class AFortDecoPreview_GenericBuildingSMActor : public AFortDecoPreview
{
public:
	class UStaticMeshComponent*                   PrimaryMeshComponent;                              // 0x035C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_GenericBuildingSMActor">();
	}
	static class AFortDecoPreview_GenericBuildingSMActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_GenericBuildingSMActor>();
	}
};
static_assert(alignof(AFortDecoPreview_GenericBuildingSMActor) == 0x000004, "Wrong alignment on AFortDecoPreview_GenericBuildingSMActor");
static_assert(sizeof(AFortDecoPreview_GenericBuildingSMActor) == 0x000360, "Wrong size on AFortDecoPreview_GenericBuildingSMActor");
static_assert(offsetof(AFortDecoPreview_GenericBuildingSMActor, PrimaryMeshComponent) == 0x00035C, "Member 'AFortDecoPreview_GenericBuildingSMActor::PrimaryMeshComponent' has a wrong offset!");

// Class FortniteGame.FortDecoPreview_GenericTrap
// 0x0004 (0x0364 - 0x0360)
class AFortDecoPreview_GenericTrap final : public AFortDecoPreview_GenericBuildingSMActor
{
public:
	class UStaticMeshComponent*                   TrapRangeMeshComponent;                            // 0x0360(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDecoPreview_GenericTrap">();
	}
	static class AFortDecoPreview_GenericTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortDecoPreview_GenericTrap>();
	}
};
static_assert(alignof(AFortDecoPreview_GenericTrap) == 0x000004, "Wrong alignment on AFortDecoPreview_GenericTrap");
static_assert(sizeof(AFortDecoPreview_GenericTrap) == 0x000364, "Wrong size on AFortDecoPreview_GenericTrap");
static_assert(offsetof(AFortDecoPreview_GenericTrap, TrapRangeMeshComponent) == 0x000360, "Member 'AFortDecoPreview_GenericTrap::TrapRangeMeshComponent' has a wrong offset!");

// Class FortniteGame.FortTrackPreview
// 0x0054 (0x03B0 - 0x035C)
class AFortTrackPreview final : public AFortDecoPreview
{
public:
	struct FTrackMeshTrackPieceTypeConfig         MeshesByTrackPieceType[0x3];                       // 0x035C(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CellSize;                                          // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackMeshComp1;                                    // 0x03A8(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   TrackMeshComp2;                                    // 0x03AC(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeTrackPreview(class UStaticMeshComponent* InTrackMeshComp1, class UStaticMeshComponent* InTrackMeshComp2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrackPreview">();
	}
	static class AFortTrackPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrackPreview>();
	}
};
static_assert(alignof(AFortTrackPreview) == 0x000004, "Wrong alignment on AFortTrackPreview");
static_assert(sizeof(AFortTrackPreview) == 0x0003B0, "Wrong size on AFortTrackPreview");
static_assert(offsetof(AFortTrackPreview, MeshesByTrackPieceType) == 0x00035C, "Member 'AFortTrackPreview::MeshesByTrackPieceType' has a wrong offset!");
static_assert(offsetof(AFortTrackPreview, CellSize) == 0x0003A4, "Member 'AFortTrackPreview::CellSize' has a wrong offset!");
static_assert(offsetof(AFortTrackPreview, TrackMeshComp1) == 0x0003A8, "Member 'AFortTrackPreview::TrackMeshComp1' has a wrong offset!");
static_assert(offsetof(AFortTrackPreview, TrackMeshComp2) == 0x0003AC, "Member 'AFortTrackPreview::TrackMeshComp2' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Breathers
// 0x0028 (0x0054 - 0x002C)
class UFortDifficultyOptionEncounter_Breathers final : public UFortDifficultyOptionEncounter
{
public:
	bool                                          bUseBreathers;                                     // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   LowPlayerPerformanceBreatherTimeSecondsCurve;      // 0x0030(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   NormalPlayerPerformanceBreatherTimeSecondsCurve;   // 0x003C(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   HighPlayerPerformanceBreatherTimeSecondsCurve;     // 0x0048(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Breathers">();
	}
	static class UFortDifficultyOptionEncounter_Breathers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Breathers>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Breathers) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_Breathers");
static_assert(sizeof(UFortDifficultyOptionEncounter_Breathers) == 0x000054, "Wrong size on UFortDifficultyOptionEncounter_Breathers");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, bUseBreathers) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_Breathers::bUseBreathers' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, LowPlayerPerformanceBreatherTimeSecondsCurve) == 0x000030, "Member 'UFortDifficultyOptionEncounter_Breathers::LowPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, NormalPlayerPerformanceBreatherTimeSecondsCurve) == 0x00003C, "Member 'UFortDifficultyOptionEncounter_Breathers::NormalPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Breathers, HighPlayerPerformanceBreatherTimeSecondsCurve) == 0x000048, "Member 'UFortDifficultyOptionEncounter_Breathers::HighPlayerPerformanceBreatherTimeSecondsCurve' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_DirectionChange
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_DirectionChange final : public UFortDifficultyOptionEncounter
{
public:
	bool                                          bChangeDirectionsOnRest;                           // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_DirectionChange">();
	}
	static class UFortDifficultyOptionEncounter_DirectionChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_DirectionChange>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_DirectionChange) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_DirectionChange");
static_assert(sizeof(UFortDifficultyOptionEncounter_DirectionChange) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_DirectionChange");
static_assert(offsetof(UFortDifficultyOptionEncounter_DirectionChange, bChangeDirectionsOnRest) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_DirectionChange::bChangeDirectionsOnRest' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_DirectionNumber
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_DirectionNumber final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         NumberOfDirections;                                // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_DirectionNumber">();
	}
	static class UFortDifficultyOptionEncounter_DirectionNumber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_DirectionNumber>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_DirectionNumber) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_DirectionNumber");
static_assert(sizeof(UFortDifficultyOptionEncounter_DirectionNumber) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_DirectionNumber");
static_assert(offsetof(UFortDifficultyOptionEncounter_DirectionNumber, NumberOfDirections) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_DirectionNumber::NumberOfDirections' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Distance
// 0x0008 (0x0034 - 0x002C)
class UFortDifficultyOptionEncounter_Distance final : public UFortDifficultyOptionEncounter
{
public:
	float                                         MinSpawnDistance;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDistance;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Distance">();
	}
	static class UFortDifficultyOptionEncounter_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Distance>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Distance) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_Distance");
static_assert(sizeof(UFortDifficultyOptionEncounter_Distance) == 0x000034, "Wrong size on UFortDifficultyOptionEncounter_Distance");
static_assert(offsetof(UFortDifficultyOptionEncounter_Distance, MinSpawnDistance) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_Distance::MinSpawnDistance' has a wrong offset!");
static_assert(offsetof(UFortDifficultyOptionEncounter_Distance, MaxSpawnDistance) == 0x000030, "Member 'UFortDifficultyOptionEncounter_Distance::MaxSpawnDistance' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_IntensityCurveSequence
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_IntensityCurveSequence final : public UFortDifficultyOptionEncounter
{
public:
	class UFortIntensityCurveSequence*            CurveSequence;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_IntensityCurveSequence">();
	}
	static class UFortDifficultyOptionEncounter_IntensityCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_IntensityCurveSequence>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_IntensityCurveSequence) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_IntensityCurveSequence");
static_assert(sizeof(UFortDifficultyOptionEncounter_IntensityCurveSequence) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_IntensityCurveSequence");
static_assert(offsetof(UFortDifficultyOptionEncounter_IntensityCurveSequence, CurveSequence) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_IntensityCurveSequence::CurveSequence' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_ModifierTags
// 0x0018 (0x0044 - 0x002C)
class UFortDifficultyOptionEncounter_ModifierTags final : public UFortDifficultyOptionEncounter
{
public:
	struct FGameplayTagContainer                  ModifierTags;                                      // 0x002C(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_ModifierTags">();
	}
	static class UFortDifficultyOptionEncounter_ModifierTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_ModifierTags>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_ModifierTags) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_ModifierTags");
static_assert(sizeof(UFortDifficultyOptionEncounter_ModifierTags) == 0x000044, "Wrong size on UFortDifficultyOptionEncounter_ModifierTags");
static_assert(offsetof(UFortDifficultyOptionEncounter_ModifierTags, ModifierTags) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_ModifierTags::ModifierTags' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_PawnNumberCap
// 0x0010 (0x003C - 0x002C)
class UFortDifficultyOptionEncounter_PawnNumberCap final : public UFortDifficultyOptionEncounter
{
public:
	struct FFortEncounterPawnNumberCaps           PawnCapsPerPlayerCount;                            // 0x002C(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_PawnNumberCap">();
	}
	static class UFortDifficultyOptionEncounter_PawnNumberCap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_PawnNumberCap>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_PawnNumberCap) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_PawnNumberCap");
static_assert(sizeof(UFortDifficultyOptionEncounter_PawnNumberCap) == 0x00003C, "Wrong size on UFortDifficultyOptionEncounter_PawnNumberCap");
static_assert(offsetof(UFortDifficultyOptionEncounter_PawnNumberCap, PawnCapsPerPlayerCount) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_PawnNumberCap::PawnCapsPerPlayerCount' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnGroupProgression
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnGroupProgression final : public UFortDifficultyOptionEncounter
{
public:
	class UFortAISpawnGroupProgressionInfo*       SpawnGroupProgression;                             // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnGroupProgression">();
	}
	static class UFortDifficultyOptionEncounter_SpawnGroupProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnGroupProgression>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnGroupProgression) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnGroupProgression");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnGroupProgression) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_SpawnGroupProgression");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnGroupProgression, SpawnGroupProgression) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnGroupProgression::SpawnGroupProgression' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnLimitPawns
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnLimitPawns final : public UFortDifficultyOptionEncounter
{
public:
	int32                                         PawnNumberLimit;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnLimitPawns">();
	}
	static class UFortDifficultyOptionEncounter_SpawnLimitPawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnLimitPawns>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnLimitPawns) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnLimitPawns");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnLimitPawns) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_SpawnLimitPawns");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnLimitPawns, PawnNumberLimit) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnLimitPawns::PawnNumberLimit' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnLimitPoints
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnLimitPoints final : public UFortDifficultyOptionEncounter
{
public:
	float                                         SpawnPointsPercentageLimit;                        // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnLimitPoints">();
	}
	static class UFortDifficultyOptionEncounter_SpawnLimitPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnLimitPoints>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnLimitPoints) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnLimitPoints");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnLimitPoints) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_SpawnLimitPoints");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnLimitPoints, SpawnPointsPercentageLimit) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnLimitPoints::SpawnPointsPercentageLimit' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsBurst
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnPointsBurst final : public UFortDifficultyOptionEncounter
{
public:
	float                                         BurstSpawnPointsPercentage;                        // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsBurst">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsBurst>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsBurst) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsBurst");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsBurst) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsBurst");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsBurst, BurstSpawnPointsPercentage) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnPointsBurst::BurstSpawnPointsPercentage' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsCurve
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnPointsCurve final : public UFortDifficultyOptionEncounter
{
public:
	class UFortSpawnPointsPercentageCurveSequence* CurveSequence;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsCurve">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsCurve>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsCurve) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsCurve");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsCurve) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsCurve");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsCurve, CurveSequence) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnPointsCurve::CurveSequence' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_SpawnPointsMultiplier
// 0x0008 (0x0034 - 0x002C)
class UFortDifficultyOptionEncounter_SpawnPointsMultiplier final : public UFortDifficultyOptionEncounter
{
public:
	struct FFloatInterval                         MultiplierRange;                                   // 0x002C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_SpawnPointsMultiplier">();
	}
	static class UFortDifficultyOptionEncounter_SpawnPointsMultiplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_SpawnPointsMultiplier>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_SpawnPointsMultiplier");
static_assert(sizeof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier) == 0x000034, "Wrong size on UFortDifficultyOptionEncounter_SpawnPointsMultiplier");
static_assert(offsetof(UFortDifficultyOptionEncounter_SpawnPointsMultiplier, MultiplierRange) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_SpawnPointsMultiplier::MultiplierRange' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_Time
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_Time final : public UFortDifficultyOptionEncounter
{
public:
	float                                         EncounterTimeSeconds;                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_Time">();
	}
	static class UFortDifficultyOptionEncounter_Time* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_Time>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_Time) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_Time");
static_assert(sizeof(UFortDifficultyOptionEncounter_Time) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_Time");
static_assert(offsetof(UFortDifficultyOptionEncounter_Time, EncounterTimeSeconds) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_Time::EncounterTimeSeconds' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesAdjustment
// 0x0004 (0x0030 - 0x002C)
class UFortDifficultyOptionEncounter_UtilitiesAdjustment final : public UFortDifficultyOptionEncounter
{
public:
	float                                         UtilitiesAdjustmentIntervalSeconds;                // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesAdjustment">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesAdjustment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesAdjustment>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesAdjustment) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesAdjustment");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesAdjustment) == 0x000030, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesAdjustment");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesAdjustment, UtilitiesAdjustmentIntervalSeconds) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_UtilitiesAdjustment::UtilitiesAdjustmentIntervalSeconds' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionEncounter_UtilitiesLocked
// 0x000C (0x0038 - 0x002C)
class UFortDifficultyOptionEncounter_UtilitiesLocked final : public UFortDifficultyOptionEncounter
{
public:
	TArray<struct FFortEncounterLockedUtility>    LockedUtilities;                                   // 0x002C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionEncounter_UtilitiesLocked">();
	}
	static class UFortDifficultyOptionEncounter_UtilitiesLocked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionEncounter_UtilitiesLocked>();
	}
};
static_assert(alignof(UFortDifficultyOptionEncounter_UtilitiesLocked) == 0x000004, "Wrong alignment on UFortDifficultyOptionEncounter_UtilitiesLocked");
static_assert(sizeof(UFortDifficultyOptionEncounter_UtilitiesLocked) == 0x000038, "Wrong size on UFortDifficultyOptionEncounter_UtilitiesLocked");
static_assert(offsetof(UFortDifficultyOptionEncounter_UtilitiesLocked, LockedUtilities) == 0x00002C, "Member 'UFortDifficultyOptionEncounter_UtilitiesLocked::LockedUtilities' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_DirectionChange
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_DirectionChange final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_DirectionChange>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_DirectionChange">();
	}
	static class UFortDifficultyOptionCategoryEncounter_DirectionChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_DirectionChange>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_DirectionChange) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_DirectionChange");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_DirectionChange) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_DirectionChange");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_DirectionChange, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_DirectionChange::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Distance
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_Distance final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Distance>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Distance">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Distance>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Distance) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Distance");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Distance) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_Distance");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Distance, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_Distance::Options' has a wrong offset!");

// Class FortniteGame.FortWeaponMeleeItemDefinition
// 0x0000 (0x06C0 - 0x06C0)
class UFortWeaponMeleeItemDefinition final : public UFortWeaponItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponMeleeItemDefinition">();
	}
	static class UFortWeaponMeleeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponMeleeItemDefinition>();
	}
};
static_assert(alignof(UFortWeaponMeleeItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponMeleeItemDefinition");
static_assert(sizeof(UFortWeaponMeleeItemDefinition) == 0x0006C0, "Wrong size on UFortWeaponMeleeItemDefinition");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_ModifierTags
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_ModifierTags final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_ModifierTags>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_ModifierTags">();
	}
	static class UFortDifficultyOptionCategoryEncounter_ModifierTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_ModifierTags>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_ModifierTags) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_ModifierTags");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_ModifierTags) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_ModifierTags");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_ModifierTags, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_ModifierTags::Options' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconHost
// 0x0010 (0x0290 - 0x0280)
class AFortLobbyBeaconHost : public ALobbyBeaconHost
{
public:
	uint8                                         bAllowReservationsToProceedToLobby : 1;            // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bWorldRecordLoaded : 1;                            // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastReservationCountForPermissionTimeoutChange;    // 0x0284(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LobbyPermissionTimeout;                            // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHost">();
	}
	static class AFortLobbyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHost>();
	}
};
static_assert(alignof(AFortLobbyBeaconHost) == 0x000004, "Wrong alignment on AFortLobbyBeaconHost");
static_assert(sizeof(AFortLobbyBeaconHost) == 0x000290, "Wrong size on AFortLobbyBeaconHost");
static_assert(offsetof(AFortLobbyBeaconHost, LastReservationCountForPermissionTimeoutChange) == 0x000284, "Member 'AFortLobbyBeaconHost::LastReservationCountForPermissionTimeoutChange' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconHost, LobbyPermissionTimeout) == 0x000288, "Member 'AFortLobbyBeaconHost::LobbyPermissionTimeout' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconHostPvP
// 0x0000 (0x0290 - 0x0290)
class AFortLobbyBeaconHostPvP final : public AFortLobbyBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostPvP">();
	}
	static class AFortLobbyBeaconHostPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostPvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostPvP) == 0x000004, "Wrong alignment on AFortLobbyBeaconHostPvP");
static_assert(sizeof(AFortLobbyBeaconHostPvP) == 0x000290, "Wrong size on AFortLobbyBeaconHostPvP");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnGroupProgression
// 0x0004 (0x0024 - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TSubclassOf<class UFortDifficultyOptionEncounter_SpawnGroupProgression> SpawnGroupProgression;                             // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnGroupProgression">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression) == 0x000024, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression, SpawnGroupProgression) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnGroupProgression::SpawnGroupProgression' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnLimitPoints
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnLimitPoints>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnLimitPoints">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnLimitPoints::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_SpawnPointsCurve
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_SpawnPointsCurve>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_SpawnPointsCurve">();
	}
	static class UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_SpawnPointsCurve::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_Time
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_Time final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_Time>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_Time">();
	}
	static class UFortDifficultyOptionCategoryEncounter_Time* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_Time>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_Time) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_Time");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_Time) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_Time");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_Time, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_Time::Options' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconState
// 0x0034 (0x0390 - 0x035C)
class AFortLobbyBeaconState : public ALobbyBeaconState
{
public:
	int32                                         MatchmakingLevel;                                  // 0x035C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MissionGeneratorClassPath;                         // 0x0360(0x000C)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortMissionGenerator*                  CachedMissionGeneratorCDO;                         // 0x036C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELobbyMissionGeneratorDetailsRequirement      MissionGeneratorDetailsRequirement;                // 0x0370(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWorldRecordLoaded;                                // 0x0371(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x1E];                                     // 0x0372(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MissionGeneratorClassPath();
	void OnRep_MissionGeneratorDetailsRequirement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconState">();
	}
	static class AFortLobbyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconState>();
	}
};
static_assert(alignof(AFortLobbyBeaconState) == 0x000004, "Wrong alignment on AFortLobbyBeaconState");
static_assert(sizeof(AFortLobbyBeaconState) == 0x000390, "Wrong size on AFortLobbyBeaconState");
static_assert(offsetof(AFortLobbyBeaconState, MatchmakingLevel) == 0x00035C, "Member 'AFortLobbyBeaconState::MatchmakingLevel' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, MissionGeneratorClassPath) == 0x000360, "Member 'AFortLobbyBeaconState::MissionGeneratorClassPath' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, CachedMissionGeneratorCDO) == 0x00036C, "Member 'AFortLobbyBeaconState::CachedMissionGeneratorCDO' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, MissionGeneratorDetailsRequirement) == 0x000370, "Member 'AFortLobbyBeaconState::MissionGeneratorDetailsRequirement' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconState, bWorldRecordLoaded) == 0x000371, "Member 'AFortLobbyBeaconState::bWorldRecordLoaded' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconStatePvE
// 0x0000 (0x0390 - 0x0390)
class AFortLobbyBeaconStatePvE : public AFortLobbyBeaconState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStatePvE">();
	}
	static class AFortLobbyBeaconStatePvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStatePvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconStatePvE) == 0x000004, "Wrong alignment on AFortLobbyBeaconStatePvE");
static_assert(sizeof(AFortLobbyBeaconStatePvE) == 0x000390, "Wrong size on AFortLobbyBeaconStatePvE");

// Class FortniteGame.FortLobbyBeaconStateOutpost
// 0x0000 (0x0390 - 0x0390)
class AFortLobbyBeaconStateOutpost final : public AFortLobbyBeaconStatePvE
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStateOutpost">();
	}
	static class AFortLobbyBeaconStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStateOutpost>();
	}
};
static_assert(alignof(AFortLobbyBeaconStateOutpost) == 0x000004, "Wrong alignment on AFortLobbyBeaconStateOutpost");
static_assert(sizeof(AFortLobbyBeaconStateOutpost) == 0x000390, "Wrong size on AFortLobbyBeaconStateOutpost");

// Class FortniteGame.FortDifficultyOptionCategoryEncounter_UtilitiesFree
// 0x000C (0x002C - 0x0020)
class UFortDifficultyOptionCategoryEncounter_UtilitiesFree final : public UFortDifficultyOptionCategoryEncounter
{
public:
	TArray<TSubclassOf<class UFortDifficultyOptionEncounter_UtilitiesFree>> Options;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryEncounter_UtilitiesFree">();
	}
	static class UFortDifficultyOptionCategoryEncounter_UtilitiesFree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryEncounter_UtilitiesFree>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryEncounter_UtilitiesFree");
static_assert(sizeof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree) == 0x00002C, "Wrong size on UFortDifficultyOptionCategoryEncounter_UtilitiesFree");
static_assert(offsetof(UFortDifficultyOptionCategoryEncounter_UtilitiesFree, Options) == 0x000020, "Member 'UFortDifficultyOptionCategoryEncounter_UtilitiesFree::Options' has a wrong offset!");

// Class FortniteGame.FortDifficultyOptionCategoryMission
// 0x0000 (0x0020 - 0x0020)
class UFortDifficultyOptionCategoryMission final : public UFortDifficultyOptionCategory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionCategoryMission">();
	}
	static class UFortDifficultyOptionCategoryMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionCategoryMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionCategoryMission) == 0x000004, "Wrong alignment on UFortDifficultyOptionCategoryMission");
static_assert(sizeof(UFortDifficultyOptionCategoryMission) == 0x000020, "Wrong size on UFortDifficultyOptionCategoryMission");

// Class FortniteGame.FortLobbyBeaconClient
// 0x0000 (0x02BC - 0x02BC)
class AFortLobbyBeaconClient : public ALobbyBeaconClient
{
public:
	void ClientSay(const class FString& PlayerName, const class FString& Message);
	void ServerIncrementHomeBaseVersion(const struct FUniqueNetIdRepl& InUniqueId);
	void ServerSay(const class FString& Msg);
	void ServerSayTeam(const class FString& Msg);
	void ServerSetCharacterGender(const struct FUniqueNetIdRepl& InUniqueId, EFortCustomGender GenderType);
	void ServerSetCurrentCharacterXp(const struct FUniqueNetIdRepl& InUniqueId, const int32 CurrentCharacterXp);
	void ServerSetGadget(const struct FUniqueNetIdRepl& InUniqueId, int32 INDEX, const class FString& GadgetPersistentName);
	void ServerSetHeroId(const struct FUniqueNetIdRepl& InUniqueId, const class FString& InHeroId);
	void ServerSetHeroType(const struct FUniqueNetIdRepl& InUniqueId, const class UFortHeroType* InHeroType);
	void ServerSetMatchmakingLevel(const struct FUniqueNetIdRepl& InUniqueId, const int32 MatchmakingLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClient">();
	}
	static class AFortLobbyBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClient>();
	}
};
static_assert(alignof(AFortLobbyBeaconClient) == 0x000004, "Wrong alignment on AFortLobbyBeaconClient");
static_assert(sizeof(AFortLobbyBeaconClient) == 0x0002BC, "Wrong size on AFortLobbyBeaconClient");

// Class FortniteGame.FortLobbyBeaconClientPvE
// 0x0000 (0x02BC - 0x02BC)
class AFortLobbyBeaconClientPvE final : public AFortLobbyBeaconClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClientPvE">();
	}
	static class AFortLobbyBeaconClientPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClientPvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconClientPvE) == 0x000004, "Wrong alignment on AFortLobbyBeaconClientPvE");
static_assert(sizeof(AFortLobbyBeaconClientPvE) == 0x0002BC, "Wrong size on AFortLobbyBeaconClientPvE");

// Class FortniteGame.FortDifficultyOptionSetMission
// 0x000C (0x0028 - 0x001C)
class UFortDifficultyOptionSetMission final : public UDataAsset
{
public:
	TArray<class UFortDifficultyOptionCategoryMission*> MissionOptionsCategories;                          // 0x001C(0x000C)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortDifficultyOptionSetMission">();
	}
	static class UFortDifficultyOptionSetMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortDifficultyOptionSetMission>();
	}
};
static_assert(alignof(UFortDifficultyOptionSetMission) == 0x000004, "Wrong alignment on UFortDifficultyOptionSetMission");
static_assert(sizeof(UFortDifficultyOptionSetMission) == 0x000028, "Wrong size on UFortDifficultyOptionSetMission");
static_assert(offsetof(UFortDifficultyOptionSetMission, MissionOptionsCategories) == 0x00001C, "Member 'UFortDifficultyOptionSetMission::MissionOptionsCategories' has a wrong offset!");

// Class FortniteGame.FortMatchmakingCriticalMission
// 0x0008 (0x00B0 - 0x00A8)
class UFortMatchmakingCriticalMission final : public UFortMatchmakingPolicy
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingCriticalMission">();
	}
	static class UFortMatchmakingCriticalMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingCriticalMission>();
	}
};
static_assert(alignof(UFortMatchmakingCriticalMission) == 0x000004, "Wrong alignment on UFortMatchmakingCriticalMission");
static_assert(sizeof(UFortMatchmakingCriticalMission) == 0x0000B0, "Wrong size on UFortMatchmakingCriticalMission");

// Class FortniteGame.FortEmitterCameraLensEffectDirectional
// 0x0010 (0x02F0 - 0x02E0)
class AFortEmitterCameraLensEffectDirectional : public AEmitterCameraLensEffectBase
{
public:
	class AFortPawn*                              DamageInstigator;                                  // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DamageInstigatorLocation;                          // 0x02DC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEmitterCameraLensEffectDirectional">();
	}
	static class AFortEmitterCameraLensEffectDirectional* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortEmitterCameraLensEffectDirectional>();
	}
};
static_assert(alignof(AFortEmitterCameraLensEffectDirectional) == 0x000010, "Wrong alignment on AFortEmitterCameraLensEffectDirectional");
static_assert(sizeof(AFortEmitterCameraLensEffectDirectional) == 0x0002F0, "Wrong size on AFortEmitterCameraLensEffectDirectional");
static_assert(offsetof(AFortEmitterCameraLensEffectDirectional, DamageInstigator) == 0x0002D8, "Member 'AFortEmitterCameraLensEffectDirectional::DamageInstigator' has a wrong offset!");
static_assert(offsetof(AFortEmitterCameraLensEffectDirectional, DamageInstigatorLocation) == 0x0002DC, "Member 'AFortEmitterCameraLensEffectDirectional::DamageInstigatorLocation' has a wrong offset!");

// Class FortniteGame.FortEngine
// 0x0000 (0x0784 - 0x0784)
class UFortEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEngine">();
	}
	static class UFortEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEngine>();
	}
};
static_assert(alignof(UFortEngine) == 0x000004, "Wrong alignment on UFortEngine");
static_assert(sizeof(UFortEngine) == 0x000784, "Wrong size on UFortEngine");

// Class FortniteGame.FortLobbyBeaconPlayerState
// 0x0094 (0x0330 - 0x029C)
class AFortLobbyBeaconPlayerState : public ALobbyBeaconPlayerState
{
public:
	EFortTeam                                     TeamAffiliation;                                   // 0x029C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCharXP;                                     // 0x02A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchmakingLevel;                                  // 0x02A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HeroId;                                            // 0x02A8(0x000C)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortHeroType*                          HeroType;                                          // 0x02B4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LobbyTimeRemaining;                                // 0x02C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         HomeBaseVersion;                                   // 0x02C4(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         SelectedGadgets;                                   // 0x02CC(0x000C)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	EFortCustomGender                             CharacterGender;                                   // 0x02D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x57];                                     // 0x02D9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CharacterGender();
	void OnRep_CharXP();
	void OnRep_Gadgets();
	void OnRep_HeroID();
	void OnRep_HeroType();
	void OnRep_HomeBaseVersion();
	void OnRep_LobbyTimeRemaining();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerState">();
	}
	static class AFortLobbyBeaconPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerState>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerState) == 0x000004, "Wrong alignment on AFortLobbyBeaconPlayerState");
static_assert(sizeof(AFortLobbyBeaconPlayerState) == 0x000330, "Wrong size on AFortLobbyBeaconPlayerState");
static_assert(offsetof(AFortLobbyBeaconPlayerState, TeamAffiliation) == 0x00029C, "Member 'AFortLobbyBeaconPlayerState::TeamAffiliation' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, CurrentCharXP) == 0x0002A0, "Member 'AFortLobbyBeaconPlayerState::CurrentCharXP' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, MatchmakingLevel) == 0x0002A4, "Member 'AFortLobbyBeaconPlayerState::MatchmakingLevel' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HeroId) == 0x0002A8, "Member 'AFortLobbyBeaconPlayerState::HeroId' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HeroType) == 0x0002B4, "Member 'AFortLobbyBeaconPlayerState::HeroType' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, LobbyTimeRemaining) == 0x0002C0, "Member 'AFortLobbyBeaconPlayerState::LobbyTimeRemaining' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, HomeBaseVersion) == 0x0002C4, "Member 'AFortLobbyBeaconPlayerState::HomeBaseVersion' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, SelectedGadgets) == 0x0002CC, "Member 'AFortLobbyBeaconPlayerState::SelectedGadgets' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconPlayerState, CharacterGender) == 0x0002D8, "Member 'AFortLobbyBeaconPlayerState::CharacterGender' has a wrong offset!");

// Class FortniteGame.FortLobbyBeaconPlayerStatePvP
// 0x0004 (0x0334 - 0x0330)
class AFortLobbyBeaconPlayerStatePvP final : public AFortLobbyBeaconPlayerState
{
public:
	uint8                                         bReadiedUp : 1;                                    // 0x0330(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_331[0x3];                                      // 0x0331(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bReadiedUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerStatePvP">();
	}
	static class AFortLobbyBeaconPlayerStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerStatePvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerStatePvP) == 0x000004, "Wrong alignment on AFortLobbyBeaconPlayerStatePvP");
static_assert(sizeof(AFortLobbyBeaconPlayerStatePvP) == 0x000334, "Wrong size on AFortLobbyBeaconPlayerStatePvP");

// Class FortniteGame.FortItemExhibitActor
// 0x0010 (0x0290 - 0x0280)
class AFortItemExhibitActor final : public AFortExhibitActor
{
public:
	class FString                                 ItemInstanceId;                                    // 0x0274(0x000C)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPickup*                            ExhibitItem;                                       // 0x0280(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284[0xC];                                      // 0x0284(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemExhibitActor">();
	}
	static class AFortItemExhibitActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortItemExhibitActor>();
	}
};
static_assert(alignof(AFortItemExhibitActor) == 0x000010, "Wrong alignment on AFortItemExhibitActor");
static_assert(sizeof(AFortItemExhibitActor) == 0x000290, "Wrong size on AFortItemExhibitActor");
static_assert(offsetof(AFortItemExhibitActor, ItemInstanceId) == 0x000274, "Member 'AFortItemExhibitActor::ItemInstanceId' has a wrong offset!");
static_assert(offsetof(AFortItemExhibitActor, ExhibitItem) == 0x000280, "Member 'AFortItemExhibitActor::ExhibitItem' has a wrong offset!");

// Class FortniteGame.FortFeedbackBank
// 0x0090 (0x00AC - 0x001C)
class UFortFeedbackBank final : public UDataAsset
{
public:
	TArray<struct FFortFeedbackActionBankDefined> BankDefinedFeedbackEvents;                         // 0x001C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortFeedbackAction>            FeedbackEvents;                                    // 0x0028(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x78];                                      // 0x0034(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortFeedbackBank">();
	}
	static class UFortFeedbackBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortFeedbackBank>();
	}
};
static_assert(alignof(UFortFeedbackBank) == 0x000004, "Wrong alignment on UFortFeedbackBank");
static_assert(sizeof(UFortFeedbackBank) == 0x0000AC, "Wrong size on UFortFeedbackBank");
static_assert(offsetof(UFortFeedbackBank, BankDefinedFeedbackEvents) == 0x00001C, "Member 'UFortFeedbackBank::BankDefinedFeedbackEvents' has a wrong offset!");
static_assert(offsetof(UFortFeedbackBank, FeedbackEvents) == 0x000028, "Member 'UFortFeedbackBank::FeedbackEvents' has a wrong offset!");

// Class FortniteGame.FortPlacementActorTagTest
// 0x0030 (0x004C - 0x001C)
class UFortPlacementActorTagTest final : public UObject
{
public:
	struct FGameplayTagContainer                  TagsToApplyOnSuccess;                              // 0x001C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagsToApplyOnFailure;                              // 0x0034(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	bool LineTraceByChannel(class AFortPlacementActor* PlacementActor, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, struct FHitResult* OutHit, bool bIgnoreSelf) const;
	bool ShouldApplyTagsToPlacementActor(class AFortPlacementActor* FocusPlacementActor, const struct FVector& AveragePlacementActorLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActorTagTest">();
	}
	static class UFortPlacementActorTagTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPlacementActorTagTest>();
	}
};
static_assert(alignof(UFortPlacementActorTagTest) == 0x000004, "Wrong alignment on UFortPlacementActorTagTest");
static_assert(sizeof(UFortPlacementActorTagTest) == 0x00004C, "Wrong size on UFortPlacementActorTagTest");
static_assert(offsetof(UFortPlacementActorTagTest, TagsToApplyOnSuccess) == 0x00001C, "Member 'UFortPlacementActorTagTest::TagsToApplyOnSuccess' has a wrong offset!");
static_assert(offsetof(UFortPlacementActorTagTest, TagsToApplyOnFailure) == 0x000034, "Member 'UFortPlacementActorTagTest::TagsToApplyOnFailure' has a wrong offset!");

// Class FortniteGame.FortGameData
// 0x0A9C (0x0AB8 - 0x001C)
class UFortGameData final : public UDataAsset
{
public:
	TSubclassOf<class UFortAIEncounterInfo>       TestEncounter;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortCombatManager>         CombatManager;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerCameraManager>       DefaultCameraManager;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortInGameMapManager>      UIMapManager;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortMusicManager>          MusicManager;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DefaultHeroName;                                   // 0x0030(0x000C)(Edit, NativeAccessSpecifierPublic)
	class UFortTips*                              LoadingScreenTips;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortTooltipMap*                        ObjClassToTooltipClassMap;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemPropertyLookupTable*           ItemPropertyLookupTable;                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineOffsetRange[0x2];                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineRandomMax;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSplineDropToGroundLength;                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasePlayerBackpackCapacity;                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortRarityData*                        RarityData;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortItemCategory*                      ItemCategories;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuickBarData                          QuickBarDefinitions[0x2];                          // 0x0064(0x000C)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           AutoEquipTags;                                     // 0x007C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AutoEquipTagContainer;                             // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           BuildingFullHealthFlashColor;                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           InvalidEditPatternColor;                           // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FFortHighlightColorsContainer          HighlightColors[0x3];                              // 0x00C0(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         ScoreDisplayFactor;                                // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortReplicatedStatMapping>     StatMappings;                                      // 0x01E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             ScoreMultiplierDataTable;                          // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreDivisor;                                      // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XPMult;                                            // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupXPRate;                                       // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CappedXPMult;                                      // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              LoadingScreenSoundMix;                             // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              BaseSoundMix;                                      // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortGlobalAbilityTargetingActor> AbilityTargetingActorBlueprintClass;               // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortAIGoalManager>         AIGoalManagerClass;                                // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   WeakSpotEnabledTimeoutHandle;                      // 0x0214(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   WeakSpotMultiplierHandle;                          // 0x0220(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseDelay;                   // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseDelayVariance;           // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseCellDistAdditiveDelay;   // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuildingStructuralCollapseCellDistAdditiveDelayVariance; // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EditModeCancelDistance;                            // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   GeneratorUnsupportedDamageDealtPerInterval;        // 0x0240(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   GeneratorUnsupportedDamageInterval;                // 0x024C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingExcessDamageRewardTimeoutHandle;           // 0x0258(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingRecentlyDamagedTimeoutHandle;              // 0x0264(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingBaseHealthHandles[0x4];                    // 0x0270(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingConstructionTimeHandles[0x4];              // 0x02A0(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCostHandles[0x4];                          // 0x02D0(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingDeconCostMultHandles[0x4];                 // 0x0300(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   PlayerBuildingDeconCostMultHandles[0x4];           // 0x0330(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingInitialHealthPercentHandles[0x4];          // 0x0360(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingRepairCostMultiplierHandles[0x4];          // 0x0390(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingBreakAnimDurationHandles[0x4];             // 0x03C0(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingDestroyAnimDurationHandles[0x4];           // 0x03F0(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingPlacementAnimDurationHandles[0x4];         // 0x0420(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCritDamagePctHandles[0x4];                 // 0x0450(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   BuildingCritDestroyAnimScaleCapHandles[0x4];       // 0x0480(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UMaterialParameterCollection> StencilDefinitionCollection;                       // 0x04B0(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 BuildingConstructionSounds[0x4];                   // 0x04C8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 GenericBuildingDeathSounds[0x4];                   // 0x0528(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSoundPerResourceLevel                 PlayerBuiltBuildingDeathSounds[0x4];               // 0x0588(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   ResourceNames[0x4];                                // 0x05E8(0x000C)(Protected, NativeAccessSpecifierProtected)
	class FText                                   BuildingTypeNames[0xC];                            // 0x0618(0x000C)(Protected, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            StoneItemDefinition;                               // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            WoodItemDefinition;                                // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            MetalItemDefinition;                               // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                PistolAmmoItemDefinition;                          // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                ShotgunAmmoItemDefinition;                         // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortResourceItemDefinition*            PermaniteItemDefinition;                           // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                RifleAmmoItemDefinition;                           // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                AssaultAmmoItemDefinition;                         // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortAmmoItemDefinition*                EnergyAmmoItemDefinition;                          // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortNeverPersistItemDefinition*        BluGloItemDefinition;                              // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    CriticalMissionRewardItemDefinition;               // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortItemDefinition*                    ScoreBonusMultiplerItemDefinition;                 // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortWorldItemDefinition> BackpackItemDefinition;                            // 0x06D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortWorldItemDefinition> MissionRewardPackItemDefinition;                   // 0x06F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortEventNotificationBank*             EventNotificationBank;                             // 0x0708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             LootTierData;                                      // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LootPackageData;                                   // 0x0710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             LoginRewardsData;                                  // 0x0714(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DifficultyData;                                    // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LootQuotaData;                                     // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LootLevelData;                                     // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            LootDropCountData;                                 // 0x0724(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SurfaceRatioBySurfaceCategoryData;                 // 0x0728(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SurfaceRatioByAffiliationData;                     // 0x072C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFortTeamIdentification>    TeamIdentifications[0xD];                          // 0x0730(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortDailyQuestInfo                    DailyQuestInfo;                                    // 0x0764(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LoadingScreenBackground_Generic;                   // 0x0774(0x0074)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortMissionGenerationData> MissionGenerationData;                             // 0x07E8(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UFortWorldItemDefinition>> CheatInventoryItems;                               // 0x0800(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TheaterMapViewerClass;                             // 0x080C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMyTownData>             MyFortData;                                        // 0x0824(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortOutpostData>        OutpostData;                                       // 0x083C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAttributeLookupTable> AttributeLookupTable;                              // 0x0854(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAttributeCategory>  AttributeCategories;                               // 0x086C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DamageNumbersActorClass;                           // 0x0884(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CrackEffectBlueprintClass;                         // 0x089C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PickupEffectBlueprintClass;                        // 0x08B4(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortGameDifficultyCalculationData> GameDifficultyData;                                // 0x08CC(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    GameDifficultyRowPIE;                              // 0x08E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AIDirectors;                                       // 0x08F0(0x000C)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AIDirectorIndex;                                   // 0x08FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlternateBalanceAIDirectorIndex;                   // 0x0900(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FeedbackManagerClass;                              // 0x0904(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortUIFeedbackBank>     UIFeedbackBank;                                    // 0x091C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   StatEventManagerClass;                             // 0x0934(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortHeroType>           DefaultHero;                                       // 0x094C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemDefinitionAndCount>        DefaultInventoryList;                              // 0x0964(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemDefinitionAndCount>        FastLoadDefaultInventoryList;                      // 0x0970(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ThreatVisualsManager;                              // 0x097C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortEditToolItemDefinition> EditToolItem;                                      // 0x0994(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAbilitySet>         GenericPlayerAbilitySet;                           // 0x09AC(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortAbilitySet>         GenericTrapAbilitySet;                             // 0x09C4(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortAbilityTagRelationship>    AbilityTagRelationships;                           // 0x09DC(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EnvironmentDamageTemplateGE;                       // 0x09E8(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FallingDamageTemplateGE;                           // 0x0A00(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HealingTemplateGE;                                 // 0x0A18(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FatalDamageTemplateGE;                             // 0x0A30(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BASEClass;                                         // 0x0A48(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObjectLibrary>          StrategicBuildingActorItemDefinitionLibrary;       // 0x0A60(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                HeroManagementWidgetClass;                         // 0x0A78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      HealthScreenDamagePostProcessMat;                  // 0x0A7C(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveTable>             SessionXPCurveTable;                               // 0x0A94(0x0018)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ForceLoadedObjects;                                // 0x0AAC(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameData">();
	}
	static class UFortGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameData>();
	}
};
static_assert(alignof(UFortGameData) == 0x000004, "Wrong alignment on UFortGameData");
static_assert(sizeof(UFortGameData) == 0x000AB8, "Wrong size on UFortGameData");
static_assert(offsetof(UFortGameData, TestEncounter) == 0x00001C, "Member 'UFortGameData::TestEncounter' has a wrong offset!");
static_assert(offsetof(UFortGameData, CombatManager) == 0x000020, "Member 'UFortGameData::CombatManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultCameraManager) == 0x000024, "Member 'UFortGameData::DefaultCameraManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, UIMapManager) == 0x000028, "Member 'UFortGameData::UIMapManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, MusicManager) == 0x00002C, "Member 'UFortGameData::MusicManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultHeroName) == 0x000030, "Member 'UFortGameData::DefaultHeroName' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenTips) == 0x00003C, "Member 'UFortGameData::LoadingScreenTips' has a wrong offset!");
static_assert(offsetof(UFortGameData, ObjClassToTooltipClassMap) == 0x000040, "Member 'UFortGameData::ObjClassToTooltipClassMap' has a wrong offset!");
static_assert(offsetof(UFortGameData, ItemPropertyLookupTable) == 0x000044, "Member 'UFortGameData::ItemPropertyLookupTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineOffsetRange) == 0x000048, "Member 'UFortGameData::PickupSplineOffsetRange' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineRandomMax) == 0x000050, "Member 'UFortGameData::PickupSplineRandomMax' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupSplineDropToGroundLength) == 0x000054, "Member 'UFortGameData::PickupSplineDropToGroundLength' has a wrong offset!");
static_assert(offsetof(UFortGameData, BasePlayerBackpackCapacity) == 0x000058, "Member 'UFortGameData::BasePlayerBackpackCapacity' has a wrong offset!");
static_assert(offsetof(UFortGameData, RarityData) == 0x00005C, "Member 'UFortGameData::RarityData' has a wrong offset!");
static_assert(offsetof(UFortGameData, ItemCategories) == 0x000060, "Member 'UFortGameData::ItemCategories' has a wrong offset!");
static_assert(offsetof(UFortGameData, QuickBarDefinitions) == 0x000064, "Member 'UFortGameData::QuickBarDefinitions' has a wrong offset!");
static_assert(offsetof(UFortGameData, AutoEquipTags) == 0x00007C, "Member 'UFortGameData::AutoEquipTags' has a wrong offset!");
static_assert(offsetof(UFortGameData, AutoEquipTagContainer) == 0x000088, "Member 'UFortGameData::AutoEquipTagContainer' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingFullHealthFlashColor) == 0x0000A0, "Member 'UFortGameData::BuildingFullHealthFlashColor' has a wrong offset!");
static_assert(offsetof(UFortGameData, InvalidEditPatternColor) == 0x0000B0, "Member 'UFortGameData::InvalidEditPatternColor' has a wrong offset!");
static_assert(offsetof(UFortGameData, HighlightColors) == 0x0000C0, "Member 'UFortGameData::HighlightColors' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreDisplayFactor) == 0x0001E0, "Member 'UFortGameData::ScoreDisplayFactor' has a wrong offset!");
static_assert(offsetof(UFortGameData, StatMappings) == 0x0001E4, "Member 'UFortGameData::StatMappings' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreMultiplierDataTable) == 0x0001F0, "Member 'UFortGameData::ScoreMultiplierDataTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreDivisor) == 0x0001F4, "Member 'UFortGameData::ScoreDivisor' has a wrong offset!");
static_assert(offsetof(UFortGameData, XPMult) == 0x0001F8, "Member 'UFortGameData::XPMult' has a wrong offset!");
static_assert(offsetof(UFortGameData, GroupXPRate) == 0x0001FC, "Member 'UFortGameData::GroupXPRate' has a wrong offset!");
static_assert(offsetof(UFortGameData, CappedXPMult) == 0x000200, "Member 'UFortGameData::CappedXPMult' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenSoundMix) == 0x000204, "Member 'UFortGameData::LoadingScreenSoundMix' has a wrong offset!");
static_assert(offsetof(UFortGameData, BaseSoundMix) == 0x000208, "Member 'UFortGameData::BaseSoundMix' has a wrong offset!");
static_assert(offsetof(UFortGameData, AbilityTargetingActorBlueprintClass) == 0x00020C, "Member 'UFortGameData::AbilityTargetingActorBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIGoalManagerClass) == 0x000210, "Member 'UFortGameData::AIGoalManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, WeakSpotEnabledTimeoutHandle) == 0x000214, "Member 'UFortGameData::WeakSpotEnabledTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, WeakSpotMultiplierHandle) == 0x000220, "Member 'UFortGameData::WeakSpotMultiplierHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseDelay) == 0x00022C, "Member 'UFortGameData::BuildingStructuralCollapseDelay' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseDelayVariance) == 0x000230, "Member 'UFortGameData::BuildingStructuralCollapseDelayVariance' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseCellDistAdditiveDelay) == 0x000234, "Member 'UFortGameData::BuildingStructuralCollapseCellDistAdditiveDelay' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingStructuralCollapseCellDistAdditiveDelayVariance) == 0x000238, "Member 'UFortGameData::BuildingStructuralCollapseCellDistAdditiveDelayVariance' has a wrong offset!");
static_assert(offsetof(UFortGameData, EditModeCancelDistance) == 0x00023C, "Member 'UFortGameData::EditModeCancelDistance' has a wrong offset!");
static_assert(offsetof(UFortGameData, GeneratorUnsupportedDamageDealtPerInterval) == 0x000240, "Member 'UFortGameData::GeneratorUnsupportedDamageDealtPerInterval' has a wrong offset!");
static_assert(offsetof(UFortGameData, GeneratorUnsupportedDamageInterval) == 0x00024C, "Member 'UFortGameData::GeneratorUnsupportedDamageInterval' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingExcessDamageRewardTimeoutHandle) == 0x000258, "Member 'UFortGameData::BuildingExcessDamageRewardTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingRecentlyDamagedTimeoutHandle) == 0x000264, "Member 'UFortGameData::BuildingRecentlyDamagedTimeoutHandle' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingBaseHealthHandles) == 0x000270, "Member 'UFortGameData::BuildingBaseHealthHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingConstructionTimeHandles) == 0x0002A0, "Member 'UFortGameData::BuildingConstructionTimeHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCostHandles) == 0x0002D0, "Member 'UFortGameData::BuildingCostHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingDeconCostMultHandles) == 0x000300, "Member 'UFortGameData::BuildingDeconCostMultHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerBuildingDeconCostMultHandles) == 0x000330, "Member 'UFortGameData::PlayerBuildingDeconCostMultHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingInitialHealthPercentHandles) == 0x000360, "Member 'UFortGameData::BuildingInitialHealthPercentHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingRepairCostMultiplierHandles) == 0x000390, "Member 'UFortGameData::BuildingRepairCostMultiplierHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingBreakAnimDurationHandles) == 0x0003C0, "Member 'UFortGameData::BuildingBreakAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingDestroyAnimDurationHandles) == 0x0003F0, "Member 'UFortGameData::BuildingDestroyAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingPlacementAnimDurationHandles) == 0x000420, "Member 'UFortGameData::BuildingPlacementAnimDurationHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCritDamagePctHandles) == 0x000450, "Member 'UFortGameData::BuildingCritDamagePctHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingCritDestroyAnimScaleCapHandles) == 0x000480, "Member 'UFortGameData::BuildingCritDestroyAnimScaleCapHandles' has a wrong offset!");
static_assert(offsetof(UFortGameData, StencilDefinitionCollection) == 0x0004B0, "Member 'UFortGameData::StencilDefinitionCollection' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingConstructionSounds) == 0x0004C8, "Member 'UFortGameData::BuildingConstructionSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericBuildingDeathSounds) == 0x000528, "Member 'UFortGameData::GenericBuildingDeathSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, PlayerBuiltBuildingDeathSounds) == 0x000588, "Member 'UFortGameData::PlayerBuiltBuildingDeathSounds' has a wrong offset!");
static_assert(offsetof(UFortGameData, ResourceNames) == 0x0005E8, "Member 'UFortGameData::ResourceNames' has a wrong offset!");
static_assert(offsetof(UFortGameData, BuildingTypeNames) == 0x000618, "Member 'UFortGameData::BuildingTypeNames' has a wrong offset!");
static_assert(offsetof(UFortGameData, StoneItemDefinition) == 0x0006A8, "Member 'UFortGameData::StoneItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, WoodItemDefinition) == 0x0006AC, "Member 'UFortGameData::WoodItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, MetalItemDefinition) == 0x0006B0, "Member 'UFortGameData::MetalItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, PistolAmmoItemDefinition) == 0x0006B4, "Member 'UFortGameData::PistolAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, ShotgunAmmoItemDefinition) == 0x0006B8, "Member 'UFortGameData::ShotgunAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, PermaniteItemDefinition) == 0x0006BC, "Member 'UFortGameData::PermaniteItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, RifleAmmoItemDefinition) == 0x0006C0, "Member 'UFortGameData::RifleAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, AssaultAmmoItemDefinition) == 0x0006C4, "Member 'UFortGameData::AssaultAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, EnergyAmmoItemDefinition) == 0x0006C8, "Member 'UFortGameData::EnergyAmmoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, BluGloItemDefinition) == 0x0006CC, "Member 'UFortGameData::BluGloItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, CriticalMissionRewardItemDefinition) == 0x0006D0, "Member 'UFortGameData::CriticalMissionRewardItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, ScoreBonusMultiplerItemDefinition) == 0x0006D4, "Member 'UFortGameData::ScoreBonusMultiplerItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, BackpackItemDefinition) == 0x0006D8, "Member 'UFortGameData::BackpackItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionRewardPackItemDefinition) == 0x0006F0, "Member 'UFortGameData::MissionRewardPackItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGameData, EventNotificationBank) == 0x000708, "Member 'UFortGameData::EventNotificationBank' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootTierData) == 0x00070C, "Member 'UFortGameData::LootTierData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootPackageData) == 0x000710, "Member 'UFortGameData::LootPackageData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoginRewardsData) == 0x000714, "Member 'UFortGameData::LoginRewardsData' has a wrong offset!");
static_assert(offsetof(UFortGameData, DifficultyData) == 0x000718, "Member 'UFortGameData::DifficultyData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootQuotaData) == 0x00071C, "Member 'UFortGameData::LootQuotaData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootLevelData) == 0x000720, "Member 'UFortGameData::LootLevelData' has a wrong offset!");
static_assert(offsetof(UFortGameData, LootDropCountData) == 0x000724, "Member 'UFortGameData::LootDropCountData' has a wrong offset!");
static_assert(offsetof(UFortGameData, SurfaceRatioBySurfaceCategoryData) == 0x000728, "Member 'UFortGameData::SurfaceRatioBySurfaceCategoryData' has a wrong offset!");
static_assert(offsetof(UFortGameData, SurfaceRatioByAffiliationData) == 0x00072C, "Member 'UFortGameData::SurfaceRatioByAffiliationData' has a wrong offset!");
static_assert(offsetof(UFortGameData, TeamIdentifications) == 0x000730, "Member 'UFortGameData::TeamIdentifications' has a wrong offset!");
static_assert(offsetof(UFortGameData, DailyQuestInfo) == 0x000764, "Member 'UFortGameData::DailyQuestInfo' has a wrong offset!");
static_assert(offsetof(UFortGameData, LoadingScreenBackground_Generic) == 0x000774, "Member 'UFortGameData::LoadingScreenBackground_Generic' has a wrong offset!");
static_assert(offsetof(UFortGameData, MissionGenerationData) == 0x0007E8, "Member 'UFortGameData::MissionGenerationData' has a wrong offset!");
static_assert(offsetof(UFortGameData, CheatInventoryItems) == 0x000800, "Member 'UFortGameData::CheatInventoryItems' has a wrong offset!");
static_assert(offsetof(UFortGameData, TheaterMapViewerClass) == 0x00080C, "Member 'UFortGameData::TheaterMapViewerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, MyFortData) == 0x000824, "Member 'UFortGameData::MyFortData' has a wrong offset!");
static_assert(offsetof(UFortGameData, OutpostData) == 0x00083C, "Member 'UFortGameData::OutpostData' has a wrong offset!");
static_assert(offsetof(UFortGameData, AttributeLookupTable) == 0x000854, "Member 'UFortGameData::AttributeLookupTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, AttributeCategories) == 0x00086C, "Member 'UFortGameData::AttributeCategories' has a wrong offset!");
static_assert(offsetof(UFortGameData, DamageNumbersActorClass) == 0x000884, "Member 'UFortGameData::DamageNumbersActorClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, CrackEffectBlueprintClass) == 0x00089C, "Member 'UFortGameData::CrackEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, PickupEffectBlueprintClass) == 0x0008B4, "Member 'UFortGameData::PickupEffectBlueprintClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, GameDifficultyData) == 0x0008CC, "Member 'UFortGameData::GameDifficultyData' has a wrong offset!");
static_assert(offsetof(UFortGameData, GameDifficultyRowPIE) == 0x0008E4, "Member 'UFortGameData::GameDifficultyRowPIE' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIDirectors) == 0x0008F0, "Member 'UFortGameData::AIDirectors' has a wrong offset!");
static_assert(offsetof(UFortGameData, AIDirectorIndex) == 0x0008FC, "Member 'UFortGameData::AIDirectorIndex' has a wrong offset!");
static_assert(offsetof(UFortGameData, AlternateBalanceAIDirectorIndex) == 0x000900, "Member 'UFortGameData::AlternateBalanceAIDirectorIndex' has a wrong offset!");
static_assert(offsetof(UFortGameData, FeedbackManagerClass) == 0x000904, "Member 'UFortGameData::FeedbackManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, UIFeedbackBank) == 0x00091C, "Member 'UFortGameData::UIFeedbackBank' has a wrong offset!");
static_assert(offsetof(UFortGameData, StatEventManagerClass) == 0x000934, "Member 'UFortGameData::StatEventManagerClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultHero) == 0x00094C, "Member 'UFortGameData::DefaultHero' has a wrong offset!");
static_assert(offsetof(UFortGameData, DefaultInventoryList) == 0x000964, "Member 'UFortGameData::DefaultInventoryList' has a wrong offset!");
static_assert(offsetof(UFortGameData, FastLoadDefaultInventoryList) == 0x000970, "Member 'UFortGameData::FastLoadDefaultInventoryList' has a wrong offset!");
static_assert(offsetof(UFortGameData, ThreatVisualsManager) == 0x00097C, "Member 'UFortGameData::ThreatVisualsManager' has a wrong offset!");
static_assert(offsetof(UFortGameData, EditToolItem) == 0x000994, "Member 'UFortGameData::EditToolItem' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericPlayerAbilitySet) == 0x0009AC, "Member 'UFortGameData::GenericPlayerAbilitySet' has a wrong offset!");
static_assert(offsetof(UFortGameData, GenericTrapAbilitySet) == 0x0009C4, "Member 'UFortGameData::GenericTrapAbilitySet' has a wrong offset!");
static_assert(offsetof(UFortGameData, AbilityTagRelationships) == 0x0009DC, "Member 'UFortGameData::AbilityTagRelationships' has a wrong offset!");
static_assert(offsetof(UFortGameData, EnvironmentDamageTemplateGE) == 0x0009E8, "Member 'UFortGameData::EnvironmentDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, FallingDamageTemplateGE) == 0x000A00, "Member 'UFortGameData::FallingDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, HealingTemplateGE) == 0x000A18, "Member 'UFortGameData::HealingTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, FatalDamageTemplateGE) == 0x000A30, "Member 'UFortGameData::FatalDamageTemplateGE' has a wrong offset!");
static_assert(offsetof(UFortGameData, BASEClass) == 0x000A48, "Member 'UFortGameData::BASEClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, StrategicBuildingActorItemDefinitionLibrary) == 0x000A60, "Member 'UFortGameData::StrategicBuildingActorItemDefinitionLibrary' has a wrong offset!");
static_assert(offsetof(UFortGameData, HeroManagementWidgetClass) == 0x000A78, "Member 'UFortGameData::HeroManagementWidgetClass' has a wrong offset!");
static_assert(offsetof(UFortGameData, HealthScreenDamagePostProcessMat) == 0x000A7C, "Member 'UFortGameData::HealthScreenDamagePostProcessMat' has a wrong offset!");
static_assert(offsetof(UFortGameData, SessionXPCurveTable) == 0x000A94, "Member 'UFortGameData::SessionXPCurveTable' has a wrong offset!");
static_assert(offsetof(UFortGameData, ForceLoadedObjects) == 0x000AAC, "Member 'UFortGameData::ForceLoadedObjects' has a wrong offset!");

// Class FortniteGame.FortLocalPlayer
// 0x0104 (0x01F4 - 0x00F0)
class UFortLocalPlayer final : public ULocalPlayer
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortOnlineAccount*                     FortOnlineAccount;                                 // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0xC];                                       // 0x00FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortClientSettingsRecord*              ClientSettingsRecord;                              // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortRewardReport                      CachedRewardReport;                                // 0x010C(0x0030)(NativeAccessSpecifierPublic)
	TArray<struct FFortPlayerScoreReport>         CachedScoreReports;                                // 0x013C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0xAC];                                     // 0x0148(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLocalPlayer">();
	}
	static class UFortLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLocalPlayer>();
	}
};
static_assert(alignof(UFortLocalPlayer) == 0x000004, "Wrong alignment on UFortLocalPlayer");
static_assert(sizeof(UFortLocalPlayer) == 0x0001F4, "Wrong size on UFortLocalPlayer");
static_assert(offsetof(UFortLocalPlayer, FortOnlineAccount) == 0x0000F8, "Member 'UFortLocalPlayer::FortOnlineAccount' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, ClientSettingsRecord) == 0x000108, "Member 'UFortLocalPlayer::ClientSettingsRecord' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, CachedRewardReport) == 0x00010C, "Member 'UFortLocalPlayer::CachedRewardReport' has a wrong offset!");
static_assert(offsetof(UFortLocalPlayer, CachedScoreReports) == 0x00013C, "Member 'UFortLocalPlayer::CachedScoreReports' has a wrong offset!");

// Class FortniteGame.FortGameDifficultyCalculationData
// 0x0040 (0x005C - 0x001C)
class UFortGameDifficultyCalculationData final : public UDataAsset
{
public:
	struct FDataTableRowHandle                    PowerPointCalculationData;                         // 0x001C(0x000C)(Edit, NativeAccessSpecifierPublic)
	class UCurveTable*                            HeroPowerPointValues;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MatchmakingMinLevels;                              // 0x002C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MatchmakingMaxLevels;                              // 0x0038(0x000C)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortHomebaseBuildingStaticDataTable> HomebaseBuildingStaticDataTable;                   // 0x0044(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameDifficultyCalculationData">();
	}
	static class UFortGameDifficultyCalculationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameDifficultyCalculationData>();
	}
};
static_assert(alignof(UFortGameDifficultyCalculationData) == 0x000004, "Wrong alignment on UFortGameDifficultyCalculationData");
static_assert(sizeof(UFortGameDifficultyCalculationData) == 0x00005C, "Wrong size on UFortGameDifficultyCalculationData");
static_assert(offsetof(UFortGameDifficultyCalculationData, PowerPointCalculationData) == 0x00001C, "Member 'UFortGameDifficultyCalculationData::PowerPointCalculationData' has a wrong offset!");
static_assert(offsetof(UFortGameDifficultyCalculationData, HeroPowerPointValues) == 0x000028, "Member 'UFortGameDifficultyCalculationData::HeroPowerPointValues' has a wrong offset!");
static_assert(offsetof(UFortGameDifficultyCalculationData, MatchmakingMinLevels) == 0x00002C, "Member 'UFortGameDifficultyCalculationData::MatchmakingMinLevels' has a wrong offset!");
static_assert(offsetof(UFortGameDifficultyCalculationData, MatchmakingMaxLevels) == 0x000038, "Member 'UFortGameDifficultyCalculationData::MatchmakingMaxLevels' has a wrong offset!");
static_assert(offsetof(UFortGameDifficultyCalculationData, HomebaseBuildingStaticDataTable) == 0x000044, "Member 'UFortGameDifficultyCalculationData::HomebaseBuildingStaticDataTable' has a wrong offset!");

// Class FortniteGame.FortGameInstance
// 0x011C (0x0168 - 0x004C)
class UFortGameInstance final : public UGameInstance
{
public:
	TScriptInterface<class IFortUIManagerInterface> UIManagerInterface;                                // 0x004C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FStringAssetReference                  UIManagerClassPath;                                // 0x0054(0x000C)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class UMcpProfileManager*                     ProfileManager;                                    // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x8];                                       // 0x0064(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMatchmaking*                       Matchmaking;                                       // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortParty*                             Party;                                             // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0xB4];                                      // 0x0074(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortTooltipManager*                    TooltipManager;                                    // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x3C];                                     // 0x012C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameInstance">();
	}
	static class UFortGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameInstance>();
	}
};
static_assert(alignof(UFortGameInstance) == 0x000004, "Wrong alignment on UFortGameInstance");
static_assert(sizeof(UFortGameInstance) == 0x000168, "Wrong size on UFortGameInstance");
static_assert(offsetof(UFortGameInstance, UIManagerInterface) == 0x00004C, "Member 'UFortGameInstance::UIManagerInterface' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, UIManagerClassPath) == 0x000054, "Member 'UFortGameInstance::UIManagerClassPath' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, ProfileManager) == 0x000060, "Member 'UFortGameInstance::ProfileManager' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, Matchmaking) == 0x00006C, "Member 'UFortGameInstance::Matchmaking' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, Party) == 0x000070, "Member 'UFortGameInstance::Party' has a wrong offset!");
static_assert(offsetof(UFortGameInstance, TooltipManager) == 0x000128, "Member 'UFortGameInstance::TooltipManager' has a wrong offset!");

// Class FortniteGame.FortGameplayEffectUIData
// 0x0024 (0x0040 - 0x001C)
class UFortGameplayEffectUIData final : public UGameplayEffectUIData
{
public:
	class FText                                   DisplayName;                                       // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 TooltipName;                                       // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayEffectUIData">();
	}
	static class UFortGameplayEffectUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayEffectUIData>();
	}
};
static_assert(alignof(UFortGameplayEffectUIData) == 0x000004, "Wrong alignment on UFortGameplayEffectUIData");
static_assert(sizeof(UFortGameplayEffectUIData) == 0x000040, "Wrong size on UFortGameplayEffectUIData");
static_assert(offsetof(UFortGameplayEffectUIData, DisplayName) == 0x00001C, "Member 'UFortGameplayEffectUIData::DisplayName' has a wrong offset!");
static_assert(offsetof(UFortGameplayEffectUIData, Description) == 0x000028, "Member 'UFortGameplayEffectUIData::Description' has a wrong offset!");
static_assert(offsetof(UFortGameplayEffectUIData, TooltipName) == 0x000034, "Member 'UFortGameplayEffectUIData::TooltipName' has a wrong offset!");

// Class FortniteGame.FortGameSession
// 0x0048 (0x02B8 - 0x0270)
class AFortGameSession : public AGameSession
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortHostSessionParams                 CurrentSessionParams;                              // 0x0280(0x000C)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x8];                                      // 0x028C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOnlineBeaconHostObject>    ReservationBeaconHostClass;                        // 0x0294(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AOnlineBeaconHostObject>    QosBeaconHostClass;                                // 0x0298(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortPartyBeaconHost*                   ReservationBeaconHost;                             // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AQosBeaconHost*                         QosBeaconHost;                                     // 0x02A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortLobbyBeaconHost*                   LobbyBeaconHost;                                   // 0x02A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0xC];                                      // 0x02AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DumpReservations() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameSession">();
	}
	static class AFortGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameSession>();
	}
};
static_assert(alignof(AFortGameSession) == 0x000004, "Wrong alignment on AFortGameSession");
static_assert(sizeof(AFortGameSession) == 0x0002B8, "Wrong size on AFortGameSession");
static_assert(offsetof(AFortGameSession, CurrentSessionParams) == 0x000280, "Member 'AFortGameSession::CurrentSessionParams' has a wrong offset!");
static_assert(offsetof(AFortGameSession, ReservationBeaconHostClass) == 0x000294, "Member 'AFortGameSession::ReservationBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AFortGameSession, QosBeaconHostClass) == 0x000298, "Member 'AFortGameSession::QosBeaconHostClass' has a wrong offset!");
static_assert(offsetof(AFortGameSession, ReservationBeaconHost) == 0x0002A0, "Member 'AFortGameSession::ReservationBeaconHost' has a wrong offset!");
static_assert(offsetof(AFortGameSession, QosBeaconHost) == 0x0002A4, "Member 'AFortGameSession::QosBeaconHost' has a wrong offset!");
static_assert(offsetof(AFortGameSession, LobbyBeaconHost) == 0x0002A8, "Member 'AFortGameSession::LobbyBeaconHost' has a wrong offset!");

// Class FortniteGame.FortPartyBeaconState
// 0x0048 (0x009C - 0x0054)
class UFortPartyBeaconState final : public UPartyBeaconState
{
public:
	struct FUniqueNetIdRepl                       GameSessionOwner;                                  // 0x0054(0x0008)(Protected, NativeAccessSpecifierProtected)
	struct FEmptyServerReservation                ReservationData;                                   // 0x005C(0x0028)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x18];                                      // 0x0084(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconState">();
	}
	static class UFortPartyBeaconState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPartyBeaconState>();
	}
};
static_assert(alignof(UFortPartyBeaconState) == 0x000004, "Wrong alignment on UFortPartyBeaconState");
static_assert(sizeof(UFortPartyBeaconState) == 0x00009C, "Wrong size on UFortPartyBeaconState");
static_assert(offsetof(UFortPartyBeaconState, GameSessionOwner) == 0x000054, "Member 'UFortPartyBeaconState::GameSessionOwner' has a wrong offset!");
static_assert(offsetof(UFortPartyBeaconState, ReservationData) == 0x00005C, "Member 'UFortPartyBeaconState::ReservationData' has a wrong offset!");

// Class FortniteGame.FortGameModeFrontEnd
// 0x0010 (0x03E4 - 0x03D4)
class AFortGameModeFrontEnd final : public AFortGameMode
{
public:
	int32                                         OwningControllerIndex;                             // 0x03D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortTheaterMapViewer*                  TheaterMapViewer;                                  // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x8];                                      // 0x03DC(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowPersonalizationScreen(class AFortPlayerController* PC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameModeFrontEnd">();
	}
	static class AFortGameModeFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameModeFrontEnd>();
	}
};
static_assert(alignof(AFortGameModeFrontEnd) == 0x000004, "Wrong alignment on AFortGameModeFrontEnd");
static_assert(sizeof(AFortGameModeFrontEnd) == 0x0003E4, "Wrong size on AFortGameModeFrontEnd");
static_assert(offsetof(AFortGameModeFrontEnd, OwningControllerIndex) == 0x0003D4, "Member 'AFortGameModeFrontEnd::OwningControllerIndex' has a wrong offset!");
static_assert(offsetof(AFortGameModeFrontEnd, TheaterMapViewer) == 0x0003D8, "Member 'AFortGameModeFrontEnd::TheaterMapViewer' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Action
// 0x0008 (0x06E4 - 0x06DC)
class UFortGameplayAbility_Action : public UFortGameplayAbility
{
public:
	class FName                                   ActionName;                                        // 0x06DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Action">();
	}
	static class UFortGameplayAbility_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Action>();
	}
};
static_assert(alignof(UFortGameplayAbility_Action) == 0x000004, "Wrong alignment on UFortGameplayAbility_Action");
static_assert(sizeof(UFortGameplayAbility_Action) == 0x0006E4, "Wrong size on UFortGameplayAbility_Action");
static_assert(offsetof(UFortGameplayAbility_Action, ActionName) == 0x0006DC, "Member 'UFortGameplayAbility_Action::ActionName' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_AIPortal
// 0x0078 (0x075C - 0x06E4)
class UFortGameplayAbility_AIPortal final : public UFortGameplayAbility_Action
{
public:
	uint8                                         Pad_6E4[0x28];                                     // 0x06E4(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PortalLifespan;                                    // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x4C];                                     // 0x0710(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ModifyCollisions();

	class ABuildingSMActor* GetPortalBuilding() const;
	struct FVector GetPortalInPoint() const;
	struct FVector GetPortalOutPoint() const;
	bool HasPortalOutPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_AIPortal">();
	}
	static class UFortGameplayAbility_AIPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_AIPortal>();
	}
};
static_assert(alignof(UFortGameplayAbility_AIPortal) == 0x000004, "Wrong alignment on UFortGameplayAbility_AIPortal");
static_assert(sizeof(UFortGameplayAbility_AIPortal) == 0x00075C, "Wrong size on UFortGameplayAbility_AIPortal");
static_assert(offsetof(UFortGameplayAbility_AIPortal, PortalLifespan) == 0x00070C, "Member 'UFortGameplayAbility_AIPortal::PortalLifespan' has a wrong offset!");

// Class FortniteGame.FortGameplayAbility_Jump
// 0x0000 (0x06E4 - 0x06E4)
class UFortGameplayAbility_Jump final : public UFortGameplayAbility_Action
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Jump">();
	}
	static class UFortGameplayAbility_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Jump>();
	}
};
static_assert(alignof(UFortGameplayAbility_Jump) == 0x000004, "Wrong alignment on UFortGameplayAbility_Jump");
static_assert(sizeof(UFortGameplayAbility_Jump) == 0x0006E4, "Wrong size on UFortGameplayAbility_Jump");

// Class FortniteGame.FortGameplayAbility_Sprint
// 0x0000 (0x06E4 - 0x06E4)
class UFortGameplayAbility_Sprint final : public UFortGameplayAbility_Action
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Sprint">();
	}
	static class UFortGameplayAbility_Sprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Sprint>();
	}
};
static_assert(alignof(UFortGameplayAbility_Sprint) == 0x000004, "Wrong alignment on UFortGameplayAbility_Sprint");
static_assert(sizeof(UFortGameplayAbility_Sprint) == 0x0006E4, "Wrong size on UFortGameplayAbility_Sprint");

// Class FortniteGame.FortGameplayAbility_AITurnTransition
// 0x001C (0x06F8 - 0x06DC)
class UFortGameplayAbility_AITurnTransition : public UFortGameplayAbility
{
public:
	float                                         MinTurnTransitionYawAngle;                         // 0x06DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTurnTransitionData>            TransitionPriorityList;                            // 0x06E0(0x000C)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   PickedMontageSectionName;                          // 0x06EC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickedTurnYawRotationRate;                         // 0x06F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GetTurnTransitionMontageSectionNameAndYawRotationRate(class FName* MontageSectionName, float* TurnYawRotationRate) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_AITurnTransition">();
	}
	static class UFortGameplayAbility_AITurnTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_AITurnTransition>();
	}
};
static_assert(alignof(UFortGameplayAbility_AITurnTransition) == 0x000004, "Wrong alignment on UFortGameplayAbility_AITurnTransition");
static_assert(sizeof(UFortGameplayAbility_AITurnTransition) == 0x0006F8, "Wrong size on UFortGameplayAbility_AITurnTransition");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, MinTurnTransitionYawAngle) == 0x0006DC, "Member 'UFortGameplayAbility_AITurnTransition::MinTurnTransitionYawAngle' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, TransitionPriorityList) == 0x0006E0, "Member 'UFortGameplayAbility_AITurnTransition::TransitionPriorityList' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, PickedMontageSectionName) == 0x0006EC, "Member 'UFortGameplayAbility_AITurnTransition::PickedMontageSectionName' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_AITurnTransition, PickedTurnYawRotationRate) == 0x0006F4, "Member 'UFortGameplayAbility_AITurnTransition::PickedTurnYawRotationRate' has a wrong offset!");

// Class FortniteGame.FortControlStrengthExecutionCalculation
// 0x0000 (0x002C - 0x002C)
class UFortControlStrengthExecutionCalculation final : public UFortGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControlStrengthExecutionCalculation">();
	}
	static class UFortControlStrengthExecutionCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControlStrengthExecutionCalculation>();
	}
};
static_assert(alignof(UFortControlStrengthExecutionCalculation) == 0x000004, "Wrong alignment on UFortControlStrengthExecutionCalculation");
static_assert(sizeof(UFortControlStrengthExecutionCalculation) == 0x00002C, "Wrong size on UFortControlStrengthExecutionCalculation");

// Class FortniteGame.FortGameplayAbility_Land
// 0x0000 (0x06DC - 0x06DC)
class UFortGameplayAbility_Land final : public UFortGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_Land">();
	}
	static class UFortGameplayAbility_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_Land>();
	}
};
static_assert(alignof(UFortGameplayAbility_Land) == 0x000004, "Wrong alignment on UFortGameplayAbility_Land");
static_assert(sizeof(UFortGameplayAbility_Land) == 0x0006DC, "Wrong size on UFortGameplayAbility_Land");

// Class FortniteGame.FortGameplayAbility_RangedWeapon
// 0x0024 (0x0700 - 0x06DC)
class UFortGameplayAbility_RangedWeapon final : public UFortGameplayAbility
{
public:
	class AFortWeaponRanged*                      CurrentWeapon;                                     // 0x06DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WeaponFireCue;                                     // 0x06E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F8[0x8];                                      // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbility_RangedWeapon">();
	}
	static class UFortGameplayAbility_RangedWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbility_RangedWeapon>();
	}
};
static_assert(alignof(UFortGameplayAbility_RangedWeapon) == 0x000004, "Wrong alignment on UFortGameplayAbility_RangedWeapon");
static_assert(sizeof(UFortGameplayAbility_RangedWeapon) == 0x000700, "Wrong size on UFortGameplayAbility_RangedWeapon");
static_assert(offsetof(UFortGameplayAbility_RangedWeapon, CurrentWeapon) == 0x0006DC, "Member 'UFortGameplayAbility_RangedWeapon::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbility_RangedWeapon, WeaponFireCue) == 0x0006E0, "Member 'UFortGameplayAbility_RangedWeapon::WeaponFireCue' has a wrong offset!");

// Class FortniteGame.FortGameplayCueManager
// 0x0000 (0x016C - 0x016C)
class UFortGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueManager">();
	}
	static class UFortGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayCueManager>();
	}
};
static_assert(alignof(UFortGameplayCueManager) == 0x000004, "Wrong alignment on UFortGameplayCueManager");
static_assert(sizeof(UFortGameplayCueManager) == 0x00016C, "Wrong size on UFortGameplayCueManager");

// Class FortniteGame.FortGameplayCueNotify_Looping
// 0x0024 (0x02AC - 0x0288)
class AFortGameplayCueNotify_Looping : public AGameplayCueNotify_Actor
{
public:
	class USoundBase*                             StartSound;                                        // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             StopSound;                                         // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StartParticleSystem;                               // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        StopParticleSystem;                                // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPoint;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayAttached;                                     // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseHitResult;                                     // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeapon;                                        // 0x02A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotation;                                   // 0x02A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAudioComponent*                        AudioComponent;                                    // 0x02A4(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayCueNotify_Looping">();
	}
	static class AFortGameplayCueNotify_Looping* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(AFortGameplayCueNotify_Looping) == 0x000004, "Wrong alignment on AFortGameplayCueNotify_Looping");
static_assert(sizeof(AFortGameplayCueNotify_Looping) == 0x0002AC, "Wrong size on AFortGameplayCueNotify_Looping");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StartSound) == 0x000288, "Member 'AFortGameplayCueNotify_Looping::StartSound' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StopSound) == 0x00028C, "Member 'AFortGameplayCueNotify_Looping::StopSound' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StartParticleSystem) == 0x000290, "Member 'AFortGameplayCueNotify_Looping::StartParticleSystem' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, StopParticleSystem) == 0x000294, "Member 'AFortGameplayCueNotify_Looping::StopParticleSystem' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, AttachPoint) == 0x000298, "Member 'AFortGameplayCueNotify_Looping::AttachPoint' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bStayAttached) == 0x0002A0, "Member 'AFortGameplayCueNotify_Looping::bStayAttached' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bUseHitResult) == 0x0002A1, "Member 'AFortGameplayCueNotify_Looping::bUseHitResult' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bUseWeapon) == 0x0002A2, "Member 'AFortGameplayCueNotify_Looping::bUseWeapon' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, bIgnoreRotation) == 0x0002A3, "Member 'AFortGameplayCueNotify_Looping::bIgnoreRotation' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, AudioComponent) == 0x0002A4, "Member 'AFortGameplayCueNotify_Looping::AudioComponent' has a wrong offset!");
static_assert(offsetof(AFortGameplayCueNotify_Looping, ParticleSystemComponent) == 0x0002A8, "Member 'AFortGameplayCueNotify_Looping::ParticleSystemComponent' has a wrong offset!");

// Class FortniteGame.FortAreaOfEffectCloud
// 0x0000 (0x0390 - 0x0390)
class AFortAreaOfEffectCloud : public AFortGameplayEffectDeliveryActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAreaOfEffectCloud">();
	}
	static class AFortAreaOfEffectCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAreaOfEffectCloud>();
	}
};
static_assert(alignof(AFortAreaOfEffectCloud) == 0x000004, "Wrong alignment on AFortAreaOfEffectCloud");
static_assert(sizeof(AFortAreaOfEffectCloud) == 0x000390, "Wrong size on AFortAreaOfEffectCloud");

// Class FortniteGame.FortProj_M80
// 0x0000 (0x0418 - 0x0418)
class AFortProj_M80 : public AFortProjectileExplosiveBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortProj_M80">();
	}
	static class AFortProj_M80* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortProj_M80>();
	}
};
static_assert(alignof(AFortProj_M80) == 0x000004, "Wrong alignment on AFortProj_M80");
static_assert(sizeof(AFortProj_M80) == 0x000418, "Wrong size on AFortProj_M80");

// Class FortniteGame.FortGameSessionDedicated
// 0x0038 (0x02F0 - 0x02B8)
class AFortGameSessionDedicated final : public AFortGameSession
{
public:
	uint8                                         Pad_2B8[0x38];                                     // 0x02B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameSessionDedicated">();
	}
	static class AFortGameSessionDedicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameSessionDedicated>();
	}
};
static_assert(alignof(AFortGameSessionDedicated) == 0x000004, "Wrong alignment on AFortGameSessionDedicated");
static_assert(sizeof(AFortGameSessionDedicated) == 0x0002F0, "Wrong size on AFortGameSessionDedicated");

// Class FortniteGame.WaterVolume_Deep
// 0x000C (0x0284 - 0x0278)
class AWaterVolume_Deep final : public APhysicsVolume
{
public:
	class USoundBase*                             EntrySound;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExitSound;                                         // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamagePerSec;                                      // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVolume_Deep">();
	}
	static class AWaterVolume_Deep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVolume_Deep>();
	}
};
static_assert(alignof(AWaterVolume_Deep) == 0x000004, "Wrong alignment on AWaterVolume_Deep");
static_assert(sizeof(AWaterVolume_Deep) == 0x000284, "Wrong size on AWaterVolume_Deep");
static_assert(offsetof(AWaterVolume_Deep, EntrySound) == 0x000278, "Member 'AWaterVolume_Deep::EntrySound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Deep, ExitSound) == 0x00027C, "Member 'AWaterVolume_Deep::ExitSound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Deep, DamagePerSec) == 0x000280, "Member 'AWaterVolume_Deep::DamagePerSec' has a wrong offset!");

// Class FortniteGame.FortGameStateKeep
// 0x004C (0x0504 - 0x04B8)
class AFortGameStateKeep final : public AFortGameStateZone
{
public:
	struct FPermaniteBoundariesInfo               PermaniteBoundariesData;                           // 0x04B8(0x0014)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x38];                                     // 0x04CC(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PermaniteBoundariesInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStateKeep">();
	}
	static class AFortGameStateKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStateKeep>();
	}
};
static_assert(alignof(AFortGameStateKeep) == 0x000004, "Wrong alignment on AFortGameStateKeep");
static_assert(sizeof(AFortGameStateKeep) == 0x000504, "Wrong size on AFortGameStateKeep");
static_assert(offsetof(AFortGameStateKeep, PermaniteBoundariesData) == 0x0004B8, "Member 'AFortGameStateKeep::PermaniteBoundariesData' has a wrong offset!");

// Class FortniteGame.FortGameStatePvPBaseDestruction
// 0x00B8 (0x0610 - 0x0558)
class AFortGameStatePvPBaseDestruction final : public AFortGameStatePvP
{
public:
	class FName                                   SessionXPRowName;                                  // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRichCurve                             TeamLevelToSessionXPCurve;                         // 0x0560(0x0054)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FRichCurve                             SessionXPToTeamLevelCurve;                         // 0x05B4(0x0054)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxTeamLevel;                                      // 0x0608(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxTeamExperience;                                 // 0x060C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetExperienceRequiredForTeamLevel(int32 TeamLevel) const;
	int32 GetMaxTeamExperience() const;
	int32 GetMaxTeamLevel() const;
	int32 GetTeamLevelForExperienceAmount(int32 Experience) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameStatePvPBaseDestruction">();
	}
	static class AFortGameStatePvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGameStatePvPBaseDestruction>();
	}
};
static_assert(alignof(AFortGameStatePvPBaseDestruction) == 0x000004, "Wrong alignment on AFortGameStatePvPBaseDestruction");
static_assert(sizeof(AFortGameStatePvPBaseDestruction) == 0x000610, "Wrong size on AFortGameStatePvPBaseDestruction");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, SessionXPRowName) == 0x000558, "Member 'AFortGameStatePvPBaseDestruction::SessionXPRowName' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, TeamLevelToSessionXPCurve) == 0x000560, "Member 'AFortGameStatePvPBaseDestruction::TeamLevelToSessionXPCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, SessionXPToTeamLevelCurve) == 0x0005B4, "Member 'AFortGameStatePvPBaseDestruction::SessionXPToTeamLevelCurve' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, MaxTeamLevel) == 0x000608, "Member 'AFortGameStatePvPBaseDestruction::MaxTeamLevel' has a wrong offset!");
static_assert(offsetof(AFortGameStatePvPBaseDestruction, MaxTeamExperience) == 0x00060C, "Member 'AFortGameStatePvPBaseDestruction::MaxTeamExperience' has a wrong offset!");

// Class FortniteGame.FortGameViewportClient
// 0x0018 (0x01CC - 0x01B4)
class UFortGameViewportClient final : public UGameViewportClient
{
public:
	class FText                                   NetworkFailureMessage;                             // 0x01B4(0x000C)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0xC];                                      // 0x01C0(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameViewportClient">();
	}
	static class UFortGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameViewportClient>();
	}
};
static_assert(alignof(UFortGameViewportClient) == 0x000004, "Wrong alignment on UFortGameViewportClient");
static_assert(sizeof(UFortGameViewportClient) == 0x0001CC, "Wrong size on UFortGameViewportClient");
static_assert(offsetof(UFortGameViewportClient, NetworkFailureMessage) == 0x0001B4, "Member 'UFortGameViewportClient::NetworkFailureMessage' has a wrong offset!");

// Class FortniteGame.MyTownPlacementActor
// 0x0004 (0x0244 - 0x0240)
class AMyTownPlacementActor : public AActor
{
public:
	class UStaticMeshComponent*                   BuildingMeshComponent;                             // 0x0240(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownPlacementActor">();
	}
	static class AMyTownPlacementActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyTownPlacementActor>();
	}
};
static_assert(alignof(AMyTownPlacementActor) == 0x000004, "Wrong alignment on AMyTownPlacementActor");
static_assert(sizeof(AMyTownPlacementActor) == 0x000244, "Wrong size on AMyTownPlacementActor");
static_assert(offsetof(AMyTownPlacementActor, BuildingMeshComponent) == 0x000240, "Member 'AMyTownPlacementActor::BuildingMeshComponent' has a wrong offset!");

// Class FortniteGame.FortGlobalEnvironmentAbilityActor
// 0x000C (0x024C - 0x0240)
class AFortGlobalEnvironmentAbilityActor final : public AInfo
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortAbilitySystemComponent*            AbilitySystemComponent;                            // 0x0244(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortDamageSet*                         DamageSet;                                         // 0x0248(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGlobalEnvironmentAbilityActor">();
	}
	static class AFortGlobalEnvironmentAbilityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortGlobalEnvironmentAbilityActor>();
	}
};
static_assert(alignof(AFortGlobalEnvironmentAbilityActor) == 0x000004, "Wrong alignment on AFortGlobalEnvironmentAbilityActor");
static_assert(sizeof(AFortGlobalEnvironmentAbilityActor) == 0x00024C, "Wrong size on AFortGlobalEnvironmentAbilityActor");
static_assert(offsetof(AFortGlobalEnvironmentAbilityActor, AbilitySystemComponent) == 0x000244, "Member 'AFortGlobalEnvironmentAbilityActor::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AFortGlobalEnvironmentAbilityActor, DamageSet) == 0x000248, "Member 'AFortGlobalEnvironmentAbilityActor::DamageSet' has a wrong offset!");

// Class FortniteGame.WorldTileGroup
// 0x00A0 (0x00BC - 0x001C)
class UWorldTileGroup final : public UDataAsset
{
public:
	class FString                                 TileID;                                            // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnlyPlaceDiagonalWithAdjacent : 1;                // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileGroupMapInfo>              FlatMapInfos;                                      // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              InnerMapInfos;                                     // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              OuterMapInfos;                                     // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTileGroupMapInfo>              StraightMapInfos;                                  // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Sim_FlatWorld;                                     // 0x005C(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_InnerWorld;                                    // 0x0074(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_OuterWorld;                                    // 0x008C(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  Sim_StraightWorld;                                 // 0x00A4(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileGroup">();
	}
	static class UWorldTileGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileGroup>();
	}
};
static_assert(alignof(UWorldTileGroup) == 0x000004, "Wrong alignment on UWorldTileGroup");
static_assert(sizeof(UWorldTileGroup) == 0x0000BC, "Wrong size on UWorldTileGroup");
static_assert(offsetof(UWorldTileGroup, TileID) == 0x00001C, "Member 'UWorldTileGroup::TileID' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, FlatMapInfos) == 0x00002C, "Member 'UWorldTileGroup::FlatMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, InnerMapInfos) == 0x000038, "Member 'UWorldTileGroup::InnerMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, OuterMapInfos) == 0x000044, "Member 'UWorldTileGroup::OuterMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, StraightMapInfos) == 0x000050, "Member 'UWorldTileGroup::StraightMapInfos' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_FlatWorld) == 0x00005C, "Member 'UWorldTileGroup::Sim_FlatWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_InnerWorld) == 0x000074, "Member 'UWorldTileGroup::Sim_InnerWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_OuterWorld) == 0x00008C, "Member 'UWorldTileGroup::Sim_OuterWorld' has a wrong offset!");
static_assert(offsetof(UWorldTileGroup, Sim_StraightWorld) == 0x0000A4, "Member 'UWorldTileGroup::Sim_StraightWorld' has a wrong offset!");

// Class FortniteGame.FortIndicatorManager
// 0x003C (0x0058 - 0x001C)
class UFortIndicatorManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x3C];                                      // 0x001C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIndicatorManager">();
	}
	static class UFortIndicatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIndicatorManager>();
	}
};
static_assert(alignof(UFortIndicatorManager) == 0x000004, "Wrong alignment on UFortIndicatorManager");
static_assert(sizeof(UFortIndicatorManager) == 0x000058, "Wrong size on UFortIndicatorManager");

// Class FortniteGame.FortCardPackItemDefinition
// 0x0030 (0x0460 - 0x0430)
class UFortCardPackItemDefinition final : public UFortAccountItemDefinition
{
public:
	class FString                                 LootTierGroup;                                     // 0x0430(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootTier;                                          // 0x043C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChoicePack;                                     // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayRarityLevel;                                // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               PackImage;                                         // 0x0448(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PackColor;                                         // 0x044C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFortPackPersonality*                   PackPersonality;                                   // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCardPackItemDefinition">();
	}
	static class UFortCardPackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCardPackItemDefinition>();
	}
};
static_assert(alignof(UFortCardPackItemDefinition) == 0x000004, "Wrong alignment on UFortCardPackItemDefinition");
static_assert(sizeof(UFortCardPackItemDefinition) == 0x000460, "Wrong size on UFortCardPackItemDefinition");
static_assert(offsetof(UFortCardPackItemDefinition, LootTierGroup) == 0x000430, "Member 'UFortCardPackItemDefinition::LootTierGroup' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, LootTier) == 0x00043C, "Member 'UFortCardPackItemDefinition::LootTier' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, bIsChoicePack) == 0x000440, "Member 'UFortCardPackItemDefinition::bIsChoicePack' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, DisplayRarityLevel) == 0x000444, "Member 'UFortCardPackItemDefinition::DisplayRarityLevel' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackImage) == 0x000448, "Member 'UFortCardPackItemDefinition::PackImage' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackColor) == 0x00044C, "Member 'UFortCardPackItemDefinition::PackColor' has a wrong offset!");
static_assert(offsetof(UFortCardPackItemDefinition, PackPersonality) == 0x00045C, "Member 'UFortCardPackItemDefinition::PackPersonality' has a wrong offset!");

// Class FortniteGame.FortCurrencyItemDefinition
// 0x0000 (0x0430 - 0x0430)
class UFortCurrencyItemDefinition final : public UFortAccountItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCurrencyItemDefinition">();
	}
	static class UFortCurrencyItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCurrencyItemDefinition>();
	}
};
static_assert(alignof(UFortCurrencyItemDefinition) == 0x000004, "Wrong alignment on UFortCurrencyItemDefinition");
static_assert(sizeof(UFortCurrencyItemDefinition) == 0x000430, "Wrong size on UFortCurrencyItemDefinition");

// Class FortniteGame.FortCurrencyItem
// 0x0000 (0x0080 - 0x0080)
class UFortCurrencyItem final : public UFortAccountItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCurrencyItem">();
	}
	static class UFortCurrencyItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCurrencyItem>();
	}
};
static_assert(alignof(UFortCurrencyItem) == 0x000004, "Wrong alignment on UFortCurrencyItem");
static_assert(sizeof(UFortCurrencyItem) == 0x000080, "Wrong size on UFortCurrencyItem");

// Class FortniteGame.FortWorldItem
// 0x009C (0x00DC - 0x0040)
class UFortWorldItem final : public UFortItem
{
public:
	uint8                                         Pad_40[0x4];                                       // 0x0040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTemporaryItem;                                  // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bNeedsPersistentUpdate;                            // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPendingPersistentDelete;                          // 0x0046(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortInventory*                         OwnerInventory;                                    // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortItemEntry                         ItemEntry;                                         // 0x004C(0x007C)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x14];                                      // 0x00C8(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldItem">();
	}
	static class UFortWorldItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWorldItem>();
	}
};
static_assert(alignof(UFortWorldItem) == 0x000004, "Wrong alignment on UFortWorldItem");
static_assert(sizeof(UFortWorldItem) == 0x0000DC, "Wrong size on UFortWorldItem");
static_assert(offsetof(UFortWorldItem, bIsTemporaryItem) == 0x000044, "Member 'UFortWorldItem::bIsTemporaryItem' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, bNeedsPersistentUpdate) == 0x000045, "Member 'UFortWorldItem::bNeedsPersistentUpdate' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, bPendingPersistentDelete) == 0x000046, "Member 'UFortWorldItem::bPendingPersistentDelete' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, OwnerInventory) == 0x000048, "Member 'UFortWorldItem::OwnerInventory' has a wrong offset!");
static_assert(offsetof(UFortWorldItem, ItemEntry) == 0x00004C, "Member 'UFortWorldItem::ItemEntry' has a wrong offset!");

// Class FortniteGame.FortItemCategory
// 0x0024 (0x0040 - 0x001C)
class UFortItemCategory final : public UDataAsset
{
public:
	TArray<struct FItemCategoryMappingData>       PrimaryCategories;                                 // 0x001C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemCategory>                  SecondaryCategories;                               // 0x0028(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemCategory>                  TertiaryCategories;                                // 0x0034(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortItemCategory">();
	}
	static class UFortItemCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortItemCategory>();
	}
};
static_assert(alignof(UFortItemCategory) == 0x000004, "Wrong alignment on UFortItemCategory");
static_assert(sizeof(UFortItemCategory) == 0x000040, "Wrong size on UFortItemCategory");
static_assert(offsetof(UFortItemCategory, PrimaryCategories) == 0x00001C, "Member 'UFortItemCategory::PrimaryCategories' has a wrong offset!");
static_assert(offsetof(UFortItemCategory, SecondaryCategories) == 0x000028, "Member 'UFortItemCategory::SecondaryCategories' has a wrong offset!");
static_assert(offsetof(UFortItemCategory, TertiaryCategories) == 0x000034, "Member 'UFortItemCategory::TertiaryCategories' has a wrong offset!");

// Class FortniteGame.FortHeroSpecialization
// 0x0064 (0x04E8 - 0x0484)
class UFortHeroSpecialization final : public UFortAlterationItemDefinition
{
public:
	TArray<struct FFortSpecializationSlot>        SpecializationSlots;                               // 0x0484(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFortCharacterCosmeticItemDefinition*   CosmeticItem;                                      // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   VitalityCurve;                                     // 0x0494(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   OffenseCurve;                                      // 0x04A0(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   ProwessCurve;                                      // 0x04AC(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   DefenceCurve;                                      // 0x04B8(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FHeroSpecializationAttributeRequirement> AttributeRequirements;                             // 0x04C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x04D0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortHeroSpecialization">();
	}
	static class UFortHeroSpecialization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortHeroSpecialization>();
	}
};
static_assert(alignof(UFortHeroSpecialization) == 0x000004, "Wrong alignment on UFortHeroSpecialization");
static_assert(sizeof(UFortHeroSpecialization) == 0x0004E8, "Wrong size on UFortHeroSpecialization");
static_assert(offsetof(UFortHeroSpecialization, SpecializationSlots) == 0x000484, "Member 'UFortHeroSpecialization::SpecializationSlots' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, CosmeticItem) == 0x000490, "Member 'UFortHeroSpecialization::CosmeticItem' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, VitalityCurve) == 0x000494, "Member 'UFortHeroSpecialization::VitalityCurve' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, OffenseCurve) == 0x0004A0, "Member 'UFortHeroSpecialization::OffenseCurve' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, ProwessCurve) == 0x0004AC, "Member 'UFortHeroSpecialization::ProwessCurve' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, DefenceCurve) == 0x0004B8, "Member 'UFortHeroSpecialization::DefenceCurve' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, AttributeRequirements) == 0x0004C4, "Member 'UFortHeroSpecialization::AttributeRequirements' has a wrong offset!");
static_assert(offsetof(UFortHeroSpecialization, RequiredTags) == 0x0004D0, "Member 'UFortHeroSpecialization::RequiredTags' has a wrong offset!");

// Class FortniteGame.FortQuestItemDefinition
// 0x006C (0x049C - 0x0430)
class UFortQuestItemDefinition final : public UFortAccountItemDefinition
{
public:
	EFortQuestType                                QuestType;                                         // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortItemQuantityPair>          Rewards;                                           // 0x0434(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortMcpQuestObjectiveInfo>     Objectives;                                        // 0x0440(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Prerequisites;                                     // 0x044C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UFortQuestItemDefinition*               PrerequisiteQuest;                                 // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    PrerequisiteObjective;                             // 0x0468(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    Category;                                          // 0x0474(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   RewardDescription;                                 // 0x0480(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x048C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48D[0x3];                                      // 0x048D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortMissionConfigDataParams           MissionConfigMetadata;                             // 0x0490(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestItemDefinition">();
	}
	static class UFortQuestItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestItemDefinition>();
	}
};
static_assert(alignof(UFortQuestItemDefinition) == 0x000004, "Wrong alignment on UFortQuestItemDefinition");
static_assert(sizeof(UFortQuestItemDefinition) == 0x00049C, "Wrong size on UFortQuestItemDefinition");
static_assert(offsetof(UFortQuestItemDefinition, QuestType) == 0x000430, "Member 'UFortQuestItemDefinition::QuestType' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Rewards) == 0x000434, "Member 'UFortQuestItemDefinition::Rewards' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Objectives) == 0x000440, "Member 'UFortQuestItemDefinition::Objectives' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Prerequisites) == 0x00044C, "Member 'UFortQuestItemDefinition::Prerequisites' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, PrerequisiteQuest) == 0x000464, "Member 'UFortQuestItemDefinition::PrerequisiteQuest' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, PrerequisiteObjective) == 0x000468, "Member 'UFortQuestItemDefinition::PrerequisiteObjective' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, Category) == 0x000474, "Member 'UFortQuestItemDefinition::Category' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, RewardDescription) == 0x000480, "Member 'UFortQuestItemDefinition::RewardDescription' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, bHidden) == 0x00048C, "Member 'UFortQuestItemDefinition::bHidden' has a wrong offset!");
static_assert(offsetof(UFortQuestItemDefinition, MissionConfigMetadata) == 0x000490, "Member 'UFortQuestItemDefinition::MissionConfigMetadata' has a wrong offset!");

// Class FortniteGame.FortTokenType
// 0x0018 (0x0448 - 0x0430)
class UFortTokenType final : public UFortAccountItemDefinition
{
public:
	TSoftClassPtr<class UClass>                   ScriptedAction;                                    // 0x0430(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTokenType">();
	}
	static class UFortTokenType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTokenType>();
	}
};
static_assert(alignof(UFortTokenType) == 0x000004, "Wrong alignment on UFortTokenType");
static_assert(sizeof(UFortTokenType) == 0x000448, "Wrong size on UFortTokenType");
static_assert(offsetof(UFortTokenType, ScriptedAction) == 0x000430, "Member 'UFortTokenType::ScriptedAction' has a wrong offset!");

// Class FortniteGame.FortStackItemDefinition
// 0x0008 (0x0420 - 0x0418)
class UFortStackItemDefinition final : public UFortItemDefinition
{
public:
	class UFortItemDefinition*                    ItemDefinition;                                    // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x041C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStackItemDefinition">();
	}
	static class UFortStackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStackItemDefinition>();
	}
};
static_assert(alignof(UFortStackItemDefinition) == 0x000004, "Wrong alignment on UFortStackItemDefinition");
static_assert(sizeof(UFortStackItemDefinition) == 0x000420, "Wrong size on UFortStackItemDefinition");
static_assert(offsetof(UFortStackItemDefinition, ItemDefinition) == 0x000418, "Member 'UFortStackItemDefinition::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortStackItemDefinition, Count) == 0x00041C, "Member 'UFortStackItemDefinition::Count' has a wrong offset!");

// Class FortniteGame.FortBackpackItemDefinition
// 0x0000 (0x05C0 - 0x05C0)
class UFortBackpackItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBackpackItemDefinition">();
	}
	static class UFortBackpackItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBackpackItemDefinition>();
	}
};
static_assert(alignof(UFortBackpackItemDefinition) == 0x000010, "Wrong alignment on UFortBackpackItemDefinition");
static_assert(sizeof(UFortBackpackItemDefinition) == 0x0005C0, "Wrong size on UFortBackpackItemDefinition");

// Class FortniteGame.FortBadgeItemDefinition
// 0x0020 (0x05E0 - 0x05C0)
class UFortBadgeItemDefinition final : public UFortWorldItemDefinition
{
public:
	class USlateBrushAsset*                       DisplayImage;                                      // 0x05B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x05BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FailedDisplayText;                                 // 0x05C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    BadgeScoringValuesHandle;                          // 0x05D4(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBadgeItemDefinition">();
	}
	static class UFortBadgeItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBadgeItemDefinition>();
	}
};
static_assert(alignof(UFortBadgeItemDefinition) == 0x000010, "Wrong alignment on UFortBadgeItemDefinition");
static_assert(sizeof(UFortBadgeItemDefinition) == 0x0005E0, "Wrong size on UFortBadgeItemDefinition");
static_assert(offsetof(UFortBadgeItemDefinition, DisplayImage) == 0x0005B8, "Member 'UFortBadgeItemDefinition::DisplayImage' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, DisplayText) == 0x0005BC, "Member 'UFortBadgeItemDefinition::DisplayText' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, FailedDisplayText) == 0x0005C8, "Member 'UFortBadgeItemDefinition::FailedDisplayText' has a wrong offset!");
static_assert(offsetof(UFortBadgeItemDefinition, BadgeScoringValuesHandle) == 0x0005D4, "Member 'UFortBadgeItemDefinition::BadgeScoringValuesHandle' has a wrong offset!");

// Class FortniteGame.FortGadgetItemDefinition
// 0x0020 (0x05E0 - 0x05C0)
class UFortGadgetItemDefinition final : public UFortWorldItemDefinition
{
public:
	uint8                                         Pad_5B8[0x4];                                      // 0x05B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortGameplayAbility>       GameplayAbility;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortDecoItemDefinition*                DecoItemDefinition;                                // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     LevelAttribute;                                    // 0x05C4(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bConsumeOnUse;                                     // 0x05C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ActivationAnimation;                               // 0x05CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    DamageStatHandle;                                  // 0x05D0(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGadgetItemDefinition">();
	}
	static class UFortGadgetItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGadgetItemDefinition>();
	}
};
static_assert(alignof(UFortGadgetItemDefinition) == 0x000010, "Wrong alignment on UFortGadgetItemDefinition");
static_assert(sizeof(UFortGadgetItemDefinition) == 0x0005E0, "Wrong size on UFortGadgetItemDefinition");
static_assert(offsetof(UFortGadgetItemDefinition, GameplayAbility) == 0x0005BC, "Member 'UFortGadgetItemDefinition::GameplayAbility' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, DecoItemDefinition) == 0x0005C0, "Member 'UFortGadgetItemDefinition::DecoItemDefinition' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, LevelAttribute) == 0x0005C4, "Member 'UFortGadgetItemDefinition::LevelAttribute' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, bConsumeOnUse) == 0x0005C8, "Member 'UFortGadgetItemDefinition::bConsumeOnUse' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, ActivationAnimation) == 0x0005CC, "Member 'UFortGadgetItemDefinition::ActivationAnimation' has a wrong offset!");
static_assert(offsetof(UFortGadgetItemDefinition, DamageStatHandle) == 0x0005D0, "Member 'UFortGadgetItemDefinition::DamageStatHandle' has a wrong offset!");

// Class FortniteGame.FortIngredientItemDefinition
// 0x0000 (0x05C0 - 0x05C0)
class UFortIngredientItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortIngredientItemDefinition">();
	}
	static class UFortIngredientItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortIngredientItemDefinition>();
	}
};
static_assert(alignof(UFortIngredientItemDefinition) == 0x000010, "Wrong alignment on UFortIngredientItemDefinition");
static_assert(sizeof(UFortIngredientItemDefinition) == 0x0005C0, "Wrong size on UFortIngredientItemDefinition");

// Class FortniteGame.FortLootTier
// 0x0000 (0x05C0 - 0x05C0)
class UFortLootTier final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLootTier">();
	}
	static class UFortLootTier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLootTier>();
	}
};
static_assert(alignof(UFortLootTier) == 0x000010, "Wrong alignment on UFortLootTier");
static_assert(sizeof(UFortLootTier) == 0x0005C0, "Wrong size on UFortLootTier");

// Class FortniteGame.FortMissionItemDefinition
// 0x0000 (0x05C0 - 0x05C0)
class UFortMissionItemDefinition final : public UFortWorldItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionItemDefinition">();
	}
	static class UFortMissionItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionItemDefinition>();
	}
};
static_assert(alignof(UFortMissionItemDefinition) == 0x000010, "Wrong alignment on UFortMissionItemDefinition");
static_assert(sizeof(UFortMissionItemDefinition) == 0x0005C0, "Wrong size on UFortMissionItemDefinition");

// Class FortniteGame.FortNeverPersistItemDefinition
// 0x0000 (0x05C0 - 0x05C0)
class UFortNeverPersistItemDefinition final : public UFortWorldItemDefinition
{
public:
	uint8                                         bBelongsInSharedInventory : 1;                     // 0x05B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bAccumulateOnPlayerState : 1;                      // 0x05B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNeverPersistItemDefinition">();
	}
	static class UFortNeverPersistItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNeverPersistItemDefinition>();
	}
};
static_assert(alignof(UFortNeverPersistItemDefinition) == 0x000010, "Wrong alignment on UFortNeverPersistItemDefinition");
static_assert(sizeof(UFortNeverPersistItemDefinition) == 0x0005C0, "Wrong size on UFortNeverPersistItemDefinition");

// Class FortniteGame.FortOutpostItemDefinition
// 0x0010 (0x05D0 - 0x05C0)
class UFortOutpostItemDefinition final : public UFortWorldItemDefinition
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    StaticGameplayEffectsByLevel;                      // 0x05B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   LongDescription;                                   // 0x05C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetLongDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostItemDefinition">();
	}
	static class UFortOutpostItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostItemDefinition>();
	}
};
static_assert(alignof(UFortOutpostItemDefinition) == 0x000010, "Wrong alignment on UFortOutpostItemDefinition");
static_assert(sizeof(UFortOutpostItemDefinition) == 0x0005D0, "Wrong size on UFortOutpostItemDefinition");
static_assert(offsetof(UFortOutpostItemDefinition, StaticGameplayEffectsByLevel) == 0x0005B8, "Member 'UFortOutpostItemDefinition::StaticGameplayEffectsByLevel' has a wrong offset!");
static_assert(offsetof(UFortOutpostItemDefinition, LongDescription) == 0x0005C4, "Member 'UFortOutpostItemDefinition::LongDescription' has a wrong offset!");

// Class FortniteGame.FortResourceItemDefinition
// 0x0000 (0x05C0 - 0x05C0)
class UFortResourceItemDefinition final : public UFortWorldItemDefinition
{
public:
	EFortResourceType                             ResourceType;                                      // 0x05B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBelongsInSharedInventory : 1;                     // 0x05BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortResourceItemDefinition">();
	}
	static class UFortResourceItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortResourceItemDefinition>();
	}
};
static_assert(alignof(UFortResourceItemDefinition) == 0x000010, "Wrong alignment on UFortResourceItemDefinition");
static_assert(sizeof(UFortResourceItemDefinition) == 0x0005C0, "Wrong size on UFortResourceItemDefinition");
static_assert(offsetof(UFortResourceItemDefinition, ResourceType) == 0x0005B8, "Member 'UFortResourceItemDefinition::ResourceType' has a wrong offset!");

// Class FortniteGame.FortBuildingItemDefinition
// 0x00A0 (0x0760 - 0x06C0)
class UFortBuildingItemDefinition final : public UFortWeaponItemDefinition
{
public:
	class UBuildingEditModeMetadata*              BuildingMetaData;                                  // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    MaterialPreviewBrushes;                            // 0x06BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   EditUseText;                                       // 0x06C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   EditRightUseText;                                  // 0x06D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            EditRightUseImageBrush;                            // 0x06E0(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_754[0xC];                                      // 0x0754(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortBuildingItemDefinition">();
	}
	static class UFortBuildingItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortBuildingItemDefinition>();
	}
};
static_assert(alignof(UFortBuildingItemDefinition) == 0x000010, "Wrong alignment on UFortBuildingItemDefinition");
static_assert(sizeof(UFortBuildingItemDefinition) == 0x000760, "Wrong size on UFortBuildingItemDefinition");
static_assert(offsetof(UFortBuildingItemDefinition, BuildingMetaData) == 0x0006B8, "Member 'UFortBuildingItemDefinition::BuildingMetaData' has a wrong offset!");
static_assert(offsetof(UFortBuildingItemDefinition, MaterialPreviewBrushes) == 0x0006BC, "Member 'UFortBuildingItemDefinition::MaterialPreviewBrushes' has a wrong offset!");
static_assert(offsetof(UFortBuildingItemDefinition, EditUseText) == 0x0006C8, "Member 'UFortBuildingItemDefinition::EditUseText' has a wrong offset!");
static_assert(offsetof(UFortBuildingItemDefinition, EditRightUseText) == 0x0006D4, "Member 'UFortBuildingItemDefinition::EditRightUseText' has a wrong offset!");
static_assert(offsetof(UFortBuildingItemDefinition, EditRightUseImageBrush) == 0x0006E0, "Member 'UFortBuildingItemDefinition::EditRightUseImageBrush' has a wrong offset!");

// Class FortniteGame.FortEditToolItemDefinition
// 0x0000 (0x06C0 - 0x06C0)
class UFortEditToolItemDefinition final : public UFortWeaponItemDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortEditToolItemDefinition">();
	}
	static class UFortEditToolItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortEditToolItemDefinition>();
	}
};
static_assert(alignof(UFortEditToolItemDefinition) == 0x000010, "Wrong alignment on UFortEditToolItemDefinition");
static_assert(sizeof(UFortEditToolItemDefinition) == 0x0006C0, "Wrong size on UFortEditToolItemDefinition");

// Class FortniteGame.FortWeaponRangedItemDefinition
// 0x0010 (0x06D0 - 0x06C0)
class UFortWeaponRangedItemDefinition final : public UFortWeaponItemDefinition
{
public:
	TSubclassOf<class AFortProjectileBase>        ProjectileTemplate;                                // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNativeWeaponTrace;                             // 0x06BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceThroughPawns;                                // 0x06BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BE[0x2];                                      // 0x06BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BulletShellFXTemplate;                             // 0x06C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldSpawnBulletShellFX;                         // 0x06C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C5[0xB];                                      // 0x06C5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeaponRangedItemDefinition">();
	}
	static class UFortWeaponRangedItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortWeaponRangedItemDefinition>();
	}
};
static_assert(alignof(UFortWeaponRangedItemDefinition) == 0x000010, "Wrong alignment on UFortWeaponRangedItemDefinition");
static_assert(sizeof(UFortWeaponRangedItemDefinition) == 0x0006D0, "Wrong size on UFortWeaponRangedItemDefinition");
static_assert(offsetof(UFortWeaponRangedItemDefinition, ProjectileTemplate) == 0x0006B8, "Member 'UFortWeaponRangedItemDefinition::ProjectileTemplate' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bUseNativeWeaponTrace) == 0x0006BC, "Member 'UFortWeaponRangedItemDefinition::bUseNativeWeaponTrace' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bTraceThroughPawns) == 0x0006BD, "Member 'UFortWeaponRangedItemDefinition::bTraceThroughPawns' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, BulletShellFXTemplate) == 0x0006C0, "Member 'UFortWeaponRangedItemDefinition::BulletShellFXTemplate' has a wrong offset!");
static_assert(offsetof(UFortWeaponRangedItemDefinition, bShouldSpawnBulletShellFX) == 0x0006C4, "Member 'UFortWeaponRangedItemDefinition::bShouldSpawnBulletShellFX' has a wrong offset!");

// Class FortniteGame.FortJumpDownLink
// 0x0000 (0x0274 - 0x0274)
class AFortJumpDownLink final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortJumpDownLink">();
	}
	static class AFortJumpDownLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortJumpDownLink>();
	}
};
static_assert(alignof(AFortJumpDownLink) == 0x000004, "Wrong alignment on AFortJumpDownLink");
static_assert(sizeof(AFortJumpDownLink) == 0x000274, "Wrong size on AFortJumpDownLink");

// Class FortniteGame.FortKeepItemManager
// 0x0258 (0x0274 - 0x001C)
class UFortKeepItemManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x258];                                     // 0x001C(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKeepItemManager">();
	}
	static class UFortKeepItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKeepItemManager>();
	}
};
static_assert(alignof(UFortKeepItemManager) == 0x000004, "Wrong alignment on UFortKeepItemManager");
static_assert(sizeof(UFortKeepItemManager) == 0x000274, "Wrong size on UFortKeepItemManager");

// Class FortniteGame.FortKismetLibrary
// 0x0000 (0x001C - 0x001C)
class UFortKismetLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyGlobalEnvironmentDamageToActor(class AActor* DamageTargetActor, float EnvironmentDamage, const struct FGameplayTagContainer& AdditionalContextTags, TSubclassOf<class UGameplayEffect> EnvironmentDamageGE);
	static struct FActiveGameplayEffectHandle ApplyGlobalEnvironmentGameplayEffectToActor(class AActor* EffectTargetActor, TSubclassOf<class UGameplayEffect> GameplayEffect, int32 GameplayEffectLevel, const struct FGameplayTagContainer& AdditionalContextTags);
	static void BroadcastMessage(class UObject* WorldContextObject, const class FString& Message, class FName Type, class AActor* Source);
	static void BroadcastSound(class UObject* WorldContextObject, class USoundBase* InSound, float VolumeMultiplier, float PitchMultiplier);
	static void BroadcastSoundAtLocation(class UObject* WorldContextObject, class USoundBase* InSound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier);
	static void ClearTutorialHighlights();
	static void ClientRequestSetTimeOfDay(class AFortPlayerController* FortPC, float TimeOfDay);
	static float ConvertToGameTime(class UObject* WorldContextObject, float InRealTime);
	static float ConvertToRealTime(class UObject* WorldContextObject, float InGameTime);
	static class UFortSpline* CreateNewSplineObject(class UObject* Outer_0);
	static void DisableTutorialHighlight(class FName WidgetName);
	static void EnableTutorialHighlight(class FName WidgetName);
	static struct FFortAbilitySetHandle EquipFortAbilitySet(TScriptInterface<class IAbilitySystemInterface> AbilitySystemInterfaceActor, class UFortAbilitySet* AbilitySet, class UObject* OverrideSourceObject);
	static bool EvaluateCurveTableRow(const struct FCurveTableRowHandle& CurveTableRowHandle, float InXY, float* OutXY, const class FString& ContextString);
	static void ExecuteClientEvent(class UObject* WorldContextObject, const struct FFortClientEventName& EventType, class UObject* EventSource, class UObject* EventFocus);
	static EFortTeam GetActorTeam(const class AActor* Actor);
	static class AFortTeamInfo* GetActorTeamInfo(class AActor* Actor);
	static class AFortAIDirector* GetAIDirector(class UObject* WorldContextObject);
	static class AFortAIGoalManager* GetAIGoalManager(const class UObject* WorldContextObject);
	static TArray<class AFortPlayerController*> GetAllFortPlayerControllers(class UObject* WorldContextObject);
	static void GetAllFortPlayerPawns(class UObject* WorldContextObject, TArray<class AFortPlayerPawn*>* OutFortPlayerPawns);
	static float GetBuildingHealthPercentage(const class ABuildingActor* BuildingActor);
	static void GetBuildingStructuralSupportSystem(class UObject* WorldContextObject, class UBuildingStructuralSupportSystem** BuildingStructuralSupportSystem);
	static float GetCalculatedGameDifficulty(class UObject* WorldContextObject);
	static class ABuildingSMActor* GetClosestBuildingActorFromArray(const class AActor* Actor, const TArray<class ABuildingSMActor*>& ArrayOfBuildings);
	static class AFortPlayerPawn* GetClosestFortPlayerPawn(class UObject* WorldContextObject, const struct FVector& Position);
	static EFortDayPhase GetCurrentDayPhase(class UObject* WorldContextObject);
	static struct FLinearColor GetDayNightDirectionalLightColor(class UObject* WorldContextObject);
	static struct FVector GetDayNightDirectionalLightVector(class UObject* WorldContextObject);
	static float GetDefaultAbsoluteTimeOfDaySpeed(class UObject* WorldContextObject);
	static struct FRotator GetDirectionActorToActor(class AActor* SourceActor, class AActor* TargetActor);
	static float GetFloatHoursUntilDayPhase(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static EPhysicalSurface GetFortPhysicalSurface(const struct FHitResult& Hit);
	static TArray<class AFortPlayerPawn*> GetFortPlayerPawns(class UObject* WorldContextObject);
	static float GetGameDifficulty();
	static float GetHostilityPercentage(class UObject* WorldContextObject);
	static int32 GetHoursUntilDayPhase(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static class FString GetHumanReadableName(class AActor* Actor);
	static void GetImpulseData(const struct FGameplayEffectContextHandle& EffectContext, struct FVector* ImpulseDirection, float* KnockbackMagnitude, float* KnockbackZAngle);
	static TArray<class AFortPlayerController*> GetLocalFortPlayerControllers(class UObject* WorldContextObject);
	static bool GetMeleeWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortMeleeWeaponStats* OutRow);
	static class UMaterialInstanceDynamic* GetMIDForSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent, int32 ElementIndex);
	static bool GetNumericCVar(const class FString& CVar, float* OutValue);
	static bool GetPawnStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortPawnStats* OutRow);
	static EFortDayPhase GetPreviousDayPhase(class UObject* WorldContextObject);
	static class UGameplayAbility* GetPrimaryInstance(const struct FGameplayAbilitySpec& Spec);
	static bool GetRangedWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortRangedWeaponStats* OutRow);
	static EFortTeamAffiliation GetTeamAffiliation(const class AActor* ActorA, const class AActor* ActorB);
	static EFortTeamAffiliation GetTeamAffiliationBetweenTeams(EFortTeam TeamA, EFortTeam TeamB);
	static class AFortTeamInfo* GetTeamInfo(class UObject* WorldContextObject, EFortTeam Team);
	static class AFortThreatVisualsManager* GetThreatVisualsManager(class UObject* WorldContextObject);
	static float GetTimeDayPhaseBegins(class UObject* WorldContextObject, EFortDayPhase DayPhase);
	static float GetTimeOfDay(class UObject* WorldContextObject);
	static float GetTimeOfDayAccumulator(class UObject* WorldContextObject);
	static float GetTimeOfDaySpeed(class UObject* WorldContextObject);
	static float GetTimeUntilInRealTimeSeconds(class UObject* WorldContextObject, float GameTime);
	static bool GetTooltipDescription(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* Description);
	static bool GetTooltipDescriptionArray(const class UObject* ObjectToDescribe, const TArray<struct FGameplayTag>& Tags, const class UFortTooltipContext* Context, TArray<class FText>* Descriptions);
	static bool GetTooltipDescriptionArrayFromTooltipClass(const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const TArray<struct FGameplayTag>& Tags, const class UFortTooltipContext* Context, TArray<class FText>* Descriptions);
	static bool GetTooltipDescriptionFromTooltipClass(const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* Description);
	static bool GetTooltipNumericValue(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FName Token, float* Value);
	static bool GetTooltipNumericValueFromTooltipClass(const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FName Token, float* Value);
	static bool GetTooltipTextFromToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText);
	static bool GetTooltipTextFromTokenFromTooltipClass(const class UObject* ObjectToDescribe, TSubclassOf<class UFortTooltip> TooltipClass, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText);
	static bool GetTrapStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortTrapStats* OutRow);
	static bool GetWeaponDurabilityByRarityStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortWeaponDurabilityByRarityStats* OutRow);
	static bool GetWeaponStatsRow(const struct FDataTableRowHandle& DataTableRowHandle, struct FFortBaseWeaponStats* OutRow);
	static void HideTutorialWidget(class FName WidgetName);
	static bool IsCriticalHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsFatalHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsFullBodyHit(const struct FGameplayEffectContextHandle& EffectContext);
	static bool IsValid(const struct FAttributeInfo& AttributeInfo);
	static TArray<class UObject*> JonLHack_GetAllObjectsOfClassFromPath(const class FString& Path, class UClass* Class_0);
	static int32 K2_DoesPlayerHaveItem(class AFortPlayerController* PlayerController, class UFortItemDefinition* ItemDefinition);
	static struct FVector K2_GetClosestAxisXY(const struct FVector& InVector);
	static void K2_GiveItemToAllPlayers(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive, bool bNotifyPlayer);
	static void K2_GiveItemToPlayer(class AFortPlayerController* PlayerController, const class UFortWorldItemDefinition* ItemDefinition, int32 NumberToGive, bool bNotifyPlayer);
	static void K2_RemoveItemFromAllPlayers(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 AmountToRemove);
	static int32 K2_RemoveItemFromPlayer(class AFortPlayerController* PlayerController, class UFortWorldItemDefinition* ItemDefinition, int32 AmountToRemove);
	static void K2_SpawnPickupInWorld(class UObject* WorldContextObject, class UFortWorldItemDefinition* ItemDefinition, int32 NumberToSpawn, const struct FVector& Position, const struct FVector& Direction, int32 OverrideMaxStackCount);
	static void MakeAllPlayersTalkToSelf(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Audio, float Delay, bool bInterruptCurrentLine, bool bCanBeInterrupted, bool bCanCue, EFortFeedbackBroadcastFilter BroadcastFilter, bool bLatent);
	static EFortBuildingState MakeBuildingState(EFortBuildingState Value);
	static EFortDayPhase MakeDayNightPhase(EFortDayPhase Value);
	static struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpecFromAbility(const struct FFortGameplayEffectContainer& EffectContainer, class UGameplayAbility* Ability, int32 GameplayEffectLevel);
	static struct FFortGameplayEffectContainerSpec MakeGameplayEffectContainerSpecFromAbilityComponent(const struct FFortGameplayEffectContainer& EffectContainer, class UAbilitySystemComponent* AbilityComp, int32 GameplayEffectLevel);
	static EFortMovementStyle MakeMovementStyle(EFortMovementStyle Value);
	static EFortResourceType MakeResourceType(EFortResourceType Value);
	static EFortWeaponCoreAnimation MakeWeaponCoreAnimation(EFortWeaponCoreAnimation Value);
	static bool OnSameTeam(const class AActor* ActorA, const class AActor* ActorB);
	static void PickLootDrops(TArray<struct FFortItemEntry>* OutLootToDrop, const class FName TierGroupName, const int32 WorldLevel, const int32 ForcedLootTier, const ELootQuotaLevel QuotaLevel);
	static struct FVector PushOffHitLocation(class AActor* RequestedBy, const struct FHitResult& Hit, float Distance);
	static struct FTransform PushOffTransformByHitLocation(class AActor* RequestedBy, const struct FTransform& InTransform, const struct FHitResult& Hit, float Distance);
	static void RegisterDayPhaseHitCallback(class UObject* Object, const class FString& FunctionName, EFortDayPhase Phase, bool bRecurring, bool bBlockTriggeringThisCycle);
	static void RegisterDayTimeHitCallback(class UObject* Object, const class FString& FunctionName, float TimeInHours, bool bRecurring, bool bBlockTriggeringThisCycle);
	static void RemoveActorsOfClassFromBuildingSMActorArray(const TArray<class ABuildingSMActor*>& ArrayToRemoveClassFrom, TSubclassOf<class ABuildingSMActor> ClassToRemove, TArray<class ABuildingSMActor*>* ArrayWithClassRemoved);
	static class UMaterialInstance* SelectMaterialInstance(class UMaterialInstance* A, class UMaterialInstance* B, bool bSelectA);
	static void SetCanBeDamaged(class AActor* Actor, bool bCanBeDamaged);
	static void SetTimeOfDay(class UObject* WorldContextObject, float TimeOfDay);
	static void SetTimeOfDaySpeed(class UObject* WorldContextObject, float TimeOfDaySpeedFactor);
	static bool ShouldHideTutorialWidget(class FName WidgetName);
	static class AFortAreaOfEffectCloud* SpawnAreaOfEffectCloud(TSubclassOf<class AFortAreaOfEffectCloud> AreaOfEffectClass, class AActor* RequestedBy, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode);
	static class ABuildingGameplayActor* SpawnBuildingGameplayActor(TSubclassOf<class ABuildingGameplayActor> BGAClass, const struct FTransform& Transform, class AFortPawn* Instigator);
	static class AFortProjectileBase* SpawnProjectile(TSubclassOf<class AFortProjectileBase> ProjectileClass, class AActor* RequestedBy, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FRotator& SpawnDirection, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnHit, const struct FFortGameplayEffectContainerSpec& EffectContainerSpecToApplyOnExplode, bool bUseDefaultPhysics, class AActor* HomingTarget, float InitialSpeed, float GravityScale, float ChargePercent);
	static bool SwitchHeroType(class AFortPlayerController* FortPC, const class FString& NewHeroName);
	static void TriggerFeedbackEvent(class UObject* WorldContextObject, const struct FFortFeedbackHandle& EventHandle, class AFortPawn* InstigatorPawn, class AFortPawn* Recipient, float OverriddenDelay, bool bAllowReplication);
	static void UnequipFortAbilitySet(struct FFortAbilitySetHandle& AbilitySetHandle);
	static void UnhideAllTutorialWidgets();
	static void UnhideTutorialWidget(class FName WidgetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortKismetLibrary">();
	}
	static class UFortKismetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortKismetLibrary>();
	}
};
static_assert(alignof(UFortKismetLibrary) == 0x000004, "Wrong alignment on UFortKismetLibrary");
static_assert(sizeof(UFortKismetLibrary) == 0x00001C, "Wrong size on UFortKismetLibrary");

// Class FortniteGame.FortLevelScriptActor
// 0x0008 (0x024C - 0x0244)
class AFortLevelScriptActor : public ALevelScriptActor
{
public:
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWorldReadyCalled : 1;                             // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarted();
	void OnWorldReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLevelScriptActor">();
	}
	static class AFortLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLevelScriptActor>();
	}
};
static_assert(alignof(AFortLevelScriptActor) == 0x000004, "Wrong alignment on AFortLevelScriptActor");
static_assert(sizeof(AFortLevelScriptActor) == 0x00024C, "Wrong size on AFortLevelScriptActor");

// Class FortniteGame.FortLobbyBeaconClientPvP
// 0x001C (0x02D8 - 0x02BC)
class AFortLobbyBeaconClientPvP final : public AFortLobbyBeaconClient
{
public:
	uint8                                         Pad_2BC[0x1C];                                     // 0x02BC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerReadyUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconClientPvP">();
	}
	static class AFortLobbyBeaconClientPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconClientPvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconClientPvP) == 0x000004, "Wrong alignment on AFortLobbyBeaconClientPvP");
static_assert(sizeof(AFortLobbyBeaconClientPvP) == 0x0002D8, "Wrong size on AFortLobbyBeaconClientPvP");

// Class FortniteGame.FortLobbyBeaconHostPvE
// 0x0000 (0x0290 - 0x0290)
class AFortLobbyBeaconHostPvE : public AFortLobbyBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostPvE">();
	}
	static class AFortLobbyBeaconHostPvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostPvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostPvE) == 0x000004, "Wrong alignment on AFortLobbyBeaconHostPvE");
static_assert(sizeof(AFortLobbyBeaconHostPvE) == 0x000290, "Wrong size on AFortLobbyBeaconHostPvE");

// Class FortniteGame.FortLobbyBeaconHostOutpost
// 0x0000 (0x0290 - 0x0290)
class AFortLobbyBeaconHostOutpost final : public AFortLobbyBeaconHostPvE
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconHostOutpost">();
	}
	static class AFortLobbyBeaconHostOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconHostOutpost>();
	}
};
static_assert(alignof(AFortLobbyBeaconHostOutpost) == 0x000004, "Wrong alignment on AFortLobbyBeaconHostOutpost");
static_assert(sizeof(AFortLobbyBeaconHostOutpost) == 0x000290, "Wrong size on AFortLobbyBeaconHostOutpost");

// Class FortniteGame.FortLobbyBeaconPlayerStatePvE
// 0x0000 (0x0330 - 0x0330)
class AFortLobbyBeaconPlayerStatePvE final : public AFortLobbyBeaconPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconPlayerStatePvE">();
	}
	static class AFortLobbyBeaconPlayerStatePvE* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconPlayerStatePvE>();
	}
};
static_assert(alignof(AFortLobbyBeaconPlayerStatePvE) == 0x000004, "Wrong alignment on AFortLobbyBeaconPlayerStatePvE");
static_assert(sizeof(AFortLobbyBeaconPlayerStatePvE) == 0x000330, "Wrong size on AFortLobbyBeaconPlayerStatePvE");

// Class FortniteGame.FortLobbyBeaconStatePvP
// 0x0008 (0x0398 - 0x0390)
class AFortLobbyBeaconStatePvP final : public AFortLobbyBeaconState
{
public:
	int32                                         PvPLobbyTimeLimit;                                 // 0x0390(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PvPLobbyTimeRemaining;                             // 0x0394(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_PvPLobbyTimeRemaining();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLobbyBeaconStatePvP">();
	}
	static class AFortLobbyBeaconStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortLobbyBeaconStatePvP>();
	}
};
static_assert(alignof(AFortLobbyBeaconStatePvP) == 0x000004, "Wrong alignment on AFortLobbyBeaconStatePvP");
static_assert(sizeof(AFortLobbyBeaconStatePvP) == 0x000398, "Wrong size on AFortLobbyBeaconStatePvP");
static_assert(offsetof(AFortLobbyBeaconStatePvP, PvPLobbyTimeLimit) == 0x000390, "Member 'AFortLobbyBeaconStatePvP::PvPLobbyTimeLimit' has a wrong offset!");
static_assert(offsetof(AFortLobbyBeaconStatePvP, PvPLobbyTimeRemaining) == 0x000394, "Member 'AFortLobbyBeaconStatePvP::PvPLobbyTimeRemaining' has a wrong offset!");

// Class FortniteGame.FortLOSComponent
// 0x0040 (0x00CC - 0x008C)
class UFortLOSComponent final : public UActorComponent
{
public:
	float                                         LOSMaxDistance;                                    // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInDegrees;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenChecks;                                 // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAfterHasBeenFound;                            // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDistanceCheckOnly;                                // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnHasBeenFound;                                    // 0x009C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasBeenFound;                                     // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x23];                                      // 0x00A9(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortLOSComponent">();
	}
	static class UFortLOSComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortLOSComponent>();
	}
};
static_assert(alignof(UFortLOSComponent) == 0x000004, "Wrong alignment on UFortLOSComponent");
static_assert(sizeof(UFortLOSComponent) == 0x0000CC, "Wrong size on UFortLOSComponent");
static_assert(offsetof(UFortLOSComponent, LOSMaxDistance) == 0x00008C, "Member 'UFortLOSComponent::LOSMaxDistance' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, FOVInDegrees) == 0x000090, "Member 'UFortLOSComponent::FOVInDegrees' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, TimeBetweenChecks) == 0x000094, "Member 'UFortLOSComponent::TimeBetweenChecks' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bStopAfterHasBeenFound) == 0x000098, "Member 'UFortLOSComponent::bStopAfterHasBeenFound' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bDistanceCheckOnly) == 0x000099, "Member 'UFortLOSComponent::bDistanceCheckOnly' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, OnHasBeenFound) == 0x00009C, "Member 'UFortLOSComponent::OnHasBeenFound' has a wrong offset!");
static_assert(offsetof(UFortLOSComponent, bHasBeenFound) == 0x0000A8, "Member 'UFortLOSComponent::bHasBeenFound' has a wrong offset!");

// Class FortniteGame.FortMarkActor
// 0x009C (0x02DC - 0x0240)
class AFortMarkActor final : public AActor
{
public:
	TWeakObjectPtr<class AFortPlayerStateZone>    OwningPlayer;                                      // 0x0240(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 MarkString;                                        // 0x0248(0x000C)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedEditing;                                  // 0x0254(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AttachedToActor;                                   // 0x0258(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachmentOffset;                                  // 0x025C(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MiniMapIconBrush;                                  // 0x0268(0x0074)(NativeAccessSpecifierPublic)

public:
	void OnRep_AttachedToActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMarkActor">();
	}
	static class AFortMarkActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMarkActor>();
	}
};
static_assert(alignof(AFortMarkActor) == 0x000004, "Wrong alignment on AFortMarkActor");
static_assert(sizeof(AFortMarkActor) == 0x0002DC, "Wrong size on AFortMarkActor");
static_assert(offsetof(AFortMarkActor, OwningPlayer) == 0x000240, "Member 'AFortMarkActor::OwningPlayer' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, MarkString) == 0x000248, "Member 'AFortMarkActor::MarkString' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, bFinishedEditing) == 0x000254, "Member 'AFortMarkActor::bFinishedEditing' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, AttachedToActor) == 0x000258, "Member 'AFortMarkActor::AttachedToActor' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, AttachmentOffset) == 0x00025C, "Member 'AFortMarkActor::AttachmentOffset' has a wrong offset!");
static_assert(offsetof(AFortMarkActor, MiniMapIconBrush) == 0x000268, "Member 'AFortMarkActor::MiniMapIconBrush' has a wrong offset!");

// Class FortniteGame.FortMatchmaking
// 0x0244 (0x0260 - 0x001C)
class UFortMatchmaking final : public UObject
{
public:
	uint8                                         Pad_1C[0x118];                                     // 0x001C(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UQosEvaluator*                          QosEvaluator;                                      // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APartyBeaconClient>         ReservationBeaconClientClass;                      // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortPartyBeaconClient*                 ReservationBeaconClient;                           // 0x013C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AFortLobbyBeaconClient*                 LobbyBeaconClient;                                 // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0xC];                                      // 0x0144(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControllerId;                                      // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TempZoneInstanceId;                                // 0x0154(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFortCachedMatchmakingSearchParams     CachedMatchmakingSearchParams;                     // 0x0160(0x006C)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x84];                                     // 0x01CC(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortMatchmakingPolicy*                 Matchmaking;                                       // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 LastCriticalMissionSessionId;                      // 0x0254(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmaking">();
	}
	static class UFortMatchmaking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmaking>();
	}
};
static_assert(alignof(UFortMatchmaking) == 0x000004, "Wrong alignment on UFortMatchmaking");
static_assert(sizeof(UFortMatchmaking) == 0x000260, "Wrong size on UFortMatchmaking");
static_assert(offsetof(UFortMatchmaking, QosEvaluator) == 0x000134, "Member 'UFortMatchmaking::QosEvaluator' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, ReservationBeaconClientClass) == 0x000138, "Member 'UFortMatchmaking::ReservationBeaconClientClass' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, ReservationBeaconClient) == 0x00013C, "Member 'UFortMatchmaking::ReservationBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, LobbyBeaconClient) == 0x000140, "Member 'UFortMatchmaking::LobbyBeaconClient' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, ControllerId) == 0x000150, "Member 'UFortMatchmaking::ControllerId' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, TempZoneInstanceId) == 0x000154, "Member 'UFortMatchmaking::TempZoneInstanceId' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, CachedMatchmakingSearchParams) == 0x000160, "Member 'UFortMatchmaking::CachedMatchmakingSearchParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, Matchmaking) == 0x000250, "Member 'UFortMatchmaking::Matchmaking' has a wrong offset!");
static_assert(offsetof(UFortMatchmaking, LastCriticalMissionSessionId) == 0x000254, "Member 'UFortMatchmaking::LastCriticalMissionSessionId' has a wrong offset!");

// Class FortniteGame.FortMatchmakingGather
// 0x0010 (0x00B8 - 0x00A8)
class UFortMatchmakingGather final : public UFortMatchmakingPolicy
{
public:
	float                                         ChanceToJoinInProgress;                            // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0xC];                                       // 0x00AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingGather">();
	}
	static class UFortMatchmakingGather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingGather>();
	}
};
static_assert(alignof(UFortMatchmakingGather) == 0x000004, "Wrong alignment on UFortMatchmakingGather");
static_assert(sizeof(UFortMatchmakingGather) == 0x0000B8, "Wrong size on UFortMatchmakingGather");
static_assert(offsetof(UFortMatchmakingGather, ChanceToJoinInProgress) == 0x0000A8, "Member 'UFortMatchmakingGather::ChanceToJoinInProgress' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_GoalOnCircle
// 0x0004 (0x0138 - 0x0134)
class UFortQueryGenerator_GoalOnCircle final : public UEnvQueryGenerator_OnCircle
{
public:
	bool                                          bIncludeCenterActorInGeneratedGoals;               // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_GoalOnCircle">();
	}
	static class UFortQueryGenerator_GoalOnCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_GoalOnCircle>();
	}
};
static_assert(alignof(UFortQueryGenerator_GoalOnCircle) == 0x000004, "Wrong alignment on UFortQueryGenerator_GoalOnCircle");
static_assert(sizeof(UFortQueryGenerator_GoalOnCircle) == 0x000138, "Wrong size on UFortQueryGenerator_GoalOnCircle");
static_assert(offsetof(UFortQueryGenerator_GoalOnCircle, bIncludeCenterActorInGeneratedGoals) == 0x000134, "Member 'UFortQueryGenerator_GoalOnCircle::bIncludeCenterActorInGeneratedGoals' has a wrong offset!");

// Class FortniteGame.FortMatchmakingSingleSession
// 0x0020 (0x00C8 - 0x00A8)
class UFortMatchmakingSingleSession final : public UFortMatchmakingPolicy
{
public:
	struct FFortInviteSessionParams               CurrentSessionParams;                              // 0x00A8(0x001C)(Transient, NativeAccessSpecifierPrivate)
	class UFortSessionHelper*                     SessionHelper;                                     // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMatchmakingSingleSession">();
	}
	static class UFortMatchmakingSingleSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMatchmakingSingleSession>();
	}
};
static_assert(alignof(UFortMatchmakingSingleSession) == 0x000004, "Wrong alignment on UFortMatchmakingSingleSession");
static_assert(sizeof(UFortMatchmakingSingleSession) == 0x0000C8, "Wrong size on UFortMatchmakingSingleSession");
static_assert(offsetof(UFortMatchmakingSingleSession, CurrentSessionParams) == 0x0000A8, "Member 'UFortMatchmakingSingleSession::CurrentSessionParams' has a wrong offset!");
static_assert(offsetof(UFortMatchmakingSingleSession, SessionHelper) == 0x0000C4, "Member 'UFortMatchmakingSingleSession::SessionHelper' has a wrong offset!");

// Class FortniteGame.FortQueryItemType_Goal
// 0x0000 (0x0020 - 0x0020)
class UFortQueryItemType_Goal final : public UEnvQueryItemType_ActorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_Goal">();
	}
	static class UFortQueryItemType_Goal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_Goal>();
	}
};
static_assert(alignof(UFortQueryItemType_Goal) == 0x000004, "Wrong alignment on UFortQueryItemType_Goal");
static_assert(sizeof(UFortQueryItemType_Goal) == 0x000020, "Wrong size on UFortQueryItemType_Goal");

// Class FortniteGame.FortMenuInputHelper
// 0x0040 (0x005C - 0x001C)
class UFortMenuInputHelper final : public UObject
{
public:
	uint8                                         Pad_1C[0x40];                                      // 0x001C(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMenuInputHelper">();
	}
	static class UFortMenuInputHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMenuInputHelper>();
	}
};
static_assert(alignof(UFortMenuInputHelper) == 0x000004, "Wrong alignment on UFortMenuInputHelper");
static_assert(sizeof(UFortMenuInputHelper) == 0x00005C, "Wrong size on UFortMenuInputHelper");

// Class FortniteGame.FortMetaNavArea_Wall
// 0x0000 (0x0040 - 0x0040)
class UFortMetaNavArea_Wall final : public UFortMetaNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Wall">();
	}
	static class UFortMetaNavArea_Wall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Wall>();
	}
};
static_assert(alignof(UFortMetaNavArea_Wall) == 0x000004, "Wrong alignment on UFortMetaNavArea_Wall");
static_assert(sizeof(UFortMetaNavArea_Wall) == 0x000040, "Wrong size on UFortMetaNavArea_Wall");

// Class FortniteGame.FortMetaNavArea_Obstacles
// 0x0004 (0x0038 - 0x0034)
class UFortMetaNavArea_Obstacles final : public UNavAreaMeta
{
public:
	int32                                         HealthThreshold;                                   // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMetaNavArea_Obstacles">();
	}
	static class UFortMetaNavArea_Obstacles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMetaNavArea_Obstacles>();
	}
};
static_assert(alignof(UFortMetaNavArea_Obstacles) == 0x000004, "Wrong alignment on UFortMetaNavArea_Obstacles");
static_assert(sizeof(UFortMetaNavArea_Obstacles) == 0x000038, "Wrong size on UFortMetaNavArea_Obstacles");
static_assert(offsetof(UFortMetaNavArea_Obstacles, HealthThreshold) == 0x000034, "Member 'UFortMetaNavArea_Obstacles::HealthThreshold' has a wrong offset!");

// Class FortniteGame.FortMissionGenerationData
// 0x009C (0x00B8 - 0x001C)
class UFortMissionGenerationData final : public UDataAsset
{
public:
	TArray<class UFortMissionGenerator*>          PrimaryMissionGenerators;                          // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PrimaryMissionMinPowerPointsUsagePercentage;       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   SecondaryMissionPowerPointsBudgetMultiplier;       // 0x002C(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinSecondaryMissionPowerPointsMultiplier;          // 0x0038(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSecondaryMissionPowerPointsMultiplier;          // 0x0044(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinSecondaryMissions;                              // 0x0050(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxSecondaryMissions;                              // 0x005C(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   TertiaryMissionPowerPointsBudgetMultiplier;        // 0x0068(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MinTertiaryMissionPowerPointsMultiplier;           // 0x0074(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   MaxTertiaryMissionPowerPointsMultiplier;           // 0x0080(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   PowerPointsCurve;                                  // 0x008C(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FFortDifficultyOptionBudget>    EncounterDifficultyOptionBudgets;                  // 0x0098(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         EncounterMinDifficultyOptionPointsUsagePercentage; // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFortDifficultyOptionBudget>    MissionDifficultyOptionBudgets;                    // 0x00A8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MissionMinDifficultyOptionPointsUsagePercentage;   // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerationData">();
	}
	static class UFortMissionGenerationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionGenerationData>();
	}
};
static_assert(alignof(UFortMissionGenerationData) == 0x000004, "Wrong alignment on UFortMissionGenerationData");
static_assert(sizeof(UFortMissionGenerationData) == 0x0000B8, "Wrong size on UFortMissionGenerationData");
static_assert(offsetof(UFortMissionGenerationData, PrimaryMissionGenerators) == 0x00001C, "Member 'UFortMissionGenerationData::PrimaryMissionGenerators' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, PrimaryMissionMinPowerPointsUsagePercentage) == 0x000028, "Member 'UFortMissionGenerationData::PrimaryMissionMinPowerPointsUsagePercentage' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, SecondaryMissionPowerPointsBudgetMultiplier) == 0x00002C, "Member 'UFortMissionGenerationData::SecondaryMissionPowerPointsBudgetMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinSecondaryMissionPowerPointsMultiplier) == 0x000038, "Member 'UFortMissionGenerationData::MinSecondaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxSecondaryMissionPowerPointsMultiplier) == 0x000044, "Member 'UFortMissionGenerationData::MaxSecondaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinSecondaryMissions) == 0x000050, "Member 'UFortMissionGenerationData::MinSecondaryMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxSecondaryMissions) == 0x00005C, "Member 'UFortMissionGenerationData::MaxSecondaryMissions' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, TertiaryMissionPowerPointsBudgetMultiplier) == 0x000068, "Member 'UFortMissionGenerationData::TertiaryMissionPowerPointsBudgetMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MinTertiaryMissionPowerPointsMultiplier) == 0x000074, "Member 'UFortMissionGenerationData::MinTertiaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MaxTertiaryMissionPowerPointsMultiplier) == 0x000080, "Member 'UFortMissionGenerationData::MaxTertiaryMissionPowerPointsMultiplier' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, PowerPointsCurve) == 0x00008C, "Member 'UFortMissionGenerationData::PowerPointsCurve' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, EncounterDifficultyOptionBudgets) == 0x000098, "Member 'UFortMissionGenerationData::EncounterDifficultyOptionBudgets' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, EncounterMinDifficultyOptionPointsUsagePercentage) == 0x0000A4, "Member 'UFortMissionGenerationData::EncounterMinDifficultyOptionPointsUsagePercentage' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MissionDifficultyOptionBudgets) == 0x0000A8, "Member 'UFortMissionGenerationData::MissionDifficultyOptionBudgets' has a wrong offset!");
static_assert(offsetof(UFortMissionGenerationData, MissionMinDifficultyOptionPointsUsagePercentage) == 0x0000B4, "Member 'UFortMissionGenerationData::MissionMinDifficultyOptionPointsUsagePercentage' has a wrong offset!");

// Class FortniteGame.FortQueryTest_CanAttackTarget
// 0x0000 (0x011C - 0x011C)
class UFortQueryTest_CanAttackTarget final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanAttackTarget">();
	}
	static class UFortQueryTest_CanAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanAttackTarget>();
	}
};
static_assert(alignof(UFortQueryTest_CanAttackTarget) == 0x000004, "Wrong alignment on UFortQueryTest_CanAttackTarget");
static_assert(sizeof(UFortQueryTest_CanAttackTarget) == 0x00011C, "Wrong size on UFortQueryTest_CanAttackTarget");

// Class FortniteGame.FortMissionGenerationManager
// 0x0004 (0x0244 - 0x0240)
class AFortMissionGenerationManager final : public AActor
{
public:
	EFortCheatMissionGenType                      CheatMissionGenType;                               // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionGenerationManager">();
	}
	static class AFortMissionGenerationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionGenerationManager>();
	}
};
static_assert(alignof(AFortMissionGenerationManager) == 0x000004, "Wrong alignment on AFortMissionGenerationManager");
static_assert(sizeof(AFortMissionGenerationManager) == 0x000244, "Wrong size on AFortMissionGenerationManager");
static_assert(offsetof(AFortMissionGenerationManager, CheatMissionGenType) == 0x000240, "Member 'AFortMissionGenerationManager::CheatMissionGenType' has a wrong offset!");

// Class FortniteGame.FortMissionInterface
// 0x0000 (0x001C - 0x001C)
class IFortMissionInterface final : public IInterface
{
public:
	void BlueprintHandleMissionEventNoReply(const struct FFortMissionEvent& MissionEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionInterface">();
	}
	static class IFortMissionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionInterface>();
	}
};
static_assert(alignof(IFortMissionInterface) == 0x000004, "Wrong alignment on IFortMissionInterface");
static_assert(sizeof(IFortMissionInterface) == 0x00001C, "Wrong size on IFortMissionInterface");

// Class FortniteGame.FortQueryItemType_GraphPoint
// 0x0000 (0x0020 - 0x0020)
class UFortQueryItemType_GraphPoint final : public UEnvQueryItemType_Point
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryItemType_GraphPoint">();
	}
	static class UFortQueryItemType_GraphPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryItemType_GraphPoint>();
	}
};
static_assert(alignof(UFortQueryItemType_GraphPoint) == 0x000004, "Wrong alignment on UFortQueryItemType_GraphPoint");
static_assert(sizeof(UFortQueryItemType_GraphPoint) == 0x000020, "Wrong size on UFortQueryItemType_GraphPoint");

// Class FortniteGame.FortMissionManager
// 0x00A8 (0x02E8 - 0x0240)
class AFortMissionManager : public AActor
{
public:
	TArray<struct FFortMissionEventName>          MissionEventNames;                                 // 0x0240(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BluGloManagerClass;                                // 0x024C(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortBluGloManager*                     BluGloManager;                                     // 0x0264(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AFortMission*>                   Missions;                                          // 0x0268(0x000C)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x3C];                                     // 0x0274(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortMissionUIActorHandle>      MissionUIActors;                                   // 0x02B0(0x000C)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class AFortNotificationManager*               NotificationManager;                               // 0x02BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           CurrentTimedMission;                               // 0x02C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFortMission*                           MissionClosestToPar;                               // 0x02C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableParClockFaceCountdown;                      // 0x02C8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x1F];                                     // 0x02C9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentTimedMission();
	void OnRep_Missions();
	void OnRep_MissionUIActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionManager">();
	}
	static class AFortMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMissionManager>();
	}
};
static_assert(alignof(AFortMissionManager) == 0x000004, "Wrong alignment on AFortMissionManager");
static_assert(sizeof(AFortMissionManager) == 0x0002E8, "Wrong size on AFortMissionManager");
static_assert(offsetof(AFortMissionManager, MissionEventNames) == 0x000240, "Member 'AFortMissionManager::MissionEventNames' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, BluGloManagerClass) == 0x00024C, "Member 'AFortMissionManager::BluGloManagerClass' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, BluGloManager) == 0x000264, "Member 'AFortMissionManager::BluGloManager' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, Missions) == 0x000268, "Member 'AFortMissionManager::Missions' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, MissionUIActors) == 0x0002B0, "Member 'AFortMissionManager::MissionUIActors' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, NotificationManager) == 0x0002BC, "Member 'AFortMissionManager::NotificationManager' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, CurrentTimedMission) == 0x0002C0, "Member 'AFortMissionManager::CurrentTimedMission' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, MissionClosestToPar) == 0x0002C4, "Member 'AFortMissionManager::MissionClosestToPar' has a wrong offset!");
static_assert(offsetof(AFortMissionManager, bEnableParClockFaceCountdown) == 0x0002C8, "Member 'AFortMissionManager::bEnableParClockFaceCountdown' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_ValidSpawnRiftActors
// 0x001C (0x0050 - 0x0034)
class UFortQueryGenerator_ValidSpawnRiftActors final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderIntValue                NumAIForGroup;                                     // 0x0034(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_ValidSpawnRiftActors">();
	}
	static class UFortQueryGenerator_ValidSpawnRiftActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_ValidSpawnRiftActors>();
	}
};
static_assert(alignof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000004, "Wrong alignment on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(sizeof(UFortQueryGenerator_ValidSpawnRiftActors) == 0x000050, "Wrong size on UFortQueryGenerator_ValidSpawnRiftActors");
static_assert(offsetof(UFortQueryGenerator_ValidSpawnRiftActors, NumAIForGroup) == 0x000034, "Member 'UFortQueryGenerator_ValidSpawnRiftActors::NumAIForGroup' has a wrong offset!");

// Class FortniteGame.FortPvPMissionManager
// 0x0000 (0x02E8 - 0x02E8)
class AFortPvPMissionManager final : public AFortMissionManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMissionManager">();
	}
	static class AFortPvPMissionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMissionManager>();
	}
};
static_assert(alignof(AFortPvPMissionManager) == 0x000004, "Wrong alignment on AFortPvPMissionManager");
static_assert(sizeof(AFortPvPMissionManager) == 0x0002E8, "Wrong size on AFortPvPMissionManager");

// Class FortniteGame.FortPlacementActorDataProviderInterface
// 0x0000 (0x001C - 0x001C)
class IFortPlacementActorDataProviderInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacementActorDataProviderInterface">();
	}
	static class IFortPlacementActorDataProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPlacementActorDataProviderInterface>();
	}
};
static_assert(alignof(IFortPlacementActorDataProviderInterface) == 0x000004, "Wrong alignment on IFortPlacementActorDataProviderInterface");
static_assert(sizeof(IFortPlacementActorDataProviderInterface) == 0x00001C, "Wrong size on IFortPlacementActorDataProviderInterface");

// Class FortniteGame.FortQueryTest_AssignmentTypeInterest
// 0x0140 (0x025C - 0x011C)
class UFortQueryTest_AssignmentTypeInterest final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              InvalidTypeStartInterest;                          // 0x011C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeEndInterest;                            // 0x0138(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeTimeBeforeLerp;                         // 0x0154(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              InvalidTypeLerpDuration;                           // 0x0170(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeStartInterest;                            // 0x018C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeEndInterest;                              // 0x01A8(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeTimeBeforeLerp;                           // 0x01C4(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValidTypeLerpDuration;                             // 0x01E0(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              StartInterestWhenUsingInvalidType;                 // 0x01FC(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              EndInterestWhenUsingInvalidType;                   // 0x0208(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              TimeBeforeLerpWhenUsingInvalidType;                // 0x0214(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              LerpDurationForInvalidType;                        // 0x0220(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              StartInterestWhenUsingValidType;                   // 0x022C(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              EndInterestWhenUsingValidType;                     // 0x0238(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              TimeBeforeLerpWhenUsingValidType;                  // 0x0244(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              LerpDurationForValidType;                          // 0x0250(0x000C)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_AssignmentTypeInterest">();
	}
	static class UFortQueryTest_AssignmentTypeInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_AssignmentTypeInterest>();
	}
};
static_assert(alignof(UFortQueryTest_AssignmentTypeInterest) == 0x000004, "Wrong alignment on UFortQueryTest_AssignmentTypeInterest");
static_assert(sizeof(UFortQueryTest_AssignmentTypeInterest) == 0x00025C, "Wrong size on UFortQueryTest_AssignmentTypeInterest");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeStartInterest) == 0x00011C, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeEndInterest) == 0x000138, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeTimeBeforeLerp) == 0x000154, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, InvalidTypeLerpDuration) == 0x000170, "Member 'UFortQueryTest_AssignmentTypeInterest::InvalidTypeLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeStartInterest) == 0x00018C, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeStartInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeEndInterest) == 0x0001A8, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeEndInterest' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeTimeBeforeLerp) == 0x0001C4, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeTimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, ValidTypeLerpDuration) == 0x0001E0, "Member 'UFortQueryTest_AssignmentTypeInterest::ValidTypeLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, StartInterestWhenUsingInvalidType) == 0x0001FC, "Member 'UFortQueryTest_AssignmentTypeInterest::StartInterestWhenUsingInvalidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, EndInterestWhenUsingInvalidType) == 0x000208, "Member 'UFortQueryTest_AssignmentTypeInterest::EndInterestWhenUsingInvalidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, TimeBeforeLerpWhenUsingInvalidType) == 0x000214, "Member 'UFortQueryTest_AssignmentTypeInterest::TimeBeforeLerpWhenUsingInvalidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, LerpDurationForInvalidType) == 0x000220, "Member 'UFortQueryTest_AssignmentTypeInterest::LerpDurationForInvalidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, StartInterestWhenUsingValidType) == 0x00022C, "Member 'UFortQueryTest_AssignmentTypeInterest::StartInterestWhenUsingValidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, EndInterestWhenUsingValidType) == 0x000238, "Member 'UFortQueryTest_AssignmentTypeInterest::EndInterestWhenUsingValidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, TimeBeforeLerpWhenUsingValidType) == 0x000244, "Member 'UFortQueryTest_AssignmentTypeInterest::TimeBeforeLerpWhenUsingValidType' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_AssignmentTypeInterest, LerpDurationForValidType) == 0x000250, "Member 'UFortQueryTest_AssignmentTypeInterest::LerpDurationForValidType' has a wrong offset!");

// Class FortniteGame.FortMissionTimerInterface
// 0x0000 (0x001C - 0x001C)
class IFortMissionTimerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionTimerInterface">();
	}
	static class IFortMissionTimerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortMissionTimerInterface>();
	}
};
static_assert(alignof(IFortMissionTimerInterface) == 0x000004, "Wrong alignment on IFortMissionTimerInterface");
static_assert(sizeof(IFortMissionTimerInterface) == 0x00001C, "Wrong size on IFortMissionTimerInterface");

// Class FortniteGame.FortQueryTest_GoalOverallDamageCaused
// 0x0000 (0x011C - 0x011C)
class UFortQueryTest_GoalOverallDamageCaused final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalOverallDamageCaused">();
	}
	static class UFortQueryTest_GoalOverallDamageCaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalOverallDamageCaused>();
	}
};
static_assert(alignof(UFortQueryTest_GoalOverallDamageCaused) == 0x000004, "Wrong alignment on UFortQueryTest_GoalOverallDamageCaused");
static_assert(sizeof(UFortQueryTest_GoalOverallDamageCaused) == 0x00011C, "Wrong size on UFortQueryTest_GoalOverallDamageCaused");

// Class FortniteGame.FortPvPMission_3PtDomination
// 0x001C (0x03CC - 0x03B0)
class AFortPvPMission_3PtDomination final : public AFortPvPMission
{
public:
	TArray<class ABuildingCapturePointActor*>     CapturePoints;                                     // 0x03B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamScores;                                        // 0x03BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         ScoreToWin;                                        // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CapturePointSetterHackTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_3PtDomination">();
	}
	static class AFortPvPMission_3PtDomination* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_3PtDomination>();
	}
};
static_assert(alignof(AFortPvPMission_3PtDomination) == 0x000004, "Wrong alignment on AFortPvPMission_3PtDomination");
static_assert(sizeof(AFortPvPMission_3PtDomination) == 0x0003CC, "Wrong size on AFortPvPMission_3PtDomination");
static_assert(offsetof(AFortPvPMission_3PtDomination, CapturePoints) == 0x0003B0, "Member 'AFortPvPMission_3PtDomination::CapturePoints' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_3PtDomination, TeamScores) == 0x0003BC, "Member 'AFortPvPMission_3PtDomination::TeamScores' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_3PtDomination, ScoreToWin) == 0x0003C8, "Member 'AFortPvPMission_3PtDomination::ScoreToWin' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalActorDot
// 0x000C (0x0128 - 0x011C)
class UFortQueryTest_GoalActorDot final : public UFortQueryTest_GoalBase
{
public:
	TSubclassOf<class UEnvQueryContext>           LineATo;                                           // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           LineBTo;                                           // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFortTestGoalActorDot                         TestMode;                                          // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteValue;                                    // 0x0125(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_126[0x2];                                      // 0x0126(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalActorDot">();
	}
	static class UFortQueryTest_GoalActorDot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalActorDot>();
	}
};
static_assert(alignof(UFortQueryTest_GoalActorDot) == 0x000004, "Wrong alignment on UFortQueryTest_GoalActorDot");
static_assert(sizeof(UFortQueryTest_GoalActorDot) == 0x000128, "Wrong size on UFortQueryTest_GoalActorDot");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineATo) == 0x00011C, "Member 'UFortQueryTest_GoalActorDot::LineATo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, LineBTo) == 0x000120, "Member 'UFortQueryTest_GoalActorDot::LineBTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, TestMode) == 0x000124, "Member 'UFortQueryTest_GoalActorDot::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalActorDot, bAbsoluteValue) == 0x000125, "Member 'UFortQueryTest_GoalActorDot::bAbsoluteValue' has a wrong offset!");

// Class FortniteGame.FortPvPMission_CTF
// 0x0010 (0x03C0 - 0x03B0)
class AFortPvPMission_CTF final : public AFortPvPMission
{
public:
	TArray<int32>                                 TeamCaptureTotals;                                 // 0x03B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalCapturesToWin;                                // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPMission_CTF">();
	}
	static class AFortPvPMission_CTF* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPMission_CTF>();
	}
};
static_assert(alignof(AFortPvPMission_CTF) == 0x000004, "Wrong alignment on AFortPvPMission_CTF");
static_assert(sizeof(AFortPvPMission_CTF) == 0x0003C0, "Wrong size on AFortPvPMission_CTF");
static_assert(offsetof(AFortPvPMission_CTF, TeamCaptureTotals) == 0x0003B0, "Member 'AFortPvPMission_CTF::TeamCaptureTotals' has a wrong offset!");
static_assert(offsetof(AFortPvPMission_CTF, TotalCapturesToWin) == 0x0003BC, "Member 'AFortPvPMission_CTF::TotalCapturesToWin' has a wrong offset!");

// Class FortniteGame.FortQueryTest_CanHitWithGameplayAbility
// 0x0020 (0x012C - 0x010C)
class UFortQueryTest_CanHitWithGameplayAbility final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           AIsUsingAbility;                                   // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           AbilityTargets;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayAbilityTag;                                // 0x0114(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanHitWithGameplayAbility">();
	}
	static class UFortQueryTest_CanHitWithGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanHitWithGameplayAbility>();
	}
};
static_assert(alignof(UFortQueryTest_CanHitWithGameplayAbility) == 0x000004, "Wrong alignment on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(sizeof(UFortQueryTest_CanHitWithGameplayAbility) == 0x00012C, "Wrong size on UFortQueryTest_CanHitWithGameplayAbility");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AIsUsingAbility) == 0x00010C, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AIsUsingAbility' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, AbilityTargets) == 0x000110, "Member 'UFortQueryTest_CanHitWithGameplayAbility::AbilityTargets' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_CanHitWithGameplayAbility, GameplayAbilityTag) == 0x000114, "Member 'UFortQueryTest_CanHitWithGameplayAbility::GameplayAbilityTag' has a wrong offset!");

// Class FortniteGame.FortPvPObjective
// 0x0004 (0x0298 - 0x0294)
class AFortPvPObjective : public AFortObjectiveBase
{
public:
	EFortTeam                                     Team;                                              // 0x0294(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective">();
	}
	static class AFortPvPObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective>();
	}
};
static_assert(alignof(AFortPvPObjective) == 0x000004, "Wrong alignment on AFortPvPObjective");
static_assert(sizeof(AFortPvPObjective) == 0x000298, "Wrong size on AFortPvPObjective");
static_assert(offsetof(AFortPvPObjective, Team) == 0x000294, "Member 'AFortPvPObjective::Team' has a wrong offset!");

// Class FortniteGame.FortPvPObjective_3PtDomination
// 0x0000 (0x0298 - 0x0298)
class AFortPvPObjective_3PtDomination final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_3PtDomination">();
	}
	static class AFortPvPObjective_3PtDomination* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_3PtDomination>();
	}
};
static_assert(alignof(AFortPvPObjective_3PtDomination) == 0x000004, "Wrong alignment on AFortPvPObjective_3PtDomination");
static_assert(sizeof(AFortPvPObjective_3PtDomination) == 0x000298, "Wrong size on AFortPvPObjective_3PtDomination");

// Class FortniteGame.FortQueryTest_GoalFrustrationDiscouragement
// 0x0000 (0x011C - 0x011C)
class UFortQueryTest_GoalFrustrationDiscouragement final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalFrustrationDiscouragement">();
	}
	static class UFortQueryTest_GoalFrustrationDiscouragement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalFrustrationDiscouragement>();
	}
};
static_assert(alignof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x000004, "Wrong alignment on UFortQueryTest_GoalFrustrationDiscouragement");
static_assert(sizeof(UFortQueryTest_GoalFrustrationDiscouragement) == 0x00011C, "Wrong size on UFortQueryTest_GoalFrustrationDiscouragement");

// Class FortniteGame.FortPvPObjective_CTF
// 0x0000 (0x0298 - 0x0298)
class AFortPvPObjective_CTF final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_CTF">();
	}
	static class AFortPvPObjective_CTF* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_CTF>();
	}
};
static_assert(alignof(AFortPvPObjective_CTF) == 0x000004, "Wrong alignment on AFortPvPObjective_CTF");
static_assert(sizeof(AFortPvPObjective_CTF) == 0x000298, "Wrong size on AFortPvPObjective_CTF");

// Class FortniteGame.FortPvPObjective_EnemyBaseDestruction
// 0x0000 (0x0298 - 0x0298)
class AFortPvPObjective_EnemyBaseDestruction final : public AFortPvPObjective
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPObjective_EnemyBaseDestruction">();
	}
	static class AFortPvPObjective_EnemyBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPvPObjective_EnemyBaseDestruction>();
	}
};
static_assert(alignof(AFortPvPObjective_EnemyBaseDestruction) == 0x000004, "Wrong alignment on AFortPvPObjective_EnemyBaseDestruction");
static_assert(sizeof(AFortPvPObjective_EnemyBaseDestruction) == 0x000298, "Wrong size on AFortPvPObjective_EnemyBaseDestruction");

// Class FortniteGame.FortQueryTest_NavGraphDistance
// 0x0004 (0x0110 - 0x010C)
class UFortQueryTest_NavGraphDistance final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_NavGraphDistance">();
	}
	static class UFortQueryTest_NavGraphDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_NavGraphDistance>();
	}
};
static_assert(alignof(UFortQueryTest_NavGraphDistance) == 0x000004, "Wrong alignment on UFortQueryTest_NavGraphDistance");
static_assert(sizeof(UFortQueryTest_NavGraphDistance) == 0x000110, "Wrong size on UFortQueryTest_NavGraphDistance");
static_assert(offsetof(UFortQueryTest_NavGraphDistance, DistanceTo) == 0x00010C, "Member 'UFortQueryTest_NavGraphDistance::DistanceTo' has a wrong offset!");

// Class FortniteGame.FortMissionTimerComponent
// 0x0048 (0x00D4 - 0x008C)
class UFortMissionTimerComponent final : public UActorComponent
{
public:
	TArray<struct FMissionTimeDisplayData>        DisplayData;                                       // 0x008C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMissionTimerData                      TimerData;                                         // 0x0098(0x0024)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	class FText                                   TimerLabelText;                                    // 0x00BC(0x000C)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisplayInTimeFormat;                              // 0x00C8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETimerOverrideSetting                         TimerVisibilityOverrideSetting;                    // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA[0xA];                                       // 0x00CA(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMissionTimer();
	void DummyTimer();
	void OnRep_TimerData();
	void PauseMissionTimer();
	void ResetMissionTimer();
	void SetMissionTimer(const class FString& FunctionName, float TimerLength);
	void SetTimerDisplayFormat(bool bNewDisplayInTimeFormat);
	void SetTimerLabelText(const class FText& NewLabelText);
	void SetTimerVisibilityOverrideSetting(ETimerOverrideSetting NewVisibilitySetting);
	void UnpauseMissionTimer();

	float GetMissionTimerTimeRemaining() const;
	float GetNormalizedTime() const;
	bool IsMissionTimerPaused() const;
	bool IsMissionTimerSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMissionTimerComponent">();
	}
	static class UFortMissionTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMissionTimerComponent>();
	}
};
static_assert(alignof(UFortMissionTimerComponent) == 0x000004, "Wrong alignment on UFortMissionTimerComponent");
static_assert(sizeof(UFortMissionTimerComponent) == 0x0000D4, "Wrong size on UFortMissionTimerComponent");
static_assert(offsetof(UFortMissionTimerComponent, DisplayData) == 0x00008C, "Member 'UFortMissionTimerComponent::DisplayData' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerData) == 0x000098, "Member 'UFortMissionTimerComponent::TimerData' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerLabelText) == 0x0000BC, "Member 'UFortMissionTimerComponent::TimerLabelText' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, bDisplayInTimeFormat) == 0x0000C8, "Member 'UFortMissionTimerComponent::bDisplayInTimeFormat' has a wrong offset!");
static_assert(offsetof(UFortMissionTimerComponent, TimerVisibilityOverrideSetting) == 0x0000C9, "Member 'UFortMissionTimerComponent::TimerVisibilityOverrideSetting' has a wrong offset!");

// Class FortniteGame.FortMovementComp_Character
// 0x0000 (0x0580 - 0x0580)
class UFortMovementComp_Character final : public UCharacterMovementComponent
{
public:
	float                                         MaxFallSpeed;                                      // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AFortPawn>                  PushBumpedPawnClass;                               // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMovementComp_Character">();
	}
	static class UFortMovementComp_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMovementComp_Character>();
	}
};
static_assert(alignof(UFortMovementComp_Character) == 0x000010, "Wrong alignment on UFortMovementComp_Character");
static_assert(sizeof(UFortMovementComp_Character) == 0x000580, "Wrong size on UFortMovementComp_Character");
static_assert(offsetof(UFortMovementComp_Character, MaxFallSpeed) == 0x000574, "Member 'UFortMovementComp_Character::MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(UFortMovementComp_Character, PushBumpedPawnClass) == 0x000578, "Member 'UFortMovementComp_Character::PushBumpedPawnClass' has a wrong offset!");

// Class FortniteGame.FortQueryTest_IsCloseToPatrolWard
// 0x0004 (0x0110 - 0x010C)
class UFortQueryTest_IsCloseToPatrolWard final : public UEnvQueryTest
{
public:
	EWardAffectType                               WardEffectTypeFilter;                              // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_IsCloseToPatrolWard">();
	}
	static class UFortQueryTest_IsCloseToPatrolWard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_IsCloseToPatrolWard>();
	}
};
static_assert(alignof(UFortQueryTest_IsCloseToPatrolWard) == 0x000004, "Wrong alignment on UFortQueryTest_IsCloseToPatrolWard");
static_assert(sizeof(UFortQueryTest_IsCloseToPatrolWard) == 0x000110, "Wrong size on UFortQueryTest_IsCloseToPatrolWard");
static_assert(offsetof(UFortQueryTest_IsCloseToPatrolWard, WardEffectTypeFilter) == 0x00010C, "Member 'UFortQueryTest_IsCloseToPatrolWard::WardEffectTypeFilter' has a wrong offset!");

// Class FortniteGame.FortMusicManager
// 0x0024 (0x0264 - 0x0240)
class AFortMusicManager : public AActor
{
public:
	class AFortPlayerController*                  ControllerOwner;                                   // 0x0240(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        MusicChannels[0x3];                                // 0x0244(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x14];                                     // 0x0250(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMusic(class USoundBase* NewMusic, EMusicFadeStyles FadeStyle, float FadeTime, class USoundBase* Stinger);
	float GetEventHeatPercent(EFortCombatEvents CombatEvent);
	float GetEventHeatPercentTotal(EFortCombatEvents CombatEvent);
	void OnDayPhaseChanged(EFortDayPhase CurrentDayPhase, EFortDayPhase PreviousDayPhase, bool bAtCreation);
	void OnThresholdChange(EFortCombatThresholds OldThreshold, EFortCombatThresholds NewThreshold);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMusicManager">();
	}
	static class AFortMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortMusicManager>();
	}
};
static_assert(alignof(AFortMusicManager) == 0x000004, "Wrong alignment on AFortMusicManager");
static_assert(sizeof(AFortMusicManager) == 0x000264, "Wrong size on AFortMusicManager");
static_assert(offsetof(AFortMusicManager, ControllerOwner) == 0x000240, "Member 'AFortMusicManager::ControllerOwner' has a wrong offset!");
static_assert(offsetof(AFortMusicManager, MusicChannels) == 0x000244, "Member 'AFortMusicManager::MusicChannels' has a wrong offset!");

// Class FortniteGame.FortNavArea_StoneWall
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_StoneWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_StoneWall">();
	}
	static class UFortNavArea_StoneWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_StoneWall>();
	}
};
static_assert(alignof(UFortNavArea_StoneWall) == 0x000004, "Wrong alignment on UFortNavArea_StoneWall");
static_assert(sizeof(UFortNavArea_StoneWall) == 0x000038, "Wrong size on UFortNavArea_StoneWall");

// Class FortniteGame.FortNavAgentCostData
// 0x0014 (0x0030 - 0x001C)
class UFortNavAgentCostData final : public UDataAsset
{
public:
	class FName                                   NavAgentName;                                      // 0x001C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UNavArea>>           NavAreaStrengthBuckets;                            // 0x0024(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAgentCostData">();
	}
	static class UFortNavAgentCostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAgentCostData>();
	}
};
static_assert(alignof(UFortNavAgentCostData) == 0x000004, "Wrong alignment on UFortNavAgentCostData");
static_assert(sizeof(UFortNavAgentCostData) == 0x000030, "Wrong size on UFortNavAgentCostData");
static_assert(offsetof(UFortNavAgentCostData, NavAgentName) == 0x00001C, "Member 'UFortNavAgentCostData::NavAgentName' has a wrong offset!");
static_assert(offsetof(UFortNavAgentCostData, NavAreaStrengthBuckets) == 0x000024, "Member 'UFortNavAgentCostData::NavAreaStrengthBuckets' has a wrong offset!");

// Class FortniteGame.FortQueryTest_PerceptionExists
// 0x0008 (0x0114 - 0x010C)
class UFortQueryTest_PerceptionExists final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionExists">();
	}
	static class UFortQueryTest_PerceptionExists* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionExists>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionExists) == 0x000004, "Wrong alignment on UFortQueryTest_PerceptionExists");
static_assert(sizeof(UFortQueryTest_PerceptionExists) == 0x000114, "Wrong size on UFortQueryTest_PerceptionExists");
static_assert(offsetof(UFortQueryTest_PerceptionExists, Sense) == 0x00010C, "Member 'UFortQueryTest_PerceptionExists::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionExists, SenseClass) == 0x000110, "Member 'UFortQueryTest_PerceptionExists::SenseClass' has a wrong offset!");

// Class FortniteGame.FortNavArea_CheapObstacle
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_CheapObstacle final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_CheapObstacle">();
	}
	static class UFortNavArea_CheapObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_CheapObstacle>();
	}
};
static_assert(alignof(UFortNavArea_CheapObstacle) == 0x000004, "Wrong alignment on UFortNavArea_CheapObstacle");
static_assert(sizeof(UFortNavArea_CheapObstacle) == 0x000038, "Wrong size on UFortNavArea_CheapObstacle");

// Class FortniteGame.FortQueryTest_PrimaryAssignment
// 0x00CC (0x01E8 - 0x011C)
class UFortQueryTest_PrimaryAssignment final : public UFortQueryTest_GoalBase
{
public:
	bool                                          bUseItemActorLocation;                             // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              DistanceClose;                                     // 0x0120(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              DistanceFar;                                       // 0x013C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueClose;                                 // 0x0158(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueRegular;                               // 0x0174(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              PercentValueFar;                                   // 0x0190(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              DistanceVeryClose;                                 // 0x01AC(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              DistanceVeryFar;                                   // 0x01B8(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              PercentValueVeryClose;                             // 0x01C4(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              PercentValueReasonableDistance;                    // 0x01D0(0x000C)(NativeAccessSpecifierPrivate)
	struct FEnvFloatParam_DEPRECATED              PercentValueVeryFar;                               // 0x01DC(0x000C)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PrimaryAssignment">();
	}
	static class UFortQueryTest_PrimaryAssignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PrimaryAssignment>();
	}
};
static_assert(alignof(UFortQueryTest_PrimaryAssignment) == 0x000004, "Wrong alignment on UFortQueryTest_PrimaryAssignment");
static_assert(sizeof(UFortQueryTest_PrimaryAssignment) == 0x0001E8, "Wrong size on UFortQueryTest_PrimaryAssignment");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, bUseItemActorLocation) == 0x00011C, "Member 'UFortQueryTest_PrimaryAssignment::bUseItemActorLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceClose) == 0x000120, "Member 'UFortQueryTest_PrimaryAssignment::DistanceClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceFar) == 0x00013C, "Member 'UFortQueryTest_PrimaryAssignment::DistanceFar' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueClose) == 0x000158, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueRegular) == 0x000174, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueRegular' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueFar) == 0x000190, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueFar' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceVeryClose) == 0x0001AC, "Member 'UFortQueryTest_PrimaryAssignment::DistanceVeryClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, DistanceVeryFar) == 0x0001B8, "Member 'UFortQueryTest_PrimaryAssignment::DistanceVeryFar' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueVeryClose) == 0x0001C4, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueVeryClose' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueReasonableDistance) == 0x0001D0, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueReasonableDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PrimaryAssignment, PercentValueVeryFar) == 0x0001DC, "Member 'UFortQueryTest_PrimaryAssignment::PercentValueVeryFar' has a wrong offset!");

// Class FortniteGame.FortNavArea_DefaultSmashable
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_DefaultSmashable : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DefaultSmashable">();
	}
	static class UFortNavArea_DefaultSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DefaultSmashable>();
	}
};
static_assert(alignof(UFortNavArea_DefaultSmashable) == 0x000004, "Wrong alignment on UFortNavArea_DefaultSmashable");
static_assert(sizeof(UFortNavArea_DefaultSmashable) == 0x000038, "Wrong size on UFortNavArea_DefaultSmashable");

// Class FortniteGame.FortNavArea_TraceSmashable
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_TraceSmashable final : public UFortNavArea_DefaultSmashable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_TraceSmashable">();
	}
	static class UFortNavArea_TraceSmashable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_TraceSmashable>();
	}
};
static_assert(alignof(UFortNavArea_TraceSmashable) == 0x000004, "Wrong alignment on UFortNavArea_TraceSmashable");
static_assert(sizeof(UFortNavArea_TraceSmashable) == 0x000038, "Wrong size on UFortNavArea_TraceSmashable");

// Class FortniteGame.FortNavArea_DiagLink
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_DiagLink final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_DiagLink">();
	}
	static class UFortNavArea_DiagLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_DiagLink>();
	}
};
static_assert(alignof(UFortNavArea_DiagLink) == 0x000004, "Wrong alignment on UFortNavArea_DiagLink");
static_assert(sizeof(UFortNavArea_DiagLink) == 0x000038, "Wrong size on UFortNavArea_DiagLink");

// Class FortniteGame.FortNavArea_HuskNull
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_HuskNull final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_HuskNull">();
	}
	static class UFortNavArea_HuskNull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_HuskNull>();
	}
};
static_assert(alignof(UFortNavArea_HuskNull) == 0x000004, "Wrong alignment on UFortNavArea_HuskNull");
static_assert(sizeof(UFortNavArea_HuskNull) == 0x000038, "Wrong size on UFortNavArea_HuskNull");

// Class FortniteGame.FortNavArea_Obstacle
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_Obstacle final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Obstacle">();
	}
	static class UFortNavArea_Obstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Obstacle>();
	}
};
static_assert(alignof(UFortNavArea_Obstacle) == 0x000004, "Wrong alignment on UFortNavArea_Obstacle");
static_assert(sizeof(UFortNavArea_Obstacle) == 0x000038, "Wrong size on UFortNavArea_Obstacle");

// Class FortniteGame.FortNavArea_PortalOrSmash
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_PortalOrSmash final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_PortalOrSmash">();
	}
	static class UFortNavArea_PortalOrSmash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_PortalOrSmash>();
	}
};
static_assert(alignof(UFortNavArea_PortalOrSmash) == 0x000004, "Wrong alignment on UFortNavArea_PortalOrSmash");
static_assert(sizeof(UFortNavArea_PortalOrSmash) == 0x000038, "Wrong size on UFortNavArea_PortalOrSmash");

// Class FortniteGame.FortNavArea_Unwalkable
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_Unwalkable final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_Unwalkable">();
	}
	static class UFortNavArea_Unwalkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_Unwalkable>();
	}
};
static_assert(alignof(UFortNavArea_Unwalkable) == 0x000004, "Wrong alignment on UFortNavArea_Unwalkable");
static_assert(sizeof(UFortNavArea_Unwalkable) == 0x000038, "Wrong size on UFortNavArea_Unwalkable");

// Class FortniteGame.FortNavArea_WallCorner
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_WallCorner final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WallCorner">();
	}
	static class UFortNavArea_WallCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WallCorner>();
	}
};
static_assert(alignof(UFortNavArea_WallCorner) == 0x000004, "Wrong alignment on UFortNavArea_WallCorner");
static_assert(sizeof(UFortNavArea_WallCorner) == 0x000038, "Wrong size on UFortNavArea_WallCorner");

// Class FortniteGame.FortNavArea_WoodenWall
// 0x0000 (0x0038 - 0x0038)
class UFortNavArea_WoodenWall final : public UFortNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavArea_WoodenWall">();
	}
	static class UFortNavArea_WoodenWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavArea_WoodenWall>();
	}
};
static_assert(alignof(UFortNavArea_WoodenWall) == 0x000004, "Wrong alignment on UFortNavArea_WoodenWall");
static_assert(sizeof(UFortNavArea_WoodenWall) == 0x000038, "Wrong size on UFortNavArea_WoodenWall");

// Class FortniteGame.FortNavAreaAutomatic
// 0x001C (0x0054 - 0x0038)
class UFortNavAreaAutomatic : public UFortNavArea
{
public:
	int32                                         NumberOfAttacks;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    PawnStatHandle;                                    // 0x003C(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EFortMovementStyle                            MovementStyle;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeTimeModifier;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutomaticNavCost;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavAreaAutomatic">();
	}
	static class UFortNavAreaAutomatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavAreaAutomatic>();
	}
};
static_assert(alignof(UFortNavAreaAutomatic) == 0x000004, "Wrong alignment on UFortNavAreaAutomatic");
static_assert(sizeof(UFortNavAreaAutomatic) == 0x000054, "Wrong size on UFortNavAreaAutomatic");
static_assert(offsetof(UFortNavAreaAutomatic, NumberOfAttacks) == 0x000038, "Member 'UFortNavAreaAutomatic::NumberOfAttacks' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, PawnStatHandle) == 0x00003C, "Member 'UFortNavAreaAutomatic::PawnStatHandle' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, MovementStyle) == 0x000048, "Member 'UFortNavAreaAutomatic::MovementStyle' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, MeleeTimeModifier) == 0x00004C, "Member 'UFortNavAreaAutomatic::MeleeTimeModifier' has a wrong offset!");
static_assert(offsetof(UFortNavAreaAutomatic, AutomaticNavCost) == 0x000050, "Member 'UFortNavAreaAutomatic::AutomaticNavCost' has a wrong offset!");

// Class FortniteGame.FortNavGraph
// 0x0444 (0x0460 - 0x001C)
class UFortNavGraph final : public UObject
{
public:
	class UBuildingStructuralSupportSystem*       BuildingSys;                                       // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFortStaticMeshLinkComponent*>   NavLinks;                                          // 0x0020(0x000C)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x434];                                     // 0x002C(0x0434)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavGraph">();
	}
	static class UFortNavGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavGraph>();
	}
};
static_assert(alignof(UFortNavGraph) == 0x000004, "Wrong alignment on UFortNavGraph");
static_assert(sizeof(UFortNavGraph) == 0x000460, "Wrong size on UFortNavGraph");
static_assert(offsetof(UFortNavGraph, BuildingSys) == 0x00001C, "Member 'UFortNavGraph::BuildingSys' has a wrong offset!");
static_assert(offsetof(UFortNavGraph, NavLinks) == 0x000020, "Member 'UFortNavGraph::NavLinks' has a wrong offset!");

// Class FortniteGame.FortNavGraphGoal
// 0x0008 (0x0248 - 0x0240)
class AFortNavGraphGoal final : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GraphRadius;                                       // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavGraphGoal">();
	}
	static class AFortNavGraphGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavGraphGoal>();
	}
};
static_assert(alignof(AFortNavGraphGoal) == 0x000004, "Wrong alignment on AFortNavGraphGoal");
static_assert(sizeof(AFortNavGraphGoal) == 0x000248, "Wrong size on AFortNavGraphGoal");
static_assert(offsetof(AFortNavGraphGoal, GraphRadius) == 0x000244, "Member 'AFortNavGraphGoal::GraphRadius' has a wrong offset!");

// Class FortniteGame.FortNavigationFilter_NoSmashing
// 0x0000 (0x0030 - 0x0030)
class UFortNavigationFilter_NoSmashing final : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_NoSmashing">();
	}
	static class UFortNavigationFilter_NoSmashing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_NoSmashing>();
	}
};
static_assert(alignof(UFortNavigationFilter_NoSmashing) == 0x000004, "Wrong alignment on UFortNavigationFilter_NoSmashing");
static_assert(sizeof(UFortNavigationFilter_NoSmashing) == 0x000030, "Wrong size on UFortNavigationFilter_NoSmashing");

// Class FortniteGame.FortNavigationMetaFilter
// 0x0000 (0x0030 - 0x0030)
class UFortNavigationMetaFilter : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationMetaFilter">();
	}
	static class UFortNavigationMetaFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationMetaFilter>();
	}
};
static_assert(alignof(UFortNavigationMetaFilter) == 0x000004, "Wrong alignment on UFortNavigationMetaFilter");
static_assert(sizeof(UFortNavigationMetaFilter) == 0x000030, "Wrong size on UFortNavigationMetaFilter");

// Class FortniteGame.FortNavigationFilter_Hunting
// 0x0000 (0x0030 - 0x0030)
class UFortNavigationFilter_Hunting final : public UFortNavigationMetaFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavigationFilter_Hunting">();
	}
	static class UFortNavigationFilter_Hunting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavigationFilter_Hunting>();
	}
};
static_assert(alignof(UFortNavigationFilter_Hunting) == 0x000004, "Wrong alignment on UFortNavigationFilter_Hunting");
static_assert(sizeof(UFortNavigationFilter_Hunting) == 0x000030, "Wrong size on UFortNavigationFilter_Hunting");

// Class FortniteGame.FortNavLinkContainer
// 0x0000 (0x0240 - 0x0240)
class AFortNavLinkContainer final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkContainer">();
	}
	static class AFortNavLinkContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavLinkContainer>();
	}
};
static_assert(alignof(AFortNavLinkContainer) == 0x000004, "Wrong alignment on AFortNavLinkContainer");
static_assert(sizeof(AFortNavLinkContainer) == 0x000240, "Wrong size on AFortNavLinkContainer");

// Class FortniteGame.FortNavLinkDefinition
// 0x0024 (0x005C - 0x0038)
class UFortNavLinkDefinition final : public UNavLinkDefinition
{
public:
	struct FFortNavLinkPattern                    Pattern;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FFortNavLinkPattern>            AdditionalPatterns;                                // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EBuildingStairsRailing>                StairsRailing;                                     // 0x004C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBuildingFloorRailing                         FloorRailing;                                      // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortNavLinkPattern                           PatternType;                                       // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavLinkDefinition">();
	}
	static class UFortNavLinkDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavLinkDefinition>();
	}
};
static_assert(alignof(UFortNavLinkDefinition) == 0x000004, "Wrong alignment on UFortNavLinkDefinition");
static_assert(sizeof(UFortNavLinkDefinition) == 0x00005C, "Wrong size on UFortNavLinkDefinition");
static_assert(offsetof(UFortNavLinkDefinition, Pattern) == 0x000038, "Member 'UFortNavLinkDefinition::Pattern' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, AdditionalPatterns) == 0x000040, "Member 'UFortNavLinkDefinition::AdditionalPatterns' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, StairsRailing) == 0x00004C, "Member 'UFortNavLinkDefinition::StairsRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, FloorRailing) == 0x000058, "Member 'UFortNavLinkDefinition::FloorRailing' has a wrong offset!");
static_assert(offsetof(UFortNavLinkDefinition, PatternType) == 0x000059, "Member 'UFortNavLinkDefinition::PatternType' has a wrong offset!");

// Class FortniteGame.FortNavMesh
// 0x0004 (0x0410 - 0x040C)
class AFortNavMesh final : public ARecastNavMesh
{
public:
	int32                                         NavDataVersion;                                    // 0x040C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavMesh">();
	}
	static class AFortNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortNavMesh>();
	}
};
static_assert(alignof(AFortNavMesh) == 0x000004, "Wrong alignment on AFortNavMesh");
static_assert(sizeof(AFortNavMesh) == 0x000410, "Wrong size on AFortNavMesh");
static_assert(offsetof(AFortNavMesh, NavDataVersion) == 0x00040C, "Member 'AFortNavMesh::NavDataVersion' has a wrong offset!");

// Class FortniteGame.FortNavObstacleComponent
// 0x0004 (0x00B8 - 0x00B4)
class UFortNavObstacleComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   ObstacleAreaClass;                                 // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavObstacleComponent">();
	}
	static class UFortNavObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavObstacleComponent>();
	}
};
static_assert(alignof(UFortNavObstacleComponent) == 0x000004, "Wrong alignment on UFortNavObstacleComponent");
static_assert(sizeof(UFortNavObstacleComponent) == 0x0000B8, "Wrong size on UFortNavObstacleComponent");
static_assert(offsetof(UFortNavObstacleComponent, ObstacleAreaClass) == 0x0000B4, "Member 'UFortNavObstacleComponent::ObstacleAreaClass' has a wrong offset!");

// Class FortniteGame.FortNavSystem
// 0x0128 (0x0430 - 0x0308)
class UFortNavSystem final : public UNavigationSystem
{
public:
	TArray<class ABuildingSMActor*>               BuildingActorsReady;                               // 0x0308(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DefaultSmashableArea;                              // 0x0314(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownArea;                                      // 0x032C(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea;                             // 0x0344(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea2;                            // 0x035C(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JumpDownSmashableArea3;                            // 0x0374(0x0018)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARecastNavMesh*>                 NamedNavmeshes;                                    // 0x038C(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bUseStaticMeshLinks : 1;                           // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksDown : 1;                      // 0x0398(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseStaticWorldLinksUp : 1;                        // 0x0398(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseJumpLinkActors : 1;                            // 0x0398(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Config, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirtyAreasUpdateFreqInactive;                      // 0x039C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x90];                                     // 0x03A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavDataRegistered(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNavSystem">();
	}
	static class UFortNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNavSystem>();
	}
};
static_assert(alignof(UFortNavSystem) == 0x000004, "Wrong alignment on UFortNavSystem");
static_assert(sizeof(UFortNavSystem) == 0x000430, "Wrong size on UFortNavSystem");
static_assert(offsetof(UFortNavSystem, BuildingActorsReady) == 0x000308, "Member 'UFortNavSystem::BuildingActorsReady' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, DefaultSmashableArea) == 0x000314, "Member 'UFortNavSystem::DefaultSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownArea) == 0x00032C, "Member 'UFortNavSystem::JumpDownArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea) == 0x000344, "Member 'UFortNavSystem::JumpDownSmashableArea' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea2) == 0x00035C, "Member 'UFortNavSystem::JumpDownSmashableArea2' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, JumpDownSmashableArea3) == 0x000374, "Member 'UFortNavSystem::JumpDownSmashableArea3' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, NamedNavmeshes) == 0x00038C, "Member 'UFortNavSystem::NamedNavmeshes' has a wrong offset!");
static_assert(offsetof(UFortNavSystem, DirtyAreasUpdateFreqInactive) == 0x00039C, "Member 'UFortNavSystem::DirtyAreasUpdateFreqInactive' has a wrong offset!");

// Class FortniteGame.FortNotificationMessage
// 0x0000 (0x001C - 0x001C)
class UFortNotificationMessage final : public ULocalMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationMessage">();
	}
	static class UFortNotificationMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNotificationMessage>();
	}
};
static_assert(alignof(UFortNotificationMessage) == 0x000004, "Wrong alignment on UFortNotificationMessage");
static_assert(sizeof(UFortNotificationMessage) == 0x00001C, "Wrong size on UFortNotificationMessage");

// Class FortniteGame.FortTrackMovementComponent
// 0x007C (0x0148 - 0x00CC)
class UFortTrackMovementComponent final : public UMovementComponent
{
public:
	struct FVector                                TrackSnapExtent;                                   // 0x00CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TurnSpeed;                                         // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SplineLocationOffsetZ;                             // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverSplineFrequency;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackVelocity;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseYawWhenReversedOnSpline;                   // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnOutOfTrack;                                      // 0x00F4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLostTrack;                                       // 0x0100(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTrackMovement                         TrackMovement;                                     // 0x010C(0x000C)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRepTrackMovement                      ReplicatedTrackMovement;                           // 0x0118(0x0010)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClientPredictionSpeedModifier;                     // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0xC];                                      // 0x013C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlipDirection();
	void OnRep_ReplicatedTrackMovement();

	float GetDistanceAlongSpline() const;
	class USplineComponent* GetSpline() const;
	class AFortTrack* GetTrack() const;
	bool IsReverseDirection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrackMovementComponent">();
	}
	static class UFortTrackMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTrackMovementComponent>();
	}
};
static_assert(alignof(UFortTrackMovementComponent) == 0x000004, "Wrong alignment on UFortTrackMovementComponent");
static_assert(sizeof(UFortTrackMovementComponent) == 0x000148, "Wrong size on UFortTrackMovementComponent");
static_assert(offsetof(UFortTrackMovementComponent, TrackSnapExtent) == 0x0000CC, "Member 'UFortTrackMovementComponent::TrackSnapExtent' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TurnSpeed) == 0x0000D8, "Member 'UFortTrackMovementComponent::TurnSpeed' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, SplineLocationOffsetZ) == 0x0000E4, "Member 'UFortTrackMovementComponent::SplineLocationOffsetZ' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, DiscoverSplineFrequency) == 0x0000E8, "Member 'UFortTrackMovementComponent::DiscoverSplineFrequency' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TrackVelocity) == 0x0000EC, "Member 'UFortTrackMovementComponent::TrackVelocity' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, bReverseYawWhenReversedOnSpline) == 0x0000F0, "Member 'UFortTrackMovementComponent::bReverseYawWhenReversedOnSpline' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, OnOutOfTrack) == 0x0000F4, "Member 'UFortTrackMovementComponent::OnOutOfTrack' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, OnLostTrack) == 0x000100, "Member 'UFortTrackMovementComponent::OnLostTrack' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, TrackMovement) == 0x00010C, "Member 'UFortTrackMovementComponent::TrackMovement' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, ReplicatedTrackMovement) == 0x000118, "Member 'UFortTrackMovementComponent::ReplicatedTrackMovement' has a wrong offset!");
static_assert(offsetof(UFortTrackMovementComponent, ClientPredictionSpeedModifier) == 0x000138, "Member 'UFortTrackMovementComponent::ClientPredictionSpeedModifier' has a wrong offset!");

// Class FortniteGame.FortNotificationQueue
// 0x001C (0x0038 - 0x001C)
class UFortNotificationQueue final : public UObject
{
public:
	uint8                                         Pad_1C[0x1C];                                      // 0x001C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortNotificationQueue">();
	}
	static class UFortNotificationQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortNotificationQueue>();
	}
};
static_assert(alignof(UFortNotificationQueue) == 0x000004, "Wrong alignment on UFortNotificationQueue");
static_assert(sizeof(UFortNotificationQueue) == 0x000038, "Wrong size on UFortNotificationQueue");

// Class FortniteGame.FortAbilityKitTooltip
// 0x0000 (0x0028 - 0x0028)
class UFortAbilityKitTooltip final : public UFortTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityKitTooltip">();
	}
	static class UFortAbilityKitTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAbilityKitTooltip>();
	}
};
static_assert(alignof(UFortAbilityKitTooltip) == 0x000004, "Wrong alignment on UFortAbilityKitTooltip");
static_assert(sizeof(UFortAbilityKitTooltip) == 0x000028, "Wrong size on UFortAbilityKitTooltip");

// Class FortniteGame.FortOnlineAccount
// 0x017C (0x0198 - 0x001C)
class UFortOnlineAccount final : public UObject
{
public:
	uint8                                         Pad_1C[0x17C];                                     // 0x001C(0x017C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOnlineAccount">();
	}
	static class UFortOnlineAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOnlineAccount>();
	}
};
static_assert(alignof(UFortOnlineAccount) == 0x000004, "Wrong alignment on UFortOnlineAccount");
static_assert(sizeof(UFortOnlineAccount) == 0x000198, "Wrong size on UFortOnlineAccount");

// Class FortniteGame.FortWeap_BuildingTool
// 0x00B4 (0x06C0 - 0x060C)
class AFortWeap_BuildingTool : public AFortWeap_BuildingToolBase
{
public:
	class UMaterialInterface*                     BlueprintPaperMaterial;                            // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BlueprintDiffuseTextures[0x4];                     // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BlueprintEmissiveMaskTextures[0x4];                // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BlueprintPaperPulseCurve;                          // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuildingEditModeMetadata*              DefaultMetadata;                                   // 0x0634(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BlueprintPaperMID;                                 // 0x0638(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              BlueprintPaperPulseTimeline;                       // 0x063C(0x0080)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EFortResourceType                             LastResourceType;                                  // 0x06BC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BD[0x3];                                      // 0x06BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlueprintPaperPulseUpdate(float InCurveVal);
	void OnRep_DefaultMetadata();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_BuildingTool">();
	}
	static class AFortWeap_BuildingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_BuildingTool>();
	}
};
static_assert(alignof(AFortWeap_BuildingTool) == 0x000004, "Wrong alignment on AFortWeap_BuildingTool");
static_assert(sizeof(AFortWeap_BuildingTool) == 0x0006C0, "Wrong size on AFortWeap_BuildingTool");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperMaterial) == 0x00060C, "Member 'AFortWeap_BuildingTool::BlueprintPaperMaterial' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintDiffuseTextures) == 0x000610, "Member 'AFortWeap_BuildingTool::BlueprintDiffuseTextures' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintEmissiveMaskTextures) == 0x000620, "Member 'AFortWeap_BuildingTool::BlueprintEmissiveMaskTextures' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperPulseCurve) == 0x000630, "Member 'AFortWeap_BuildingTool::BlueprintPaperPulseCurve' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, DefaultMetadata) == 0x000634, "Member 'AFortWeap_BuildingTool::DefaultMetadata' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperMID) == 0x000638, "Member 'AFortWeap_BuildingTool::BlueprintPaperMID' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, BlueprintPaperPulseTimeline) == 0x00063C, "Member 'AFortWeap_BuildingTool::BlueprintPaperPulseTimeline' has a wrong offset!");
static_assert(offsetof(AFortWeap_BuildingTool, LastResourceType) == 0x0006BC, "Member 'AFortWeap_BuildingTool::LastResourceType' has a wrong offset!");

// Class FortniteGame.OutpostPOSTRequirementData
// 0x0018 (0x0034 - 0x001C)
class UOutpostPOSTRequirementData final : public UObject
{
public:
	class UFortItemDefinition*                    RequirementItemDefinition;                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalRequired;                                     // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlreadyDeposited;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountOwned;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEnough;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountToDeposit;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutpostPOSTRequirementData">();
	}
	static class UOutpostPOSTRequirementData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutpostPOSTRequirementData>();
	}
};
static_assert(alignof(UOutpostPOSTRequirementData) == 0x000004, "Wrong alignment on UOutpostPOSTRequirementData");
static_assert(sizeof(UOutpostPOSTRequirementData) == 0x000034, "Wrong size on UOutpostPOSTRequirementData");
static_assert(offsetof(UOutpostPOSTRequirementData, RequirementItemDefinition) == 0x00001C, "Member 'UOutpostPOSTRequirementData::RequirementItemDefinition' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, TotalRequired) == 0x000020, "Member 'UOutpostPOSTRequirementData::TotalRequired' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AlreadyDeposited) == 0x000024, "Member 'UOutpostPOSTRequirementData::AlreadyDeposited' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AmountOwned) == 0x000028, "Member 'UOutpostPOSTRequirementData::AmountOwned' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, bHasEnough) == 0x00002C, "Member 'UOutpostPOSTRequirementData::bHasEnough' has a wrong offset!");
static_assert(offsetof(UOutpostPOSTRequirementData, AmountToDeposit) == 0x000030, "Member 'UOutpostPOSTRequirementData::AmountToDeposit' has a wrong offset!");

// Class FortniteGame.FortOutpostData
// 0x0110 (0x012C - 0x001C)
class UFortOutpostData final : public UDataAsset
{
public:
	class UDataTable*                             OutpostUpgradesData;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOutpostUpgradesPerTheaterData> PerTheaterOutpostUpgradesData;                     // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             OutpostFabricatorData;                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOutpostFabricatorPerTheaterData> PerTheaterFabricatorData;                          // 0x0030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             OutpostCraftingTableData;                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPrestigeLevel;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisintegrationToFabricationRatio;                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantumGooProductionTime;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StructureLimitNotificationThreshold;               // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFortOutpostItemDefinition> StormShield;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortOutpostItemDefinition> CraftingTable;                                     // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortOutpostItemDefinition> Fabricator;                                        // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortOutpostItemDefinition> HarvestingOptimizer;                               // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortOutpostItemDefinition> StorageVault;                                      // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortOutpostItemDefinition> POST;                                              // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FabricatorCapacityPerLevel;                        // 0x00E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 StorageVaultCapacityPerLevel;                      // 0x00EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FOutpostPOSTBoost                      DefaultPOSTData;                                   // 0x00F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOutpostPOSTPerTheaterData>     POSTDataPerTheater;                                // 0x0104(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            POSTBuildingGameplayEffectClass;                   // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FOutpostPrestigeEffects                DefaultPrestigeData;                               // 0x0114(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FOutpostPrestigeEffectsPerTheater> PrestigeDataPerTheater;                            // 0x0120(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostData">();
	}
	static class UFortOutpostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostData>();
	}
};
static_assert(alignof(UFortOutpostData) == 0x000004, "Wrong alignment on UFortOutpostData");
static_assert(sizeof(UFortOutpostData) == 0x00012C, "Wrong size on UFortOutpostData");
static_assert(offsetof(UFortOutpostData, OutpostUpgradesData) == 0x00001C, "Member 'UFortOutpostData::OutpostUpgradesData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, PerTheaterOutpostUpgradesData) == 0x000020, "Member 'UFortOutpostData::PerTheaterOutpostUpgradesData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, OutpostFabricatorData) == 0x00002C, "Member 'UFortOutpostData::OutpostFabricatorData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, PerTheaterFabricatorData) == 0x000030, "Member 'UFortOutpostData::PerTheaterFabricatorData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, OutpostCraftingTableData) == 0x00003C, "Member 'UFortOutpostData::OutpostCraftingTableData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, MaxPrestigeLevel) == 0x000040, "Member 'UFortOutpostData::MaxPrestigeLevel' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, DisintegrationToFabricationRatio) == 0x000044, "Member 'UFortOutpostData::DisintegrationToFabricationRatio' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, QuantumGooProductionTime) == 0x000048, "Member 'UFortOutpostData::QuantumGooProductionTime' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StructureLimitNotificationThreshold) == 0x00004C, "Member 'UFortOutpostData::StructureLimitNotificationThreshold' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StormShield) == 0x000050, "Member 'UFortOutpostData::StormShield' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, CraftingTable) == 0x000068, "Member 'UFortOutpostData::CraftingTable' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, Fabricator) == 0x000080, "Member 'UFortOutpostData::Fabricator' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, HarvestingOptimizer) == 0x000098, "Member 'UFortOutpostData::HarvestingOptimizer' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StorageVault) == 0x0000B0, "Member 'UFortOutpostData::StorageVault' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, POST) == 0x0000C8, "Member 'UFortOutpostData::POST' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, FabricatorCapacityPerLevel) == 0x0000E0, "Member 'UFortOutpostData::FabricatorCapacityPerLevel' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, StorageVaultCapacityPerLevel) == 0x0000EC, "Member 'UFortOutpostData::StorageVaultCapacityPerLevel' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, DefaultPOSTData) == 0x0000F8, "Member 'UFortOutpostData::DefaultPOSTData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, POSTDataPerTheater) == 0x000104, "Member 'UFortOutpostData::POSTDataPerTheater' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, POSTBuildingGameplayEffectClass) == 0x000110, "Member 'UFortOutpostData::POSTBuildingGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, DefaultPrestigeData) == 0x000114, "Member 'UFortOutpostData::DefaultPrestigeData' has a wrong offset!");
static_assert(offsetof(UFortOutpostData, PrestigeDataPerTheater) == 0x000120, "Member 'UFortOutpostData::PrestigeDataPerTheater' has a wrong offset!");

// Class FortniteGame.FortOutpostFunctionLibrary
// 0x0000 (0x001C - 0x001C)
class UFortOutpostFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TSubclassOf<class UGameplayEffect> GetEnemyGameplayEffectDictatedByPrestige(class UObject* WorldContextObject);
	static class AFortPlayerControllerOutpost* GetOutpostOwner(class UObject* WorldContextObject);
	static class UFortMissionConfigData* GetOutpostQuestMissionConfigData(class UObject* WorldContextObject, const struct FGameplayTag& ConfigTag);
	static void SetOutpostDefenseActive(class UObject* WorldContextObject, bool bActive);
	static void SetOutpostGameDifficultyRow(class UObject* WorldContextObject, const struct FDataTableRowHandle& GameDifficultyInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortOutpostFunctionLibrary">();
	}
	static class UFortOutpostFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortOutpostFunctionLibrary>();
	}
};
static_assert(alignof(UFortOutpostFunctionLibrary) == 0x000004, "Wrong alignment on UFortOutpostFunctionLibrary");
static_assert(sizeof(UFortOutpostFunctionLibrary) == 0x00001C, "Wrong size on UFortOutpostFunctionLibrary");

// Class FortniteGame.FortParty
// 0x0004 (0x01D8 - 0x01D4)
class UFortParty final : public UParty
{
public:
	bool                                          bTutorialCompleted;                                // 0x01D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortParty">();
	}
	static class UFortParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortParty>();
	}
};
static_assert(alignof(UFortParty) == 0x000004, "Wrong alignment on UFortParty");
static_assert(sizeof(UFortParty) == 0x0001D8, "Wrong size on UFortParty");
static_assert(offsetof(UFortParty, bTutorialCompleted) == 0x0001D4, "Member 'UFortParty::bTutorialCompleted' has a wrong offset!");

// Class FortniteGame.FortPartyBeaconHost
// 0x0014 (0x02A8 - 0x0294)
class AFortPartyBeaconHost final : public APartyBeaconHost
{
public:
	uint8                                         Pad_294[0x14];                                     // 0x0294(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPartyBeaconHost">();
	}
	static class AFortPartyBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPartyBeaconHost>();
	}
};
static_assert(alignof(AFortPartyBeaconHost) == 0x000004, "Wrong alignment on AFortPartyBeaconHost");
static_assert(sizeof(AFortPartyBeaconHost) == 0x0002A8, "Wrong size on AFortPartyBeaconHost");

// Class FortniteGame.FortAbilityDecoTool
// 0x0020 (0x0640 - 0x0620)
class AFortAbilityDecoTool : public AFortDecoTool
{
public:
	struct FAbilityToolSpawnParameters            CachedSpawnParameters;                             // 0x0620(0x0020)(Transient, NativeAccessSpecifierPrivate)

public:
	class ABuildingActor* AbilitySpawnDeco(const struct FAbilityToolSpawnParameters& SpawnParameters);
	struct FGameplayAbilitySpecHandle GetPlacementAbilityHandle();
	class UFortGameplayAbility* GetPlacementAbilityInstance();

	void GetSpawnParameters(struct FAbilityToolSpawnParameters* OutSpawnParamters) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAbilityDecoTool">();
	}
	static class AFortAbilityDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAbilityDecoTool>();
	}
};
static_assert(alignof(AFortAbilityDecoTool) == 0x000004, "Wrong alignment on AFortAbilityDecoTool");
static_assert(sizeof(AFortAbilityDecoTool) == 0x000640, "Wrong size on AFortAbilityDecoTool");
static_assert(offsetof(AFortAbilityDecoTool, CachedSpawnParameters) == 0x000620, "Member 'AFortAbilityDecoTool::CachedSpawnParameters' has a wrong offset!");

// Class FortniteGame.FortPawn_Flinger
// 0x0000 (0x0E50 - 0x0E50)
class AFortPawn_Flinger : public AFortAIPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_Flinger">();
	}
	static class AFortPawn_Flinger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_Flinger>();
	}
};
static_assert(alignof(AFortPawn_Flinger) == 0x000010, "Wrong alignment on AFortPawn_Flinger");
static_assert(sizeof(AFortPawn_Flinger) == 0x000E50, "Wrong size on AFortPawn_Flinger");

// Class FortniteGame.FortPawn_InteractablePawn
// 0x0020 (0x0E70 - 0x0E50)
class AFortPawn_InteractablePawn final : public AFortAIPawn
{
public:
	uint8                                         Pad_E50[0x4];                                      // 0x0E50(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MyGuid;                                            // 0x0E54(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E64[0xC];                                      // 0x0E64(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnBeginInteract();
	void BlueprintOnInteract(const class AFortPawn* InteractingPawn);

	bool BlueprintCanInteract(const class AFortPawn* InteractingPawn) const;
	class FText BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_InteractablePawn">();
	}
	static class AFortPawn_InteractablePawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_InteractablePawn>();
	}
};
static_assert(alignof(AFortPawn_InteractablePawn) == 0x000010, "Wrong alignment on AFortPawn_InteractablePawn");
static_assert(sizeof(AFortPawn_InteractablePawn) == 0x000E70, "Wrong size on AFortPawn_InteractablePawn");
static_assert(offsetof(AFortPawn_InteractablePawn, MyGuid) == 0x000E54, "Member 'AFortPawn_InteractablePawn::MyGuid' has a wrong offset!");

// Class FortniteGame.FortWorldManager
// 0x02DC (0x051C - 0x0240)
class AFortWorldManager final : public AInfo
{
public:
	TArray<struct FFortLevelStreamingInfo>        StreamedLevels;                                    // 0x0240(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bSaveToCloud : 1;                                  // 0x024C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bStreamInBuildings : 1;                            // 0x024C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bConstructTileWorld : 1;                           // 0x024C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bUseSimMaps : 1;                                   // 0x024C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EditorOnlyWorldLevelOverride;                      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TheaterSlotOverride;                               // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataTableRowHandle                    GameDifficultyRowPIEOverride;                      // 0x0258(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LootLevelOverrideForPIE;                           // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortWorldManagerState                        WorldManagerState;                                 // 0x0268(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldTileManager*                      TileManager;                                       // 0x026C(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         X_Size;                                            // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y_Size;                                            // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z_StructuralGrid_Size;                             // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileEdgeSize;                                      // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldTheme*                            Theme;                                             // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultLootQuotaCategory;                          // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortTileLootData                      LootData;                                          // 0x028C(0x00E0)(NativeAccessSpecifierPublic)
	int32                                         MaxTiles;                                          // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedSeed;                                     // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FixedSeed;                                         // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWorldTileSubArray>             Y;                                                 // 0x0378(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ExplorationActorClass;                             // 0x0384(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumExplorationActors;                              // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorationActorDistanceRangeMin;                  // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplorationActorDistanceRangeMax;                  // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExplorationActorRequiredTags;                      // 0x03A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                FriendlyPlayerSpawnExtent;                         // 0x03C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PadPlayerSpawnExtent;                              // 0x03CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DangerPlayerSpawnExclusionRadius;                  // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectivePlayerSpawnExclusionRadius;               // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OverrideInitialPlayerSpawnTags;                    // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OverrideBackupPlayerSpawnTags;                     // 0x03F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFortStartingMissionInfo               StartingMissionInfo;                               // 0x0410(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UFortWorldRecord*                       CurrentWorldRecord;                                // 0x041C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortZoneRecord*                        CurrentZoneRecord;                                 // 0x0420(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x1C];                                     // 0x0424(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentZoneIndex;                                  // 0x0440(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZoneCompleted;                                    // 0x0444(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortDeferredNewActorData>      DeferredActors;                                    // 0x0448(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_454[0xBC];                                     // 0x0454(0x00BC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpawnedExplorationActors;                          // 0x0510(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldManager">();
	}
	static class AFortWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWorldManager>();
	}
};
static_assert(alignof(AFortWorldManager) == 0x000004, "Wrong alignment on AFortWorldManager");
static_assert(sizeof(AFortWorldManager) == 0x00051C, "Wrong size on AFortWorldManager");
static_assert(offsetof(AFortWorldManager, StreamedLevels) == 0x000240, "Member 'AFortWorldManager::StreamedLevels' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, EditorOnlyWorldLevelOverride) == 0x000250, "Member 'AFortWorldManager::EditorOnlyWorldLevelOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, TheaterSlotOverride) == 0x000254, "Member 'AFortWorldManager::TheaterSlotOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, GameDifficultyRowPIEOverride) == 0x000258, "Member 'AFortWorldManager::GameDifficultyRowPIEOverride' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, LootLevelOverrideForPIE) == 0x000264, "Member 'AFortWorldManager::LootLevelOverrideForPIE' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, WorldManagerState) == 0x000268, "Member 'AFortWorldManager::WorldManagerState' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, TileManager) == 0x00026C, "Member 'AFortWorldManager::TileManager' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, X_Size) == 0x000270, "Member 'AFortWorldManager::X_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Y_Size) == 0x000274, "Member 'AFortWorldManager::Y_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Z_StructuralGrid_Size) == 0x000278, "Member 'AFortWorldManager::Z_StructuralGrid_Size' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, TileEdgeSize) == 0x00027C, "Member 'AFortWorldManager::TileEdgeSize' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Theme) == 0x000280, "Member 'AFortWorldManager::Theme' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DefaultLootQuotaCategory) == 0x000284, "Member 'AFortWorldManager::DefaultLootQuotaCategory' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, LootData) == 0x00028C, "Member 'AFortWorldManager::LootData' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, MaxTiles) == 0x00036C, "Member 'AFortWorldManager::MaxTiles' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bUseFixedSeed) == 0x000370, "Member 'AFortWorldManager::bUseFixedSeed' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, FixedSeed) == 0x000374, "Member 'AFortWorldManager::FixedSeed' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, Y) == 0x000378, "Member 'AFortWorldManager::Y' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorClass) == 0x000384, "Member 'AFortWorldManager::ExplorationActorClass' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, NumExplorationActors) == 0x00039C, "Member 'AFortWorldManager::NumExplorationActors' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorDistanceRangeMin) == 0x0003A0, "Member 'AFortWorldManager::ExplorationActorDistanceRangeMin' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorDistanceRangeMax) == 0x0003A4, "Member 'AFortWorldManager::ExplorationActorDistanceRangeMax' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ExplorationActorRequiredTags) == 0x0003A8, "Member 'AFortWorldManager::ExplorationActorRequiredTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, FriendlyPlayerSpawnExtent) == 0x0003C0, "Member 'AFortWorldManager::FriendlyPlayerSpawnExtent' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, PadPlayerSpawnExtent) == 0x0003CC, "Member 'AFortWorldManager::PadPlayerSpawnExtent' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DangerPlayerSpawnExclusionRadius) == 0x0003D8, "Member 'AFortWorldManager::DangerPlayerSpawnExclusionRadius' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, ObjectivePlayerSpawnExclusionRadius) == 0x0003DC, "Member 'AFortWorldManager::ObjectivePlayerSpawnExclusionRadius' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, OverrideInitialPlayerSpawnTags) == 0x0003E0, "Member 'AFortWorldManager::OverrideInitialPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, OverrideBackupPlayerSpawnTags) == 0x0003F8, "Member 'AFortWorldManager::OverrideBackupPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, StartingMissionInfo) == 0x000410, "Member 'AFortWorldManager::StartingMissionInfo' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentWorldRecord) == 0x00041C, "Member 'AFortWorldManager::CurrentWorldRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentZoneRecord) == 0x000420, "Member 'AFortWorldManager::CurrentZoneRecord' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, CurrentZoneIndex) == 0x000440, "Member 'AFortWorldManager::CurrentZoneIndex' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, bZoneCompleted) == 0x000444, "Member 'AFortWorldManager::bZoneCompleted' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, DeferredActors) == 0x000448, "Member 'AFortWorldManager::DeferredActors' has a wrong offset!");
static_assert(offsetof(AFortWorldManager, SpawnedExplorationActors) == 0x000510, "Member 'AFortWorldManager::SpawnedExplorationActors' has a wrong offset!");

// Class FortniteGame.FortPawn_Taker
// 0x0010 (0x0E60 - 0x0E50)
class AFortPawn_Taker final : public AFortAIPawn
{
public:
	uint8                                         bUseClimbLinks : 1;                                // 0x0E50(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_E51[0xF];                                      // 0x0E51(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawn_Taker">();
	}
	static class AFortPawn_Taker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPawn_Taker>();
	}
};
static_assert(alignof(AFortPawn_Taker) == 0x000010, "Wrong alignment on AFortPawn_Taker");
static_assert(sizeof(AFortPawn_Taker) == 0x000E60, "Wrong size on AFortPawn_Taker");

// Class FortniteGame.FortPawnAction_ExecuteGameplayAbility
// 0x0028 (0x008C - 0x0064)
class UFortPawnAction_ExecuteGameplayAbility final : public UPawnAction
{
public:
	struct FGameplayAbilitySpecHandle             GameplayAbilitySpecHandle;                         // 0x0064(0x0004)(Protected, NativeAccessSpecifierProtected)
	uint8                                         bLoopExecution : 1;                                // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRetryOnCooldown : 1;                              // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bRetryOnAbilityAlreadyRunning : 1;                 // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x23];                                      // 0x0069(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnAction_ExecuteGameplayAbility">();
	}
	static class UFortPawnAction_ExecuteGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnAction_ExecuteGameplayAbility>();
	}
};
static_assert(alignof(UFortPawnAction_ExecuteGameplayAbility) == 0x000004, "Wrong alignment on UFortPawnAction_ExecuteGameplayAbility");
static_assert(sizeof(UFortPawnAction_ExecuteGameplayAbility) == 0x00008C, "Wrong size on UFortPawnAction_ExecuteGameplayAbility");
static_assert(offsetof(UFortPawnAction_ExecuteGameplayAbility, GameplayAbilitySpecHandle) == 0x000064, "Member 'UFortPawnAction_ExecuteGameplayAbility::GameplayAbilitySpecHandle' has a wrong offset!");

// Class FortniteGame.WorldTileType
// 0x002C (0x0048 - 0x001C)
class UWorldTileType final : public UDataAsset
{
public:
	class FString                                 TileID;                                            // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TileGroups;                                        // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TileWeight;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             North;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             East;                                              // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             South;                                             // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortTileEdgeType                             West;                                              // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapNames;                                          // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileType">();
	}
	static class UWorldTileType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileType>();
	}
};
static_assert(alignof(UWorldTileType) == 0x000004, "Wrong alignment on UWorldTileType");
static_assert(sizeof(UWorldTileType) == 0x000048, "Wrong size on UWorldTileType");
static_assert(offsetof(UWorldTileType, TileID) == 0x00001C, "Member 'UWorldTileType::TileID' has a wrong offset!");
static_assert(offsetof(UWorldTileType, TileGroups) == 0x000028, "Member 'UWorldTileType::TileGroups' has a wrong offset!");
static_assert(offsetof(UWorldTileType, TileWeight) == 0x000034, "Member 'UWorldTileType::TileWeight' has a wrong offset!");
static_assert(offsetof(UWorldTileType, North) == 0x000038, "Member 'UWorldTileType::North' has a wrong offset!");
static_assert(offsetof(UWorldTileType, East) == 0x000039, "Member 'UWorldTileType::East' has a wrong offset!");
static_assert(offsetof(UWorldTileType, South) == 0x00003A, "Member 'UWorldTileType::South' has a wrong offset!");
static_assert(offsetof(UWorldTileType, West) == 0x00003B, "Member 'UWorldTileType::West' has a wrong offset!");
static_assert(offsetof(UWorldTileType, MapNames) == 0x00003C, "Member 'UWorldTileType::MapNames' has a wrong offset!");

// Class FortniteGame.FortPawnAction_FuzzyQueue
// 0x001C (0x00E0 - 0x00C4)
class UFortPawnAction_FuzzyQueue final : public UFortPawnAction_Move
{
public:
	uint8                                         Pad_C4[0x1C];                                      // 0x00C4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnAction_FuzzyQueue">();
	}
	static class UFortPawnAction_FuzzyQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnAction_FuzzyQueue>();
	}
};
static_assert(alignof(UFortPawnAction_FuzzyQueue) == 0x000004, "Wrong alignment on UFortPawnAction_FuzzyQueue");
static_assert(sizeof(UFortPawnAction_FuzzyQueue) == 0x0000E0, "Wrong size on UFortPawnAction_FuzzyQueue");

// Class FortniteGame.FortPawnAction_RotateToFace
// 0x0018 (0x007C - 0x0064)
class UFortPawnAction_RotateToFace final : public UPawnAction
{
public:
	class AActor*                                 FocusTarget;                                       // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FocalPoint;                                        // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PrecisionDot;                                      // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bStopFacingWhenPaused : 1;                         // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bStopFacingWhenFinished : 1;                       // 0x0078(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnAction_RotateToFace">();
	}
	static class UFortPawnAction_RotateToFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnAction_RotateToFace>();
	}
};
static_assert(alignof(UFortPawnAction_RotateToFace) == 0x000004, "Wrong alignment on UFortPawnAction_RotateToFace");
static_assert(sizeof(UFortPawnAction_RotateToFace) == 0x00007C, "Wrong size on UFortPawnAction_RotateToFace");
static_assert(offsetof(UFortPawnAction_RotateToFace, FocusTarget) == 0x000064, "Member 'UFortPawnAction_RotateToFace::FocusTarget' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_RotateToFace, FocalPoint) == 0x000068, "Member 'UFortPawnAction_RotateToFace::FocalPoint' has a wrong offset!");
static_assert(offsetof(UFortPawnAction_RotateToFace, PrecisionDot) == 0x000074, "Member 'UFortPawnAction_RotateToFace::PrecisionDot' has a wrong offset!");

// Class FortniteGame.HomeBaseWorkers
// 0x00A0 (0x00BC - 0x001C)
class UHomeBaseWorkers final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnWorkersChanged;                                  // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnWorkerSlotted;                                   // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Rating;                                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMyTownBuildingItem>     BuildingItem;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UHomeBaseMainBuilding*                  Building;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x10];                                      // 0x004C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHomeBaseWorker*>                Workers;                                           // 0x005C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UHomeBaseWorker*>                Managers;                                          // 0x0068(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FHomeBaseWorkerSlot>            Slots;                                             // 0x0074(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x3C];                                      // 0x0080(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CalculateTotalWorkerRatings(const TArray<class UHomeBaseWorker*>& Workers_0);
	TArray<class UHomeBaseWorker*> GetAllManagers();
	TArray<class UHomeBaseWorker*> GetAllWorkers();
	TArray<struct FHomeBaseWorkerSlot> GetSlots();
	TArray<class UHomeBaseWorker*> GetSlottedWorkers();
	class UHomeBaseWorker* GetWorkerFromItem(const class UFortWorker* WorkerItem);
	void OnBuildingItemChanged(bool bItemChanged, bool bAmmoChanged, bool bIngredientsChanged);
	void SlotWorker(class UHomeBaseWorker* Worker, int32 SlotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseWorkers">();
	}
	static class UHomeBaseWorkers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseWorkers>();
	}
};
static_assert(alignof(UHomeBaseWorkers) == 0x000004, "Wrong alignment on UHomeBaseWorkers");
static_assert(sizeof(UHomeBaseWorkers) == 0x0000BC, "Wrong size on UHomeBaseWorkers");
static_assert(offsetof(UHomeBaseWorkers, OnWorkersChanged) == 0x00001C, "Member 'UHomeBaseWorkers::OnWorkersChanged' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, OnWorkerSlotted) == 0x000028, "Member 'UHomeBaseWorkers::OnWorkerSlotted' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, Rating) == 0x000034, "Member 'UHomeBaseWorkers::Rating' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, BuildingItem) == 0x000040, "Member 'UHomeBaseWorkers::BuildingItem' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, Building) == 0x000048, "Member 'UHomeBaseWorkers::Building' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, Workers) == 0x00005C, "Member 'UHomeBaseWorkers::Workers' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, Managers) == 0x000068, "Member 'UHomeBaseWorkers::Managers' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorkers, Slots) == 0x000074, "Member 'UHomeBaseWorkers::Slots' has a wrong offset!");

// Class FortniteGame.FortPawnAction_Sleep
// 0x0000 (0x0064 - 0x0064)
class UFortPawnAction_Sleep final : public UPawnAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPawnAction_Sleep">();
	}
	static class UFortPawnAction_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPawnAction_Sleep>();
	}
};
static_assert(alignof(UFortPawnAction_Sleep) == 0x000004, "Wrong alignment on UFortPawnAction_Sleep");
static_assert(sizeof(UFortPawnAction_Sleep) == 0x000064, "Wrong size on UFortPawnAction_Sleep");

// Class FortniteGame.FortPermaniteStructureInterface
// 0x0000 (0x001C - 0x001C)
class IFortPermaniteStructureInterface final : public IInterface
{
public:
	void OnBoundariesChanged(int32 MinLevel, int32 MaxLevel, int32 CurrentLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPermaniteStructureInterface">();
	}
	static class IFortPermaniteStructureInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortPermaniteStructureInterface>();
	}
};
static_assert(alignof(IFortPermaniteStructureInterface) == 0x000004, "Wrong alignment on IFortPermaniteStructureInterface");
static_assert(sizeof(IFortPermaniteStructureInterface) == 0x00001C, "Wrong size on IFortPermaniteStructureInterface");

// Class FortniteGame.FortPickupBackpack
// 0x0000 (0x03B8 - 0x03B8)
class AFortPickupBackpack final : public AFortPickup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupBackpack">();
	}
	static class AFortPickupBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickupBackpack>();
	}
};
static_assert(alignof(AFortPickupBackpack) == 0x000004, "Wrong alignment on AFortPickupBackpack");
static_assert(sizeof(AFortPickupBackpack) == 0x0003B8, "Wrong size on AFortPickupBackpack");

// Class FortniteGame.FortPickupEffect
// 0x0030 (0x0270 - 0x0240)
class AFortPickupEffect : public AActor
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFortWorldItemDefinition*               ItemDefinition;                                    // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotShowSpawnParticles;                          // 0x024C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D[0x3];                                      // 0x024D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PickupColor;                                       // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackpackWorldPosition;                             // 0x025C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOwnedByALocalPlayer : 1;                          // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOwnedByPlayer : 1;                                // 0x026C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAboutToEnterBackpack();
	void OnAttached();
	void OnPickedUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPickupEffect">();
	}
	static class AFortPickupEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPickupEffect>();
	}
};
static_assert(alignof(AFortPickupEffect) == 0x000004, "Wrong alignment on AFortPickupEffect");
static_assert(sizeof(AFortPickupEffect) == 0x000270, "Wrong size on AFortPickupEffect");
static_assert(offsetof(AFortPickupEffect, StaticMesh) == 0x000240, "Member 'AFortPickupEffect::StaticMesh' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, SkeletalMesh) == 0x000244, "Member 'AFortPickupEffect::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, ItemDefinition) == 0x000248, "Member 'AFortPickupEffect::ItemDefinition' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, bDoNotShowSpawnParticles) == 0x00024C, "Member 'AFortPickupEffect::bDoNotShowSpawnParticles' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, PickupColor) == 0x000250, "Member 'AFortPickupEffect::PickupColor' has a wrong offset!");
static_assert(offsetof(AFortPickupEffect, BackpackWorldPosition) == 0x00025C, "Member 'AFortPickupEffect::BackpackWorldPosition' has a wrong offset!");

// Class FortniteGame.FortPlacedPawnMarker
// 0x0000 (0x0254 - 0x0254)
class AFortPlacedPawnMarker final : public ANavigationObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlacedPawnMarker">();
	}
	static class AFortPlacedPawnMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlacedPawnMarker>();
	}
};
static_assert(alignof(AFortPlacedPawnMarker) == 0x000004, "Wrong alignment on AFortPlacedPawnMarker");
static_assert(sizeof(AFortPlacedPawnMarker) == 0x000254, "Wrong size on AFortPlacedPawnMarker");

// Class FortniteGame.FortPlayerARPGCamera
// 0x0010 (0x1254 - 0x1244)
class AFortPlayerARPGCamera final : public APlayerCameraManager
{
public:
	float                                         CameraDistance;                                    // 0x1244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitch;                                       // 0x1248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYaw;                                         // 0x124C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOV;                                         // 0x1250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerARPGCamera">();
	}
	static class AFortPlayerARPGCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerARPGCamera>();
	}
};
static_assert(alignof(AFortPlayerARPGCamera) == 0x000004, "Wrong alignment on AFortPlayerARPGCamera");
static_assert(sizeof(AFortPlayerARPGCamera) == 0x001254, "Wrong size on AFortPlayerARPGCamera");
static_assert(offsetof(AFortPlayerARPGCamera, CameraDistance) == 0x001244, "Member 'AFortPlayerARPGCamera::CameraDistance' has a wrong offset!");
static_assert(offsetof(AFortPlayerARPGCamera, CameraPitch) == 0x001248, "Member 'AFortPlayerARPGCamera::CameraPitch' has a wrong offset!");
static_assert(offsetof(AFortPlayerARPGCamera, CameraYaw) == 0x00124C, "Member 'AFortPlayerARPGCamera::CameraYaw' has a wrong offset!");
static_assert(offsetof(AFortPlayerARPGCamera, CameraFOV) == 0x001250, "Member 'AFortPlayerARPGCamera::CameraFOV' has a wrong offset!");

// Class FortniteGame.FortPvPFunctionLibrary
// 0x0000 (0x001C - 0x001C)
class UFortPvPFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DestroyAllFortPickupsWithItem(class UObject* WorldContextObject, const class UFortWorldItemDefinition* ItemDefinitionToCheck);
	static class AFortTeamInfoPvPBaseDestruction* GetBaseDestructionTeamInfo(class UObject* WorldContextObject, EFortTeam Team);
	static void GetDifficultyRowNamesFromPvPRating(TArray<class FName>* OutDifficultyRows, const float InPvPRating);
	static int32 GetMatchLevel(class UObject* WorldContextObject);
	static int32 GetRoundTimeAccumulated(class UObject* WorldContextObject);
	static class AFortPvPBaseCornerstone* GetTeamCornerstone(class UObject* WorldContextObject, EFortTeam Team);
	static class AStrategicBuildingActor* GetTeamStrategicBuildingActor(class UObject* WorldContextObject, EFortTeam Team, const struct FTeamStrategicBuildingHandle& SBAHandle);
	static void SetMatchLevel(class UObject* WorldContextObject, int32 MatchLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPvPFunctionLibrary">();
	}
	static class UFortPvPFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortPvPFunctionLibrary>();
	}
};
static_assert(alignof(UFortPvPFunctionLibrary) == 0x000004, "Wrong alignment on UFortPvPFunctionLibrary");
static_assert(sizeof(UFortPvPFunctionLibrary) == 0x00001C, "Wrong size on UFortPvPFunctionLibrary");

// Class FortniteGame.FortUIBaseClass
// 0x005C (0x0350 - 0x02F4)
class AFortUIBaseClass : public AHUD
{
public:
	uint8                                         Pad_2F4[0x5C];                                     // 0x02F4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TutorialToggleHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIBaseClass">();
	}
	static class AFortUIBaseClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIBaseClass>();
	}
};
static_assert(alignof(AFortUIBaseClass) == 0x000004, "Wrong alignment on AFortUIBaseClass");
static_assert(sizeof(AFortUIBaseClass) == 0x000350, "Wrong size on AFortUIBaseClass");

// Class FortniteGame.FortQueryContext_AllGoals
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_AllGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllGoals">();
	}
	static class UFortQueryContext_AllGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllGoals>();
	}
};
static_assert(alignof(UFortQueryContext_AllGoals) == 0x000004, "Wrong alignment on UFortQueryContext_AllGoals");
static_assert(sizeof(UFortQueryContext_AllGoals) == 0x00001C, "Wrong size on UFortQueryContext_AllGoals");

// Class FortniteGame.FortUIZone
// 0x01D0 (0x0520 - 0x0350)
class AFortUIZone : public AFortUIBaseClass
{
public:
	struct FFontRenderInfo                        TextRenderInfo;                                    // 0x0350(0x0028)(NativeAccessSpecifierPublic)
	class UReporterGraph*                         CombatGraph;                                       // 0x0378(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         FactorGraph;                                       // 0x037C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         IntensityGraph;                                    // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDValuesGraph;                                    // 0x0384(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         PIDContributionsGraph;                             // 0x0388(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReporterGraph*                         UtilitiesGraph;                                    // 0x038C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortContextualReticleTypes                   CurrentContextualReticleIconType;                  // 0x0390(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CurrentContextualReticleColor;                     // 0x0394(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              ContextualReticleIcons[0x8];                       // 0x0398(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastReticleSize;                                   // 0x0458(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0xB8];                                     // 0x045C(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFortSpottedActorIndicator*>     SpottedActorIndicators;                            // 0x0514(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ToggleTargetInfo();
	void ToggleTargetInfoAI();
	void ToggleTargetInfoLock(bool bTraceComplex);
	void ToggleTargetInfoPaths();
	void ToggleTargetInfoSensing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIZone">();
	}
	static class AFortUIZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIZone>();
	}
};
static_assert(alignof(AFortUIZone) == 0x000004, "Wrong alignment on AFortUIZone");
static_assert(sizeof(AFortUIZone) == 0x000520, "Wrong size on AFortUIZone");
static_assert(offsetof(AFortUIZone, TextRenderInfo) == 0x000350, "Member 'AFortUIZone::TextRenderInfo' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CombatGraph) == 0x000378, "Member 'AFortUIZone::CombatGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, FactorGraph) == 0x00037C, "Member 'AFortUIZone::FactorGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, IntensityGraph) == 0x000380, "Member 'AFortUIZone::IntensityGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, PIDValuesGraph) == 0x000384, "Member 'AFortUIZone::PIDValuesGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, PIDContributionsGraph) == 0x000388, "Member 'AFortUIZone::PIDContributionsGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, UtilitiesGraph) == 0x00038C, "Member 'AFortUIZone::UtilitiesGraph' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CurrentContextualReticleIconType) == 0x000390, "Member 'AFortUIZone::CurrentContextualReticleIconType' has a wrong offset!");
static_assert(offsetof(AFortUIZone, CurrentContextualReticleColor) == 0x000394, "Member 'AFortUIZone::CurrentContextualReticleColor' has a wrong offset!");
static_assert(offsetof(AFortUIZone, ContextualReticleIcons) == 0x000398, "Member 'AFortUIZone::ContextualReticleIcons' has a wrong offset!");
static_assert(offsetof(AFortUIZone, LastReticleSize) == 0x000458, "Member 'AFortUIZone::LastReticleSize' has a wrong offset!");
static_assert(offsetof(AFortUIZone, SpottedActorIndicators) == 0x000514, "Member 'AFortUIZone::SpottedActorIndicators' has a wrong offset!");

// Class FortniteGame.FortPlayerStateOutpost
// 0x0008 (0x0768 - 0x0760)
class AFortPlayerStateOutpost final : public AFortPlayerStateZone
{
public:
	bool                                          bCanEditOutpost;                                   // 0x0760(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CraftingTableItemsRemaing;                         // 0x0764(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_CanEditOutpost();
	void OnRep_CraftingTableItemsRemaing();
	void ServerSetCanEditOutpost(class AFortPlayerStateOutpost* InPlayer, bool bCanEdit);
	void SetCanEditOutpost(class AFortPlayerStateOutpost* InPlayer, bool bCanEdit);

	bool CanEditOutpost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateOutpost">();
	}
	static class AFortPlayerStateOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateOutpost>();
	}
};
static_assert(alignof(AFortPlayerStateOutpost) == 0x000004, "Wrong alignment on AFortPlayerStateOutpost");
static_assert(sizeof(AFortPlayerStateOutpost) == 0x000768, "Wrong size on AFortPlayerStateOutpost");
static_assert(offsetof(AFortPlayerStateOutpost, bCanEditOutpost) == 0x000760, "Member 'AFortPlayerStateOutpost::bCanEditOutpost' has a wrong offset!");
static_assert(offsetof(AFortPlayerStateOutpost, CraftingTableItemsRemaing) == 0x000764, "Member 'AFortPlayerStateOutpost::CraftingTableItemsRemaing' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerARPG
// 0x0078 (0x0CE8 - 0x0C70)
class AFortPlayerControllerARPG final : public AFortPlayerControllerZone
{
public:
	uint8                                         Pad_C70[0x58];                                     // 0x0C70(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        ARPGCameraInputComponent;                          // 0x0CC8(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBuildingTextureData>    TransparentTextureData;                            // 0x0CCC(0x0018)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE4[0x4];                                      // 0x0CE4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TogglePointAndClickMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerARPG">();
	}
	static class AFortPlayerControllerARPG* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerARPG>();
	}
};
static_assert(alignof(AFortPlayerControllerARPG) == 0x000004, "Wrong alignment on AFortPlayerControllerARPG");
static_assert(sizeof(AFortPlayerControllerARPG) == 0x000CE8, "Wrong size on AFortPlayerControllerARPG");
static_assert(offsetof(AFortPlayerControllerARPG, ARPGCameraInputComponent) == 0x000CC8, "Member 'AFortPlayerControllerARPG::ARPGCameraInputComponent' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerARPG, TransparentTextureData) == 0x000CCC, "Member 'AFortPlayerControllerARPG::TransparentTextureData' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterGoalsOnGround
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterGoalsOnGround final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsOnGround">();
	}
	static class UFortQueryContext_EncounterGoalsOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsOnGround>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsOnGround) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterGoalsOnGround");
static_assert(sizeof(UFortQueryContext_EncounterGoalsOnGround) == 0x00001C, "Wrong size on UFortQueryContext_EncounterGoalsOnGround");

// Class FortniteGame.FortPlayerControllerKeep
// 0x0020 (0x0C90 - 0x0C70)
class AFortPlayerControllerKeep final : public AFortPlayerControllerZone
{
public:
	uint8                                         Pad_C70[0x4];                                      // 0x0C70(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   UnableToPlaceReachedLimit;                         // 0x0C74(0x000C)(Protected, NativeAccessSpecifierProtected)
	int32                                         WorkshopPickedItems;                               // 0x0C80(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ArmoryPickedItems;                                 // 0x0C84(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C88[0x8];                                      // 0x0C88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientSetPermaniteAvailability(bool bAvailable);
	void ClientUnloadFoundations();
	void DumpItemData();
	void ResetContainers();
	void RestoreContainers();
	void ServerOnContainerItemsChosen(class AKeepItemContainer* Container, const TArray<class FString>& ItemTemplateIDs);
	void SetPermaniteAvailability(bool bAvailable);
	void StreamInStuff();
	void StreamOutStuff();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerKeep">();
	}
	static class AFortPlayerControllerKeep* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerKeep>();
	}
};
static_assert(alignof(AFortPlayerControllerKeep) == 0x000004, "Wrong alignment on AFortPlayerControllerKeep");
static_assert(sizeof(AFortPlayerControllerKeep) == 0x000C90, "Wrong size on AFortPlayerControllerKeep");
static_assert(offsetof(AFortPlayerControllerKeep, UnableToPlaceReachedLimit) == 0x000C74, "Member 'AFortPlayerControllerKeep::UnableToPlaceReachedLimit' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerKeep, WorkshopPickedItems) == 0x000C80, "Member 'AFortPlayerControllerKeep::WorkshopPickedItems' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerKeep, ArmoryPickedItems) == 0x000C84, "Member 'AFortPlayerControllerKeep::ArmoryPickedItems' has a wrong offset!");

// Class FortniteGame.FortPlayerControllerOutpost
// 0x0124 (0x0D94 - 0x0C70)
class AFortPlayerControllerOutpost : public AFortPlayerControllerZone
{
public:
	UMulticastDelegateProperty_                   OnItemFabricated;                                  // 0x0C70(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7C[0xC];                                      // 0x0C7C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortOutpostItemDefinition*             StructureBeingUpgraded;                            // 0x0C88(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelBeforeUpgrade;                                // 0x0C8C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PrestigeLevel;                                     // 0x0C90(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFortWorldItemDefinition*               ItemPendingToFabricate;                            // 0x0C94(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C98[0x10];                                     // 0x0C98(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFortWorldItem*                         FabricatedItemPendingForNotification;              // 0x0CA8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CAC[0x8];                                      // 0x0CAC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         DisintegrationStartTime;                           // 0x0CB4(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuantumGooCompleted;                               // 0x0CBC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuantumGooIncoming;                                // 0x0CC0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC4[0x8];                                      // 0x0CC4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDepositedResources>            PostDepositedResources;                            // 0x0CCC(0x000C)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         StormShieldLevelDefended;                          // 0x0CD8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOutpostOwnerInPIE;                              // 0x0CDC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CDD[0x3];                                      // 0x0CDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UFortOutpostItemDefinition*, TWeakObjectPtr<class AOutpostStructureBase>> CachedStructures;                                  // 0x0CE0(0x003C)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UFortOutpostItemDefinition*, class UFortWorldItem*> CachedStructureItems;                              // 0x0D1C(0x003C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UFortOutpostItemDefinition*, int32> CachedStructureMaxLevels;                          // 0x0D58(0x003C)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void ClientExecuteInventoryItem(const struct FGuid& ItemGuid, float Delay);
	void ClientOnStructureLevelChanged(class UFortOutpostItemDefinition* UpgradedStructure, int32 InLevelBeforeUpgrade);
	void ClientShowVictoryScreen();
	void DumpInventory();
	void OnRep_DisintegrationStartTime();
	void OnRep_PostDepositedResources();
	void OnRep_QuantumGooCompleted();
	void OnRep_QuantumGooIncoming();
	void ServeMoveItemFromStorageVault(const struct FFortItemEntry& NewlyCollectedItem);
	void ServeMoveItemToStorageVault(const struct FFortItemEntry& NewlyStoredItem);
	void ServerAbortDisintegration();
	void ServerActivateCraftingTable();
	void ServerDeactivateCraftingTable();
	void ServerDepositPOSTResource(const struct FGuid& ItemGuid, int32 Count);
	void ServerDisintegrateItem(const struct FGuid& ItemGuid, int32 Count);
	void ServerFabricateItem(const class UFortWorldItemDefinition* ItemDef);
	void ServerIncreaseOutpostPrestigeLevel();
	void ServerLeaveOutpostAsParty();
	void ServerNotifyPendingFabricationCompleted();
	void ServerUpgradePOST();
	void ServerUpgradeStructure(class UFortOutpostItemDefinition* StructureToUpgrade);
	void ToggleOwnerInPIE();
	void UpgradeStructure(class UFortOutpostItemDefinition* StructureToUpgrade);

	bool CanUpgradeStructure(class UFortOutpostItemDefinition* OutpostStructure, bool bLog) const;
	float GetPendingFabricationProgress() const;
	class UFortWorldItemDefinition* GetPendingItemToFabricate() const;
	int32 GetStormShieldLevelDefended() const;
	int32 GetStructureLevel(class UFortOutpostItemDefinition* OutpostStructure) const;
	int32 GetStructureMaxLevel(class UFortOutpostItemDefinition* OutpostStructure) const;
	void GetUpgradeStructureCost(class UFortOutpostItemDefinition* OutpostStructure, TArray<struct FFortItemQuantityPair>* OutWorldItems, TArray<struct FFortItemQuantityPair>* OutAccountItems) const;
	bool IsFabricationPending() const;
	bool IsOutpostOwner() const;
	void ShowOutpostVictoryScreenToAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerOutpost">();
	}
	static class AFortPlayerControllerOutpost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerOutpost>();
	}
};
static_assert(alignof(AFortPlayerControllerOutpost) == 0x000004, "Wrong alignment on AFortPlayerControllerOutpost");
static_assert(sizeof(AFortPlayerControllerOutpost) == 0x000D94, "Wrong size on AFortPlayerControllerOutpost");
static_assert(offsetof(AFortPlayerControllerOutpost, OnItemFabricated) == 0x000C70, "Member 'AFortPlayerControllerOutpost::OnItemFabricated' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, StructureBeingUpgraded) == 0x000C88, "Member 'AFortPlayerControllerOutpost::StructureBeingUpgraded' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, LevelBeforeUpgrade) == 0x000C8C, "Member 'AFortPlayerControllerOutpost::LevelBeforeUpgrade' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, PrestigeLevel) == 0x000C90, "Member 'AFortPlayerControllerOutpost::PrestigeLevel' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, ItemPendingToFabricate) == 0x000C94, "Member 'AFortPlayerControllerOutpost::ItemPendingToFabricate' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, FabricatedItemPendingForNotification) == 0x000CA8, "Member 'AFortPlayerControllerOutpost::FabricatedItemPendingForNotification' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, DisintegrationStartTime) == 0x000CB4, "Member 'AFortPlayerControllerOutpost::DisintegrationStartTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, QuantumGooCompleted) == 0x000CBC, "Member 'AFortPlayerControllerOutpost::QuantumGooCompleted' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, QuantumGooIncoming) == 0x000CC0, "Member 'AFortPlayerControllerOutpost::QuantumGooIncoming' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, PostDepositedResources) == 0x000CCC, "Member 'AFortPlayerControllerOutpost::PostDepositedResources' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, StormShieldLevelDefended) == 0x000CD8, "Member 'AFortPlayerControllerOutpost::StormShieldLevelDefended' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, bIsOutpostOwnerInPIE) == 0x000CDC, "Member 'AFortPlayerControllerOutpost::bIsOutpostOwnerInPIE' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, CachedStructures) == 0x000CE0, "Member 'AFortPlayerControllerOutpost::CachedStructures' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, CachedStructureItems) == 0x000D1C, "Member 'AFortPlayerControllerOutpost::CachedStructureItems' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerOutpost, CachedStructureMaxLevels) == 0x000D58, "Member 'AFortPlayerControllerOutpost::CachedStructureMaxLevels' has a wrong offset!");

// Class FortniteGame.FortQueryContext_EncounterTargetObjective
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterTargetObjective final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterTargetObjective">();
	}
	static class UFortQueryContext_EncounterTargetObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterTargetObjective>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterTargetObjective) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterTargetObjective");
static_assert(sizeof(UFortQueryContext_EncounterTargetObjective) == 0x00001C, "Wrong size on UFortQueryContext_EncounterTargetObjective");

// Class FortniteGame.FortQueryContext_EncounterFallbackTarget
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterFallbackTarget final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterFallbackTarget">();
	}
	static class UFortQueryContext_EncounterFallbackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterFallbackTarget>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterFallbackTarget) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterFallbackTarget");
static_assert(sizeof(UFortQueryContext_EncounterFallbackTarget) == 0x00001C, "Wrong size on UFortQueryContext_EncounterFallbackTarget");

// Class FortniteGame.FortPlayerControllerZoneFake
// 0x0064 (0x0CD4 - 0x0C70)
class AFortPlayerControllerZoneFake final : public AFortPlayerControllerZone
{
public:
	float                                         LastRandomTurnTime;                                // 0x0C70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickLootTime;                                  // 0x0C74(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPickEnemyTime;                                 // 0x0C78(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyLastSeenTime;                                 // 0x0C7C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastGoodInteraction;                               // 0x0C80(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastCheckGoodTarget;                               // 0x0C84(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastQuickbarTime;                                  // 0x0C88(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBuildOrCraftTime;                              // 0x0C8C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRespawnAttemptTime;                            // 0x0C90(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBuildPending;                                  // 0x0C94(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasBuildFirePending;                              // 0x0C95(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsBuildingFloor;                                  // 0x0C96(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C97[0x1];                                      // 0x0C97(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildWaitTime;                                     // 0x0C98(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFortResourceType                             PickedBuildingMaterial;                            // 0x0C9C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9D[0x3];                                      // 0x0C9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastJumpTime;                                      // 0x0CA0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLookInput;                                     // 0x0CA4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortAIPawn*                            EnemyTarget;                                       // 0x0CA8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPickup*                            PickupTarget;                                      // 0x0CAC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     LootTarget;                                        // 0x0CB0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABuildingContainer*                     SearchTarget;                                      // 0x0CB4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastPawnHealth;                                    // 0x0CB8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHadPawn;                                       // 0x0CBC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBD[0x3];                                      // 0x0CBD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0CC0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AFortPlayerPawn*                        MyPawn;                                            // 0x0CCC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD0[0x4];                                      // 0x0CD0(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerControllerZoneFake">();
	}
	static class AFortPlayerControllerZoneFake* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerControllerZoneFake>();
	}
};
static_assert(alignof(AFortPlayerControllerZoneFake) == 0x000004, "Wrong alignment on AFortPlayerControllerZoneFake");
static_assert(sizeof(AFortPlayerControllerZoneFake) == 0x000CD4, "Wrong size on AFortPlayerControllerZoneFake");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastRandomTurnTime) == 0x000C70, "Member 'AFortPlayerControllerZoneFake::LastRandomTurnTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastPickLootTime) == 0x000C74, "Member 'AFortPlayerControllerZoneFake::LastPickLootTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastPickEnemyTime) == 0x000C78, "Member 'AFortPlayerControllerZoneFake::LastPickEnemyTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, EnemyLastSeenTime) == 0x000C7C, "Member 'AFortPlayerControllerZoneFake::EnemyLastSeenTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastGoodInteraction) == 0x000C80, "Member 'AFortPlayerControllerZoneFake::LastGoodInteraction' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastCheckGoodTarget) == 0x000C84, "Member 'AFortPlayerControllerZoneFake::LastCheckGoodTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastQuickbarTime) == 0x000C88, "Member 'AFortPlayerControllerZoneFake::LastQuickbarTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastBuildOrCraftTime) == 0x000C8C, "Member 'AFortPlayerControllerZoneFake::LastBuildOrCraftTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastRespawnAttemptTime) == 0x000C90, "Member 'AFortPlayerControllerZoneFake::LastRespawnAttemptTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, bHasBuildPending) == 0x000C94, "Member 'AFortPlayerControllerZoneFake::bHasBuildPending' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, bHasBuildFirePending) == 0x000C95, "Member 'AFortPlayerControllerZoneFake::bHasBuildFirePending' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, bIsBuildingFloor) == 0x000C96, "Member 'AFortPlayerControllerZoneFake::bIsBuildingFloor' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, BuildWaitTime) == 0x000C98, "Member 'AFortPlayerControllerZoneFake::BuildWaitTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, PickedBuildingMaterial) == 0x000C9C, "Member 'AFortPlayerControllerZoneFake::PickedBuildingMaterial' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastJumpTime) == 0x000CA0, "Member 'AFortPlayerControllerZoneFake::LastJumpTime' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastLookInput) == 0x000CA4, "Member 'AFortPlayerControllerZoneFake::LastLookInput' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, EnemyTarget) == 0x000CA8, "Member 'AFortPlayerControllerZoneFake::EnemyTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, PickupTarget) == 0x000CAC, "Member 'AFortPlayerControllerZoneFake::PickupTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LootTarget) == 0x000CB0, "Member 'AFortPlayerControllerZoneFake::LootTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, SearchTarget) == 0x000CB4, "Member 'AFortPlayerControllerZoneFake::SearchTarget' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, LastPawnHealth) == 0x000CB8, "Member 'AFortPlayerControllerZoneFake::LastPawnHealth' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, bHasHadPawn) == 0x000CBC, "Member 'AFortPlayerControllerZoneFake::bHasHadPawn' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, ViewLocation) == 0x000CC0, "Member 'AFortPlayerControllerZoneFake::ViewLocation' has a wrong offset!");
static_assert(offsetof(AFortPlayerControllerZoneFake, MyPawn) == 0x000CCC, "Member 'AFortPlayerControllerZoneFake::MyPawn' has a wrong offset!");

// Class FortniteGame.FortQueryData_CurvesAroundLine
// 0x0048 (0x0064 - 0x001C)
class UFortQueryData_CurvesAroundLine final : public UDataAsset
{
public:
	struct FFortPointsOnCurve                     PointsLeftOfLine;                                  // 0x001C(0x0024)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FFortPointsOnCurve                     PointsRightOfLine;                                 // 0x0040(0x0024)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryData_CurvesAroundLine">();
	}
	static class UFortQueryData_CurvesAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryData_CurvesAroundLine>();
	}
};
static_assert(alignof(UFortQueryData_CurvesAroundLine) == 0x000004, "Wrong alignment on UFortQueryData_CurvesAroundLine");
static_assert(sizeof(UFortQueryData_CurvesAroundLine) == 0x000064, "Wrong size on UFortQueryData_CurvesAroundLine");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsLeftOfLine) == 0x00001C, "Member 'UFortQueryData_CurvesAroundLine::PointsLeftOfLine' has a wrong offset!");
static_assert(offsetof(UFortQueryData_CurvesAroundLine, PointsRightOfLine) == 0x000040, "Member 'UFortQueryData_CurvesAroundLine::PointsRightOfLine' has a wrong offset!");

// Class FortniteGame.FortPlayerMannequin
// 0x00C0 (0x0324 - 0x0264)
class AFortPlayerMannequin final : public ASkeletalMeshActor
{
public:
	class UCustomCharacterPart*                   CharacterParts[0x7];                               // 0x0264(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomCharacterPart*                   CharacterPartList[0x6];                            // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomColorSwatch*                     CharacterPartColorSwatches[0x7];                   // 0x0298(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomColorSwatch*                     ColorSwatchesForCharacterParts[0x6];               // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomColorComponent*                  AccessoryColorSwatchHandler[0x6];                  // 0x02CC(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomColorSwatch*                     ColorSwatches[0x2];                                // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          WeaponSkeletalMesh;                                // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachSocket;                                // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x1C];                                     // 0x02F8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMorphValuePair>                MorphTargets;                                      // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x0320(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x3];                                      // 0x0321(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CyclePartBP(EFortCustomPartType Part, bool bNextPart);
	bool RemovePart(EFortCustomPartType Part);
	bool SetPart(EFortCustomPartType Part, class UCustomCharacterPart* PartAsset);
	void SetSkeletalMesh(class USkeletalMesh* SkeletalMesh);
	bool SetWeaponSkeletalMesh(class USkeletalMesh* SkeletalMesh);
	void ToggleGenderBP();
	void UpdateMorphTargets();

	EFortCustomGender GetGender() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerMannequin">();
	}
	static class AFortPlayerMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerMannequin>();
	}
};
static_assert(alignof(AFortPlayerMannequin) == 0x000004, "Wrong alignment on AFortPlayerMannequin");
static_assert(sizeof(AFortPlayerMannequin) == 0x000324, "Wrong size on AFortPlayerMannequin");
static_assert(offsetof(AFortPlayerMannequin, CharacterParts) == 0x000264, "Member 'AFortPlayerMannequin::CharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, CharacterPartList) == 0x000280, "Member 'AFortPlayerMannequin::CharacterPartList' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, CharacterPartColorSwatches) == 0x000298, "Member 'AFortPlayerMannequin::CharacterPartColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, ColorSwatchesForCharacterParts) == 0x0002B4, "Member 'AFortPlayerMannequin::ColorSwatchesForCharacterParts' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, AccessoryColorSwatchHandler) == 0x0002CC, "Member 'AFortPlayerMannequin::AccessoryColorSwatchHandler' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, ColorSwatches) == 0x0002E4, "Member 'AFortPlayerMannequin::ColorSwatches' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, WeaponSkeletalMesh) == 0x0002EC, "Member 'AFortPlayerMannequin::WeaponSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, WeaponAttachSocket) == 0x0002F0, "Member 'AFortPlayerMannequin::WeaponAttachSocket' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, MorphTargets) == 0x000314, "Member 'AFortPlayerMannequin::MorphTargets' has a wrong offset!");
static_assert(offsetof(AFortPlayerMannequin, bInitialized) == 0x000320, "Member 'AFortPlayerMannequin::bInitialized' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_PointsAroundLine
// 0x0070 (0x00CC - 0x005C)
class UFortQueryGenerator_PointsAroundLine final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderBoolValue               SkipCellsWithCollision;                            // 0x005C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderIntValue                MaxPointsPerClusterLocation;                       // 0x007C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              RadiusAroundClusterLocation;                       // 0x0098(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFortQueryData_CurvesAroundLine> CurvesAroundLineAsset;                             // 0x00B4(0x0018)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsAroundLine">();
	}
	static class UFortQueryGenerator_PointsAroundLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsAroundLine>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsAroundLine) == 0x000004, "Wrong alignment on UFortQueryGenerator_PointsAroundLine");
static_assert(sizeof(UFortQueryGenerator_PointsAroundLine) == 0x0000CC, "Wrong size on UFortQueryGenerator_PointsAroundLine");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, SkipCellsWithCollision) == 0x00005C, "Member 'UFortQueryGenerator_PointsAroundLine::SkipCellsWithCollision' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, GenerateAround) == 0x000078, "Member 'UFortQueryGenerator_PointsAroundLine::GenerateAround' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, MaxPointsPerClusterLocation) == 0x00007C, "Member 'UFortQueryGenerator_PointsAroundLine::MaxPointsPerClusterLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, RadiusAroundClusterLocation) == 0x000098, "Member 'UFortQueryGenerator_PointsAroundLine::RadiusAroundClusterLocation' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsAroundLine, CurvesAroundLineAsset) == 0x0000B4, "Member 'UFortQueryGenerator_PointsAroundLine::CurvesAroundLineAsset' has a wrong offset!");

// Class FortniteGame.FortPlayerStart
// 0x0004 (0x0260 - 0x025C)
class AFortPlayerStart final : public APlayerStart
{
public:
	class UParticleSystemComponent*               StartParticleComponent;                            // 0x025C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStart">();
	}
	static class AFortPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStart>();
	}
};
static_assert(alignof(AFortPlayerStart) == 0x000004, "Wrong alignment on AFortPlayerStart");
static_assert(sizeof(AFortPlayerStart) == 0x000260, "Wrong size on AFortPlayerStart");
static_assert(offsetof(AFortPlayerStart, StartParticleComponent) == 0x00025C, "Member 'AFortPlayerStart::StartParticleComponent' has a wrong offset!");

// Class FortniteGame.FortPlayerStateFrontEnd
// 0x0000 (0x0614 - 0x0614)
class AFortPlayerStateFrontEnd final : public AFortPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateFrontEnd">();
	}
	static class AFortPlayerStateFrontEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateFrontEnd>();
	}
};
static_assert(alignof(AFortPlayerStateFrontEnd) == 0x000004, "Wrong alignment on AFortPlayerStateFrontEnd");
static_assert(sizeof(AFortPlayerStateFrontEnd) == 0x000614, "Wrong size on AFortPlayerStateFrontEnd");

// Class FortniteGame.FortQueryGenerator_Buildings
// 0x00C8 (0x00FC - 0x0034)
class UFortQueryGenerator_Buildings final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           BuildingGridVolumeCenter;                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                HorizontalBuildingCellRadius;                      // 0x0038(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsAbove;                                // 0x0054(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                BuildingCellsBelow;                                // 0x0070(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeWalls;                                     // 0x008C(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeFloors;                                    // 0x00A8(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               bIncludeCenterCell;                                // 0x00C4(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderIntValue                MaxBuildingActorsPerVolumeCenterToCollect;         // 0x00E0(0x001C)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_Buildings">();
	}
	static class UFortQueryGenerator_Buildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_Buildings>();
	}
};
static_assert(alignof(UFortQueryGenerator_Buildings) == 0x000004, "Wrong alignment on UFortQueryGenerator_Buildings");
static_assert(sizeof(UFortQueryGenerator_Buildings) == 0x0000FC, "Wrong size on UFortQueryGenerator_Buildings");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingGridVolumeCenter) == 0x000034, "Member 'UFortQueryGenerator_Buildings::BuildingGridVolumeCenter' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, HorizontalBuildingCellRadius) == 0x000038, "Member 'UFortQueryGenerator_Buildings::HorizontalBuildingCellRadius' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsAbove) == 0x000054, "Member 'UFortQueryGenerator_Buildings::BuildingCellsAbove' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, BuildingCellsBelow) == 0x000070, "Member 'UFortQueryGenerator_Buildings::BuildingCellsBelow' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeWalls) == 0x00008C, "Member 'UFortQueryGenerator_Buildings::bIncludeWalls' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeFloors) == 0x0000A8, "Member 'UFortQueryGenerator_Buildings::bIncludeFloors' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, bIncludeCenterCell) == 0x0000C4, "Member 'UFortQueryGenerator_Buildings::bIncludeCenterCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_Buildings, MaxBuildingActorsPerVolumeCenterToCollect) == 0x0000E0, "Member 'UFortQueryGenerator_Buildings::MaxBuildingActorsPerVolumeCenterToCollect' has a wrong offset!");

// Class FortniteGame.FortQueryContext_GoalProviderRootAssignmentGoals
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_GoalProviderRootAssignmentGoals final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_GoalProviderRootAssignmentGoals">();
	}
	static class UFortQueryContext_GoalProviderRootAssignmentGoals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_GoalProviderRootAssignmentGoals>();
	}
};
static_assert(alignof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x000004, "Wrong alignment on UFortQueryContext_GoalProviderRootAssignmentGoals");
static_assert(sizeof(UFortQueryContext_GoalProviderRootAssignmentGoals) == 0x00001C, "Wrong size on UFortQueryContext_GoalProviderRootAssignmentGoals");

// Class FortniteGame.FortPlayerStateManor
// 0x0000 (0x0760 - 0x0760)
class AFortPlayerStateManor final : public AFortPlayerStateZone
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStateManor">();
	}
	static class AFortPlayerStateManor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStateManor>();
	}
};
static_assert(alignof(AFortPlayerStateManor) == 0x000004, "Wrong alignment on AFortPlayerStateManor");
static_assert(sizeof(AFortPlayerStateManor) == 0x000760, "Wrong size on AFortPlayerStateManor");

// Class FortniteGame.FortPlayerStatePvP
// 0x0000 (0x0760 - 0x0760)
class AFortPlayerStatePvP final : public AFortPlayerStateZone
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortPlayerStatePvP">();
	}
	static class AFortPlayerStatePvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortPlayerStatePvP>();
	}
};
static_assert(alignof(AFortPlayerStatePvP) == 0x000004, "Wrong alignment on AFortPlayerStatePvP");
static_assert(sizeof(AFortPlayerStatePvP) == 0x000760, "Wrong size on AFortPlayerStatePvP");

// Class FortniteGame.FortQueryContext_AllEnemies
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_AllEnemies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_AllEnemies">();
	}
	static class UFortQueryContext_AllEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_AllEnemies>();
	}
};
static_assert(alignof(UFortQueryContext_AllEnemies) == 0x000004, "Wrong alignment on UFortQueryContext_AllEnemies");
static_assert(sizeof(UFortQueryContext_AllEnemies) == 0x00001C, "Wrong size on UFortQueryContext_AllEnemies");

// Class FortniteGame.FortQueryContext_EncounterGoalsCenterLocation
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterGoalsCenterLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterGoalsCenterLocation">();
	}
	static class UFortQueryContext_EncounterGoalsCenterLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterGoalsCenterLocation>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterGoalsCenterLocation");
static_assert(sizeof(UFortQueryContext_EncounterGoalsCenterLocation) == 0x00001C, "Wrong size on UFortQueryContext_EncounterGoalsCenterLocation");

// Class FortniteGame.FortQueryContext_EncounterQueryActor
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterQueryActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterQueryActor">();
	}
	static class UFortQueryContext_EncounterQueryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterQueryActor>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterQueryActor) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterQueryActor");
static_assert(sizeof(UFortQueryContext_EncounterQueryActor) == 0x00001C, "Wrong size on UFortQueryContext_EncounterQueryActor");

// Class FortniteGame.FortQueryContext_EncounterRandomDirection
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_EncounterRandomDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_EncounterRandomDirection">();
	}
	static class UFortQueryContext_EncounterRandomDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_EncounterRandomDirection>();
	}
};
static_assert(alignof(UFortQueryContext_EncounterRandomDirection) == 0x000004, "Wrong alignment on UFortQueryContext_EncounterRandomDirection");
static_assert(sizeof(UFortQueryContext_EncounterRandomDirection) == 0x00001C, "Wrong size on UFortQueryContext_EncounterRandomDirection");

// Class FortniteGame.FortQueryContext_NearbyFriends
// 0x0000 (0x001C - 0x001C)
class UFortQueryContext_NearbyFriends final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryContext_NearbyFriends">();
	}
	static class UFortQueryContext_NearbyFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryContext_NearbyFriends>();
	}
};
static_assert(alignof(UFortQueryContext_NearbyFriends) == 0x000004, "Wrong alignment on UFortQueryContext_NearbyFriends");
static_assert(sizeof(UFortQueryContext_NearbyFriends) == 0x00001C, "Wrong size on UFortQueryContext_NearbyFriends");

// Class FortniteGame.FortQueryGenerator_AssignmentGoal
// 0x0000 (0x0034 - 0x0034)
class UFortQueryGenerator_AssignmentGoal final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_AssignmentGoal">();
	}
	static class UFortQueryGenerator_AssignmentGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_AssignmentGoal>();
	}
};
static_assert(alignof(UFortQueryGenerator_AssignmentGoal) == 0x000004, "Wrong alignment on UFortQueryGenerator_AssignmentGoal");
static_assert(sizeof(UFortQueryGenerator_AssignmentGoal) == 0x000034, "Wrong size on UFortQueryGenerator_AssignmentGoal");

// Class FortniteGame.FortQueryGenerator_PointsFromNavGraph
// 0x005C (0x00B8 - 0x005C)
class UFortQueryGenerator_PointsFromNavGraph final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              MinPathDistance;                                   // 0x005C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathDistance;                                   // 0x0078(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               SkipCellsWithCollision;                            // 0x0094(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFortPointsFromNavGraphGoalPathDistanceFilterOperator PathDistanceFilterOperator;                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsFromNavGraph">();
	}
	static class UFortQueryGenerator_PointsFromNavGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsFromNavGraph>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsFromNavGraph) == 0x000004, "Wrong alignment on UFortQueryGenerator_PointsFromNavGraph");
static_assert(sizeof(UFortQueryGenerator_PointsFromNavGraph) == 0x0000B8, "Wrong size on UFortQueryGenerator_PointsFromNavGraph");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MinPathDistance) == 0x00005C, "Member 'UFortQueryGenerator_PointsFromNavGraph::MinPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, MaxPathDistance) == 0x000078, "Member 'UFortQueryGenerator_PointsFromNavGraph::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, SkipCellsWithCollision) == 0x000094, "Member 'UFortQueryGenerator_PointsFromNavGraph::SkipCellsWithCollision' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, PathDistanceFilterOperator) == 0x0000B0, "Member 'UFortQueryGenerator_PointsFromNavGraph::PathDistanceFilterOperator' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsFromNavGraph, GenerateAround) == 0x0000B4, "Member 'UFortQueryGenerator_PointsFromNavGraph::GenerateAround' has a wrong offset!");

// Class FortniteGame.FortQueryGenerator_PointsOnBuildingGrid
// 0x0040 (0x009C - 0x005C)
class UFortQueryGenerator_PointsOnBuildingGrid final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderIntValue                HorizontalGridSize;                                // 0x005C(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                VerticalGridSize;                                  // 0x0078(0x001C)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bStartGridFromBottom;                              // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUsePointInVerticalCenterOfCell;                   // 0x0095(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryGenerator_PointsOnBuildingGrid">();
	}
	static class UFortQueryGenerator_PointsOnBuildingGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryGenerator_PointsOnBuildingGrid>();
	}
};
static_assert(alignof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x000004, "Wrong alignment on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(sizeof(UFortQueryGenerator_PointsOnBuildingGrid) == 0x00009C, "Wrong size on UFortQueryGenerator_PointsOnBuildingGrid");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, HorizontalGridSize) == 0x00005C, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::HorizontalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, VerticalGridSize) == 0x000078, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::VerticalGridSize' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bStartGridFromBottom) == 0x000094, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bStartGridFromBottom' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, bUsePointInVerticalCenterOfCell) == 0x000095, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::bUsePointInVerticalCenterOfCell' has a wrong offset!");
static_assert(offsetof(UFortQueryGenerator_PointsOnBuildingGrid, GenerateAround) == 0x000098, "Member 'UFortQueryGenerator_PointsOnBuildingGrid::GenerateAround' has a wrong offset!");

// Class FortniteGame.FortQueryTest_CanBeDamaged
// 0x0000 (0x011C - 0x011C)
class UFortQueryTest_CanBeDamaged final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_CanBeDamaged">();
	}
	static class UFortQueryTest_CanBeDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_CanBeDamaged>();
	}
};
static_assert(alignof(UFortQueryTest_CanBeDamaged) == 0x000004, "Wrong alignment on UFortQueryTest_CanBeDamaged");
static_assert(sizeof(UFortQueryTest_CanBeDamaged) == 0x00011C, "Wrong size on UFortQueryTest_CanBeDamaged");

// Class FortniteGame.FortQueryTest_GoalDistance
// 0x000C (0x0128 - 0x011C)
class UFortQueryTest_GoalDistance final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistance">();
	}
	static class UFortQueryTest_GoalDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistance>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistance) == 0x000004, "Wrong alignment on UFortQueryTest_GoalDistance");
static_assert(sizeof(UFortQueryTest_GoalDistance) == 0x000128, "Wrong size on UFortQueryTest_GoalDistance");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceMode) == 0x00011C, "Member 'UFortQueryTest_GoalDistance::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, DistanceTo) == 0x000120, "Member 'UFortQueryTest_GoalDistance::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistance, TestMode) == 0x000124, "Member 'UFortQueryTest_GoalDistance::TestMode' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalDistanceRanges
// 0x0018 (0x0134 - 0x011C)
class UFortQueryTest_GoalDistanceRanges final : public UFortQueryTest_GoalBase
{
public:
	EDistanceMode                                 DistanceMode;                                      // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              ScreeningTestMode;                                 // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvTestDistance                              TestMode;                                          // 0x0125(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_126[0x2];                                      // 0x0126(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGoalDistanceData>              GoalDistanceDataRanges;                            // 0x0128(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalDistanceRanges">();
	}
	static class UFortQueryTest_GoalDistanceRanges* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalDistanceRanges>();
	}
};
static_assert(alignof(UFortQueryTest_GoalDistanceRanges) == 0x000004, "Wrong alignment on UFortQueryTest_GoalDistanceRanges");
static_assert(sizeof(UFortQueryTest_GoalDistanceRanges) == 0x000134, "Wrong size on UFortQueryTest_GoalDistanceRanges");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceMode) == 0x00011C, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, DistanceTo) == 0x000120, "Member 'UFortQueryTest_GoalDistanceRanges::DistanceTo' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, ScreeningTestMode) == 0x000124, "Member 'UFortQueryTest_GoalDistanceRanges::ScreeningTestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, TestMode) == 0x000125, "Member 'UFortQueryTest_GoalDistanceRanges::TestMode' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalDistanceRanges, GoalDistanceDataRanges) == 0x000128, "Member 'UFortQueryTest_GoalDistanceRanges::GoalDistanceDataRanges' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalStickiness
// 0x00BC (0x01D8 - 0x011C)
class UFortQueryTest_GoalStickiness final : public UFortQueryTest_GoalBase
{
public:
	struct FAIDataProviderFloatValue              StartValueForGoal;                                 // 0x011C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              EndValueForGoal;                                   // 0x0138(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              TimeBeforeValueLerp;                               // 0x0154(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              ValueLerpDuration;                                 // 0x0170(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               ApplyStickinessToAllGoalsWithSameActor;            // 0x018C(0x001C)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              StartValueForCurrentGoal;                          // 0x01A8(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              EndValueForCurrentGoal;                            // 0x01B4(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              TimeBeforeLerp;                                    // 0x01C0(0x000C)(Protected, NativeAccessSpecifierProtected)
	struct FEnvFloatParam_DEPRECATED              LerpDuration;                                      // 0x01CC(0x000C)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalStickiness">();
	}
	static class UFortQueryTest_GoalStickiness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalStickiness>();
	}
};
static_assert(alignof(UFortQueryTest_GoalStickiness) == 0x000004, "Wrong alignment on UFortQueryTest_GoalStickiness");
static_assert(sizeof(UFortQueryTest_GoalStickiness) == 0x0001D8, "Wrong size on UFortQueryTest_GoalStickiness");
static_assert(offsetof(UFortQueryTest_GoalStickiness, StartValueForGoal) == 0x00011C, "Member 'UFortQueryTest_GoalStickiness::StartValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, EndValueForGoal) == 0x000138, "Member 'UFortQueryTest_GoalStickiness::EndValueForGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, TimeBeforeValueLerp) == 0x000154, "Member 'UFortQueryTest_GoalStickiness::TimeBeforeValueLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ValueLerpDuration) == 0x000170, "Member 'UFortQueryTest_GoalStickiness::ValueLerpDuration' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, ApplyStickinessToAllGoalsWithSameActor) == 0x00018C, "Member 'UFortQueryTest_GoalStickiness::ApplyStickinessToAllGoalsWithSameActor' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, StartValueForCurrentGoal) == 0x0001A8, "Member 'UFortQueryTest_GoalStickiness::StartValueForCurrentGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, EndValueForCurrentGoal) == 0x0001B4, "Member 'UFortQueryTest_GoalStickiness::EndValueForCurrentGoal' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, TimeBeforeLerp) == 0x0001C0, "Member 'UFortQueryTest_GoalStickiness::TimeBeforeLerp' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_GoalStickiness, LerpDuration) == 0x0001CC, "Member 'UFortQueryTest_GoalStickiness::LerpDuration' has a wrong offset!");

// Class FortniteGame.FortQueryTest_GoalType
// 0x0000 (0x011C - 0x011C)
class UFortQueryTest_GoalType final : public UFortQueryTest_GoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_GoalType">();
	}
	static class UFortQueryTest_GoalType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_GoalType>();
	}
};
static_assert(alignof(UFortQueryTest_GoalType) == 0x000004, "Wrong alignment on UFortQueryTest_GoalType");
static_assert(sizeof(UFortQueryTest_GoalType) == 0x00011C, "Wrong size on UFortQueryTest_GoalType");

// Class FortniteGame.FortQueryTest_InsideBuilding
// 0x0000 (0x010C - 0x010C)
class UFortQueryTest_InsideBuilding final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_InsideBuilding">();
	}
	static class UFortQueryTest_InsideBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_InsideBuilding>();
	}
};
static_assert(alignof(UFortQueryTest_InsideBuilding) == 0x000004, "Wrong alignment on UFortQueryTest_InsideBuilding");
static_assert(sizeof(UFortQueryTest_InsideBuilding) == 0x00010C, "Wrong size on UFortQueryTest_InsideBuilding");

// Class FortniteGame.FortQueryTest_PerceptionAge
// 0x0008 (0x0114 - 0x010C)
class UFortQueryTest_PerceptionAge final : public UEnvQueryTest
{
public:
	ECorePerceptionTypes                          Sense;                                             // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense>                   SenseClass;                                        // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQueryTest_PerceptionAge">();
	}
	static class UFortQueryTest_PerceptionAge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQueryTest_PerceptionAge>();
	}
};
static_assert(alignof(UFortQueryTest_PerceptionAge) == 0x000004, "Wrong alignment on UFortQueryTest_PerceptionAge");
static_assert(sizeof(UFortQueryTest_PerceptionAge) == 0x000114, "Wrong size on UFortQueryTest_PerceptionAge");
static_assert(offsetof(UFortQueryTest_PerceptionAge, Sense) == 0x00010C, "Member 'UFortQueryTest_PerceptionAge::Sense' has a wrong offset!");
static_assert(offsetof(UFortQueryTest_PerceptionAge, SenseClass) == 0x000110, "Member 'UFortQueryTest_PerceptionAge::SenseClass' has a wrong offset!");

// Class FortniteGame.FortQuestCategory
// 0x0030 (0x004C - 0x001C)
class UFortQuestCategory final : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UFortQuestItem*>                 CurrentQuests;                                     // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExpanded;                                         // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortCategoryTableRow                  CategoryInfo;                                      // 0x0038(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x4];                                       // 0x0048(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasUnseenQuests() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestCategory">();
	}
	static class UFortQuestCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestCategory>();
	}
};
static_assert(alignof(UFortQuestCategory) == 0x000004, "Wrong alignment on UFortQuestCategory");
static_assert(sizeof(UFortQuestCategory) == 0x00004C, "Wrong size on UFortQuestCategory");
static_assert(offsetof(UFortQuestCategory, Name_0) == 0x00001C, "Member 'UFortQuestCategory::Name_0' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, CurrentQuests) == 0x000028, "Member 'UFortQuestCategory::CurrentQuests' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, bExpanded) == 0x000034, "Member 'UFortQuestCategory::bExpanded' has a wrong offset!");
static_assert(offsetof(UFortQuestCategory, CategoryInfo) == 0x000038, "Member 'UFortQuestCategory::CategoryInfo' has a wrong offset!");

// Class FortniteGame.FortQuestManager
// 0x0094 (0x00B0 - 0x001C)
class UFortQuestManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnQuestsUpdated;                                   // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnQuestRewardClaimed;                              // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNoQuestRewardsToClaim;                           // 0x0034(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDailyQuestRerolled;                              // 0x0040(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UFortQuestItem*>                 CurrentQuests;                                     // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UFortQuestCategory*>  CurrentCategorizedQuestsMap;                       // 0x0058(0x003C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortQuestObjectiveCompletion>  PendingChanges;                                    // 0x0094(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClaimNextCompletedQuestReward() const;
	void ClaimQuestReward(const class UFortQuestItem* Quest) const;
	void GetCurrentQuestsCategories(TArray<class UFortQuestCategory*>* Categories) const;
	class UFortQuestItem* GetQuestWithDefinition(const class UFortQuestItemDefinition* Definition) const;
	int32 GetRemainingDailyQuestRerolls() const;
	void GetSourceAndContextTags(struct FGameplayTagContainer* OutSourceTags, struct FGameplayTagContainer* OutContextTags) const;
	void GrantFirstDailyQuest() const;
	bool HasCompletedObjective(const class UFortQuestItemDefinition* Definition, const struct FDataTableRowHandle& ObjectiveStatHandle) const;
	bool HasCompletedQuest(const class UFortQuestItemDefinition* Definition) const;
	bool HasUnseenQuests() const;
	void MarkQuestSeen(class UFortQuestItem* Quest) const;
	void MarkQuestsSeen() const;
	void RerollDailyQuest(const class UFortQuestItem* QuestToDiscard) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortQuestManager">();
	}
	static class UFortQuestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortQuestManager>();
	}
};
static_assert(alignof(UFortQuestManager) == 0x000004, "Wrong alignment on UFortQuestManager");
static_assert(sizeof(UFortQuestManager) == 0x0000B0, "Wrong size on UFortQuestManager");
static_assert(offsetof(UFortQuestManager, OnQuestsUpdated) == 0x00001C, "Member 'UFortQuestManager::OnQuestsUpdated' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnQuestRewardClaimed) == 0x000028, "Member 'UFortQuestManager::OnQuestRewardClaimed' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnNoQuestRewardsToClaim) == 0x000034, "Member 'UFortQuestManager::OnNoQuestRewardsToClaim' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, OnDailyQuestRerolled) == 0x000040, "Member 'UFortQuestManager::OnDailyQuestRerolled' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, CurrentQuests) == 0x00004C, "Member 'UFortQuestManager::CurrentQuests' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, CurrentCategorizedQuestsMap) == 0x000058, "Member 'UFortQuestManager::CurrentCategorizedQuestsMap' has a wrong offset!");
static_assert(offsetof(UFortQuestManager, PendingChanges) == 0x000094, "Member 'UFortQuestManager::PendingChanges' has a wrong offset!");

// Class FortniteGame.FortRarityData
// 0x0460 (0x047C - 0x001C)
class UFortRarityData final : public UDataAsset
{
public:
	struct FFortRarityItemData                    RarityCollection[0xA];                             // 0x001C(0x0070)(Edit, NativeAccessSpecifierPublic)

public:
	static struct FFortRarityItemData BPGetRarityData(EFortRarity Rarity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortRarityData">();
	}
	static class UFortRarityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortRarityData>();
	}
};
static_assert(alignof(UFortRarityData) == 0x000004, "Wrong alignment on UFortRarityData");
static_assert(sizeof(UFortRarityData) == 0x00047C, "Wrong size on UFortRarityData");
static_assert(offsetof(UFortRarityData, RarityCollection) == 0x00001C, "Member 'UFortRarityData::RarityCollection' has a wrong offset!");

// Class FortniteGame.FortSaveFileBuildingInstructionsHandler
// 0x00A4 (0x02E4 - 0x0240)
class AFortSaveFileBuildingInstructionsHandler : public AActor
{
public:
	class FString                                 SaveFilename;                                      // 0x0240(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LoadedBuildingsScale;                              // 0x024C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LoadedBuildingsAdditionalTranslation;              // 0x0258(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUseAbsoluteCoordinates : 1;                       // 0x0264(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bTrackDestroyedBuildings : 1;                      // 0x0264(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFortBuildingInstructions> DefaultBuildingInstructions;                       // 0x0268(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoadInvisible : 1;                                // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDespawnOnLoad : 1;                                // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x63];                                     // 0x0281(0x0063)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreBuildingsLoaded();
	TArray<class ABuildingActor*> GetAllSpawnedBuildings();
	void LoadBuildings(class AFortPlayerController* FortPC);
	bool ResetBuildings(class AFortPlayerController* FortPC);
	bool SaveBuildings(class AFortPlayerController* FortPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSaveFileBuildingInstructionsHandler">();
	}
	static class AFortSaveFileBuildingInstructionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSaveFileBuildingInstructionsHandler>();
	}
};
static_assert(alignof(AFortSaveFileBuildingInstructionsHandler) == 0x000004, "Wrong alignment on AFortSaveFileBuildingInstructionsHandler");
static_assert(sizeof(AFortSaveFileBuildingInstructionsHandler) == 0x0002E4, "Wrong size on AFortSaveFileBuildingInstructionsHandler");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, SaveFilename) == 0x000240, "Member 'AFortSaveFileBuildingInstructionsHandler::SaveFilename' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, LoadedBuildingsScale) == 0x00024C, "Member 'AFortSaveFileBuildingInstructionsHandler::LoadedBuildingsScale' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, LoadedBuildingsAdditionalTranslation) == 0x000258, "Member 'AFortSaveFileBuildingInstructionsHandler::LoadedBuildingsAdditionalTranslation' has a wrong offset!");
static_assert(offsetof(AFortSaveFileBuildingInstructionsHandler, DefaultBuildingInstructions) == 0x000268, "Member 'AFortSaveFileBuildingInstructionsHandler::DefaultBuildingInstructions' has a wrong offset!");

// Class FortniteGame.FortScriptedAction
// 0x0034 (0x0274 - 0x0240)
class AFortScriptedAction final : public AActor
{
public:
	EFortScriptedActionEnvironment                ActionEnvironment;                                 // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortClientEventName                   ClientEventTrigger;                                // 0x0244(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ActionPriority;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFortScriptedActionParams              CachedParams;                                      // 0x0258(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsActive;                                         // 0x0270(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAction();
	void CompleteAction();
	void Execute(const struct FFortScriptedActionParams& Params_0);
	void GetParams(struct FFortScriptedActionParams* Params_0);

	bool CanExecute(const struct FFortScriptedActionParams& Params_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortScriptedAction">();
	}
	static class AFortScriptedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortScriptedAction>();
	}
};
static_assert(alignof(AFortScriptedAction) == 0x000004, "Wrong alignment on AFortScriptedAction");
static_assert(sizeof(AFortScriptedAction) == 0x000274, "Wrong size on AFortScriptedAction");
static_assert(offsetof(AFortScriptedAction, ActionEnvironment) == 0x000240, "Member 'AFortScriptedAction::ActionEnvironment' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, ClientEventTrigger) == 0x000244, "Member 'AFortScriptedAction::ClientEventTrigger' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, ActionPriority) == 0x000254, "Member 'AFortScriptedAction::ActionPriority' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, CachedParams) == 0x000258, "Member 'AFortScriptedAction::CachedParams' has a wrong offset!");
static_assert(offsetof(AFortScriptedAction, bIsActive) == 0x000270, "Member 'AFortScriptedAction::bIsActive' has a wrong offset!");

// Class FortniteGame.FortScriptedActionManager
// 0x002C (0x026C - 0x0240)
class AFortScriptedActionManager final : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortScriptedAction*>            ActiveScriptedActions;                             // 0x0244(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortAvailableScriptedAction>   AvailableScriptedActions;                          // 0x0250(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortClientEventName>           PendingClientEvents;                               // 0x025C(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsProcessingClientEvent;                          // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleClientEvent_Undefined(class UObject* EventSource, class UObject* EventFocus, const struct FFortClientEvent& ClientEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortScriptedActionManager">();
	}
	static class AFortScriptedActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortScriptedActionManager>();
	}
};
static_assert(alignof(AFortScriptedActionManager) == 0x000004, "Wrong alignment on AFortScriptedActionManager");
static_assert(sizeof(AFortScriptedActionManager) == 0x00026C, "Wrong size on AFortScriptedActionManager");
static_assert(offsetof(AFortScriptedActionManager, ActiveScriptedActions) == 0x000244, "Member 'AFortScriptedActionManager::ActiveScriptedActions' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, AvailableScriptedActions) == 0x000250, "Member 'AFortScriptedActionManager::AvailableScriptedActions' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, PendingClientEvents) == 0x00025C, "Member 'AFortScriptedActionManager::PendingClientEvents' has a wrong offset!");
static_assert(offsetof(AFortScriptedActionManager, bIsProcessingClientEvent) == 0x000268, "Member 'AFortScriptedActionManager::bIsProcessingClientEvent' has a wrong offset!");

// Class FortniteGame.FortSocialItem
// 0x0048 (0x0064 - 0x001C)
class UFortSocialItem final : public UObject
{
public:
	EFortSocialItemType                           SocialItemType;                                    // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HeaderName;                                        // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPresenceUpdated;                                 // 0x002C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInviteJoinUpdated;                               // 0x0038(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x20];                                      // 0x0044(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FFortSocialItemBasicData GetBasicInfo();

	class FText GetDisplayName() const;
	class FText GetLocation() const;
	EFortSocialItemPresenceStatus GetPresenceStatus() const;
	struct FUniqueNetIdRepl GetUniquePlayerId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSocialItem">();
	}
	static class UFortSocialItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSocialItem>();
	}
};
static_assert(alignof(UFortSocialItem) == 0x000004, "Wrong alignment on UFortSocialItem");
static_assert(sizeof(UFortSocialItem) == 0x000064, "Wrong size on UFortSocialItem");
static_assert(offsetof(UFortSocialItem, SocialItemType) == 0x00001C, "Member 'UFortSocialItem::SocialItemType' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, HeaderName) == 0x000020, "Member 'UFortSocialItem::HeaderName' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, OnPresenceUpdated) == 0x00002C, "Member 'UFortSocialItem::OnPresenceUpdated' has a wrong offset!");
static_assert(offsetof(UFortSocialItem, OnInviteJoinUpdated) == 0x000038, "Member 'UFortSocialItem::OnInviteJoinUpdated' has a wrong offset!");

// Class FortniteGame.FortSpawnPointsPercentageCurveSequence
// 0x0010 (0x002C - 0x001C)
class UFortSpawnPointsPercentageCurveSequence final : public UDataAsset
{
public:
	TArray<struct FDataTableRowHandle>            SpawnPointsPercentageCurves;                       // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EFortIntensityCurveSequenceType               SequenceType;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpawnPointsPercentageCurveSequence">();
	}
	static class UFortSpawnPointsPercentageCurveSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortSpawnPointsPercentageCurveSequence>();
	}
};
static_assert(alignof(UFortSpawnPointsPercentageCurveSequence) == 0x000004, "Wrong alignment on UFortSpawnPointsPercentageCurveSequence");
static_assert(sizeof(UFortSpawnPointsPercentageCurveSequence) == 0x00002C, "Wrong size on UFortSpawnPointsPercentageCurveSequence");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SpawnPointsPercentageCurves) == 0x00001C, "Member 'UFortSpawnPointsPercentageCurveSequence::SpawnPointsPercentageCurves' has a wrong offset!");
static_assert(offsetof(UFortSpawnPointsPercentageCurveSequence, SequenceType) == 0x000028, "Member 'UFortSpawnPointsPercentageCurveSequence::SequenceType' has a wrong offset!");

// Class FortniteGame.StatManager
// 0x0058 (0x0074 - 0x001C)
class UStatManager final : public UObject
{
public:
	TArray<class UStat*>                          Stats;                                             // 0x001C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 StatPrefix;                                        // 0x0028(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFortPlayerController*                  FPC;                                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x3C];                                      // 0x0038(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatManager">();
	}
	static class UStatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatManager>();
	}
};
static_assert(alignof(UStatManager) == 0x000004, "Wrong alignment on UStatManager");
static_assert(sizeof(UStatManager) == 0x000074, "Wrong size on UStatManager");
static_assert(offsetof(UStatManager, Stats) == 0x00001C, "Member 'UStatManager::Stats' has a wrong offset!");
static_assert(offsetof(UStatManager, StatPrefix) == 0x000028, "Member 'UStatManager::StatPrefix' has a wrong offset!");
static_assert(offsetof(UStatManager, FPC) == 0x000034, "Member 'UStatManager::FPC' has a wrong offset!");

// Class FortniteGame.FortStatEventManager
// 0x0048 (0x0064 - 0x001C)
class UFortStatEventManager final : public UObject
{
public:
	class AFortPlayerController*                  FPC;                                               // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEvent>                 StatEvents;                                        // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEventSequence>         StatEventSequences;                                // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PinnedSchematicNotification;                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PinnedCanCraftStats;                               // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PinnedCanNotCraftStats;                            // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FFortStatEventSequence>         PinnedSchematicSequences;                          // 0x0058(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStatEventManager">();
	}
	static class UFortStatEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStatEventManager>();
	}
};
static_assert(alignof(UFortStatEventManager) == 0x000004, "Wrong alignment on UFortStatEventManager");
static_assert(sizeof(UFortStatEventManager) == 0x000064, "Wrong size on UFortStatEventManager");
static_assert(offsetof(UFortStatEventManager, FPC) == 0x00001C, "Member 'UFortStatEventManager::FPC' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, StatEvents) == 0x000020, "Member 'UFortStatEventManager::StatEvents' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, StatEventSequences) == 0x00002C, "Member 'UFortStatEventManager::StatEventSequences' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedSchematicNotification) == 0x000038, "Member 'UFortStatEventManager::PinnedSchematicNotification' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedCanCraftStats) == 0x000040, "Member 'UFortStatEventManager::PinnedCanCraftStats' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedCanNotCraftStats) == 0x00004C, "Member 'UFortStatEventManager::PinnedCanNotCraftStats' has a wrong offset!");
static_assert(offsetof(UFortStatEventManager, PinnedSchematicSequences) == 0x000058, "Member 'UFortStatEventManager::PinnedSchematicSequences' has a wrong offset!");

// Class FortniteGame.FortStaticMeshActor
// 0x000C (0x0254 - 0x0248)
class AFortStaticMeshActor final : public AStaticMeshActor
{
public:
	TArray<class UNavRelevantComponent*>          LinkComps;                                         // 0x0248(0x000C)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshActor">();
	}
	static class AFortStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortStaticMeshActor>();
	}
};
static_assert(alignof(AFortStaticMeshActor) == 0x000004, "Wrong alignment on AFortStaticMeshActor");
static_assert(sizeof(AFortStaticMeshActor) == 0x000254, "Wrong size on AFortStaticMeshActor");
static_assert(offsetof(AFortStaticMeshActor, LinkComps) == 0x000248, "Member 'AFortStaticMeshActor::LinkComps' has a wrong offset!");

// Class FortniteGame.FortStaticMeshLinkComponent
// 0x0018 (0x00CC - 0x00B4)
class UFortStaticMeshLinkComponent final : public UNavRelevantComponent
{
public:
	uint8                                         Pad_B4[0x18];                                      // 0x00B4(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshLinkComponent">();
	}
	static class UFortStaticMeshLinkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStaticMeshLinkComponent>();
	}
};
static_assert(alignof(UFortStaticMeshLinkComponent) == 0x000004, "Wrong alignment on UFortStaticMeshLinkComponent");
static_assert(sizeof(UFortStaticMeshLinkComponent) == 0x0000CC, "Wrong size on UFortStaticMeshLinkComponent");

// Class FortniteGame.FortStaticMeshUserData
// 0x000C (0x0028 - 0x001C)
class UFortStaticMeshUserData final : public UAssetUserData
{
public:
	TArray<struct FTransformableNavLinkClass>     NavLinks;                                          // 0x001C(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortStaticMeshUserData">();
	}
	static class UFortStaticMeshUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortStaticMeshUserData>();
	}
};
static_assert(alignof(UFortStaticMeshUserData) == 0x000004, "Wrong alignment on UFortStaticMeshUserData");
static_assert(sizeof(UFortStaticMeshUserData) == 0x000028, "Wrong size on UFortStaticMeshUserData");
static_assert(offsetof(UFortStaticMeshUserData, NavLinks) == 0x00001C, "Member 'UFortStaticMeshUserData::NavLinks' has a wrong offset!");

// Class FortniteGame.FortTaggedActorsManager
// 0x0354 (0x0370 - 0x001C)
class UFortTaggedActorsManager final : public UObject
{
public:
	uint8                                         Pad_1C[0x354];                                     // 0x001C(0x0354)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTaggedActorsManager">();
	}
	static class UFortTaggedActorsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTaggedActorsManager>();
	}
};
static_assert(alignof(UFortTaggedActorsManager) == 0x000004, "Wrong alignment on UFortTaggedActorsManager");
static_assert(sizeof(UFortTaggedActorsManager) == 0x000370, "Wrong size on UFortTaggedActorsManager");

// Class FortniteGame.FortTeamIdentification
// 0x0008 (0x0024 - 0x001C)
class UFortTeamIdentification : public UObject
{
public:
	struct FColor                                 HUDColor;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCustomAccessoryColorSwatch*            CharacterAccessoryColorSwatch;                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamIdentification">();
	}
	static class UFortTeamIdentification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTeamIdentification>();
	}
};
static_assert(alignof(UFortTeamIdentification) == 0x000004, "Wrong alignment on UFortTeamIdentification");
static_assert(sizeof(UFortTeamIdentification) == 0x000024, "Wrong size on UFortTeamIdentification");
static_assert(offsetof(UFortTeamIdentification, HUDColor) == 0x00001C, "Member 'UFortTeamIdentification::HUDColor' has a wrong offset!");
static_assert(offsetof(UFortTeamIdentification, CharacterAccessoryColorSwatch) == 0x000020, "Member 'UFortTeamIdentification::CharacterAccessoryColorSwatch' has a wrong offset!");

// Class FortniteGame.FortTeamInfo
// 0x00A8 (0x02E8 - 0x0240)
class AFortTeamInfo : public AInfo
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    TeamMembers;                                       // 0x0244(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EFortTeam                                     Team;                                              // 0x0250(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTeamSpottedActorInfoArray             TeamSpottedActors;                                 // 0x0254(0x0090)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetTeamExperience() const;
	int32 GetTeamLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamInfo">();
	}
	static class AFortTeamInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTeamInfo>();
	}
};
static_assert(alignof(AFortTeamInfo) == 0x000004, "Wrong alignment on AFortTeamInfo");
static_assert(sizeof(AFortTeamInfo) == 0x0002E8, "Wrong size on AFortTeamInfo");
static_assert(offsetof(AFortTeamInfo, TeamMembers) == 0x000244, "Member 'AFortTeamInfo::TeamMembers' has a wrong offset!");
static_assert(offsetof(AFortTeamInfo, Team) == 0x000250, "Member 'AFortTeamInfo::Team' has a wrong offset!");
static_assert(offsetof(AFortTeamInfo, TeamSpottedActors) == 0x000254, "Member 'AFortTeamInfo::TeamSpottedActors' has a wrong offset!");

// Class FortniteGame.FortTeamInfoPvPBaseDestruction
// 0x00B4 (0x039C - 0x02E8)
class AFortTeamInfoPvPBaseDestruction final : public AFortTeamInfo
{
public:
	class AFortPvPBaseCornerstone*                TeamCornerstone;                                   // 0x02E8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTeamStrategicBuildingEntryArray       TeamStrategicBuildingActors;                       // 0x02EC(0x008C)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         StrategicBuildingHandleGenerator;                  // 0x0378(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TeamLevel;                                         // 0x037C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleTeamLevelChanged;                          // 0x0380(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	int32                                         TeamExperience;                                    // 0x038C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnHandleTeamXPChanged;                             // 0x0390(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_TeamExperience();
	void OnRep_TeamLevel();

	class AStrategicBuildingActor* GetStrategicBuildingActor(const struct FTeamStrategicBuildingHandle& Handle) const;
	class AFortPvPBaseCornerstone* GetTeamCornerstone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTeamInfoPvPBaseDestruction">();
	}
	static class AFortTeamInfoPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTeamInfoPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortTeamInfoPvPBaseDestruction) == 0x000004, "Wrong alignment on AFortTeamInfoPvPBaseDestruction");
static_assert(sizeof(AFortTeamInfoPvPBaseDestruction) == 0x00039C, "Wrong size on AFortTeamInfoPvPBaseDestruction");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamCornerstone) == 0x0002E8, "Member 'AFortTeamInfoPvPBaseDestruction::TeamCornerstone' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamStrategicBuildingActors) == 0x0002EC, "Member 'AFortTeamInfoPvPBaseDestruction::TeamStrategicBuildingActors' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, StrategicBuildingHandleGenerator) == 0x000378, "Member 'AFortTeamInfoPvPBaseDestruction::StrategicBuildingHandleGenerator' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamLevel) == 0x00037C, "Member 'AFortTeamInfoPvPBaseDestruction::TeamLevel' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnHandleTeamLevelChanged) == 0x000380, "Member 'AFortTeamInfoPvPBaseDestruction::OnHandleTeamLevelChanged' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, TeamExperience) == 0x00038C, "Member 'AFortTeamInfoPvPBaseDestruction::TeamExperience' has a wrong offset!");
static_assert(offsetof(AFortTeamInfoPvPBaseDestruction, OnHandleTeamXPChanged) == 0x000390, "Member 'AFortTeamInfoPvPBaseDestruction::OnHandleTeamXPChanged' has a wrong offset!");

// Class FortniteGame.FortTheaterList
// 0x000C (0x0028 - 0x001C)
class UFortTheaterList final : public UDataAsset
{
public:
	TArray<class UFortTheaterInfo*>               ActiveTheatersList;                                // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterList">();
	}
	static class UFortTheaterList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTheaterList>();
	}
};
static_assert(alignof(UFortTheaterList) == 0x000004, "Wrong alignment on UFortTheaterList");
static_assert(sizeof(UFortTheaterList) == 0x000028, "Wrong size on UFortTheaterList");
static_assert(offsetof(UFortTheaterList, ActiveTheatersList) == 0x00001C, "Member 'UFortTheaterList::ActiveTheatersList' has a wrong offset!");

// Class FortniteGame.FortTheaterMapTile
// 0x0140 (0x0380 - 0x0240)
class AFortTheaterMapTile : public AActor
{
public:
	bool                                          bFocused;                                          // 0x0240(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHostSelected;                                     // 0x0241(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGoToPromptEnabled;                                // 0x0242(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_243[0x1];                                      // 0x0243(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFortHexMapCoord                       MapCoord;                                          // 0x0244(0x000C)(NativeAccessSpecifierPublic)
	bool                                          bHasFinishedLoading;                               // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EFortTheaterMapTileType                       TileType;                                          // 0x0251(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252[0x2];                                      // 0x0252(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFortZoneTheme>             ZoneThemeClass;                                    // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TileIndex;                                         // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RegionIndex;                                       // 0x025C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SelectionOffset;                                   // 0x0260(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                FocusOffset;                                       // 0x026C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SelectionInterpSpeed;                              // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalBrightness;                                  // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockedBrightness;                                  // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusedBrightness;                                 // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectedBrightnessRange;                           // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectedPulseSpeed;                                // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableBrightnessCode;                             // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticMeshMaterialID;                              // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialLocation;                                   // 0x0298(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFortAvailableMissionData              MissionData;                                       // 0x02A4(0x0060)(Protected, NativeAccessSpecifierProtected)
	struct FFortAvailableMissionData              LastValidMissionData;                              // 0x0304(0x0060)(Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ZoneDifficultyInfo;                                // 0x0364(0x000C)(Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0370(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AdjacencyMIDs;                                     // 0x0374(0x000C)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnClientDeselect();
	void OnClientSelect();
	void OnDefocus();
	void OnDeselectWrapper(bool bIsGameSessionOwner);
	void OnDisableGoToPrompt();
	void OnEnableGoToPrompt();
	void OnFocus();
	void OnHostDeselect();
	void OnHostSelect();
	void OnInitializeTile();
	void OnMissionDataUpdated();
	void OnMouseOverBegin();
	void OnMouseOverEnd();
	void OnSelectWrapper(bool bIsGameSessionOwner);
	void OnTileClicked();

	struct FGameDifficultyInfo GetZoneDifficulty() const;
	bool HasValidMissionData() const;
	bool IsTileHidden() const;
	bool IsTileLocked() const;
	bool IsTilePlayable() const;
	bool IsTileSelectable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTheaterMapTile">();
	}
	static class AFortTheaterMapTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTheaterMapTile>();
	}
};
static_assert(alignof(AFortTheaterMapTile) == 0x000004, "Wrong alignment on AFortTheaterMapTile");
static_assert(sizeof(AFortTheaterMapTile) == 0x000380, "Wrong size on AFortTheaterMapTile");
static_assert(offsetof(AFortTheaterMapTile, bFocused) == 0x000240, "Member 'AFortTheaterMapTile::bFocused' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bHostSelected) == 0x000241, "Member 'AFortTheaterMapTile::bHostSelected' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bGoToPromptEnabled) == 0x000242, "Member 'AFortTheaterMapTile::bGoToPromptEnabled' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, MapCoord) == 0x000244, "Member 'AFortTheaterMapTile::MapCoord' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bHasFinishedLoading) == 0x000250, "Member 'AFortTheaterMapTile::bHasFinishedLoading' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, TileType) == 0x000251, "Member 'AFortTheaterMapTile::TileType' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, ZoneThemeClass) == 0x000254, "Member 'AFortTheaterMapTile::ZoneThemeClass' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, TileIndex) == 0x000258, "Member 'AFortTheaterMapTile::TileIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, RegionIndex) == 0x00025C, "Member 'AFortTheaterMapTile::RegionIndex' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectionOffset) == 0x000260, "Member 'AFortTheaterMapTile::SelectionOffset' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, FocusOffset) == 0x00026C, "Member 'AFortTheaterMapTile::FocusOffset' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectionInterpSpeed) == 0x000278, "Member 'AFortTheaterMapTile::SelectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, NormalBrightness) == 0x00027C, "Member 'AFortTheaterMapTile::NormalBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, LockedBrightness) == 0x000280, "Member 'AFortTheaterMapTile::LockedBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, FocusedBrightness) == 0x000284, "Member 'AFortTheaterMapTile::FocusedBrightness' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectedBrightnessRange) == 0x000288, "Member 'AFortTheaterMapTile::SelectedBrightnessRange' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, SelectedPulseSpeed) == 0x00028C, "Member 'AFortTheaterMapTile::SelectedPulseSpeed' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, bEnableBrightnessCode) == 0x000290, "Member 'AFortTheaterMapTile::bEnableBrightnessCode' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, StaticMeshMaterialID) == 0x000294, "Member 'AFortTheaterMapTile::StaticMeshMaterialID' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, InitialLocation) == 0x000298, "Member 'AFortTheaterMapTile::InitialLocation' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, MissionData) == 0x0002A4, "Member 'AFortTheaterMapTile::MissionData' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, LastValidMissionData) == 0x000304, "Member 'AFortTheaterMapTile::LastValidMissionData' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, ZoneDifficultyInfo) == 0x000364, "Member 'AFortTheaterMapTile::ZoneDifficultyInfo' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, StaticMeshComponent) == 0x000370, "Member 'AFortTheaterMapTile::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AFortTheaterMapTile, AdjacencyMIDs) == 0x000374, "Member 'AFortTheaterMapTile::AdjacencyMIDs' has a wrong offset!");

// Class FortniteGame.FortThreatParticleActor
// 0x0004 (0x0244 - 0x0240)
class AFortThreatParticleActor : public AActor
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnThreatCloudsChanged(const TArray<struct FThreatLocationInfo>& ThreatLocationInfo);

	TArray<struct FThreatLocationInfo> GetThreatClouds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortThreatParticleActor">();
	}
	static class AFortThreatParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortThreatParticleActor>();
	}
};
static_assert(alignof(AFortThreatParticleActor) == 0x000004, "Wrong alignment on AFortThreatParticleActor");
static_assert(sizeof(AFortThreatParticleActor) == 0x000244, "Wrong size on AFortThreatParticleActor");

// Class FortniteGame.FortTips
// 0x000C (0x0028 - 0x001C)
class UFortTips final : public UDataAsset
{
public:
	TArray<class FText>                           Tips;                                              // 0x001C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTips">();
	}
	static class UFortTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortTips>();
	}
};
static_assert(alignof(UFortTips) == 0x000004, "Wrong alignment on UFortTips");
static_assert(sizeof(UFortTips) == 0x000028, "Wrong size on UFortTips");
static_assert(offsetof(UFortTips, Tips) == 0x00001C, "Member 'UFortTips::Tips' has a wrong offset!");

// Class FortniteGame.FortGameplayAbilityTooltip
// 0x0054 (0x007C - 0x0028)
class UFortGameplayAbilityTooltip : public UFortTooltip
{
public:
	struct FGameplayAbilitySpec                   CachedSpec;                                        // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UFortTooltipContext*                    CachedContext;                                     // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilitySpec(const struct FGameplayAbilitySpec& Spec, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTextForTokenFromAbilitySpecInternal(const struct FGameplayAbilitySpec& Spec, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGameplayAbilityTooltip">();
	}
	static class UFortGameplayAbilityTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGameplayAbilityTooltip>();
	}
};
static_assert(alignof(UFortGameplayAbilityTooltip) == 0x000004, "Wrong alignment on UFortGameplayAbilityTooltip");
static_assert(sizeof(UFortGameplayAbilityTooltip) == 0x00007C, "Wrong size on UFortGameplayAbilityTooltip");
static_assert(offsetof(UFortGameplayAbilityTooltip, CachedSpec) == 0x000028, "Member 'UFortGameplayAbilityTooltip::CachedSpec' has a wrong offset!");
static_assert(offsetof(UFortGameplayAbilityTooltip, CachedContext) == 0x000078, "Member 'UFortGameplayAbilityTooltip::CachedContext' has a wrong offset!");

// Class FortniteGame.FortGadgetItemDefinitionTooltip
// 0x0000 (0x0028 - 0x0028)
class UFortGadgetItemDefinitionTooltip final : public UFortWorldItemDefinitionTooltip
{
public:
	bool GetTextForToken(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, const class FName& Token, class FText* OutText) const;
	bool GetTokenizedDescriptionText(const class UObject* ObjectToDescribe, const struct FGameplayTag& Tag, const class UFortTooltipContext* Context, class FText* OutDescription) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortGadgetItemDefinitionTooltip">();
	}
	static class UFortGadgetItemDefinitionTooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortGadgetItemDefinitionTooltip>();
	}
};
static_assert(alignof(UFortGadgetItemDefinitionTooltip) == 0x000004, "Wrong alignment on UFortGadgetItemDefinitionTooltip");
static_assert(sizeof(UFortGadgetItemDefinitionTooltip) == 0x000028, "Wrong size on UFortGadgetItemDefinitionTooltip");

// Class FortniteGame.FortTracerBase
// 0x0064 (0x02A4 - 0x0240)
class AFortTracerBase : public AActor
{
public:
	class UMovementComp_Tracer*                   TracerMovementComponent;                           // 0x0240(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   TracerMesh;                                        // 0x0244(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCurveTableRowHandle                   Speed;                                             // 0x0248(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                MeshScaleMult;                                     // 0x0254(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MeshScaleTime;                                     // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleOnDeath;                                     // 0x0264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracerDistance;                                    // 0x0268(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Destination;                                       // 0x026C(0x000C)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x2C];                                     // 0x0278(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(const struct FVector& Start, const struct FVector& End);
	void OnInitTracerDistance(float Distance);
	void OnRep_TracerDistance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTracerBase">();
	}
	static class AFortTracerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTracerBase>();
	}
};
static_assert(alignof(AFortTracerBase) == 0x000004, "Wrong alignment on AFortTracerBase");
static_assert(sizeof(AFortTracerBase) == 0x0002A4, "Wrong size on AFortTracerBase");
static_assert(offsetof(AFortTracerBase, TracerMovementComponent) == 0x000240, "Member 'AFortTracerBase::TracerMovementComponent' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, TracerMesh) == 0x000244, "Member 'AFortTracerBase::TracerMesh' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, Speed) == 0x000248, "Member 'AFortTracerBase::Speed' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, MeshScaleMult) == 0x000254, "Member 'AFortTracerBase::MeshScaleMult' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, MeshScaleTime) == 0x000260, "Member 'AFortTracerBase::MeshScaleTime' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, bScaleOnDeath) == 0x000264, "Member 'AFortTracerBase::bScaleOnDeath' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, TracerDistance) == 0x000268, "Member 'AFortTracerBase::TracerDistance' has a wrong offset!");
static_assert(offsetof(AFortTracerBase, Destination) == 0x00026C, "Member 'AFortTracerBase::Destination' has a wrong offset!");

// Class FortniteGame.FortUIPvP
// 0x0004 (0x0524 - 0x0520)
class AFortUIPvP : public AFortUIZone
{
public:
	uint8                                         Pad_520[0x4];                                      // 0x0520(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIPvP">();
	}
	static class AFortUIPvP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIPvP>();
	}
};
static_assert(alignof(AFortUIPvP) == 0x000004, "Wrong alignment on AFortUIPvP");
static_assert(sizeof(AFortUIPvP) == 0x000524, "Wrong size on AFortUIPvP");

// Class FortniteGame.FortUIPvPBaseDestruction
// 0x0000 (0x0524 - 0x0524)
class AFortUIPvPBaseDestruction final : public AFortUIPvP
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIPvPBaseDestruction">();
	}
	static class AFortUIPvPBaseDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortUIPvPBaseDestruction>();
	}
};
static_assert(alignof(AFortUIPvPBaseDestruction) == 0x000004, "Wrong alignment on AFortUIPvPBaseDestruction");
static_assert(sizeof(AFortUIPvPBaseDestruction) == 0x000524, "Wrong size on AFortUIPvPBaseDestruction");

// Class FortniteGame.FortUIFeedbackBank
// 0x0054 (0x0070 - 0x001C)
class UFortUIFeedbackBank final : public UDataAsset
{
public:
	uint8                                         Pad_1C[0x3C];                                      // 0x001C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortUIFeedback>                FeedbackEvents;                                    // 0x0058(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FFortUIFeedbackBlueprintOnly>   BankDefinedFeedbackEvents;                         // 0x0064(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIFeedbackBank">();
	}
	static class UFortUIFeedbackBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortUIFeedbackBank>();
	}
};
static_assert(alignof(UFortUIFeedbackBank) == 0x000004, "Wrong alignment on UFortUIFeedbackBank");
static_assert(sizeof(UFortUIFeedbackBank) == 0x000070, "Wrong size on UFortUIFeedbackBank");
static_assert(offsetof(UFortUIFeedbackBank, FeedbackEvents) == 0x000058, "Member 'UFortUIFeedbackBank::FeedbackEvents' has a wrong offset!");
static_assert(offsetof(UFortUIFeedbackBank, BankDefinedFeedbackEvents) == 0x000064, "Member 'UFortUIFeedbackBank::BankDefinedFeedbackEvents' has a wrong offset!");

// Class FortniteGame.FortUIManagerInterface
// 0x0000 (0x001C - 0x001C)
class IFortUIManagerInterface final : public IInterface
{
public:
	void KillConfirmation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortUIManagerInterface">();
	}
	static class IFortUIManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFortUIManagerInterface>();
	}
};
static_assert(alignof(IFortUIManagerInterface) == 0x000004, "Wrong alignment on IFortUIManagerInterface");
static_assert(sizeof(IFortUIManagerInterface) == 0x00001C, "Wrong size on IFortUIManagerInterface");

// Class FortniteGame.FortMiniMapComponent
// 0x0088 (0x0128 - 0x00A0)
class UFortMiniMapComponent final : public UFortVisibilityComponent
{
public:
	struct FFortMiniMapData                       MiniMapData;                                       // 0x00A0(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, Net, SaveGame, RepNotify, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UFortMiniMapIndicator>   MiniMapIndicator;                                  // 0x0114(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0xC];                                      // 0x011C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MiniMapData();
	void SetMiniMapIcon(class UTexture2D* MiniMapIcon);
	void SetMiniMapIconColor(const struct FLinearColor& InColor);
	void SetMiniMapIconColorPulsesPerSecond(float ColorPulsesPerSecond);
	void SetMiniMapIconPulseColor(const struct FLinearColor& PulseColor);
	void SetMiniMapIconSizePulsesPerSecond(float SizePulsesPerSecond);
	void SetMiniMapIndicatorIsVisible(bool bVisible);
	void SetMiniMapViewableDistance(float ViewDistance);
	void SetupMiniMapComponent(class UTexture2D* MiniMapIcon, const struct FLinearColor& IconColor, const struct FLinearColor& PulseColor, float ColorPulsesPerSecond, float SizePulsesPerSecond);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortMiniMapComponent">();
	}
	static class UFortMiniMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortMiniMapComponent>();
	}
};
static_assert(alignof(UFortMiniMapComponent) == 0x000004, "Wrong alignment on UFortMiniMapComponent");
static_assert(sizeof(UFortMiniMapComponent) == 0x000128, "Wrong size on UFortMiniMapComponent");
static_assert(offsetof(UFortMiniMapComponent, MiniMapData) == 0x0000A0, "Member 'UFortMiniMapComponent::MiniMapData' has a wrong offset!");
static_assert(offsetof(UFortMiniMapComponent, MiniMapIndicator) == 0x000114, "Member 'UFortMiniMapComponent::MiniMapIndicator' has a wrong offset!");

// Class FortniteGame.FortVisibilityManager
// 0x009C (0x02DC - 0x0240)
class AFortVisibilityManager final : public AActor
{
public:
	uint8                                         Pad_240[0xC];                                      // 0x0240(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVisibiltyInfoArray                    VisibilityInfoArray;                               // 0x024C(0x008C)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x4];                                      // 0x02D8(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortVisibilityManager">();
	}
	static class AFortVisibilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortVisibilityManager>();
	}
};
static_assert(alignof(AFortVisibilityManager) == 0x000004, "Wrong alignment on AFortVisibilityManager");
static_assert(sizeof(AFortVisibilityManager) == 0x0002DC, "Wrong size on AFortVisibilityManager");
static_assert(offsetof(AFortVisibilityManager, VisibilityInfoArray) == 0x00024C, "Member 'AFortVisibilityManager::VisibilityInfoArray' has a wrong offset!");

// Class FortniteGame.FortCustomizableAbilityDecoTool
// 0x0000 (0x0640 - 0x0640)
class AFortCustomizableAbilityDecoTool : public AFortAbilityDecoTool
{
public:
	void BPOnEquip(class AFortWeapon* OldWeapon);
	void BPOnSetDecoObjectPreview(class AFortDecoHelper* FortDecoHelper);
	void BPOnUnEquip();
	void BPPressSecondaryFire(class AFortDecoHelper* FortDecoHelper);
	void BPPressTrigger(class AFortDecoHelper* FortDecoHelper);
	void BPReleaseSecondaryFire(class AFortDecoHelper* FortDecoHelper);
	void BPReleaseTrigger(class AFortDecoHelper* FortDecoHelper);
	void BPServerPressSecondaryFire();
	void BPServerReleaseSecondaryFire();
	void ServerPressSecondaryFire();
	void ServerPressTrigger();
	void ServerReleaseSecondaryFire();
	void ServerReleaseTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCustomizableAbilityDecoTool">();
	}
	static class AFortCustomizableAbilityDecoTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCustomizableAbilityDecoTool>();
	}
};
static_assert(alignof(AFortCustomizableAbilityDecoTool) == 0x000004, "Wrong alignment on AFortCustomizableAbilityDecoTool");
static_assert(sizeof(AFortCustomizableAbilityDecoTool) == 0x000640, "Wrong size on AFortCustomizableAbilityDecoTool");

// Class FortniteGame.FortTrapTool
// 0x0000 (0x0620 - 0x0620)
class AFortTrapTool : public AFortDecoTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortTrapTool">();
	}
	static class AFortTrapTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortTrapTool>();
	}
};
static_assert(alignof(AFortTrapTool) == 0x000004, "Wrong alignment on AFortTrapTool");
static_assert(sizeof(AFortTrapTool) == 0x000620, "Wrong size on AFortTrapTool");

// Class FortniteGame.FortWeap_EditingTool
// 0x0008 (0x0614 - 0x060C)
class AFortWeap_EditingTool : public AFortWeap_BuildingToolBase
{
public:
	class ABuildingSMActor*                       EditActor;                                         // 0x060C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEditConfirmed;                                    // 0x0610(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EditActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWeap_EditingTool">();
	}
	static class AFortWeap_EditingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWeap_EditingTool>();
	}
};
static_assert(alignof(AFortWeap_EditingTool) == 0x000004, "Wrong alignment on AFortWeap_EditingTool");
static_assert(sizeof(AFortWeap_EditingTool) == 0x000614, "Wrong size on AFortWeap_EditingTool");
static_assert(offsetof(AFortWeap_EditingTool, EditActor) == 0x00060C, "Member 'AFortWeap_EditingTool::EditActor' has a wrong offset!");
static_assert(offsetof(AFortWeap_EditingTool, bEditConfirmed) == 0x000610, "Member 'AFortWeap_EditingTool::bEditConfirmed' has a wrong offset!");

// Class FortniteGame.WorldTileManager
// 0x0040 (0x005C - 0x001C)
class UWorldTileManager final : public UObject
{
public:
	class AFortWorldManager*                      WorldManager;                                      // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x3C];                                      // 0x0020(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldTileManager">();
	}
	static class UWorldTileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldTileManager>();
	}
};
static_assert(alignof(UWorldTileManager) == 0x000004, "Wrong alignment on UWorldTileManager");
static_assert(sizeof(UWorldTileManager) == 0x00005C, "Wrong size on UWorldTileManager");
static_assert(offsetof(UWorldTileManager, WorldManager) == 0x00001C, "Member 'UWorldTileManager::WorldManager' has a wrong offset!");

// Class FortniteGame.FortWorldSettings
// 0x0094 (0x0408 - 0x0374)
class AFortWorldSettings final : public AWorldSettings
{
public:
	uint8                                         Pad_374[0x3C];                                     // 0x0374(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeAddedWorldReadyActor;                          // 0x03B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 WorldCells;                                        // 0x03B4(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WorldCellsOrigin;                                  // 0x03C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         WorldCellsFlags;                                   // 0x03CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowTerrainJumpLinks : 1;                         // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowTerrainClimbLinks : 1;                        // 0x03D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowTerrainCollisions : 1;                        // 0x03D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowTerrainNavGraph : 1;                          // 0x03D0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bShowTerrainIsolatedRegions : 1;                   // 0x03D0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bGenerateTestLevelSaves : 1;                       // 0x03D0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, Transient, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableCullDistance : 1;                          // 0x03D0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TeamOnePvPMiniMapImage;                            // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TeamTwoPvPMiniMapImage;                            // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PvPMapWorldCenter;                                 // 0x03DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PvPMapWorldWidth;                                  // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PvPMapWorldHeight;                                 // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPvPUseWidgetRotation : 1;                         // 0x03EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapZOffset;                                        // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MapRotation;                                       // 0x03F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapInitialMask;                                    // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideMainMapSettings : 1;                      // 0x0404(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDisableDormantAI : 1;                             // 0x0404(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortWorldSettings">();
	}
	static class AFortWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortWorldSettings>();
	}
};
static_assert(alignof(AFortWorldSettings) == 0x000004, "Wrong alignment on AFortWorldSettings");
static_assert(sizeof(AFortWorldSettings) == 0x000408, "Wrong size on AFortWorldSettings");
static_assert(offsetof(AFortWorldSettings, TimeAddedWorldReadyActor) == 0x0003B0, "Member 'AFortWorldSettings::TimeAddedWorldReadyActor' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldCells) == 0x0003B4, "Member 'AFortWorldSettings::WorldCells' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldCellsOrigin) == 0x0003C0, "Member 'AFortWorldSettings::WorldCellsOrigin' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, WorldCellsFlags) == 0x0003CC, "Member 'AFortWorldSettings::WorldCellsFlags' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, TeamOnePvPMiniMapImage) == 0x0003D4, "Member 'AFortWorldSettings::TeamOnePvPMiniMapImage' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, TeamTwoPvPMiniMapImage) == 0x0003D8, "Member 'AFortWorldSettings::TeamTwoPvPMiniMapImage' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldCenter) == 0x0003DC, "Member 'AFortWorldSettings::PvPMapWorldCenter' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldWidth) == 0x0003E4, "Member 'AFortWorldSettings::PvPMapWorldWidth' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, PvPMapWorldHeight) == 0x0003E8, "Member 'AFortWorldSettings::PvPMapWorldHeight' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapZOffset) == 0x0003F0, "Member 'AFortWorldSettings::MapZOffset' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapRotation) == 0x0003F4, "Member 'AFortWorldSettings::MapRotation' has a wrong offset!");
static_assert(offsetof(AFortWorldSettings, MapInitialMask) == 0x000400, "Member 'AFortWorldSettings::MapInitialMask' has a wrong offset!");

// Class FortniteGame.FortZoneTheme
// 0x00F0 (0x010C - 0x001C)
class UFortZoneTheme final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   TheaterMapTileClass;                               // 0x001C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ZoneToUse;                                         // 0x0034(0x0018)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   ZoneName;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ZoneDescription;                                   // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   AbundantResources;                                 // 0x0064(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EFortZoneType                                 ZoneType;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ZoneGameMode;                                      // 0x0074(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ZoneTags;                                          // 0x008C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   LobbyBeaconHostClass;                              // 0x00A4(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZoneIndex;                                         // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaylistId;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamSize;                                          // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPartySize;                                      // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IgnoreGeneratedRewards : 1;                        // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABuildingSMActor>           PlayerSpawnPadClass;                               // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSpawnPadObjectiveExclusionRadius;            // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InitialPlayerSpawnTags;                            // 0x00DC(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BackupPlayerSpawnTags;                             // 0x00F4(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortZoneTheme">();
	}
	static class UFortZoneTheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortZoneTheme>();
	}
};
static_assert(alignof(UFortZoneTheme) == 0x000004, "Wrong alignment on UFortZoneTheme");
static_assert(sizeof(UFortZoneTheme) == 0x00010C, "Wrong size on UFortZoneTheme");
static_assert(offsetof(UFortZoneTheme, TheaterMapTileClass) == 0x00001C, "Member 'UFortZoneTheme::TheaterMapTileClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneToUse) == 0x000034, "Member 'UFortZoneTheme::ZoneToUse' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneName) == 0x00004C, "Member 'UFortZoneTheme::ZoneName' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneDescription) == 0x000058, "Member 'UFortZoneTheme::ZoneDescription' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, AbundantResources) == 0x000064, "Member 'UFortZoneTheme::AbundantResources' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneType) == 0x000070, "Member 'UFortZoneTheme::ZoneType' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneGameMode) == 0x000074, "Member 'UFortZoneTheme::ZoneGameMode' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneTags) == 0x00008C, "Member 'UFortZoneTheme::ZoneTags' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, LobbyBeaconHostClass) == 0x0000A4, "Member 'UFortZoneTheme::LobbyBeaconHostClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, ZoneIndex) == 0x0000BC, "Member 'UFortZoneTheme::ZoneIndex' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, PlaylistId) == 0x0000C0, "Member 'UFortZoneTheme::PlaylistId' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, TeamSize) == 0x0000C4, "Member 'UFortZoneTheme::TeamSize' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, TeamCount) == 0x0000C8, "Member 'UFortZoneTheme::TeamCount' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, MaxPartySize) == 0x0000CC, "Member 'UFortZoneTheme::MaxPartySize' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, PlayerSpawnPadClass) == 0x0000D4, "Member 'UFortZoneTheme::PlayerSpawnPadClass' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, PlayerSpawnPadObjectiveExclusionRadius) == 0x0000D8, "Member 'UFortZoneTheme::PlayerSpawnPadObjectiveExclusionRadius' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, InitialPlayerSpawnTags) == 0x0000DC, "Member 'UFortZoneTheme::InitialPlayerSpawnTags' has a wrong offset!");
static_assert(offsetof(UFortZoneTheme, BackupPlayerSpawnTags) == 0x0000F4, "Member 'UFortZoneTheme::BackupPlayerSpawnTags' has a wrong offset!");

// Class FortniteGame.FrontEndSettings
// 0x000C (0x024C - 0x0240)
class AFrontEndSettings : public AActor
{
public:
	TArray<struct FCameraPair>                    Cameras;                                           // 0x0240(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrontEndSettings">();
	}
	static class AFrontEndSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFrontEndSettings>();
	}
};
static_assert(alignof(AFrontEndSettings) == 0x000004, "Wrong alignment on AFrontEndSettings");
static_assert(sizeof(AFrontEndSettings) == 0x00024C, "Wrong size on AFrontEndSettings");
static_assert(offsetof(AFrontEndSettings, Cameras) == 0x000240, "Member 'AFrontEndSettings::Cameras' has a wrong offset!");

// Class FortniteGame.HomeBaseWorker
// 0x0024 (0x0040 - 0x001C)
class UHomeBaseWorker final : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Rating;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHomeBaseMainBuilding*                  TargetBuilding;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UFortWorker>             WorkerItem;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UFortWorkerType*                        WorkerType;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorkerEmploy                                 Employment;                                        // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFortWorker* GetWorkerItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseWorker">();
	}
	static class UHomeBaseWorker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseWorker>();
	}
};
static_assert(alignof(UHomeBaseWorker) == 0x000004, "Wrong alignment on UHomeBaseWorker");
static_assert(sizeof(UHomeBaseWorker) == 0x000040, "Wrong size on UHomeBaseWorker");
static_assert(offsetof(UHomeBaseWorker, Name_0) == 0x00001C, "Member 'UHomeBaseWorker::Name_0' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorker, Rating) == 0x000028, "Member 'UHomeBaseWorker::Rating' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorker, TargetBuilding) == 0x00002C, "Member 'UHomeBaseWorker::TargetBuilding' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorker, WorkerItem) == 0x000030, "Member 'UHomeBaseWorker::WorkerItem' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorker, WorkerType) == 0x000038, "Member 'UHomeBaseWorker::WorkerType' has a wrong offset!");
static_assert(offsetof(UHomeBaseWorker, Employment) == 0x00003C, "Member 'UHomeBaseWorker::Employment' has a wrong offset!");

// Class FortniteGame.HomeBaseCommandCenterBuilding
// 0x000C (0x00E8 - 0x00DC)
class UHomeBaseCommandCenterBuilding final : public UHomeBaseMainBuilding
{
public:
	UMulticastDelegateProperty_                   OnResourcesCollected;                              // 0x00DC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CollectProducedResources();

	TArray<struct FHomeBaseProducedResources> GetProducedResources() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeBaseCommandCenterBuilding">();
	}
	static class UHomeBaseCommandCenterBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeBaseCommandCenterBuilding>();
	}
};
static_assert(alignof(UHomeBaseCommandCenterBuilding) == 0x000004, "Wrong alignment on UHomeBaseCommandCenterBuilding");
static_assert(sizeof(UHomeBaseCommandCenterBuilding) == 0x0000E8, "Wrong size on UHomeBaseCommandCenterBuilding");
static_assert(offsetof(UHomeBaseCommandCenterBuilding, OnResourcesCollected) == 0x0000DC, "Member 'UHomeBaseCommandCenterBuilding::OnResourcesCollected' has a wrong offset!");

// Class FortniteGame.LevelTestingActorBase
// 0x0000 (0x0240 - 0x0240)
class ALevelTestingActorBase final : public AActor
{
public:
	static class USkeletalMesh* ExtractSkeletalMesh(TSubclassOf<class AActor> BlueprintClass);
	static struct FVector ExtractSkeletalMeshScale(TSubclassOf<class AActor> BlueprintClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelTestingActorBase">();
	}
	static class ALevelTestingActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelTestingActorBase>();
	}
};
static_assert(alignof(ALevelTestingActorBase) == 0x000004, "Wrong alignment on ALevelTestingActorBase");
static_assert(sizeof(ALevelTestingActorBase) == 0x000240, "Wrong size on ALevelTestingActorBase");

// Class FortniteGame.ManorPortal
// 0x002C (0x026C - 0x0240)
class AManorPortal final : public AActor
{
public:
	uint8                                         Pad_240[0x2C];                                     // 0x0240(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintOnUnlockPortalComplete();
	int32 GetCurrencyCost(class AFortPlayerController* Player);
	int32 GetPlayerCurrencyAmount(class AFortPlayerController* Player);
	bool IsPortalUnlocked(class AFortPlayerController* Player);
	bool IsProfileValidToReadPortalAvailability(class AFortPlayerController* Player);
	void OpenUnlockMenu(class AFortPlayerController* Player);
	void UnlockPortal(class AFortPlayerController* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManorPortal">();
	}
	static class AManorPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AManorPortal>();
	}
};
static_assert(alignof(AManorPortal) == 0x000004, "Wrong alignment on AManorPortal");
static_assert(sizeof(AManorPortal) == 0x00026C, "Wrong size on AManorPortal");

// Class FortniteGame.MovementComp_Tracer
// 0x0004 (0x00D0 - 0x00CC)
class UMovementComp_Tracer final : public UMovementComponent
{
public:
	float                                         Speed;                                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementComp_Tracer">();
	}
	static class UMovementComp_Tracer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementComp_Tracer>();
	}
};
static_assert(alignof(UMovementComp_Tracer) == 0x000004, "Wrong alignment on UMovementComp_Tracer");
static_assert(sizeof(UMovementComp_Tracer) == 0x0000D0, "Wrong size on UMovementComp_Tracer");
static_assert(offsetof(UMovementComp_Tracer, Speed) == 0x0000CC, "Member 'UMovementComp_Tracer::Speed' has a wrong offset!");

// Class FortniteGame.MyTownActor
// 0x00B0 (0x02F0 - 0x0240)
class AMyTownActor : public AActor
{
public:
	UMulticastDelegateProperty_                   OnMyTownInitialized;                               // 0x0240(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownChanged;                                   // 0x024C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingUpgradeStarted;                    // 0x0258(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingUpgradeFinished;                   // 0x0264(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBannerColorChanged;                        // 0x0270(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingWorkersChanged;                    // 0x027C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingPanelOpened;                       // 0x0288(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMyTownBuildingPanelClosed;                       // 0x0294(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   MenuTransitionEvent;                               // 0x02A0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FocusLimiterBoxRelativeTransform;                  // 0x02B0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0xC];                                      // 0x02E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          FocusLimiterBox;                                   // 0x02EC(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyTownActor">();
	}
	static class AMyTownActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMyTownActor>();
	}
};
static_assert(alignof(AMyTownActor) == 0x000010, "Wrong alignment on AMyTownActor");
static_assert(sizeof(AMyTownActor) == 0x0002F0, "Wrong size on AMyTownActor");
static_assert(offsetof(AMyTownActor, OnMyTownInitialized) == 0x000240, "Member 'AMyTownActor::OnMyTownInitialized' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownChanged) == 0x00024C, "Member 'AMyTownActor::OnMyTownChanged' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBuildingUpgradeStarted) == 0x000258, "Member 'AMyTownActor::OnMyTownBuildingUpgradeStarted' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBuildingUpgradeFinished) == 0x000264, "Member 'AMyTownActor::OnMyTownBuildingUpgradeFinished' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBannerColorChanged) == 0x000270, "Member 'AMyTownActor::OnMyTownBannerColorChanged' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBuildingWorkersChanged) == 0x00027C, "Member 'AMyTownActor::OnMyTownBuildingWorkersChanged' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBuildingPanelOpened) == 0x000288, "Member 'AMyTownActor::OnMyTownBuildingPanelOpened' has a wrong offset!");
static_assert(offsetof(AMyTownActor, OnMyTownBuildingPanelClosed) == 0x000294, "Member 'AMyTownActor::OnMyTownBuildingPanelClosed' has a wrong offset!");
static_assert(offsetof(AMyTownActor, MenuTransitionEvent) == 0x0002A0, "Member 'AMyTownActor::MenuTransitionEvent' has a wrong offset!");
static_assert(offsetof(AMyTownActor, FocusLimiterBoxRelativeTransform) == 0x0002B0, "Member 'AMyTownActor::FocusLimiterBoxRelativeTransform' has a wrong offset!");
static_assert(offsetof(AMyTownActor, FocusLimiterBox) == 0x0002EC, "Member 'AMyTownActor::FocusLimiterBox' has a wrong offset!");

// Class FortniteGame.PartyDisplayManager
// 0x0058 (0x0298 - 0x0240)
class APartyDisplayManager final : public AActor
{
public:
	TArray<class AActor*>                         PlacementActors;                                   // 0x0240(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 VaultPlacementActor;                               // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x48];                                     // 0x0250(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyDisplayManager">();
	}
	static class APartyDisplayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APartyDisplayManager>();
	}
};
static_assert(alignof(APartyDisplayManager) == 0x000004, "Wrong alignment on APartyDisplayManager");
static_assert(sizeof(APartyDisplayManager) == 0x000298, "Wrong size on APartyDisplayManager");
static_assert(offsetof(APartyDisplayManager, PlacementActors) == 0x000240, "Member 'APartyDisplayManager::PlacementActors' has a wrong offset!");
static_assert(offsetof(APartyDisplayManager, VaultPlacementActor) == 0x00024C, "Member 'APartyDisplayManager::VaultPlacementActor' has a wrong offset!");

// Class FortniteGame.WaterVolume_Shallow
// 0x0008 (0x0280 - 0x0278)
class AWaterVolume_Shallow final : public APhysicsVolume
{
public:
	class USoundBase*                             EntrySound;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExitSound;                                         // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterVolume_Shallow">();
	}
	static class AWaterVolume_Shallow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterVolume_Shallow>();
	}
};
static_assert(alignof(AWaterVolume_Shallow) == 0x000004, "Wrong alignment on AWaterVolume_Shallow");
static_assert(sizeof(AWaterVolume_Shallow) == 0x000280, "Wrong size on AWaterVolume_Shallow");
static_assert(offsetof(AWaterVolume_Shallow, EntrySound) == 0x000278, "Member 'AWaterVolume_Shallow::EntrySound' has a wrong offset!");
static_assert(offsetof(AWaterVolume_Shallow, ExitSound) == 0x00027C, "Member 'AWaterVolume_Shallow::ExitSound' has a wrong offset!");

}

#pragma pack(pop)
