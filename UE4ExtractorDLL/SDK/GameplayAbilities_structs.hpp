#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayAbilities

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"


#pragma pack(push, 0x4)
namespace SDK
{

// Enum GameplayAbilities.EGameplayEffectGrantedAbilityRemovePolicy
// NumValues: 0x0004
enum class EGameplayEffectGrantedAbilityRemovePolicy : uint8
{
	CancelAbilityImmediately                 = 0,
	RemoveAbilityOnEnd                       = 1,
	DoNothing                                = 2,
	EGameplayEffectGrantedAbilityRemovePolicy_MAX = 3,
};

// Enum GameplayAbilities.EGameplayEffectAttributeCaptureSource
// NumValues: 0x0003
enum class EGameplayEffectAttributeCaptureSource : uint8
{
	Source                                   = 0,
	Target                                   = 1,
	EGameplayEffectAttributeCaptureSource_MAX = 2,
};

// Enum GameplayAbilities.EGameplayAbilityActivationMode
// NumValues: 0x0005
enum class EGameplayAbilityActivationMode : uint8
{
	Authority                                = 0,
	NonAuthority                             = 1,
	Predicting                               = 2,
	Confirmed                                = 3,
	EGameplayAbilityActivationMode_MAX       = 4,
};

// Enum GameplayAbilities.EAbilityGenericReplicatedEvent
// NumValues: 0x000D
enum class EAbilityGenericReplicatedEvent : uint8
{
	GenericConfirm                           = 0,
	GenericCancel                            = 1,
	InputPressed                             = 2,
	InputReleased                            = 3,
	GenericSignalFromClient                  = 4,
	GenericSignalFromServer                  = 5,
	GameCustom1                              = 6,
	GameCustom2                              = 7,
	GameCustom3                              = 8,
	GameCustom4                              = 9,
	GameCustom5                              = 10,
	MAX                                      = 11,
	EAbilityGenericReplicatedEvent_MAX       = 12,
};

// Enum GameplayAbilities.EGameplayTagEventType
// NumValues: 0x0003
enum class EGameplayTagEventType : uint8
{
	NewOrRemoved                             = 0,
	AnyCountChange                           = 1,
	EGameplayTagEventType_MAX                = 2,
};

// Enum GameplayAbilities.EGameplayCueEvent
// NumValues: 0x0005
enum class EGameplayCueEvent : uint8
{
	OnActive                                 = 0,
	WhileActive                              = 1,
	Executed                                 = 2,
	Removed                                  = 3,
	EGameplayCueEvent_MAX                    = 4,
};

// Enum GameplayAbilities.EGameplayEffectStackingType
// NumValues: 0x0004
enum class EGameplayEffectStackingType : uint8
{
	None                                     = 0,
	AggregateBySource                        = 1,
	AggregateByTarget                        = 2,
	EGameplayEffectStackingType_MAX          = 3,
};

// Enum GameplayAbilities.EGameplayModOp
// NumValues: 0x0006
enum class EGameplayModOp : uint8
{
	Additive                                 = 0,
	Multiplicitive                           = 1,
	Division                                 = 2,
	Override                                 = 3,
	Max                                      = 4,
	EGameplayModOp_MAX                       = 5,
};

// Enum GameplayAbilities.EGameplayAbilityTargetingLocationType
// NumValues: 0x0004
enum class EGameplayAbilityTargetingLocationType : uint8
{
	LiteralTransform                         = 0,
	ActorTransform                           = 1,
	SocketTransform                          = 2,
	EGameplayAbilityTargetingLocationType_MAX = 3,
};

// Enum GameplayAbilities.EGameplayTargetingConfirmation
// NumValues: 0x0005
enum class EGameplayTargetingConfirmation : uint8
{
	Instant                                  = 0,
	UserConfirmed                            = 1,
	Custom                                   = 2,
	CustomMulti                              = 3,
	EGameplayTargetingConfirmation_MAX       = 4,
};

// Enum GameplayAbilities.EGameplayEffectStackingExpirationPolicy
// NumValues: 0x0004
enum class EGameplayEffectStackingExpirationPolicy : uint8
{
	ClearEntireStack                         = 0,
	RemoveSingleStackAndRefreshDuration      = 1,
	RefreshDuration                          = 2,
	EGameplayEffectStackingExpirationPolicy_MAX = 3,
};

// Enum GameplayAbilities.EGameplayEffectStackingPeriodPolicy
// NumValues: 0x0003
enum class EGameplayEffectStackingPeriodPolicy : uint8
{
	ResetOnSuccessfulApplication             = 0,
	NeverReset                               = 1,
	EGameplayEffectStackingPeriodPolicy_MAX  = 2,
};

// Enum GameplayAbilities.EGameplayEffectStackingDurationPolicy
// NumValues: 0x0003
enum class EGameplayEffectStackingDurationPolicy : uint8
{
	RefreshOnSuccessfulApplication           = 0,
	NeverRefresh                             = 1,
	EGameplayEffectStackingDurationPolicy_MAX = 2,
};

// Enum GameplayAbilities.EGameplayEffectDurationType
// NumValues: 0x0004
enum class EGameplayEffectDurationType : uint8
{
	Instant                                  = 0,
	Infinite                                 = 1,
	HasDuration                              = 2,
	EGameplayEffectDurationType_MAX          = 3,
};

// Enum GameplayAbilities.EAttributeBasedFloatCalculationType
// NumValues: 0x0004
enum class EAttributeBasedFloatCalculationType : uint8
{
	AttributeMagnitude                       = 0,
	AttributeBaseValue                       = 1,
	AttributeBonusMagnitude                  = 2,
	EAttributeBasedFloatCalculationType_MAX  = 3,
};

// Enum GameplayAbilities.EGameplayEffectMagnitudeCalculation
// NumValues: 0x0005
enum class EGameplayEffectMagnitudeCalculation : uint8
{
	ScalableFloat                            = 0,
	AttributeBased                           = 1,
	CustomCalculationClass                   = 2,
	SetByCaller                              = 3,
	EGameplayEffectMagnitudeCalculation_MAX  = 4,
};

// Enum GameplayAbilities.EGameplayAbilityTriggerSource
// NumValues: 0x0004
enum class EGameplayAbilityTriggerSource : uint8
{
	GameplayEvent                            = 0,
	OwnedTagAdded                            = 1,
	OwnedTagPresent                          = 2,
	EGameplayAbilityTriggerSource_MAX        = 3,
};

// Enum GameplayAbilities.EGameplayAbilityReplicationPolicy
// NumValues: 0x0003
enum class EGameplayAbilityReplicationPolicy : uint8
{
	ReplicateNo                              = 0,
	ReplicateYes                             = 1,
	EGameplayAbilityReplicationPolicy_MAX    = 2,
};

// Enum GameplayAbilities.EGameplayAbilityNetExecutionPolicy
// NumValues: 0x0005
enum class EGameplayAbilityNetExecutionPolicy : uint8
{
	LocalPredicted                           = 0,
	LocalOnly                                = 1,
	ServerInitiated                          = 2,
	ServerOnly                               = 3,
	EGameplayAbilityNetExecutionPolicy_MAX   = 4,
};

// Enum GameplayAbilities.EGameplayAbilityInstancingPolicy
// NumValues: 0x0004
enum class EGameplayAbilityInstancingPolicy : uint8
{
	NonInstanced                             = 0,
	InstancedPerActor                        = 1,
	InstancedPerExecution                    = 2,
	EGameplayAbilityInstancingPolicy_MAX     = 3,
};

// Enum GameplayAbilities.ETargetDataFilterSelf
// NumValues: 0x0004
enum class ETargetDataFilterSelf : uint8
{
	TDFS_Any                                 = 0,
	TDFS_NoSelf                              = 1,
	TDFS_NoOthers                            = 2,
	TDFS_MAX                                 = 3,
};

// Enum GameplayAbilities.EAbilityTaskWaitState
// NumValues: 0x0003
enum class EAbilityTaskWaitState : uint8
{
	WaitingOnGame                            = 0,
	WaitingOnUser                            = 1,
	EAbilityTaskWaitState_MAX                = 2,
};

// Enum GameplayAbilities.EAbilityTaskNetSyncType
// NumValues: 0x0004
enum class EAbilityTaskNetSyncType : uint8
{
	BothWait                                 = 0,
	OnlyServerWait                           = 1,
	OnlyClientWait                           = 2,
	EAbilityTaskNetSyncType_MAX              = 3,
};

// Enum GameplayAbilities.EWaitAttributeChangeComparison
// NumValues: 0x0009
enum class EWaitAttributeChangeComparison : uint8
{
	None                                     = 0,
	GreaterThan                              = 1,
	LessThan                                 = 2,
	GreaterThanOrEqualTo                     = 3,
	LessThanOrEqualTo                        = 4,
	NotEqualTo                               = 5,
	ExactlyEqualTo                           = 6,
	MAX                                      = 7,
	EWaitAttributeChangeComparison_MAX       = 8,
};

// Enum GameplayAbilities.EGameplayAbilityInputBinds
// NumValues: 0x000A
enum class EGameplayAbilityInputBinds : uint8
{
	Ability1                                 = 0,
	Ability2                                 = 1,
	Ability3                                 = 2,
	Ability4                                 = 3,
	Ability5                                 = 4,
	Ability6                                 = 5,
	Ability7                                 = 6,
	Ability8                                 = 7,
	Ability9                                 = 8,
	EGameplayAbilityInputBinds_MAX           = 9,
};

// Enum GameplayAbilities.ETargetAbilitySelfSelection
// NumValues: 0x0004
enum class ETargetAbilitySelfSelection : uint8
{
	TASS_Permit                              = 0,
	TASS_Forbid                              = 1,
	TASS_Require                             = 2,
	TASS_MAX                                 = 3,
};

// Enum GameplayAbilities.EGameplayCuePayloadType
// NumValues: 0x0004
enum class EGameplayCuePayloadType : uint8
{
	EffectContext                            = 0,
	CueParameters                            = 1,
	FromSpec                                 = 2,
	EGameplayCuePayloadType_MAX              = 3,
};

// ScriptStruct GameplayAbilities.GameplayAttribute
// 0x0004 (0x0004 - 0x0000)
struct FGameplayAttribute final
{
public:
	class UProperty*                              Attribute;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAttribute) == 0x000004, "Wrong alignment on FGameplayAttribute");
static_assert(sizeof(FGameplayAttribute) == 0x000004, "Wrong size on FGameplayAttribute");
static_assert(offsetof(FGameplayAttribute, Attribute) == 0x000000, "Member 'FGameplayAttribute::Attribute' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectModifiedAttribute
// 0x0008 (0x0008 - 0x0000)
struct FGameplayEffectModifiedAttribute final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0004)(NativeAccessSpecifierPublic)
	float                                         TotalMagnitude;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectModifiedAttribute) == 0x000004, "Wrong alignment on FGameplayEffectModifiedAttribute");
static_assert(sizeof(FGameplayEffectModifiedAttribute) == 0x000008, "Wrong size on FGameplayEffectModifiedAttribute");
static_assert(offsetof(FGameplayEffectModifiedAttribute, Attribute) == 0x000000, "Member 'FGameplayEffectModifiedAttribute::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifiedAttribute, TotalMagnitude) == 0x000004, "Member 'FGameplayEffectModifiedAttribute::TotalMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureDefinition
// 0x0008 (0x0008 - 0x0000)
struct FGameplayEffectAttributeCaptureDefinition final
{
public:
	struct FGameplayAttribute                     AttributeToCapture;                                // 0x0000(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGameplayEffectAttributeCaptureSource         AttributeSource;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapshot;                                         // 0x0005(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureDefinition) == 0x000004, "Wrong alignment on FGameplayEffectAttributeCaptureDefinition");
static_assert(sizeof(FGameplayEffectAttributeCaptureDefinition) == 0x000008, "Wrong size on FGameplayEffectAttributeCaptureDefinition");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, AttributeToCapture) == 0x000000, "Member 'FGameplayEffectAttributeCaptureDefinition::AttributeToCapture' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, AttributeSource) == 0x000004, "Member 'FGameplayEffectAttributeCaptureDefinition::AttributeSource' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureDefinition, bSnapshot) == 0x000005, "Member 'FGameplayEffectAttributeCaptureDefinition::bSnapshot' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureSpec
// 0x0010 (0x0010 - 0x0000)
struct FGameplayEffectAttributeCaptureSpec final
{
public:
	struct FGameplayEffectAttributeCaptureDefinition BackingDefinition;                                 // 0x0000(0x0008)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureSpec) == 0x000004, "Wrong alignment on FGameplayEffectAttributeCaptureSpec");
static_assert(sizeof(FGameplayEffectAttributeCaptureSpec) == 0x000010, "Wrong size on FGameplayEffectAttributeCaptureSpec");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpec, BackingDefinition) == 0x000000, "Member 'FGameplayEffectAttributeCaptureSpec::BackingDefinition' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectAttributeCaptureSpecContainer
// 0x001C (0x001C - 0x0000)
struct FGameplayEffectAttributeCaptureSpecContainer final
{
public:
	TArray<struct FGameplayEffectAttributeCaptureSpec> SourceAttributes;                                  // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayEffectAttributeCaptureSpec> TargetAttributes;                                  // 0x000C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasNonSnapshottedAttributes;                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectAttributeCaptureSpecContainer) == 0x000004, "Wrong alignment on FGameplayEffectAttributeCaptureSpecContainer");
static_assert(sizeof(FGameplayEffectAttributeCaptureSpecContainer) == 0x00001C, "Wrong size on FGameplayEffectAttributeCaptureSpecContainer");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, SourceAttributes) == 0x000000, "Member 'FGameplayEffectAttributeCaptureSpecContainer::SourceAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, TargetAttributes) == 0x00000C, "Member 'FGameplayEffectAttributeCaptureSpecContainer::TargetAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectAttributeCaptureSpecContainer, bHasNonSnapshottedAttributes) == 0x000018, "Member 'FGameplayEffectAttributeCaptureSpecContainer::bHasNonSnapshottedAttributes' has a wrong offset!");

// ScriptStruct GameplayAbilities.TagContainerAggregator
// 0x0064 (0x0064 - 0x0000)
struct FTagContainerAggregator final
{
public:
	struct FGameplayTagContainer                  CapturedActorTags;                                 // 0x0000(0x0018)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  CapturedSpecTags;                                  // 0x0018(0x0018)(NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  ScopedTags;                                        // 0x0030(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x1C];                                      // 0x0048(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTagContainerAggregator) == 0x000004, "Wrong alignment on FTagContainerAggregator");
static_assert(sizeof(FTagContainerAggregator) == 0x000064, "Wrong size on FTagContainerAggregator");
static_assert(offsetof(FTagContainerAggregator, CapturedActorTags) == 0x000000, "Member 'FTagContainerAggregator::CapturedActorTags' has a wrong offset!");
static_assert(offsetof(FTagContainerAggregator, CapturedSpecTags) == 0x000018, "Member 'FTagContainerAggregator::CapturedSpecTags' has a wrong offset!");
static_assert(offsetof(FTagContainerAggregator, ScopedTags) == 0x000030, "Member 'FTagContainerAggregator::ScopedTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.ModifierSpec
// 0x0004 (0x0004 - 0x0000)
struct FModifierSpec final
{
public:
	float                                         EvaluatedMagnitude;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FModifierSpec) == 0x000004, "Wrong alignment on FModifierSpec");
static_assert(sizeof(FModifierSpec) == 0x000004, "Wrong size on FModifierSpec");
static_assert(offsetof(FModifierSpec, EvaluatedMagnitude) == 0x000000, "Member 'FModifierSpec::EvaluatedMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.ScalableFloat
// 0x0014 (0x0014 - 0x0000)
struct FScalableFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   Curve;                                             // 0x0004(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableFloat) == 0x000004, "Wrong alignment on FScalableFloat");
static_assert(sizeof(FScalableFloat) == 0x000014, "Wrong size on FScalableFloat");
static_assert(offsetof(FScalableFloat, Value) == 0x000000, "Member 'FScalableFloat::Value' has a wrong offset!");
static_assert(offsetof(FScalableFloat, Curve) == 0x000004, "Member 'FScalableFloat::Curve' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecHandle
// 0x0004 (0x0004 - 0x0000)
struct FGameplayAbilitySpecHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAbilitySpecHandle) == 0x000004, "Wrong alignment on FGameplayAbilitySpecHandle");
static_assert(sizeof(FGameplayAbilitySpecHandle) == 0x000004, "Wrong size on FGameplayAbilitySpecHandle");
static_assert(offsetof(FGameplayAbilitySpecHandle, Handle) == 0x000000, "Member 'FGameplayAbilitySpecHandle::Handle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecDef
// 0x002C (0x002C - 0x0000)
struct FGameplayAbilitySpecDef final
{
public:
	TSubclassOf<class UGameplayAbility>           Ability;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         LevelScalableFloat;                                // 0x0008(0x0014)(Edit, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectGrantedAbilityRemovePolicy     RemovalPolicy;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                SourceObject;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilitySpecHandle             AssignedHandle;                                    // 0x0028(0x0004)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilitySpecDef) == 0x000004, "Wrong alignment on FGameplayAbilitySpecDef");
static_assert(sizeof(FGameplayAbilitySpecDef) == 0x00002C, "Wrong size on FGameplayAbilitySpecDef");
static_assert(offsetof(FGameplayAbilitySpecDef, Ability) == 0x000000, "Member 'FGameplayAbilitySpecDef::Ability' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, Level) == 0x000004, "Member 'FGameplayAbilitySpecDef::Level' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, LevelScalableFloat) == 0x000008, "Member 'FGameplayAbilitySpecDef::LevelScalableFloat' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, InputID) == 0x00001C, "Member 'FGameplayAbilitySpecDef::InputID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, RemovalPolicy) == 0x000020, "Member 'FGameplayAbilitySpecDef::RemovalPolicy' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, SourceObject) == 0x000024, "Member 'FGameplayAbilitySpecDef::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecDef, AssignedHandle) == 0x000028, "Member 'FGameplayAbilitySpecDef::AssignedHandle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectContextHandle
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGameplayEffectContextHandle final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectContextHandle) == 0x000004, "Wrong alignment on FGameplayEffectContextHandle");
static_assert(sizeof(FGameplayEffectContextHandle) == 0x00000C, "Wrong size on FGameplayEffectContextHandle");

// ScriptStruct GameplayAbilities.GameplayEffectSpec
// 0x01A8 (0x01A8 - 0x0000)
struct FGameplayEffectSpec final
{
public:
	class UGameplayEffect*                        Def;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifiedAttribute> ModifiedAttributes;                                // 0x0004(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectAttributeCaptureSpecContainer CapturedRelevantAttributes;                        // 0x0010(0x001C)(RepSkip, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToApplyToTarget;                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTagContainerAggregator                CapturedSourceTags;                                // 0x0044(0x0064)(RepSkip, NativeAccessSpecifierPublic)
	struct FTagContainerAggregator                CapturedTargetTags;                                // 0x00A8(0x0064)(RepSkip, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicGrantedTags;                                // 0x010C(0x0018)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicAssetTags;                                  // 0x0124(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FModifierSpec>                  Modifiers;                                         // 0x013C(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompletedSourceAttributeCapture : 1;              // 0x014C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCompletedTargetAttributeCapture : 1;              // 0x014C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bDurationLocked : 1;                               // 0x014C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecDef>        GrantedAbilitySpecs;                               // 0x0150(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x3C];                                     // 0x015C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0198(0x000C)(NativeAccessSpecifierPrivate)
	float                                         Level;                                             // 0x01A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayEffectSpec) == 0x000004, "Wrong alignment on FGameplayEffectSpec");
static_assert(sizeof(FGameplayEffectSpec) == 0x0001A8, "Wrong size on FGameplayEffectSpec");
static_assert(offsetof(FGameplayEffectSpec, Def) == 0x000000, "Member 'FGameplayEffectSpec::Def' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, ModifiedAttributes) == 0x000004, "Member 'FGameplayEffectSpec::ModifiedAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedRelevantAttributes) == 0x000010, "Member 'FGameplayEffectSpec::CapturedRelevantAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Duration) == 0x000038, "Member 'FGameplayEffectSpec::Duration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Period) == 0x00003C, "Member 'FGameplayEffectSpec::Period' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, ChanceToApplyToTarget) == 0x000040, "Member 'FGameplayEffectSpec::ChanceToApplyToTarget' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedSourceTags) == 0x000044, "Member 'FGameplayEffectSpec::CapturedSourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, CapturedTargetTags) == 0x0000A8, "Member 'FGameplayEffectSpec::CapturedTargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicGrantedTags) == 0x00010C, "Member 'FGameplayEffectSpec::DynamicGrantedTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, DynamicAssetTags) == 0x000124, "Member 'FGameplayEffectSpec::DynamicAssetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Modifiers) == 0x00013C, "Member 'FGameplayEffectSpec::Modifiers' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, StackCount) == 0x000148, "Member 'FGameplayEffectSpec::StackCount' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, GrantedAbilitySpecs) == 0x000150, "Member 'FGameplayEffectSpec::GrantedAbilitySpecs' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, EffectContext) == 0x000198, "Member 'FGameplayEffectSpec::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpec, Level) == 0x0001A4, "Member 'FGameplayEffectSpec::Level' has a wrong offset!");

// ScriptStruct GameplayAbilities.PredictionKey
// 0x000C (0x000C - 0x0000)
struct FPredictionKey final
{
public:
	int16                                         Current;                                           // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Base;                                              // 0x0002(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPackageMap*                            PredictiveConnection;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStale;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsServerInitiated;                                // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionKey) == 0x000004, "Wrong alignment on FPredictionKey");
static_assert(sizeof(FPredictionKey) == 0x00000C, "Wrong size on FPredictionKey");
static_assert(offsetof(FPredictionKey, Current) == 0x000000, "Member 'FPredictionKey::Current' has a wrong offset!");
static_assert(offsetof(FPredictionKey, Base) == 0x000002, "Member 'FPredictionKey::Base' has a wrong offset!");
static_assert(offsetof(FPredictionKey, PredictiveConnection) == 0x000004, "Member 'FPredictionKey::PredictiveConnection' has a wrong offset!");
static_assert(offsetof(FPredictionKey, bIsStale) == 0x000008, "Member 'FPredictionKey::bIsStale' has a wrong offset!");
static_assert(offsetof(FPredictionKey, bIsServerInitiated) == 0x000009, "Member 'FPredictionKey::bIsServerInitiated' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffect
// 0x020C (0x0218 - 0x000C)
struct FActiveGameplayEffect final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectSpec                    Spec;                                              // 0x0010(0x01A8)(NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x01B8(0x000C)(NativeAccessSpecifierPublic)
	float                                         StartServerWorldTime;                              // 0x01C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedStartServerWorldTime;                        // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWorldTime;                                    // 0x01CC(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInhibited;                                      // 0x01D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x47];                                     // 0x01D1(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffect) == 0x000004, "Wrong alignment on FActiveGameplayEffect");
static_assert(sizeof(FActiveGameplayEffect) == 0x000218, "Wrong size on FActiveGameplayEffect");
static_assert(offsetof(FActiveGameplayEffect, Spec) == 0x000010, "Member 'FActiveGameplayEffect::Spec' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, PredictionKey) == 0x0001B8, "Member 'FActiveGameplayEffect::PredictionKey' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, StartServerWorldTime) == 0x0001C4, "Member 'FActiveGameplayEffect::StartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, CachedStartServerWorldTime) == 0x0001C8, "Member 'FActiveGameplayEffect::CachedStartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, StartWorldTime) == 0x0001CC, "Member 'FActiveGameplayEffect::StartWorldTime' has a wrong offset!");
static_assert(offsetof(FActiveGameplayEffect, bIsInhibited) == 0x0001D0, "Member 'FActiveGameplayEffect::bIsInhibited' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeBasedFloat
// 0x0084 (0x0084 - 0x0000)
struct FAttributeBasedFloat final
{
public:
	struct FScalableFloat                         Coefficient;                                       // 0x0000(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PreMultiplyAdditiveValue;                          // 0x0014(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PostMultiplyAdditiveValue;                         // 0x0028(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayEffectAttributeCaptureDefinition BackingAttribute;                                  // 0x003C(0x0008)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCurveTableRowHandle                   AttributeCurve;                                    // 0x0044(0x000C)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EAttributeBasedFloatCalculationType           AttributeCalculationType;                          // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SourceTagFilter;                                   // 0x0054(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTagFilter;                                   // 0x006C(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeBasedFloat) == 0x000004, "Wrong alignment on FAttributeBasedFloat");
static_assert(sizeof(FAttributeBasedFloat) == 0x000084, "Wrong size on FAttributeBasedFloat");
static_assert(offsetof(FAttributeBasedFloat, Coefficient) == 0x000000, "Member 'FAttributeBasedFloat::Coefficient' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, PreMultiplyAdditiveValue) == 0x000014, "Member 'FAttributeBasedFloat::PreMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, PostMultiplyAdditiveValue) == 0x000028, "Member 'FAttributeBasedFloat::PostMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, BackingAttribute) == 0x00003C, "Member 'FAttributeBasedFloat::BackingAttribute' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, AttributeCurve) == 0x000044, "Member 'FAttributeBasedFloat::AttributeCurve' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, AttributeCalculationType) == 0x000050, "Member 'FAttributeBasedFloat::AttributeCalculationType' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, SourceTagFilter) == 0x000054, "Member 'FAttributeBasedFloat::SourceTagFilter' has a wrong offset!");
static_assert(offsetof(FAttributeBasedFloat, TargetTagFilter) == 0x00006C, "Member 'FAttributeBasedFloat::TargetTagFilter' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueTag
// 0x0008 (0x0008 - 0x0000)
struct FGameplayCueTag final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueTag) == 0x000004, "Wrong alignment on FGameplayCueTag");
static_assert(sizeof(FGameplayCueTag) == 0x000008, "Wrong size on FGameplayCueTag");
static_assert(offsetof(FGameplayCueTag, GameplayCueTag) == 0x000000, "Member 'FGameplayCueTag::GameplayCueTag' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectContext
// 0x0048 (0x0048 - 0x0000)
struct FGameplayEffectContext
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  EffectCauser;                                      // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAbilitySystemComponent> InstigatorAbilitySystemComponent;                  // 0x001C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          Actors;                                            // 0x0024(0x000C)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldOrigin;                                       // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasWorldOrigin;                                   // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectContext) == 0x000004, "Wrong alignment on FGameplayEffectContext");
static_assert(sizeof(FGameplayEffectContext) == 0x000048, "Wrong size on FGameplayEffectContext");
static_assert(offsetof(FGameplayEffectContext, Instigator) == 0x000004, "Member 'FGameplayEffectContext::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, EffectCauser) == 0x00000C, "Member 'FGameplayEffectContext::EffectCauser' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, SourceObject) == 0x000014, "Member 'FGameplayEffectContext::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, InstigatorAbilitySystemComponent) == 0x00001C, "Member 'FGameplayEffectContext::InstigatorAbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, Actors) == 0x000024, "Member 'FGameplayEffectContext::Actors' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, WorldOrigin) == 0x000038, "Member 'FGameplayEffectContext::WorldOrigin' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContext, bHasWorldOrigin) == 0x000044, "Member 'FGameplayEffectContext::bHasWorldOrigin' has a wrong offset!");

// ScriptStruct GameplayAbilities.WorldReticleParameters
// 0x000C (0x000C - 0x0000)
struct FWorldReticleParameters final
{
public:
	struct FVector                                AOEScale;                                          // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldReticleParameters) == 0x000004, "Wrong alignment on FWorldReticleParameters");
static_assert(sizeof(FWorldReticleParameters) == 0x00000C, "Wrong size on FWorldReticleParameters");
static_assert(offsetof(FWorldReticleParameters, AOEScale) == 0x000000, "Member 'FWorldReticleParameters::AOEScale' has a wrong offset!");

// ScriptStruct GameplayAbilities.CustomCalculationBasedFloat
// 0x0040 (0x0040 - 0x0000)
struct FCustomCalculationBasedFloat final
{
public:
	TSubclassOf<class UGameplayModMagnitudeCalculation> CalculationClassMagnitude;                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Coefficient;                                       // 0x0004(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PreMultiplyAdditiveValue;                          // 0x0018(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         PostMultiplyAdditiveValue;                         // 0x002C(0x0014)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomCalculationBasedFloat) == 0x000004, "Wrong alignment on FCustomCalculationBasedFloat");
static_assert(sizeof(FCustomCalculationBasedFloat) == 0x000040, "Wrong size on FCustomCalculationBasedFloat");
static_assert(offsetof(FCustomCalculationBasedFloat, CalculationClassMagnitude) == 0x000000, "Member 'FCustomCalculationBasedFloat::CalculationClassMagnitude' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, Coefficient) == 0x000004, "Member 'FCustomCalculationBasedFloat::Coefficient' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, PreMultiplyAdditiveValue) == 0x000018, "Member 'FCustomCalculationBasedFloat::PreMultiplyAdditiveValue' has a wrong offset!");
static_assert(offsetof(FCustomCalculationBasedFloat, PostMultiplyAdditiveValue) == 0x00002C, "Member 'FCustomCalculationBasedFloat::PostMultiplyAdditiveValue' has a wrong offset!");

// ScriptStruct GameplayAbilities.SetByCallerFloat
// 0x0008 (0x0008 - 0x0000)
struct FSetByCallerFloat final
{
public:
	class FName                                   DataName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetByCallerFloat) == 0x000004, "Wrong alignment on FSetByCallerFloat");
static_assert(sizeof(FSetByCallerFloat) == 0x000008, "Wrong size on FSetByCallerFloat");
static_assert(offsetof(FSetByCallerFloat, DataName) == 0x000000, "Member 'FSetByCallerFloat::DataName' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectModifierMagnitude
// 0x00E4 (0x00E4 - 0x0000)
struct FGameplayEffectModifierMagnitude final
{
public:
	EGameplayEffectMagnitudeCalculation           MagnitudeCalculationType;                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ScalableFloatMagnitude;                            // 0x0004(0x0014)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAttributeBasedFloat                   AttributeBasedMagnitude;                           // 0x0018(0x0084)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCustomCalculationBasedFloat           CustomMagnitude;                                   // 0x009C(0x0040)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSetByCallerFloat                      SetByCallerMagnitude;                              // 0x00DC(0x0008)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayEffectModifierMagnitude) == 0x000004, "Wrong alignment on FGameplayEffectModifierMagnitude");
static_assert(sizeof(FGameplayEffectModifierMagnitude) == 0x0000E4, "Wrong size on FGameplayEffectModifierMagnitude");
static_assert(offsetof(FGameplayEffectModifierMagnitude, MagnitudeCalculationType) == 0x000000, "Member 'FGameplayEffectModifierMagnitude::MagnitudeCalculationType' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, ScalableFloatMagnitude) == 0x000004, "Member 'FGameplayEffectModifierMagnitude::ScalableFloatMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, AttributeBasedMagnitude) == 0x000018, "Member 'FGameplayEffectModifierMagnitude::AttributeBasedMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, CustomMagnitude) == 0x00009C, "Member 'FGameplayEffectModifierMagnitude::CustomMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectModifierMagnitude, SetByCallerMagnitude) == 0x0000DC, "Member 'FGameplayEffectModifierMagnitude::SetByCallerMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectsContainer
// 0x021C (0x029C - 0x0080)
struct FActiveGameplayEffectsContainer final : public FFastArraySerializer
{
public:
	uint8                                         Pad_80[0x24];                                      // 0x0080(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffect>          GameplayEffects_Internal;                          // 0x00A4(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x1EC];                                     // 0x00B0(0x01EC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffectsContainer) == 0x000004, "Wrong alignment on FActiveGameplayEffectsContainer");
static_assert(sizeof(FActiveGameplayEffectsContainer) == 0x00029C, "Wrong size on FActiveGameplayEffectsContainer");
static_assert(offsetof(FActiveGameplayEffectsContainer, GameplayEffects_Internal) == 0x0000A4, "Member 'FActiveGameplayEffectsContainer::GameplayEffects_Internal' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityActivationInfo
// 0x0010 (0x0010 - 0x0000)
struct FGameplayAbilityActivationInfo final
{
public:
	EGameplayAbilityActivationMode                ActivationMode;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanBeEndedByOtherInstance : 1;                    // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKeyWhenActivated;                        // 0x0004(0x000C)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAbilityActivationInfo) == 0x000004, "Wrong alignment on FGameplayAbilityActivationInfo");
static_assert(sizeof(FGameplayAbilityActivationInfo) == 0x000010, "Wrong size on FGameplayAbilityActivationInfo");
static_assert(offsetof(FGameplayAbilityActivationInfo, ActivationMode) == 0x000000, "Member 'FGameplayAbilityActivationInfo::ActivationMode' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActivationInfo, PredictionKeyWhenActivated) == 0x000004, "Member 'FGameplayAbilityActivationInfo::PredictionKeyWhenActivated' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectHandle
// 0x0004 (0x0004 - 0x0000)
struct FActiveGameplayEffectHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FActiveGameplayEffectHandle) == 0x000004, "Wrong alignment on FActiveGameplayEffectHandle");
static_assert(sizeof(FActiveGameplayEffectHandle) == 0x000004, "Wrong size on FActiveGameplayEffectHandle");
static_assert(offsetof(FActiveGameplayEffectHandle, Handle) == 0x000000, "Member 'FActiveGameplayEffectHandle::Handle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpec
// 0x0044 (0x0050 - 0x000C)
struct FGameplayAbilitySpec final : public FFastArraySerializerItem
{
public:
	struct FGameplayAbilitySpecHandle             Handle;                                            // 0x000C(0x0004)(NativeAccessSpecifierPublic)
	class UGameplayAbility*                       Ability;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActiveCount;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InputPressed : 1;                                  // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         RemoveAfterActivation : 1;                         // 0x0021(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         PendingRemove : 1;                                 // 0x0021(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (RepSkip, NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0024(0x0010)(RepSkip, NativeAccessSpecifierPublic)
	TArray<class UGameplayAbility*>               NonReplicatedInstances;                            // 0x0034(0x000C)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<class UGameplayAbility*>               ReplicatedInstances;                               // 0x0040(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            GameplayEffectHandle;                              // 0x004C(0x0004)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilitySpec) == 0x000004, "Wrong alignment on FGameplayAbilitySpec");
static_assert(sizeof(FGameplayAbilitySpec) == 0x000050, "Wrong size on FGameplayAbilitySpec");
static_assert(offsetof(FGameplayAbilitySpec, Handle) == 0x00000C, "Member 'FGameplayAbilitySpec::Handle' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, Ability) == 0x000010, "Member 'FGameplayAbilitySpec::Ability' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, Level) == 0x000014, "Member 'FGameplayAbilitySpec::Level' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, InputID) == 0x000018, "Member 'FGameplayAbilitySpec::InputID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, SourceObject) == 0x00001C, "Member 'FGameplayAbilitySpec::SourceObject' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ActiveCount) == 0x000020, "Member 'FGameplayAbilitySpec::ActiveCount' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ActivationInfo) == 0x000024, "Member 'FGameplayAbilitySpec::ActivationInfo' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, NonReplicatedInstances) == 0x000034, "Member 'FGameplayAbilitySpec::NonReplicatedInstances' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, ReplicatedInstances) == 0x000040, "Member 'FGameplayAbilitySpec::ReplicatedInstances' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpec, GameplayEffectHandle) == 0x00004C, "Member 'FGameplayAbilitySpec::GameplayEffectHandle' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTagRequirements
// 0x0030 (0x0030 - 0x0000)
struct FGameplayTagRequirements final
{
public:
	struct FGameplayTagContainer                  RequireTags;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagRequirements) == 0x000004, "Wrong alignment on FGameplayTagRequirements");
static_assert(sizeof(FGameplayTagRequirements) == 0x000030, "Wrong size on FGameplayTagRequirements");
static_assert(offsetof(FGameplayTagRequirements, RequireTags) == 0x000000, "Member 'FGameplayTagRequirements::RequireTags' has a wrong offset!");
static_assert(offsetof(FGameplayTagRequirements, IgnoreTags) == 0x000018, "Member 'FGameplayTagRequirements::IgnoreTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayModifierInfo
// 0x0160 (0x0160 - 0x0000)
struct FGameplayModifierInfo final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Magnitude;                                         // 0x0008(0x0014)(NativeAccessSpecifierPublic)
	struct FGameplayEffectModifierMagnitude       ModifierMagnitude;                                 // 0x001C(0x00E4)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTags;                                        // 0x0100(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTags;                                        // 0x0130(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayModifierInfo) == 0x000004, "Wrong alignment on FGameplayModifierInfo");
static_assert(sizeof(FGameplayModifierInfo) == 0x000160, "Wrong size on FGameplayModifierInfo");
static_assert(offsetof(FGameplayModifierInfo, Attribute) == 0x000000, "Member 'FGameplayModifierInfo::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, ModifierOp) == 0x000004, "Member 'FGameplayModifierInfo::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, Magnitude) == 0x000008, "Member 'FGameplayModifierInfo::Magnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, ModifierMagnitude) == 0x00001C, "Member 'FGameplayModifierInfo::ModifierMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, SourceTags) == 0x000100, "Member 'FGameplayModifierInfo::SourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayModifierInfo, TargetTags) == 0x000130, "Member 'FGameplayModifierInfo::TargetTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTargetDataFilter
// 0x0014 (0x0014 - 0x0000)
struct FGameplayTargetDataFilter final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SelfActor;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetDataFilterSelf                         SelfFilter;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     RequiredActorClass;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseFilter;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTargetDataFilter) == 0x000004, "Wrong alignment on FGameplayTargetDataFilter");
static_assert(sizeof(FGameplayTargetDataFilter) == 0x000014, "Wrong size on FGameplayTargetDataFilter");
static_assert(offsetof(FGameplayTargetDataFilter, SelfActor) == 0x000004, "Member 'FGameplayTargetDataFilter::SelfActor' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, SelfFilter) == 0x000008, "Member 'FGameplayTargetDataFilter::SelfFilter' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, RequiredActorClass) == 0x00000C, "Member 'FGameplayTargetDataFilter::RequiredActorClass' has a wrong offset!");
static_assert(offsetof(FGameplayTargetDataFilter, bReverseFilter) == 0x000010, "Member 'FGameplayTargetDataFilter::bReverseFilter' has a wrong offset!");

// ScriptStruct GameplayAbilities.InheritedTagContainer
// 0x0048 (0x0048 - 0x0000)
struct FInheritedTagContainer final
{
public:
	struct FGameplayTagContainer                  CombinedTags;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Added;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Removed;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInheritedTagContainer) == 0x000004, "Wrong alignment on FInheritedTagContainer");
static_assert(sizeof(FInheritedTagContainer) == 0x000048, "Wrong size on FInheritedTagContainer");
static_assert(offsetof(FInheritedTagContainer, CombinedTags) == 0x000000, "Member 'FInheritedTagContainer::CombinedTags' has a wrong offset!");
static_assert(offsetof(FInheritedTagContainer, Added) == 0x000018, "Member 'FInheritedTagContainer::Added' has a wrong offset!");
static_assert(offsetof(FInheritedTagContainer, Removed) == 0x000030, "Member 'FInheritedTagContainer::Removed' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayCue
// 0x0018 (0x0024 - 0x000C)
struct FActiveGameplayCue final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x000C(0x0008)(NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0014(0x000C)(NativeAccessSpecifierPublic)
	bool                                          bPredictivelyRemoved;                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayCue) == 0x000004, "Wrong alignment on FActiveGameplayCue");
static_assert(sizeof(FActiveGameplayCue) == 0x000024, "Wrong size on FActiveGameplayCue");
static_assert(offsetof(FActiveGameplayCue, GameplayCueTag) == 0x00000C, "Member 'FActiveGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, PredictionKey) == 0x000014, "Member 'FActiveGameplayCue::PredictionKey' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCue, bPredictivelyRemoved) == 0x000020, "Member 'FActiveGameplayCue::bPredictivelyRemoved' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayCueContainer
// 0x0010 (0x0090 - 0x0080)
struct FActiveGameplayCueContainer final : public FFastArraySerializer
{
public:
	TArray<struct FActiveGameplayCue>             GameplayCues;                                      // 0x0080(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                Owner;                                             // 0x008C(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveGameplayCueContainer) == 0x000004, "Wrong alignment on FActiveGameplayCueContainer");
static_assert(sizeof(FActiveGameplayCueContainer) == 0x000090, "Wrong size on FActiveGameplayCueContainer");
static_assert(offsetof(FActiveGameplayCueContainer, GameplayCues) == 0x000080, "Member 'FActiveGameplayCueContainer::GameplayCues' has a wrong offset!");
static_assert(offsetof(FActiveGameplayCueContainer, Owner) == 0x00008C, "Member 'FActiveGameplayCueContainer::Owner' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityTriggerData
// 0x000C (0x000C - 0x0000)
struct FAbilityTriggerData final
{
public:
	struct FGameplayTag                           TriggerTag;                                        // 0x0000(0x0008)(Edit, NativeAccessSpecifierPublic)
	EGameplayAbilityTriggerSource                 TriggerSource;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTriggerData) == 0x000004, "Wrong alignment on FAbilityTriggerData");
static_assert(sizeof(FAbilityTriggerData) == 0x00000C, "Wrong size on FAbilityTriggerData");
static_assert(offsetof(FAbilityTriggerData, TriggerTag) == 0x000000, "Member 'FAbilityTriggerData::TriggerTag' has a wrong offset!");
static_assert(offsetof(FAbilityTriggerData, TriggerSource) == 0x000008, "Member 'FAbilityTriggerData::TriggerSource' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData) == 0x000004, "Wrong alignment on FGameplayAbilityTargetData");
static_assert(sizeof(FGameplayAbilityTargetData) == 0x000004, "Wrong size on FGameplayAbilityTargetData");

// ScriptStruct GameplayAbilities.GameplayEffectSpecHandle
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGameplayEffectSpecHandle final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectSpecHandle) == 0x000004, "Wrong alignment on FGameplayEffectSpecHandle");
static_assert(sizeof(FGameplayEffectSpecHandle) == 0x00000C, "Wrong size on FGameplayEffectSpecHandle");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetingLocationInfo
// 0x0070 (0x0070 - 0x0000)
struct FGameplayAbilityTargetingLocationInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayAbilityTargetingLocationType         LocationType;                                      // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LiteralTransform;                                  // 0x0020(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         SourceComponent;                                   // 0x0054(0x0004)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       SourceAbility;                                     // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSocketName;                                  // 0x005C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetingLocationInfo) == 0x000010, "Wrong alignment on FGameplayAbilityTargetingLocationInfo");
static_assert(sizeof(FGameplayAbilityTargetingLocationInfo) == 0x000070, "Wrong size on FGameplayAbilityTargetingLocationInfo");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, LocationType) == 0x000010, "Member 'FGameplayAbilityTargetingLocationInfo::LocationType' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, LiteralTransform) == 0x000020, "Member 'FGameplayAbilityTargetingLocationInfo::LiteralTransform' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceActor) == 0x000050, "Member 'FGameplayAbilityTargetingLocationInfo::SourceActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceComponent) == 0x000054, "Member 'FGameplayAbilityTargetingLocationInfo::SourceComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceAbility) == 0x000058, "Member 'FGameplayAbilityTargetingLocationInfo::SourceAbility' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetingLocationInfo, SourceSocketName) == 0x00005C, "Member 'FGameplayAbilityTargetingLocationInfo::SourceSocketName' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_ActorArray
// 0x008C (0x0090 - 0x0004)
struct FGameplayAbilityTargetData_ActorArray final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x0070)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          TargetActorArray;                                  // 0x0080(0x000C)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetData_ActorArray) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_ActorArray");
static_assert(sizeof(FGameplayAbilityTargetData_ActorArray) == 0x000090, "Wrong size on FGameplayAbilityTargetData_ActorArray");
static_assert(offsetof(FGameplayAbilityTargetData_ActorArray, SourceLocation) == 0x000010, "Member 'FGameplayAbilityTargetData_ActorArray::SourceLocation' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_ActorArray, TargetActorArray) == 0x000080, "Member 'FGameplayAbilityTargetData_ActorArray::TargetActorArray' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEventData
// 0x0058 (0x0058 - 0x0000)
struct FGameplayEventData final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject2;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           ContextHandle;                                     // 0x0018(0x000C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InstigatorTags;                                    // 0x0024(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x003C(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         EventMagnitude;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEventData) == 0x000004, "Wrong alignment on FGameplayEventData");
static_assert(sizeof(FGameplayEventData) == 0x000058, "Wrong size on FGameplayEventData");
static_assert(offsetof(FGameplayEventData, EventTag) == 0x000000, "Member 'FGameplayEventData::EventTag' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, Instigator) == 0x000008, "Member 'FGameplayEventData::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, Target) == 0x00000C, "Member 'FGameplayEventData::Target' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, OptionalObject) == 0x000010, "Member 'FGameplayEventData::OptionalObject' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, OptionalObject2) == 0x000014, "Member 'FGameplayEventData::OptionalObject2' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, ContextHandle) == 0x000018, "Member 'FGameplayEventData::ContextHandle' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, InstigatorTags) == 0x000024, "Member 'FGameplayEventData::InstigatorTags' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, TargetTags) == 0x00003C, "Member 'FGameplayEventData::TargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEventData, EventMagnitude) == 0x000054, "Member 'FGameplayEventData::EventMagnitude' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectSpecForRPC
// 0x0050 (0x0050 - 0x0000)
struct FGameplayEffectSpecForRPC final
{
public:
	class UGameplayEffect*                        Def;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectModifiedAttribute> ModifiedAttributes;                                // 0x0004(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0010(0x000C)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedSourceTags;                              // 0x001C(0x0018)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedTargetTags;                              // 0x0034(0x0018)(NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectSpecForRPC) == 0x000004, "Wrong alignment on FGameplayEffectSpecForRPC");
static_assert(sizeof(FGameplayEffectSpecForRPC) == 0x000050, "Wrong size on FGameplayEffectSpecForRPC");
static_assert(offsetof(FGameplayEffectSpecForRPC, Def) == 0x000000, "Member 'FGameplayEffectSpecForRPC::Def' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, ModifiedAttributes) == 0x000004, "Member 'FGameplayEffectSpecForRPC::ModifiedAttributes' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, EffectContext) == 0x000010, "Member 'FGameplayEffectSpecForRPC::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, AggregatedSourceTags) == 0x00001C, "Member 'FGameplayEffectSpecForRPC::AggregatedSourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, AggregatedTargetTags) == 0x000034, "Member 'FGameplayEffectSpecForRPC::AggregatedTargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectSpecForRPC, Level) == 0x00004C, "Member 'FGameplayEffectSpecForRPC::Level' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueNotifyData
// 0x001C (0x001C - 0x0000)
struct FGameplayCueNotifyData final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Edit, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  GameplayCueNotifyObj;                              // 0x0008(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UClass*                                 LoadedGameplayCueClass;                            // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayCueNotifyData) == 0x000004, "Wrong alignment on FGameplayCueNotifyData");
static_assert(sizeof(FGameplayCueNotifyData) == 0x00001C, "Wrong size on FGameplayCueNotifyData");
static_assert(offsetof(FGameplayCueNotifyData, GameplayCueTag) == 0x000000, "Member 'FGameplayCueNotifyData::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifyData, GameplayCueNotifyObj) == 0x000008, "Member 'FGameplayCueNotifyData::GameplayCueNotifyObj' has a wrong offset!");
static_assert(offsetof(FGameplayCueNotifyData, LoadedGameplayCueClass) == 0x000014, "Member 'FGameplayCueNotifyData::LoadedGameplayCueClass' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCueParameters
// 0x0084 (0x0084 - 0x0000)
struct FGameplayCueParameters final
{
public:
	float                                         NormalizedMagnitude;                               // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawMagnitude;                                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x000C)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   MatchedTagName;                                    // 0x0014(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OriginalTag;                                       // 0x001C(0x0008)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedSourceTags;                              // 0x0024(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AggregatedTargetTags;                              // 0x003C(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  Location;                                          // 0x0054(0x000C)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0060(0x000C)(BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Instigator;                                        // 0x006C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  EffectCauser;                                      // 0x0074(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x007C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCueParameters) == 0x000004, "Wrong alignment on FGameplayCueParameters");
static_assert(sizeof(FGameplayCueParameters) == 0x000084, "Wrong size on FGameplayCueParameters");
static_assert(offsetof(FGameplayCueParameters, NormalizedMagnitude) == 0x000000, "Member 'FGameplayCueParameters::NormalizedMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, RawMagnitude) == 0x000004, "Member 'FGameplayCueParameters::RawMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, EffectContext) == 0x000008, "Member 'FGameplayCueParameters::EffectContext' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, MatchedTagName) == 0x000014, "Member 'FGameplayCueParameters::MatchedTagName' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, OriginalTag) == 0x00001C, "Member 'FGameplayCueParameters::OriginalTag' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, AggregatedSourceTags) == 0x000024, "Member 'FGameplayCueParameters::AggregatedSourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, AggregatedTargetTags) == 0x00003C, "Member 'FGameplayCueParameters::AggregatedTargetTags' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Location) == 0x000054, "Member 'FGameplayCueParameters::Location' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Normal) == 0x000060, "Member 'FGameplayCueParameters::Normal' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, Instigator) == 0x00006C, "Member 'FGameplayCueParameters::Instigator' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, EffectCauser) == 0x000074, "Member 'FGameplayCueParameters::EffectCauser' has a wrong offset!");
static_assert(offsetof(FGameplayCueParameters, SourceObject) == 0x00007C, "Member 'FGameplayCueParameters::SourceObject' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayModifierEvaluatedData
// 0x0014 (0x0014 - 0x0000)
struct FGameplayModifierEvaluatedData final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0004)(NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Magnitude;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            Handle;                                            // 0x000C(0x0004)(NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayModifierEvaluatedData) == 0x000004, "Wrong alignment on FGameplayModifierEvaluatedData");
static_assert(sizeof(FGameplayModifierEvaluatedData) == 0x000014, "Wrong size on FGameplayModifierEvaluatedData");
static_assert(offsetof(FGameplayModifierEvaluatedData, Attribute) == 0x000000, "Member 'FGameplayModifierEvaluatedData::Attribute' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, ModifierOp) == 0x000004, "Member 'FGameplayModifierEvaluatedData::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, Magnitude) == 0x000008, "Member 'FGameplayModifierEvaluatedData::Magnitude' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, Handle) == 0x00000C, "Member 'FGameplayModifierEvaluatedData::Handle' has a wrong offset!");
static_assert(offsetof(FGameplayModifierEvaluatedData, IsValid) == 0x000010, "Member 'FGameplayModifierEvaluatedData::IsValid' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectCustomExecutionOutput
// 0x0010 (0x0010 - 0x0000)
struct FGameplayEffectCustomExecutionOutput final
{
public:
	TArray<struct FGameplayModifierEvaluatedData> OutputModifiers;                                   // 0x0000(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         bTriggerConditionalGameplayEffects : 1;            // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bHandledStackCountManually : 1;                    // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         bHandledGameplayCuesManually : 1;                  // 0x000C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPrivate))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectCustomExecutionOutput) == 0x000004, "Wrong alignment on FGameplayEffectCustomExecutionOutput");
static_assert(sizeof(FGameplayEffectCustomExecutionOutput) == 0x000010, "Wrong size on FGameplayEffectCustomExecutionOutput");
static_assert(offsetof(FGameplayEffectCustomExecutionOutput, OutputModifiers) == 0x000000, "Member 'FGameplayEffectCustomExecutionOutput::OutputModifiers' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetDataHandle
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FGameplayAbilityTargetDataHandle final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilityTargetDataHandle) == 0x000004, "Wrong alignment on FGameplayAbilityTargetDataHandle");
static_assert(sizeof(FGameplayAbilityTargetDataHandle) == 0x000014, "Wrong size on FGameplayAbilityTargetDataHandle");

// ScriptStruct GameplayAbilities.GameplayAbilityLocalAnimMontage
// 0x0018 (0x0018 - 0x0000)
struct FGameplayAbilityLocalAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayBit;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0008(0x000C)(NativeAccessSpecifierPublic)
	class UGameplayAbility*                       AnimatingAbility;                                  // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityLocalAnimMontage) == 0x000004, "Wrong alignment on FGameplayAbilityLocalAnimMontage");
static_assert(sizeof(FGameplayAbilityLocalAnimMontage) == 0x000018, "Wrong size on FGameplayAbilityLocalAnimMontage");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, AnimMontage) == 0x000000, "Member 'FGameplayAbilityLocalAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, PlayBit) == 0x000004, "Member 'FGameplayAbilityLocalAnimMontage::PlayBit' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, PredictionKey) == 0x000008, "Member 'FGameplayAbilityLocalAnimMontage::PredictionKey' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityLocalAnimMontage, AnimatingAbility) == 0x000014, "Member 'FGameplayAbilityLocalAnimMontage::AnimatingAbility' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityRepAnimMontage
// 0x0020 (0x0020 - 0x0000)
struct FGameplayAbilityRepAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextSectionID;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsStopped : 1;                                     // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         ForcePlayBit : 1;                                  // 0x0011(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPredictionKey                         PredictionKey;                                     // 0x0014(0x000C)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityRepAnimMontage) == 0x000004, "Wrong alignment on FGameplayAbilityRepAnimMontage");
static_assert(sizeof(FGameplayAbilityRepAnimMontage) == 0x000020, "Wrong size on FGameplayAbilityRepAnimMontage");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, AnimMontage) == 0x000000, "Member 'FGameplayAbilityRepAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, PlayRate) == 0x000004, "Member 'FGameplayAbilityRepAnimMontage::PlayRate' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, Position) == 0x000008, "Member 'FGameplayAbilityRepAnimMontage::Position' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, BlendTime) == 0x00000C, "Member 'FGameplayAbilityRepAnimMontage::BlendTime' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, NextSectionID) == 0x000010, "Member 'FGameplayAbilityRepAnimMontage::NextSectionID' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityRepAnimMontage, PredictionKey) == 0x000014, "Member 'FGameplayAbilityRepAnimMontage::PredictionKey' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityActorInfo
// 0x0034 (0x0034 - 0x0000)
struct FGameplayAbilityActorInfo final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  OwnerActor;                                        // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AvatarActor;                                       // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerController>       PlayerController;                                  // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> AbilitySystemComponent;                            // 0x001C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAnimInstance>           AnimInstance;                                      // 0x0024(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMovementComponent>      MovementComponent;                                 // 0x002C(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityActorInfo) == 0x000004, "Wrong alignment on FGameplayAbilityActorInfo");
static_assert(sizeof(FGameplayAbilityActorInfo) == 0x000034, "Wrong size on FGameplayAbilityActorInfo");
static_assert(offsetof(FGameplayAbilityActorInfo, OwnerActor) == 0x000004, "Member 'FGameplayAbilityActorInfo::OwnerActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AvatarActor) == 0x00000C, "Member 'FGameplayAbilityActorInfo::AvatarActor' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, PlayerController) == 0x000014, "Member 'FGameplayAbilityActorInfo::PlayerController' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AbilitySystemComponent) == 0x00001C, "Member 'FGameplayAbilityActorInfo::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, AnimInstance) == 0x000024, "Member 'FGameplayAbilityActorInfo::AnimInstance' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityActorInfo, MovementComponent) == 0x00002C, "Member 'FGameplayAbilityActorInfo::MovementComponent' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectQuery
// 0x00CC (0x00CC - 0x0000)
struct FGameplayEffectQuery final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FActiveGameplayEffect& Effect, bool* bMatches)> CustomMatchDelegate_BP;                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      OwningTagQuery;                                    // 0x0018(0x0034)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      EffectTagQuery;                                    // 0x004C(0x0034)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SourceTagQuery;                                    // 0x0080(0x0034)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     ModifyingAttribute;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                EffectSource;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayEffect*                        EffectDefinition;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0xC];                                       // 0x00C0(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectQuery) == 0x000004, "Wrong alignment on FGameplayEffectQuery");
static_assert(sizeof(FGameplayEffectQuery) == 0x0000CC, "Wrong size on FGameplayEffectQuery");
static_assert(offsetof(FGameplayEffectQuery, CustomMatchDelegate_BP) == 0x000008, "Member 'FGameplayEffectQuery::CustomMatchDelegate_BP' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, OwningTagQuery) == 0x000018, "Member 'FGameplayEffectQuery::OwningTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectTagQuery) == 0x00004C, "Member 'FGameplayEffectQuery::EffectTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, SourceTagQuery) == 0x000080, "Member 'FGameplayEffectQuery::SourceTagQuery' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, ModifyingAttribute) == 0x0000B4, "Member 'FGameplayEffectQuery::ModifyingAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectSource) == 0x0000B8, "Member 'FGameplayEffectQuery::EffectSource' has a wrong offset!");
static_assert(offsetof(FGameplayEffectQuery, EffectDefinition) == 0x0000BC, "Member 'FGameplayEffectQuery::EffectDefinition' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecContainer
// 0x0010 (0x0090 - 0x0080)
struct FGameplayAbilitySpecContainer final : public FFastArraySerializer
{
public:
	TArray<struct FGameplayAbilitySpec>           Items;                                             // 0x0080(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayAbilitySpecContainer) == 0x000004, "Wrong alignment on FGameplayAbilitySpecContainer");
static_assert(sizeof(FGameplayAbilitySpecContainer) == 0x000090, "Wrong size on FGameplayAbilitySpecContainer");
static_assert(offsetof(FGameplayAbilitySpecContainer, Items) == 0x000080, "Member 'FGameplayAbilitySpecContainer::Items' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeDefaults
// 0x0008 (0x0008 - 0x0000)
struct FAttributeDefaults final
{
public:
	TSubclassOf<class UAttributeSet>              Attributes;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultStartingTable;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeDefaults) == 0x000004, "Wrong alignment on FAttributeDefaults");
static_assert(sizeof(FAttributeDefaults) == 0x000008, "Wrong size on FAttributeDefaults");
static_assert(offsetof(FAttributeDefaults, Attributes) == 0x000000, "Member 'FAttributeDefaults::Attributes' has a wrong offset!");
static_assert(offsetof(FAttributeDefaults, DefaultStartingTable) == 0x000004, "Member 'FAttributeDefaults::DefaultStartingTable' has a wrong offset!");

// ScriptStruct GameplayAbilities.AttributeMetaData
// 0x001C (0x001C - 0x0000)
struct FAttributeMetaData final : public FTableRowBase
{
public:
	float                                         BaseValue;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DerivedAttributeInfo;                              // 0x000C(0x000C)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStack;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeMetaData) == 0x000004, "Wrong alignment on FAttributeMetaData");
static_assert(sizeof(FAttributeMetaData) == 0x00001C, "Wrong size on FAttributeMetaData");
static_assert(offsetof(FAttributeMetaData, BaseValue) == 0x000000, "Member 'FAttributeMetaData::BaseValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, MinValue) == 0x000004, "Member 'FAttributeMetaData::MinValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, MaxValue) == 0x000008, "Member 'FAttributeMetaData::MaxValue' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, DerivedAttributeInfo) == 0x00000C, "Member 'FAttributeMetaData::DerivedAttributeInfo' has a wrong offset!");
static_assert(offsetof(FAttributeMetaData, bCanStack) == 0x000018, "Member 'FAttributeMetaData::bCanStack' has a wrong offset!");

// ScriptStruct GameplayAbilities.GlobalCurveDataOverride
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGlobalCurveDataOverride final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalCurveDataOverride) == 0x000004, "Wrong alignment on FGlobalCurveDataOverride");
static_assert(sizeof(FGlobalCurveDataOverride) == 0x00000C, "Wrong size on FGlobalCurveDataOverride");

// ScriptStruct GameplayAbilities.GameplayEffectExecutionScopedModifierInfo
// 0x0150 (0x0150 - 0x0000)
struct FGameplayEffectExecutionScopedModifierInfo final
{
public:
	struct FGameplayEffectAttributeCaptureDefinition CapturedAttribute;                                 // 0x0000(0x0008)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	EGameplayModOp                                ModifierOp;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectModifierMagnitude       ModifierMagnitude;                                 // 0x000C(0x00E4)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               SourceTags;                                        // 0x00F0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TargetTags;                                        // 0x0120(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectExecutionScopedModifierInfo) == 0x000004, "Wrong alignment on FGameplayEffectExecutionScopedModifierInfo");
static_assert(sizeof(FGameplayEffectExecutionScopedModifierInfo) == 0x000150, "Wrong size on FGameplayEffectExecutionScopedModifierInfo");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, CapturedAttribute) == 0x000000, "Member 'FGameplayEffectExecutionScopedModifierInfo::CapturedAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, ModifierOp) == 0x000008, "Member 'FGameplayEffectExecutionScopedModifierInfo::ModifierOp' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, ModifierMagnitude) == 0x00000C, "Member 'FGameplayEffectExecutionScopedModifierInfo::ModifierMagnitude' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, SourceTags) == 0x0000F0, "Member 'FGameplayEffectExecutionScopedModifierInfo::SourceTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionScopedModifierInfo, TargetTags) == 0x000120, "Member 'FGameplayEffectExecutionScopedModifierInfo::TargetTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectExecutionDefinition
// 0x0034 (0x0034 - 0x0000)
struct FGameplayEffectExecutionDefinition final
{
public:
	TSubclassOf<class UGameplayEffectExecutionCalculation> CalculationClass;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  PassedInTags;                                      // 0x0004(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectExecutionScopedModifierInfo> CalculationModifiers;                              // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    ConditionalGameplayEffectClasses;                  // 0x0028(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectExecutionDefinition) == 0x000004, "Wrong alignment on FGameplayEffectExecutionDefinition");
static_assert(sizeof(FGameplayEffectExecutionDefinition) == 0x000034, "Wrong size on FGameplayEffectExecutionDefinition");
static_assert(offsetof(FGameplayEffectExecutionDefinition, CalculationClass) == 0x000000, "Member 'FGameplayEffectExecutionDefinition::CalculationClass' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, PassedInTags) == 0x000004, "Member 'FGameplayEffectExecutionDefinition::PassedInTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, CalculationModifiers) == 0x00001C, "Member 'FGameplayEffectExecutionDefinition::CalculationModifiers' has a wrong offset!");
static_assert(offsetof(FGameplayEffectExecutionDefinition, ConditionalGameplayEffectClasses) == 0x000028, "Member 'FGameplayEffectExecutionDefinition::ConditionalGameplayEffectClasses' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_SingleTargetHit
// 0x0080 (0x0084 - 0x0004)
struct FGameplayAbilityTargetData_SingleTargetHit final : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0004(0x0080)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_SingleTargetHit) == 0x000004, "Wrong alignment on FGameplayAbilityTargetData_SingleTargetHit");
static_assert(sizeof(FGameplayAbilityTargetData_SingleTargetHit) == 0x000084, "Wrong size on FGameplayAbilityTargetData_SingleTargetHit");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHit, HitResult) == 0x000004, "Member 'FGameplayAbilityTargetData_SingleTargetHit::HitResult' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilityTargetData_LocationInfo
// 0x00EC (0x00F0 - 0x0004)
struct FGameplayAbilityTargetData_LocationInfo final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x0070)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetingLocationInfo  TargetLocation;                                    // 0x0080(0x0070)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_LocationInfo) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_LocationInfo");
static_assert(sizeof(FGameplayAbilityTargetData_LocationInfo) == 0x0000F0, "Wrong size on FGameplayAbilityTargetData_LocationInfo");
static_assert(offsetof(FGameplayAbilityTargetData_LocationInfo, SourceLocation) == 0x000010, "Member 'FGameplayAbilityTargetData_LocationInfo::SourceLocation' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_LocationInfo, TargetLocation) == 0x000080, "Member 'FGameplayAbilityTargetData_LocationInfo::TargetLocation' has a wrong offset!");

// ScriptStruct GameplayAbilities.ActiveGameplayEffectQuery
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FActiveGameplayEffectQuery final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGameplayEffectQuery) == 0x000004, "Wrong alignment on FActiveGameplayEffectQuery");
static_assert(sizeof(FActiveGameplayEffectQuery) == 0x000030, "Wrong size on FActiveGameplayEffectQuery");

// ScriptStruct GameplayAbilities.GameplayEffectCue
// 0x0024 (0x0024 - 0x0000)
struct FGameplayEffectCue final
{
public:
	struct FGameplayAttribute                     MagnitudeAttribute;                                // 0x0000(0x0004)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MinLevel;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLevel;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayCueTags;                                   // 0x000C(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectCue) == 0x000004, "Wrong alignment on FGameplayEffectCue");
static_assert(sizeof(FGameplayEffectCue) == 0x000024, "Wrong size on FGameplayEffectCue");
static_assert(offsetof(FGameplayEffectCue, MagnitudeAttribute) == 0x000000, "Member 'FGameplayEffectCue::MagnitudeAttribute' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, MinLevel) == 0x000004, "Member 'FGameplayEffectCue::MinLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, MaxLevel) == 0x000008, "Member 'FGameplayEffectCue::MaxLevel' has a wrong offset!");
static_assert(offsetof(FGameplayEffectCue, GameplayCueTags) == 0x00000C, "Member 'FGameplayEffectCue::GameplayCueTags' has a wrong offset!");

// ScriptStruct GameplayAbilities.PreallocationInfo
// 0x004C (0x004C - 0x0000)
struct FPreallocationInfo final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGameplayCueNotify_Actor*>       ClassesNeedingPreallocation;                       // 0x003C(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UWorld*                                 OwningWorld;                                       // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreallocationInfo) == 0x000004, "Wrong alignment on FPreallocationInfo");
static_assert(sizeof(FPreallocationInfo) == 0x00004C, "Wrong size on FPreallocationInfo");
static_assert(offsetof(FPreallocationInfo, ClassesNeedingPreallocation) == 0x00003C, "Member 'FPreallocationInfo::ClassesNeedingPreallocation' has a wrong offset!");
static_assert(offsetof(FPreallocationInfo, OwningWorld) == 0x000048, "Member 'FPreallocationInfo::OwningWorld' has a wrong offset!");

// ScriptStruct GameplayAbilities.AbilityTaskDebugMessage
// 0x0010 (0x0010 - 0x0000)
struct FAbilityTaskDebugMessage final
{
public:
	class UGameplayTask*                          FromTask;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAbilityTaskDebugMessage) == 0x000004, "Wrong alignment on FAbilityTaskDebugMessage");
static_assert(sizeof(FAbilityTaskDebugMessage) == 0x000010, "Wrong size on FAbilityTaskDebugMessage");
static_assert(offsetof(FAbilityTaskDebugMessage, FromTask) == 0x000000, "Member 'FAbilityTaskDebugMessage::FromTask' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayAbilitySpecHandleAndPredictionKey
// 0x0008 (0x0008 - 0x0000)
struct FGameplayAbilitySpecHandleAndPredictionKey final
{
public:
	struct FGameplayAbilitySpecHandle             AbilityHandle;                                     // 0x0000(0x0004)(NativeAccessSpecifierPrivate)
	int32                                         PredictionKeyAtCreation;                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayAbilitySpecHandleAndPredictionKey) == 0x000004, "Wrong alignment on FGameplayAbilitySpecHandleAndPredictionKey");
static_assert(sizeof(FGameplayAbilitySpecHandleAndPredictionKey) == 0x000008, "Wrong size on FGameplayAbilitySpecHandleAndPredictionKey");
static_assert(offsetof(FGameplayAbilitySpecHandleAndPredictionKey, AbilityHandle) == 0x000000, "Member 'FGameplayAbilitySpecHandleAndPredictionKey::AbilityHandle' has a wrong offset!");
static_assert(offsetof(FGameplayAbilitySpecHandleAndPredictionKey, PredictionKeyAtCreation) == 0x000004, "Member 'FGameplayAbilitySpecHandleAndPredictionKey::PredictionKeyAtCreation' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTargetDataFilterHandle
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FGameplayTargetDataFilterHandle final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTargetDataFilterHandle) == 0x000004, "Wrong alignment on FGameplayTargetDataFilterHandle");
static_assert(sizeof(FGameplayTargetDataFilterHandle) == 0x000008, "Wrong size on FGameplayTargetDataFilterHandle");

// ScriptStruct GameplayAbilities.GameplayAbilityBindInfo
// 0x0008 (0x0008 - 0x0000)
struct FGameplayAbilityBindInfo final
{
public:
	EGameplayAbilityInputBinds                    Command;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           GameplayAbilityClass;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityBindInfo) == 0x000004, "Wrong alignment on FGameplayAbilityBindInfo");
static_assert(sizeof(FGameplayAbilityBindInfo) == 0x000008, "Wrong size on FGameplayAbilityBindInfo");
static_assert(offsetof(FGameplayAbilityBindInfo, Command) == 0x000000, "Member 'FGameplayAbilityBindInfo::Command' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityBindInfo, GameplayAbilityClass) == 0x000004, "Member 'FGameplayAbilityBindInfo::GameplayAbilityClass' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayCuePendingExecute
// 0x00F0 (0x00F0 - 0x0000)
struct FGameplayCuePendingExecute final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(NativeAccessSpecifierPublic)
	struct FPredictionKey                         PredictionKey;                                     // 0x0008(0x000C)(NativeAccessSpecifierPublic)
	EGameplayCuePayloadType                       PayloadType;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OwningComponent;                                   // 0x0018(0x0004)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpecForRPC              FromSpec;                                          // 0x001C(0x0050)(NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParameters;                                     // 0x006C(0x0084)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayCuePendingExecute) == 0x000004, "Wrong alignment on FGameplayCuePendingExecute");
static_assert(sizeof(FGameplayCuePendingExecute) == 0x0000F0, "Wrong size on FGameplayCuePendingExecute");
static_assert(offsetof(FGameplayCuePendingExecute, GameplayCueTag) == 0x000000, "Member 'FGameplayCuePendingExecute::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, PredictionKey) == 0x000008, "Member 'FGameplayCuePendingExecute::PredictionKey' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, PayloadType) == 0x000014, "Member 'FGameplayCuePendingExecute::PayloadType' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, OwningComponent) == 0x000018, "Member 'FGameplayCuePendingExecute::OwningComponent' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, FromSpec) == 0x00001C, "Member 'FGameplayCuePendingExecute::FromSpec' has a wrong offset!");
static_assert(offsetof(FGameplayCuePendingExecute, CueParameters) == 0x00006C, "Member 'FGameplayCuePendingExecute::CueParameters' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayEffectCustomExecutionParameters
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x04) FGameplayEffectCustomExecutionParameters final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayEffectCustomExecutionParameters) == 0x000004, "Wrong alignment on FGameplayEffectCustomExecutionParameters");
static_assert(sizeof(FGameplayEffectCustomExecutionParameters) == 0x000060, "Wrong size on FGameplayEffectCustomExecutionParameters");

// ScriptStruct GameplayAbilities.GameplayTagReponsePair
// 0x0010 (0x0010 - 0x0000)
struct FGameplayTagReponsePair final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ResponseGameplayEffect;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SoftCountCap;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagReponsePair) == 0x000004, "Wrong alignment on FGameplayTagReponsePair");
static_assert(sizeof(FGameplayTagReponsePair) == 0x000010, "Wrong size on FGameplayTagReponsePair");
static_assert(offsetof(FGameplayTagReponsePair, Tag) == 0x000000, "Member 'FGameplayTagReponsePair::Tag' has a wrong offset!");
static_assert(offsetof(FGameplayTagReponsePair, ResponseGameplayEffect) == 0x000008, "Member 'FGameplayTagReponsePair::ResponseGameplayEffect' has a wrong offset!");
static_assert(offsetof(FGameplayTagReponsePair, SoftCountCap) == 0x00000C, "Member 'FGameplayTagReponsePair::SoftCountCap' has a wrong offset!");

// ScriptStruct GameplayAbilities.GameplayTagResponseTableEntry
// 0x0020 (0x0020 - 0x0000)
struct FGameplayTagResponseTableEntry final
{
public:
	struct FGameplayTagReponsePair                Positive;                                          // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagReponsePair                Negative;                                          // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagResponseTableEntry) == 0x000004, "Wrong alignment on FGameplayTagResponseTableEntry");
static_assert(sizeof(FGameplayTagResponseTableEntry) == 0x000020, "Wrong size on FGameplayTagResponseTableEntry");
static_assert(offsetof(FGameplayTagResponseTableEntry, Positive) == 0x000000, "Member 'FGameplayTagResponseTableEntry::Positive' has a wrong offset!");
static_assert(offsetof(FGameplayTagResponseTableEntry, Negative) == 0x000010, "Member 'FGameplayTagResponseTableEntry::Negative' has a wrong offset!");

}

#pragma pack(pop)
