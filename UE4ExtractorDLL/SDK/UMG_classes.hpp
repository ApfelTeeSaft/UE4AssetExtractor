#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UMG

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "MovieScene_classes.hpp"
#include "MovieSceneTracks_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Slate_structs.hpp"


#pragma pack(push, 0x4)
namespace SDK
{

// Class UMG.AsyncTaskDownloadImage
// 0x0018 (0x0034 - 0x001C)
class UAsyncTaskDownloadImage final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFail;                                            // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncTaskDownloadImage* DownloadImage(const class FString& URL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskDownloadImage">();
	}
	static class UAsyncTaskDownloadImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskDownloadImage>();
	}
};
static_assert(alignof(UAsyncTaskDownloadImage) == 0x000004, "Wrong alignment on UAsyncTaskDownloadImage");
static_assert(sizeof(UAsyncTaskDownloadImage) == 0x000034, "Wrong size on UAsyncTaskDownloadImage");
static_assert(offsetof(UAsyncTaskDownloadImage, OnSuccess) == 0x00001C, "Member 'UAsyncTaskDownloadImage::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncTaskDownloadImage, OnFail) == 0x000028, "Member 'UAsyncTaskDownloadImage::OnFail' has a wrong offset!");

// Class UMG.DragDropOperation
// 0x0044 (0x0060 - 0x001C)
class UDragDropOperation final : public UObject
{
public:
	class FString                                 Tag;                                               // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                DefaultDragVisual;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDragPivot                                    Pivot;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDrop;                                            // 0x003C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDragCancelled;                                   // 0x0048(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDragged;                                         // 0x0054(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DragCancelled(const struct FPointerEvent& PointerEvent);
	void Dragged(const struct FPointerEvent& PointerEvent);
	void Drop(const struct FPointerEvent& PointerEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropOperation">();
	}
	static class UDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropOperation>();
	}
};
static_assert(alignof(UDragDropOperation) == 0x000004, "Wrong alignment on UDragDropOperation");
static_assert(sizeof(UDragDropOperation) == 0x000060, "Wrong size on UDragDropOperation");
static_assert(offsetof(UDragDropOperation, Tag) == 0x00001C, "Member 'UDragDropOperation::Tag' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Payload) == 0x000028, "Member 'UDragDropOperation::Payload' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, DefaultDragVisual) == 0x00002C, "Member 'UDragDropOperation::DefaultDragVisual' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Pivot) == 0x000030, "Member 'UDragDropOperation::Pivot' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Offset) == 0x000034, "Member 'UDragDropOperation::Offset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDrop) == 0x00003C, "Member 'UDragDropOperation::OnDrop' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDragCancelled) == 0x000048, "Member 'UDragDropOperation::OnDragCancelled' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDragged) == 0x000054, "Member 'UDragDropOperation::OnDragged' has a wrong offset!");

// Class UMG.MovieScene2DTransformSection
// 0x0250 (0x0280 - 0x0030)
class UMovieScene2DTransformSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRichCurve                             Translation[0x2];                                  // 0x0034(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             Rotation;                                          // 0x00DC(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             Scale[0x2];                                        // 0x0130(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             Shear[0x2];                                        // 0x01D8(0x0054)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieScene2DTransformSection">();
	}
	static class UMovieScene2DTransformSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieScene2DTransformSection>();
	}
};
static_assert(alignof(UMovieScene2DTransformSection) == 0x000004, "Wrong alignment on UMovieScene2DTransformSection");
static_assert(sizeof(UMovieScene2DTransformSection) == 0x000280, "Wrong size on UMovieScene2DTransformSection");
static_assert(offsetof(UMovieScene2DTransformSection, Translation) == 0x000034, "Member 'UMovieScene2DTransformSection::Translation' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Rotation) == 0x0000DC, "Member 'UMovieScene2DTransformSection::Rotation' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Scale) == 0x000130, "Member 'UMovieScene2DTransformSection::Scale' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Shear) == 0x0001D8, "Member 'UMovieScene2DTransformSection::Shear' has a wrong offset!");

// Class UMG.MovieScene2DTransformTrack
// 0x0000 (0x003C - 0x003C)
class UMovieScene2DTransformTrack final : public UMovieScenePropertyTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieScene2DTransformTrack">();
	}
	static class UMovieScene2DTransformTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieScene2DTransformTrack>();
	}
};
static_assert(alignof(UMovieScene2DTransformTrack) == 0x000004, "Wrong alignment on UMovieScene2DTransformTrack");
static_assert(sizeof(UMovieScene2DTransformTrack) == 0x00003C, "Wrong size on UMovieScene2DTransformTrack");

// Class UMG.MovieSceneMarginSection
// 0x0154 (0x0184 - 0x0030)
class UMovieSceneMarginSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRichCurve                             TopCurve;                                          // 0x0034(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             LeftCurve;                                         // 0x0088(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             RightCurve;                                        // 0x00DC(0x0054)(NativeAccessSpecifierPrivate)
	struct FRichCurve                             BottomCurve;                                       // 0x0130(0x0054)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneMarginSection">();
	}
	static class UMovieSceneMarginSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneMarginSection>();
	}
};
static_assert(alignof(UMovieSceneMarginSection) == 0x000004, "Wrong alignment on UMovieSceneMarginSection");
static_assert(sizeof(UMovieSceneMarginSection) == 0x000184, "Wrong size on UMovieSceneMarginSection");
static_assert(offsetof(UMovieSceneMarginSection, TopCurve) == 0x000034, "Member 'UMovieSceneMarginSection::TopCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, LeftCurve) == 0x000088, "Member 'UMovieSceneMarginSection::LeftCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, RightCurve) == 0x0000DC, "Member 'UMovieSceneMarginSection::RightCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, BottomCurve) == 0x000130, "Member 'UMovieSceneMarginSection::BottomCurve' has a wrong offset!");

// Class UMG.MovieSceneMarginTrack
// 0x0000 (0x003C - 0x003C)
class UMovieSceneMarginTrack final : public UMovieScenePropertyTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneMarginTrack">();
	}
	static class UMovieSceneMarginTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneMarginTrack>();
	}
};
static_assert(alignof(UMovieSceneMarginTrack) == 0x000004, "Wrong alignment on UMovieSceneMarginTrack");
static_assert(sizeof(UMovieSceneMarginTrack) == 0x00003C, "Wrong size on UMovieSceneMarginTrack");

// Class UMG.NamedSlotInterface
// 0x0000 (0x001C - 0x001C)
class INamedSlotInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamedSlotInterface">();
	}
	static class INamedSlotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INamedSlotInterface>();
	}
};
static_assert(alignof(INamedSlotInterface) == 0x000004, "Wrong alignment on INamedSlotInterface");
static_assert(sizeof(INamedSlotInterface) == 0x00001C, "Wrong size on INamedSlotInterface");

// Class UMG.PropertyBinding
// 0x001C (0x0038 - 0x001C)
class UPropertyBinding : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FDynamicPropertyPath                   SourcePath;                                        // 0x0024(0x000C)(NativeAccessSpecifierPublic)
	class FName                                   DestinationProperty;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyBinding">();
	}
	static class UPropertyBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyBinding>();
	}
};
static_assert(alignof(UPropertyBinding) == 0x000004, "Wrong alignment on UPropertyBinding");
static_assert(sizeof(UPropertyBinding) == 0x000038, "Wrong size on UPropertyBinding");
static_assert(offsetof(UPropertyBinding, SourceObject) == 0x00001C, "Member 'UPropertyBinding::SourceObject' has a wrong offset!");
static_assert(offsetof(UPropertyBinding, SourcePath) == 0x000024, "Member 'UPropertyBinding::SourcePath' has a wrong offset!");
static_assert(offsetof(UPropertyBinding, DestinationProperty) == 0x000030, "Member 'UPropertyBinding::DestinationProperty' has a wrong offset!");

// Class UMG.BoolBinding
// 0x0000 (0x0038 - 0x0038)
class UBoolBinding final : public UPropertyBinding
{
public:
	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoolBinding">();
	}
	static class UBoolBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoolBinding>();
	}
};
static_assert(alignof(UBoolBinding) == 0x000004, "Wrong alignment on UBoolBinding");
static_assert(sizeof(UBoolBinding) == 0x000038, "Wrong size on UBoolBinding");

// Class UMG.BrushBinding
// 0x0004 (0x003C - 0x0038)
class UBrushBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSlateBrush GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrushBinding">();
	}
	static class UBrushBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrushBinding>();
	}
};
static_assert(alignof(UBrushBinding) == 0x000004, "Wrong alignment on UBrushBinding");
static_assert(sizeof(UBrushBinding) == 0x00003C, "Wrong size on UBrushBinding");

// Class UMG.CheckedStateBinding
// 0x0004 (0x003C - 0x0038)
class UCheckedStateBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ECheckBoxState GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckedStateBinding">();
	}
	static class UCheckedStateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckedStateBinding>();
	}
};
static_assert(alignof(UCheckedStateBinding) == 0x000004, "Wrong alignment on UCheckedStateBinding");
static_assert(sizeof(UCheckedStateBinding) == 0x00003C, "Wrong size on UCheckedStateBinding");

// Class UMG.ColorBinding
// 0x0004 (0x003C - 0x0038)
class UColorBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetLinearValue() const;
	struct FSlateColor GetSlateValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBinding">();
	}
	static class UColorBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorBinding>();
	}
};
static_assert(alignof(UColorBinding) == 0x000004, "Wrong alignment on UColorBinding");
static_assert(sizeof(UColorBinding) == 0x00003C, "Wrong size on UColorBinding");

// Class UMG.FloatBinding
// 0x0000 (0x0038 - 0x0038)
class UFloatBinding final : public UPropertyBinding
{
public:
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatBinding">();
	}
	static class UFloatBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatBinding>();
	}
};
static_assert(alignof(UFloatBinding) == 0x000004, "Wrong alignment on UFloatBinding");
static_assert(sizeof(UFloatBinding) == 0x000038, "Wrong size on UFloatBinding");

// Class UMG.Int32Binding
// 0x0000 (0x0038 - 0x0038)
class UInt32Binding final : public UPropertyBinding
{
public:
	int32 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Int32Binding">();
	}
	static class UInt32Binding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInt32Binding>();
	}
};
static_assert(alignof(UInt32Binding) == 0x000004, "Wrong alignment on UInt32Binding");
static_assert(sizeof(UInt32Binding) == 0x000038, "Wrong size on UInt32Binding");

// Class UMG.MouseCursorBinding
// 0x0000 (0x0038 - 0x0038)
class UMouseCursorBinding final : public UPropertyBinding
{
public:
	EMouseCursor GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseCursorBinding">();
	}
	static class UMouseCursorBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseCursorBinding>();
	}
};
static_assert(alignof(UMouseCursorBinding) == 0x000004, "Wrong alignment on UMouseCursorBinding");
static_assert(sizeof(UMouseCursorBinding) == 0x000038, "Wrong size on UMouseCursorBinding");

// Class UMG.TextBinding
// 0x0004 (0x003C - 0x0038)
class UTextBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetStringValue() const;
	class FText GetTextValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextBinding">();
	}
	static class UTextBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextBinding>();
	}
};
static_assert(alignof(UTextBinding) == 0x000004, "Wrong alignment on UTextBinding");
static_assert(sizeof(UTextBinding) == 0x00003C, "Wrong size on UTextBinding");

// Class UMG.VisibilityBinding
// 0x0000 (0x0038 - 0x0038)
class UVisibilityBinding final : public UPropertyBinding
{
public:
	ESlateVisibility GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibilityBinding">();
	}
	static class UVisibilityBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibilityBinding>();
	}
};
static_assert(alignof(UVisibilityBinding) == 0x000004, "Wrong alignment on UVisibilityBinding");
static_assert(sizeof(UVisibilityBinding) == 0x000038, "Wrong size on UVisibilityBinding");

// Class UMG.WidgetBinding
// 0x0000 (0x0038 - 0x0038)
class UWidgetBinding final : public UPropertyBinding
{
public:
	class UWidget* GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetBinding">();
	}
	static class UWidgetBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetBinding>();
	}
};
static_assert(alignof(UWidgetBinding) == 0x000004, "Wrong alignment on UWidgetBinding");
static_assert(sizeof(UWidgetBinding) == 0x000038, "Wrong size on UWidgetBinding");

// Class UMG.RichTextBlockDecorator
// 0x0008 (0x0024 - 0x001C)
class URichTextBlockDecorator final : public UObject
{
public:
	bool                                          bReveal;                                           // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RevealedIndex;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockDecorator">();
	}
	static class URichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockDecorator>();
	}
};
static_assert(alignof(URichTextBlockDecorator) == 0x000004, "Wrong alignment on URichTextBlockDecorator");
static_assert(sizeof(URichTextBlockDecorator) == 0x000024, "Wrong size on URichTextBlockDecorator");
static_assert(offsetof(URichTextBlockDecorator, bReveal) == 0x00001C, "Member 'URichTextBlockDecorator::bReveal' has a wrong offset!");
static_assert(offsetof(URichTextBlockDecorator, RevealedIndex) == 0x000020, "Member 'URichTextBlockDecorator::RevealedIndex' has a wrong offset!");

// Class UMG.SlateBlueprintLibrary
// 0x0000 (0x001C - 0x001C)
class USlateBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D AbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate);
	static void AbsoluteToViewport(class UObject* WorldContextObject, const struct FVector2D& AbsoluteDesktopCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition);
	static struct FVector2D GetLocalSize(const struct FGeometry& Geometry);
	static bool IsUnderLocation(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate);
	static struct FVector2D LocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate);
	static void LocalToViewport(class UObject* WorldContextObject, const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateBlueprintLibrary">();
	}
	static class USlateBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlateBlueprintLibrary>();
	}
};
static_assert(alignof(USlateBlueprintLibrary) == 0x000004, "Wrong alignment on USlateBlueprintLibrary");
static_assert(sizeof(USlateBlueprintLibrary) == 0x00001C, "Wrong size on USlateBlueprintLibrary");

// Class UMG.SlateDataSheet
// 0x0404 (0x0420 - 0x001C)
class USlateDataSheet final : public UObject
{
public:
	class UTexture2D*                             DataTexture;                                       // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20[0x400];                                     // 0x0020(0x0400)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateDataSheet">();
	}
	static class USlateDataSheet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlateDataSheet>();
	}
};
static_assert(alignof(USlateDataSheet) == 0x000004, "Wrong alignment on USlateDataSheet");
static_assert(sizeof(USlateDataSheet) == 0x000420, "Wrong size on USlateDataSheet");
static_assert(offsetof(USlateDataSheet, DataTexture) == 0x00001C, "Member 'USlateDataSheet::DataTexture' has a wrong offset!");

// Class UMG.SlateVectorArtData
// 0x002C (0x0048 - 0x001C)
class USlateVectorArtData final : public UObject
{
public:
	TArray<struct FSlateMeshVertex>               VertexData;                                        // 0x001C(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint32>                                IndexData;                                         // 0x0028(0x000C)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     Material;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ExtentMin;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              ExtentMax;                                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlateVectorArtData">();
	}
	static class USlateVectorArtData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlateVectorArtData>();
	}
};
static_assert(alignof(USlateVectorArtData) == 0x000004, "Wrong alignment on USlateVectorArtData");
static_assert(sizeof(USlateVectorArtData) == 0x000048, "Wrong size on USlateVectorArtData");
static_assert(offsetof(USlateVectorArtData, VertexData) == 0x00001C, "Member 'USlateVectorArtData::VertexData' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, IndexData) == 0x000028, "Member 'USlateVectorArtData::IndexData' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, Material) == 0x000034, "Member 'USlateVectorArtData::Material' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, ExtentMin) == 0x000038, "Member 'USlateVectorArtData::ExtentMin' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, ExtentMax) == 0x000040, "Member 'USlateVectorArtData::ExtentMax' has a wrong offset!");

// Class UMG.UMGSequencePlayer
// 0x00A8 (0x00C4 - 0x001C)
class UUMGSequencePlayer final : public UObject
{
public:
	uint8                                         Pad_1C[0x10];                                      // 0x001C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       Animation;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x94];                                      // 0x0030(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSequencePlayer">();
	}
	static class UUMGSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSequencePlayer>();
	}
};
static_assert(alignof(UUMGSequencePlayer) == 0x000004, "Wrong alignment on UUMGSequencePlayer");
static_assert(sizeof(UUMGSequencePlayer) == 0x0000C4, "Wrong size on UUMGSequencePlayer");
static_assert(offsetof(UUMGSequencePlayer, Animation) == 0x00002C, "Member 'UUMGSequencePlayer::Animation' has a wrong offset!");

// Class UMG.Visual
// 0x0000 (0x001C - 0x001C)
class UVisual : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Visual">();
	}
	static class UVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisual>();
	}
};
static_assert(alignof(UVisual) == 0x000004, "Wrong alignment on UVisual");
static_assert(sizeof(UVisual) == 0x00001C, "Wrong size on UVisual");

// Class UMG.PanelSlot
// 0x0008 (0x0024 - 0x001C)
class UPanelSlot : public UVisual
{
public:
	class UPanelWidget*                           Parent;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Content;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PanelSlot">();
	}
	static class UPanelSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPanelSlot>();
	}
};
static_assert(alignof(UPanelSlot) == 0x000004, "Wrong alignment on UPanelSlot");
static_assert(sizeof(UPanelSlot) == 0x000024, "Wrong size on UPanelSlot");
static_assert(offsetof(UPanelSlot, Parent) == 0x00001C, "Member 'UPanelSlot::Parent' has a wrong offset!");
static_assert(offsetof(UPanelSlot, Content) == 0x000020, "Member 'UPanelSlot::Content' has a wrong offset!");

// Class UMG.BorderSlot
// 0x001C (0x0040 - 0x0024)
class UBorderSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36[0xA];                                       // 0x0036(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderSlot">();
	}
	static class UBorderSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBorderSlot>();
	}
};
static_assert(alignof(UBorderSlot) == 0x000004, "Wrong alignment on UBorderSlot");
static_assert(sizeof(UBorderSlot) == 0x000040, "Wrong size on UBorderSlot");
static_assert(offsetof(UBorderSlot, Padding) == 0x000024, "Member 'UBorderSlot::Padding' has a wrong offset!");
static_assert(offsetof(UBorderSlot, HorizontalAlignment) == 0x000034, "Member 'UBorderSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBorderSlot, VerticalAlignment) == 0x000035, "Member 'UBorderSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.ButtonSlot
// 0x001C (0x0040 - 0x0024)
class UButtonSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0xA];                                       // 0x0036(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonSlot">();
	}
	static class UButtonSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonSlot>();
	}
};
static_assert(alignof(UButtonSlot) == 0x000004, "Wrong alignment on UButtonSlot");
static_assert(sizeof(UButtonSlot) == 0x000040, "Wrong size on UButtonSlot");
static_assert(offsetof(UButtonSlot, Padding) == 0x000024, "Member 'UButtonSlot::Padding' has a wrong offset!");
static_assert(offsetof(UButtonSlot, HorizontalAlignment) == 0x000034, "Member 'UButtonSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UButtonSlot, VerticalAlignment) == 0x000035, "Member 'UButtonSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.CanvasPanelSlot
// 0x0034 (0x0058 - 0x0024)
class UCanvasPanelSlot final : public UPanelSlot
{
public:
	struct FAnchorData                            LayoutData;                                        // 0x0024(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAutoSize;                                         // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlignment(const struct FVector2D& InAlignment);
	void SetAnchors(const struct FAnchors& InAnchors);
	void SetAutoSize(bool InbAutoSize);
	void SetLayout(const struct FAnchorData& InLayoutData);
	void SetMaximum(const struct FVector2D& InMaximumAnchors);
	void SetMinimum(const struct FVector2D& InMinimumAnchors);
	void SetOffsets(const struct FMargin& InOffset);
	void SetPosition(const struct FVector2D& InPosition);
	void SetSize(const struct FVector2D& InSize);
	void SetZOrder(int32 InZOrder);

	struct FVector2D GetAlignment() const;
	struct FAnchors GetAnchors() const;
	bool GetAutoSize() const;
	struct FAnchorData GetLayout() const;
	struct FMargin GetOffsets() const;
	struct FVector2D GetPosition() const;
	struct FVector2D GetSize() const;
	int32 GetZOrder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanvasPanelSlot">();
	}
	static class UCanvasPanelSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanvasPanelSlot>();
	}
};
static_assert(alignof(UCanvasPanelSlot) == 0x000004, "Wrong alignment on UCanvasPanelSlot");
static_assert(sizeof(UCanvasPanelSlot) == 0x000058, "Wrong size on UCanvasPanelSlot");
static_assert(offsetof(UCanvasPanelSlot, LayoutData) == 0x000024, "Member 'UCanvasPanelSlot::LayoutData' has a wrong offset!");
static_assert(offsetof(UCanvasPanelSlot, bAutoSize) == 0x00004C, "Member 'UCanvasPanelSlot::bAutoSize' has a wrong offset!");
static_assert(offsetof(UCanvasPanelSlot, ZOrder) == 0x000050, "Member 'UCanvasPanelSlot::ZOrder' has a wrong offset!");

// Class UMG.GridSlot
// 0x0024 (0x0048 - 0x0024)
class UGridSlot final : public UPanelSlot
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Row;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RowSpan;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColumnSpan;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Layer;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Nudge;                                             // 0x003C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 InColumn);
	void SetColumnSpan(int32 InColumnSpan);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetLayer(int32 InLayer);
	void SetRow(int32 InRow);
	void SetRowSpan(int32 InRowSpan);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridSlot">();
	}
	static class UGridSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridSlot>();
	}
};
static_assert(alignof(UGridSlot) == 0x000004, "Wrong alignment on UGridSlot");
static_assert(sizeof(UGridSlot) == 0x000048, "Wrong size on UGridSlot");
static_assert(offsetof(UGridSlot, HorizontalAlignment) == 0x000024, "Member 'UGridSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UGridSlot, VerticalAlignment) == 0x000025, "Member 'UGridSlot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UGridSlot, Row) == 0x000028, "Member 'UGridSlot::Row' has a wrong offset!");
static_assert(offsetof(UGridSlot, RowSpan) == 0x00002C, "Member 'UGridSlot::RowSpan' has a wrong offset!");
static_assert(offsetof(UGridSlot, Column) == 0x000030, "Member 'UGridSlot::Column' has a wrong offset!");
static_assert(offsetof(UGridSlot, ColumnSpan) == 0x000034, "Member 'UGridSlot::ColumnSpan' has a wrong offset!");
static_assert(offsetof(UGridSlot, Layer) == 0x000038, "Member 'UGridSlot::Layer' has a wrong offset!");
static_assert(offsetof(UGridSlot, Nudge) == 0x00003C, "Member 'UGridSlot::Nudge' has a wrong offset!");

// Class UMG.HorizontalBoxSlot
// 0x0020 (0x0044 - 0x0024)
class UHorizontalBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateChildSize                        Size;                                              // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x6];                                       // 0x003E(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetSize(const struct FSlateChildSize& InSize);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorizontalBoxSlot">();
	}
	static class UHorizontalBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorizontalBoxSlot>();
	}
};
static_assert(alignof(UHorizontalBoxSlot) == 0x000004, "Wrong alignment on UHorizontalBoxSlot");
static_assert(sizeof(UHorizontalBoxSlot) == 0x000044, "Wrong size on UHorizontalBoxSlot");
static_assert(offsetof(UHorizontalBoxSlot, Padding) == 0x000024, "Member 'UHorizontalBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, Size) == 0x000034, "Member 'UHorizontalBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, HorizontalAlignment) == 0x00003C, "Member 'UHorizontalBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, VerticalAlignment) == 0x00003D, "Member 'UHorizontalBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.OverlaySlot
// 0x0018 (0x003C - 0x0024)
class UOverlaySlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x6];                                       // 0x0036(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverlaySlot">();
	}
	static class UOverlaySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlaySlot>();
	}
};
static_assert(alignof(UOverlaySlot) == 0x000004, "Wrong alignment on UOverlaySlot");
static_assert(sizeof(UOverlaySlot) == 0x00003C, "Wrong size on UOverlaySlot");
static_assert(offsetof(UOverlaySlot, Padding) == 0x000024, "Member 'UOverlaySlot::Padding' has a wrong offset!");
static_assert(offsetof(UOverlaySlot, HorizontalAlignment) == 0x000034, "Member 'UOverlaySlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UOverlaySlot, VerticalAlignment) == 0x000035, "Member 'UOverlaySlot::VerticalAlignment' has a wrong offset!");

// Class UMG.SafeZoneSlot
// 0x0014 (0x0038 - 0x0024)
class USafeZoneSlot final : public UPanelSlot
{
public:
	bool                                          bIsTitleSafe;                                      // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HAlign;                                            // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VAlign;                                            // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneSlot">();
	}
	static class USafeZoneSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneSlot>();
	}
};
static_assert(alignof(USafeZoneSlot) == 0x000004, "Wrong alignment on USafeZoneSlot");
static_assert(sizeof(USafeZoneSlot) == 0x000038, "Wrong size on USafeZoneSlot");
static_assert(offsetof(USafeZoneSlot, bIsTitleSafe) == 0x000024, "Member 'USafeZoneSlot::bIsTitleSafe' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, HAlign) == 0x000025, "Member 'USafeZoneSlot::HAlign' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, VAlign) == 0x000026, "Member 'USafeZoneSlot::VAlign' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, Padding) == 0x000028, "Member 'USafeZoneSlot::Padding' has a wrong offset!");

// Class UMG.ScaleBoxSlot
// 0x001C (0x0040 - 0x0024)
class UScaleBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0xA];                                       // 0x0036(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleBoxSlot">();
	}
	static class UScaleBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScaleBoxSlot>();
	}
};
static_assert(alignof(UScaleBoxSlot) == 0x000004, "Wrong alignment on UScaleBoxSlot");
static_assert(sizeof(UScaleBoxSlot) == 0x000040, "Wrong size on UScaleBoxSlot");
static_assert(offsetof(UScaleBoxSlot, Padding) == 0x000024, "Member 'UScaleBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UScaleBoxSlot, HorizontalAlignment) == 0x000034, "Member 'UScaleBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UScaleBoxSlot, VerticalAlignment) == 0x000035, "Member 'UScaleBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.ScrollBoxSlot
// 0x0018 (0x003C - 0x0024)
class UScrollBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x7];                                       // 0x0035(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollBoxSlot">();
	}
	static class UScrollBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollBoxSlot>();
	}
};
static_assert(alignof(UScrollBoxSlot) == 0x000004, "Wrong alignment on UScrollBoxSlot");
static_assert(sizeof(UScrollBoxSlot) == 0x00003C, "Wrong size on UScrollBoxSlot");
static_assert(offsetof(UScrollBoxSlot, Padding) == 0x000024, "Member 'UScrollBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UScrollBoxSlot, HorizontalAlignment) == 0x000034, "Member 'UScrollBoxSlot::HorizontalAlignment' has a wrong offset!");

// Class UMG.SizeBoxSlot
// 0x001C (0x0040 - 0x0024)
class USizeBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0xA];                                       // 0x0036(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SizeBoxSlot">();
	}
	static class USizeBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<USizeBoxSlot>();
	}
};
static_assert(alignof(USizeBoxSlot) == 0x000004, "Wrong alignment on USizeBoxSlot");
static_assert(sizeof(USizeBoxSlot) == 0x000040, "Wrong size on USizeBoxSlot");
static_assert(offsetof(USizeBoxSlot, Padding) == 0x000024, "Member 'USizeBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(USizeBoxSlot, HorizontalAlignment) == 0x000034, "Member 'USizeBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(USizeBoxSlot, VerticalAlignment) == 0x000035, "Member 'USizeBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.UniformGridSlot
// 0x0010 (0x0034 - 0x0024)
class UUniformGridSlot final : public UPanelSlot
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Row;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x4];                                       // 0x0030(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 InColumn);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetRow(int32 InRow);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniformGridSlot">();
	}
	static class UUniformGridSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniformGridSlot>();
	}
};
static_assert(alignof(UUniformGridSlot) == 0x000004, "Wrong alignment on UUniformGridSlot");
static_assert(sizeof(UUniformGridSlot) == 0x000034, "Wrong size on UUniformGridSlot");
static_assert(offsetof(UUniformGridSlot, HorizontalAlignment) == 0x000024, "Member 'UUniformGridSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, VerticalAlignment) == 0x000025, "Member 'UUniformGridSlot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, Row) == 0x000028, "Member 'UUniformGridSlot::Row' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, Column) == 0x00002C, "Member 'UUniformGridSlot::Column' has a wrong offset!");

// Class UMG.VerticalBoxSlot
// 0x0020 (0x0044 - 0x0024)
class UVerticalBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateChildSize                        Size;                                              // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x6];                                       // 0x003E(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetSize(const struct FSlateChildSize& InSize);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerticalBoxSlot">();
	}
	static class UVerticalBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerticalBoxSlot>();
	}
};
static_assert(alignof(UVerticalBoxSlot) == 0x000004, "Wrong alignment on UVerticalBoxSlot");
static_assert(sizeof(UVerticalBoxSlot) == 0x000044, "Wrong size on UVerticalBoxSlot");
static_assert(offsetof(UVerticalBoxSlot, Padding) == 0x000024, "Member 'UVerticalBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, Size) == 0x000034, "Member 'UVerticalBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, HorizontalAlignment) == 0x00003C, "Member 'UVerticalBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, VerticalAlignment) == 0x00003D, "Member 'UVerticalBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.WidgetSwitcherSlot
// 0x0018 (0x003C - 0x0024)
class UWidgetSwitcherSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x6];                                       // 0x0036(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetSwitcherSlot">();
	}
	static class UWidgetSwitcherSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetSwitcherSlot>();
	}
};
static_assert(alignof(UWidgetSwitcherSlot) == 0x000004, "Wrong alignment on UWidgetSwitcherSlot");
static_assert(sizeof(UWidgetSwitcherSlot) == 0x00003C, "Wrong size on UWidgetSwitcherSlot");
static_assert(offsetof(UWidgetSwitcherSlot, Padding) == 0x000024, "Member 'UWidgetSwitcherSlot::Padding' has a wrong offset!");
static_assert(offsetof(UWidgetSwitcherSlot, HorizontalAlignment) == 0x000034, "Member 'UWidgetSwitcherSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWidgetSwitcherSlot, VerticalAlignment) == 0x000035, "Member 'UWidgetSwitcherSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.WrapBoxSlot
// 0x0020 (0x0044 - 0x0024)
class UWrapBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bFillEmptySpace;                                   // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FillSpanWhenLessThan;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x6];                                       // 0x003E(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillEmptySpace(bool InbFillEmptySpace);
	void SetFillSpanWhenLessThan(float InFillSpanWhenLessThan);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrapBoxSlot">();
	}
	static class UWrapBoxSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWrapBoxSlot>();
	}
};
static_assert(alignof(UWrapBoxSlot) == 0x000004, "Wrong alignment on UWrapBoxSlot");
static_assert(sizeof(UWrapBoxSlot) == 0x000044, "Wrong size on UWrapBoxSlot");
static_assert(offsetof(UWrapBoxSlot, Padding) == 0x000024, "Member 'UWrapBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, bFillEmptySpace) == 0x000034, "Member 'UWrapBoxSlot::bFillEmptySpace' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, FillSpanWhenLessThan) == 0x000038, "Member 'UWrapBoxSlot::FillSpanWhenLessThan' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, HorizontalAlignment) == 0x00003C, "Member 'UWrapBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, VerticalAlignment) == 0x00003D, "Member 'UWrapBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.Widget
// 0x00B4 (0x00D0 - 0x001C)
class UWidget : public UVisual
{
public:
	bool                                          bIsVariable;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCreatedByConstructionScript;                      // 0x001D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelSlot*                             Slot;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             bIsEnabledDelegate;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   ToolTipText;                                       // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ToolTipTextDelegate;                               // 0x0044(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UWidget*                                ToolTipWidget;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ToolTipWidgetDelegate;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visiblity;                                         // 0x0068(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visibility;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             VisibilityDelegate;                                // 0x006C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverride_Cursor : 1;                              // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EMouseCursor                                  Cursor;                                            // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVolatile;                                       // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetTransform                       RenderTransform;                                   // 0x0084(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              RenderTransformPivot;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UWidgetNavigation*                      Navigation;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x18];                                      // 0x00AC(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPropertyBinding*>               NativeBindings;                                    // 0x00C4(0x000C)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ForceLayoutPrepass();
	void ForceVolatile(bool bForce);
	void InvalidateLayoutAndVolatility();
	void RemoveFromParent();
	void ResetCursor();
	void SetCursor(EMouseCursor InCursor);
	void SetIsEnabled(bool bInIsEnabled);
	void SetKeyboardFocus();
	void SetRenderAngle(float Angle);
	void SetRenderScale(const struct FVector2D& Scale);
	void SetRenderShear(const struct FVector2D& Shear);
	void SetRenderTransform(const struct FWidgetTransform& InTransform);
	void SetRenderTransformPivot(const struct FVector2D& Pivot);
	void SetRenderTranslation(const struct FVector2D& Translation);
	void SetToolTip(class UWidget* Widget);
	void SetToolTipText(const class FText& InToolTipText);
	void SetUserFocus(class APlayerController* PlayerController);
	void SetVisibility(ESlateVisibility InVisibility);

	struct FVector2D GetDesiredSize() const;
	bool GetIsEnabled() const;
	class UPanelWidget* GetParent() const;
	ESlateVisibility GetVisibility() const;
	bool HasAnyUserFocus() const;
	bool HasFocusedDescendants() const;
	bool HasKeyboardFocus() const;
	bool HasMouseCapture() const;
	bool HasUserFocus(class APlayerController* PlayerController) const;
	bool HasUserFocusedDescendants(class APlayerController* PlayerController) const;
	bool IsHovered() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Widget">();
	}
	static class UWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidget>();
	}
};
static_assert(alignof(UWidget) == 0x000004, "Wrong alignment on UWidget");
static_assert(sizeof(UWidget) == 0x0000D0, "Wrong size on UWidget");
static_assert(offsetof(UWidget, bIsVariable) == 0x00001C, "Member 'UWidget::bIsVariable' has a wrong offset!");
static_assert(offsetof(UWidget, bCreatedByConstructionScript) == 0x00001D, "Member 'UWidget::bCreatedByConstructionScript' has a wrong offset!");
static_assert(offsetof(UWidget, Slot) == 0x000020, "Member 'UWidget::Slot' has a wrong offset!");
static_assert(offsetof(UWidget, bIsEnabled) == 0x000024, "Member 'UWidget::bIsEnabled' has a wrong offset!");
static_assert(offsetof(UWidget, bIsEnabledDelegate) == 0x000028, "Member 'UWidget::bIsEnabledDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipText) == 0x000038, "Member 'UWidget::ToolTipText' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipTextDelegate) == 0x000044, "Member 'UWidget::ToolTipTextDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipWidget) == 0x000054, "Member 'UWidget::ToolTipWidget' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipWidgetDelegate) == 0x000058, "Member 'UWidget::ToolTipWidgetDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, Visiblity) == 0x000068, "Member 'UWidget::Visiblity' has a wrong offset!");
static_assert(offsetof(UWidget, Visibility) == 0x000069, "Member 'UWidget::Visibility' has a wrong offset!");
static_assert(offsetof(UWidget, VisibilityDelegate) == 0x00006C, "Member 'UWidget::VisibilityDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, Cursor) == 0x000080, "Member 'UWidget::Cursor' has a wrong offset!");
static_assert(offsetof(UWidget, bIsVolatile) == 0x000081, "Member 'UWidget::bIsVolatile' has a wrong offset!");
static_assert(offsetof(UWidget, RenderTransform) == 0x000084, "Member 'UWidget::RenderTransform' has a wrong offset!");
static_assert(offsetof(UWidget, RenderTransformPivot) == 0x0000A0, "Member 'UWidget::RenderTransformPivot' has a wrong offset!");
static_assert(offsetof(UWidget, Navigation) == 0x0000A8, "Member 'UWidget::Navigation' has a wrong offset!");
static_assert(offsetof(UWidget, NativeBindings) == 0x0000C4, "Member 'UWidget::NativeBindings' has a wrong offset!");

// Class UMG.CircularThrobber
// 0x008C (0x015C - 0x00D0)
class UCircularThrobber final : public UWidget
{
public:
	int32                                         NumberOfPieces;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       PieceImage;                                        // 0x00DC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Image;                                             // 0x00E0(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x8];                                      // 0x0154(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNumberOfPieces(int32 InNumberOfPieces);
	void SetPeriod(float InPeriod);
	void SetRadius(float InRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CircularThrobber">();
	}
	static class UCircularThrobber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCircularThrobber>();
	}
};
static_assert(alignof(UCircularThrobber) == 0x000004, "Wrong alignment on UCircularThrobber");
static_assert(sizeof(UCircularThrobber) == 0x00015C, "Wrong size on UCircularThrobber");
static_assert(offsetof(UCircularThrobber, NumberOfPieces) == 0x0000D0, "Member 'UCircularThrobber::NumberOfPieces' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Period) == 0x0000D4, "Member 'UCircularThrobber::Period' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Radius) == 0x0000D8, "Member 'UCircularThrobber::Radius' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, PieceImage) == 0x0000DC, "Member 'UCircularThrobber::PieceImage' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Image) == 0x0000E0, "Member 'UCircularThrobber::Image' has a wrong offset!");

// Class UMG.ComboBox
// 0x0024 (0x00F4 - 0x00D0)
class UComboBox final : public UWidget
{
public:
	TArray<class UObject*>                        Items;                                             // 0x00D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* Item)>          OnGenerateWidgetEvent;                             // 0x00DC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x8];                                       // 0x00EC(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBox">();
	}
	static class UComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBox>();
	}
};
static_assert(alignof(UComboBox) == 0x000004, "Wrong alignment on UComboBox");
static_assert(sizeof(UComboBox) == 0x0000F4, "Wrong size on UComboBox");
static_assert(offsetof(UComboBox, Items) == 0x0000D0, "Member 'UComboBox::Items' has a wrong offset!");
static_assert(offsetof(UComboBox, OnGenerateWidgetEvent) == 0x0000DC, "Member 'UComboBox::OnGenerateWidgetEvent' has a wrong offset!");

// Class UMG.ComboBoxString
// 0x03E0 (0x04B0 - 0x00D0)
class UComboBoxString final : public UWidget
{
public:
	TArray<class FString>                         DefaultOptions;                                    // 0x00D0(0x000C)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 SelectedOption;                                    // 0x00DC(0x000C)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x00E8(0x0364)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x044C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x0464(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSelectionChanged;                                // 0x0474(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnOpening;                                         // 0x0480(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48C[0x24];                                     // 0x048C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(const class FString& Option);
	void ClearOptions();
	void ClearSelection();
	void RefreshOptions();
	bool RemoveOption(const class FString& Option);
	void SetSelectedOption(const class FString& Option);

	int32 FindOptionIndex(const class FString& Option) const;
	class FString GetOptionAtIndex(int32 INDEX) const;
	int32 GetOptionCount() const;
	class FString GetSelectedOption() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxString">();
	}
	static class UComboBoxString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxString>();
	}
};
static_assert(alignof(UComboBoxString) == 0x000004, "Wrong alignment on UComboBoxString");
static_assert(sizeof(UComboBoxString) == 0x0004B0, "Wrong size on UComboBoxString");
static_assert(offsetof(UComboBoxString, DefaultOptions) == 0x0000D0, "Member 'UComboBoxString::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UComboBoxString, SelectedOption) == 0x0000DC, "Member 'UComboBoxString::SelectedOption' has a wrong offset!");
static_assert(offsetof(UComboBoxString, WidgetStyle) == 0x0000E8, "Member 'UComboBoxString::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxString, ContentPadding) == 0x00044C, "Member 'UComboBoxString::ContentPadding' has a wrong offset!");
static_assert(offsetof(UComboBoxString, MaxListHeight) == 0x00045C, "Member 'UComboBoxString::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UComboBoxString, HasDownArrow) == 0x000460, "Member 'UComboBoxString::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnGenerateWidgetEvent) == 0x000464, "Member 'UComboBoxString::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnSelectionChanged) == 0x000474, "Member 'UComboBoxString::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnOpening) == 0x000480, "Member 'UComboBoxString::OnOpening' has a wrong offset!");

// Class UMG.EditableText
// 0x0260 (0x0330 - 0x00D0)
class UEditableText final : public UWidget
{
public:
	class FText                                   TEXT;                                              // 0x00D0(0x000C)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x00DC(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x00EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FEditableTextStyle                     WidgetStyle;                                       // 0x0108(0x01A4)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x02AC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImageSelected;                           // 0x02B0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImageComposing;                          // 0x02B4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       CaretImage;                                        // 0x02B8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x02BC(0x0028)(Deprecated, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x02E4(0x001C)(Deprecated, NativeAccessSpecifierPublic)
	bool                                          IsReadOnly;                                        // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsPassword;                                        // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDesiredWidth;                               // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCaretMovedWhenGainFocus;                         // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextWhenFocused;                          // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          RevertTextOnEscape;                                // 0x030A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x030B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x030C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x030D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x030E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30F[0x1];                                      // 0x030F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTextChanged;                                     // 0x0310(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTextCommitted;                                   // 0x031C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHintText(const class FText& InHintText);
	void SetIsPassword(bool InbIsPassword);
	void SetIsReadOnly(bool InbIsReadyOnly);
	void SetText(const class FText& InText);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableText">();
	}
	static class UEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableText>();
	}
};
static_assert(alignof(UEditableText) == 0x000004, "Wrong alignment on UEditableText");
static_assert(sizeof(UEditableText) == 0x000330, "Wrong size on UEditableText");
static_assert(offsetof(UEditableText, TEXT) == 0x0000D0, "Member 'UEditableText::TEXT' has a wrong offset!");
static_assert(offsetof(UEditableText, TextDelegate) == 0x0000DC, "Member 'UEditableText::TextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableText, HintText) == 0x0000EC, "Member 'UEditableText::HintText' has a wrong offset!");
static_assert(offsetof(UEditableText, HintTextDelegate) == 0x0000F8, "Member 'UEditableText::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableText, WidgetStyle) == 0x000108, "Member 'UEditableText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEditableText, Style) == 0x0002AC, "Member 'UEditableText::Style' has a wrong offset!");
static_assert(offsetof(UEditableText, BackgroundImageSelected) == 0x0002B0, "Member 'UEditableText::BackgroundImageSelected' has a wrong offset!");
static_assert(offsetof(UEditableText, BackgroundImageComposing) == 0x0002B4, "Member 'UEditableText::BackgroundImageComposing' has a wrong offset!");
static_assert(offsetof(UEditableText, CaretImage) == 0x0002B8, "Member 'UEditableText::CaretImage' has a wrong offset!");
static_assert(offsetof(UEditableText, Font) == 0x0002BC, "Member 'UEditableText::Font' has a wrong offset!");
static_assert(offsetof(UEditableText, ColorAndOpacity) == 0x0002E4, "Member 'UEditableText::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UEditableText, IsReadOnly) == 0x000300, "Member 'UEditableText::IsReadOnly' has a wrong offset!");
static_assert(offsetof(UEditableText, IsPassword) == 0x000301, "Member 'UEditableText::IsPassword' has a wrong offset!");
static_assert(offsetof(UEditableText, MinimumDesiredWidth) == 0x000304, "Member 'UEditableText::MinimumDesiredWidth' has a wrong offset!");
static_assert(offsetof(UEditableText, IsCaretMovedWhenGainFocus) == 0x000308, "Member 'UEditableText::IsCaretMovedWhenGainFocus' has a wrong offset!");
static_assert(offsetof(UEditableText, SelectAllTextWhenFocused) == 0x000309, "Member 'UEditableText::SelectAllTextWhenFocused' has a wrong offset!");
static_assert(offsetof(UEditableText, RevertTextOnEscape) == 0x00030A, "Member 'UEditableText::RevertTextOnEscape' has a wrong offset!");
static_assert(offsetof(UEditableText, ClearKeyboardFocusOnCommit) == 0x00030B, "Member 'UEditableText::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableText, SelectAllTextOnCommit) == 0x00030C, "Member 'UEditableText::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableText, AllowContextMenu) == 0x00030D, "Member 'UEditableText::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UEditableText, KeyboardType) == 0x00030E, "Member 'UEditableText::KeyboardType' has a wrong offset!");
static_assert(offsetof(UEditableText, OnTextChanged) == 0x000310, "Member 'UEditableText::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UEditableText, OnTextCommitted) == 0x00031C, "Member 'UEditableText::OnTextCommitted' has a wrong offset!");

// Class UMG.EditableTextBox
// 0x076C (0x083C - 0x00D0)
class UEditableTextBox final : public UWidget
{
public:
	class FText                                   TEXT;                                              // 0x00D0(0x000C)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x00DC(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FEditableTextBoxStyle                  WidgetStyle;                                       // 0x00EC(0x0698)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x0784(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0788(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x0794(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x07A4(0x0028)(Deprecated, NativeAccessSpecifierPublic)
	struct FLinearColor                           ForegroundColor;                                   // 0x07CC(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x07DC(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReadOnlyForegroundColor;                           // 0x07EC(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsReadOnly;                                        // 0x07FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsPassword;                                        // 0x07FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7FE[0x2];                                      // 0x07FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDesiredWidth;                               // 0x0800(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0804(0x0010)(Deprecated, NativeAccessSpecifierPublic)
	bool                                          IsCaretMovedWhenGainFocus;                         // 0x0814(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextWhenFocused;                          // 0x0815(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          RevertTextOnEscape;                                // 0x0816(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x0817(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x0818(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x0819(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x081A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81B[0x1];                                      // 0x081B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTextChanged;                                     // 0x081C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTextCommitted;                                   // 0x0828(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x8];                                      // 0x0834(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearError();
	void SetError(const class FText& InError);
	void SetText(const class FText& InText);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditableTextBox">();
	}
	static class UEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditableTextBox>();
	}
};
static_assert(alignof(UEditableTextBox) == 0x000004, "Wrong alignment on UEditableTextBox");
static_assert(sizeof(UEditableTextBox) == 0x00083C, "Wrong size on UEditableTextBox");
static_assert(offsetof(UEditableTextBox, TEXT) == 0x0000D0, "Member 'UEditableTextBox::TEXT' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, TextDelegate) == 0x0000DC, "Member 'UEditableTextBox::TextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, WidgetStyle) == 0x0000EC, "Member 'UEditableTextBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, Style) == 0x000784, "Member 'UEditableTextBox::Style' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, HintText) == 0x000788, "Member 'UEditableTextBox::HintText' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, HintTextDelegate) == 0x000794, "Member 'UEditableTextBox::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, Font) == 0x0007A4, "Member 'UEditableTextBox::Font' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, ForegroundColor) == 0x0007CC, "Member 'UEditableTextBox::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, BackgroundColor) == 0x0007DC, "Member 'UEditableTextBox::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, ReadOnlyForegroundColor) == 0x0007EC, "Member 'UEditableTextBox::ReadOnlyForegroundColor' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsReadOnly) == 0x0007FC, "Member 'UEditableTextBox::IsReadOnly' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsPassword) == 0x0007FD, "Member 'UEditableTextBox::IsPassword' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, MinimumDesiredWidth) == 0x000800, "Member 'UEditableTextBox::MinimumDesiredWidth' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, Padding) == 0x000804, "Member 'UEditableTextBox::Padding' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsCaretMovedWhenGainFocus) == 0x000814, "Member 'UEditableTextBox::IsCaretMovedWhenGainFocus' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, SelectAllTextWhenFocused) == 0x000815, "Member 'UEditableTextBox::SelectAllTextWhenFocused' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, RevertTextOnEscape) == 0x000816, "Member 'UEditableTextBox::RevertTextOnEscape' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, ClearKeyboardFocusOnCommit) == 0x000817, "Member 'UEditableTextBox::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, SelectAllTextOnCommit) == 0x000818, "Member 'UEditableTextBox::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, AllowContextMenu) == 0x000819, "Member 'UEditableTextBox::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, KeyboardType) == 0x00081A, "Member 'UEditableTextBox::KeyboardType' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, OnTextChanged) == 0x00081C, "Member 'UEditableTextBox::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, OnTextCommitted) == 0x000828, "Member 'UEditableTextBox::OnTextCommitted' has a wrong offset!");

// Class UMG.ExpandableArea
// 0x01C4 (0x0294 - 0x00D0)
class UExpandableArea final : public UWidget
{
public:
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpandableAreaStyle                   Style;                                             // 0x00D4(0x00EC)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BorderBrush;                                       // 0x01C0(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            BorderColor;                                       // 0x0234(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsExpanded;                                       // 0x0250(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeight;                                         // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                HeaderPadding;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMargin                                AreaPadding;                                       // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnExpansionChanged;                                // 0x0278(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                HeaderContent;                                     // 0x0284(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BodyContent;                                       // 0x0288(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x8];                                      // 0x028C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsExpanded(bool IsExpanded);

	bool GetIsExpanded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExpandableArea">();
	}
	static class UExpandableArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExpandableArea>();
	}
};
static_assert(alignof(UExpandableArea) == 0x000004, "Wrong alignment on UExpandableArea");
static_assert(sizeof(UExpandableArea) == 0x000294, "Wrong size on UExpandableArea");
static_assert(offsetof(UExpandableArea, Style) == 0x0000D4, "Member 'UExpandableArea::Style' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BorderBrush) == 0x0001C0, "Member 'UExpandableArea::BorderBrush' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BorderColor) == 0x000234, "Member 'UExpandableArea::BorderColor' has a wrong offset!");
static_assert(offsetof(UExpandableArea, bIsExpanded) == 0x000250, "Member 'UExpandableArea::bIsExpanded' has a wrong offset!");
static_assert(offsetof(UExpandableArea, MaxHeight) == 0x000254, "Member 'UExpandableArea::MaxHeight' has a wrong offset!");
static_assert(offsetof(UExpandableArea, HeaderPadding) == 0x000258, "Member 'UExpandableArea::HeaderPadding' has a wrong offset!");
static_assert(offsetof(UExpandableArea, AreaPadding) == 0x000268, "Member 'UExpandableArea::AreaPadding' has a wrong offset!");
static_assert(offsetof(UExpandableArea, OnExpansionChanged) == 0x000278, "Member 'UExpandableArea::OnExpansionChanged' has a wrong offset!");
static_assert(offsetof(UExpandableArea, HeaderContent) == 0x000284, "Member 'UExpandableArea::HeaderContent' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BodyContent) == 0x000288, "Member 'UExpandableArea::BodyContent' has a wrong offset!");

// Class UMG.Image
// 0x00C0 (0x0190 - 0x00D0)
class UImage final : public UWidget
{
public:
	class USlateBrushAsset*                       Image;                                             // 0x00D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Brush;                                             // 0x00D4(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0148(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0168(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x0178(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetOpacity(float InOpacity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Image">();
	}
	static class UImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImage>();
	}
};
static_assert(alignof(UImage) == 0x000004, "Wrong alignment on UImage");
static_assert(sizeof(UImage) == 0x000190, "Wrong size on UImage");
static_assert(offsetof(UImage, Image) == 0x0000D0, "Member 'UImage::Image' has a wrong offset!");
static_assert(offsetof(UImage, Brush) == 0x0000D4, "Member 'UImage::Brush' has a wrong offset!");
static_assert(offsetof(UImage, BrushDelegate) == 0x000148, "Member 'UImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UImage, ColorAndOpacity) == 0x000158, "Member 'UImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UImage, ColorAndOpacityDelegate) == 0x000168, "Member 'UImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UImage, OnMouseButtonDownEvent) == 0x000178, "Member 'UImage::OnMouseButtonDownEvent' has a wrong offset!");

// Class UMG.NativeWidgetHost
// 0x0008 (0x00D8 - 0x00D0)
class UNativeWidgetHost : public UWidget
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NativeWidgetHost">();
	}
	static class UNativeWidgetHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNativeWidgetHost>();
	}
};
static_assert(alignof(UNativeWidgetHost) == 0x000004, "Wrong alignment on UNativeWidgetHost");
static_assert(sizeof(UNativeWidgetHost) == 0x0000D8, "Wrong size on UNativeWidgetHost");

// Class UMG.PanelWidget
// 0x0010 (0x00E0 - 0x00D0)
class UPanelWidget : public UWidget
{
public:
	TArray<class UPanelSlot*>                     Slots;                                             // 0x00D0(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPanelSlot* AddChild(class UWidget* Content);
	void ClearChildren();
	bool RemoveChild(class UWidget* Content);
	bool RemoveChildAt(int32 INDEX);

	class UWidget* GetChildAt(int32 INDEX) const;
	int32 GetChildIndex(class UWidget* Content) const;
	int32 GetChildrenCount() const;
	bool HasAnyChildren() const;
	bool HasChild(class UWidget* Content) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PanelWidget">();
	}
	static class UPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPanelWidget>();
	}
};
static_assert(alignof(UPanelWidget) == 0x000004, "Wrong alignment on UPanelWidget");
static_assert(sizeof(UPanelWidget) == 0x0000E0, "Wrong size on UPanelWidget");
static_assert(offsetof(UPanelWidget, Slots) == 0x0000D0, "Member 'UPanelWidget::Slots' has a wrong offset!");

// Class UMG.CanvasPanel
// 0x0008 (0x00E8 - 0x00E0)
class UCanvasPanel final : public UPanelWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCanvasPanelSlot* AddChildToCanvas(class UWidget* Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanvasPanel">();
	}
	static class UCanvasPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanvasPanel>();
	}
};
static_assert(alignof(UCanvasPanel) == 0x000004, "Wrong alignment on UCanvasPanel");
static_assert(sizeof(UCanvasPanel) == 0x0000E8, "Wrong size on UCanvasPanel");

// Class UMG.ContentWidget
// 0x0000 (0x00E0 - 0x00E0)
class UContentWidget : public UPanelWidget
{
public:
	class UPanelSlot* GetContentSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentWidget">();
	}
	static class UContentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentWidget>();
	}
};
static_assert(alignof(UContentWidget) == 0x000004, "Wrong alignment on UContentWidget");
static_assert(sizeof(UContentWidget) == 0x0000E0, "Wrong size on UContentWidget");

// Class UMG.Border
// 0x0128 (0x0208 - 0x00E0)
class UBorder final : public UContentWidget
{
public:
	struct FLinearColor                           ContentColorAndOpacity;                            // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ContentColorAndOpacityDelegate;                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Background;                                        // 0x0114(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BackgroundDelegate;                                // 0x0188(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BrushColor;                                        // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushColorDelegate;                                // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShowEffectWhenDisabled;                           // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x01BC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonUpEvent;                              // 0x01CC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseMoveEvent;                                  // 0x01DC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseDoubleClickEvent;                           // 0x01EC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x8];                                      // 0x01FC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateBrushAsset*                       Brush;                                             // 0x0204(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	void SetBrush(const struct FSlateBrush& InBrush);
	void SetBrushColor(const struct FLinearColor& InBrushColor);
	void SetBrushFromAsset(class USlateBrushAsset* Asset);
	void SetBrushFromMaterial(class UMaterialInterface* Material);
	void SetBrushFromTexture(class UTexture2D* Texture);
	void SetContentColorAndOpacity(const struct FLinearColor& InContentColorAndOpacity);
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment);
	void SetPadding(const struct FMargin& InPadding);
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Border">();
	}
	static class UBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBorder>();
	}
};
static_assert(alignof(UBorder) == 0x000004, "Wrong alignment on UBorder");
static_assert(sizeof(UBorder) == 0x000208, "Wrong size on UBorder");
static_assert(offsetof(UBorder, ContentColorAndOpacity) == 0x0000E0, "Member 'UBorder::ContentColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UBorder, ContentColorAndOpacityDelegate) == 0x0000F0, "Member 'UBorder::ContentColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, Padding) == 0x000100, "Member 'UBorder::Padding' has a wrong offset!");
static_assert(offsetof(UBorder, HorizontalAlignment) == 0x000110, "Member 'UBorder::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBorder, VerticalAlignment) == 0x000111, "Member 'UBorder::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UBorder, Background) == 0x000114, "Member 'UBorder::Background' has a wrong offset!");
static_assert(offsetof(UBorder, BackgroundDelegate) == 0x000188, "Member 'UBorder::BackgroundDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, BrushColor) == 0x000198, "Member 'UBorder::BrushColor' has a wrong offset!");
static_assert(offsetof(UBorder, BrushColorDelegate) == 0x0001A8, "Member 'UBorder::BrushColorDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, bShowEffectWhenDisabled) == 0x0001B8, "Member 'UBorder::bShowEffectWhenDisabled' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseButtonDownEvent) == 0x0001BC, "Member 'UBorder::OnMouseButtonDownEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseButtonUpEvent) == 0x0001CC, "Member 'UBorder::OnMouseButtonUpEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseMoveEvent) == 0x0001DC, "Member 'UBorder::OnMouseMoveEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseDoubleClickEvent) == 0x0001EC, "Member 'UBorder::OnMouseDoubleClickEvent' has a wrong offset!");
static_assert(offsetof(UBorder, Brush) == 0x000204, "Member 'UBorder::Brush' has a wrong offset!");

// Class UMG.Button
// 0x0298 (0x0378 - 0x00E0)
class UButton : public UContentWidget
{
public:
	class USlateWidgetStyleAsset*                 Style;                                             // 0x00E0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FButtonStyle                           WidgetStyle;                                       // 0x00E4(0x022C)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EButtonClickMethod                            ClickMethod;                                       // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonTouchMethod                            TouchMethod;                                       // 0x0331(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0332(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnClicked;                                         // 0x0334(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPressed;                                         // 0x0340(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReleased;                                        // 0x034C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHovered;                                         // 0x0358(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUnhovered;                                       // 0x0364(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBackgroundColor(const struct FLinearColor& InBackgroundColor);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetStyle(const struct FButtonStyle& InStyle);

	bool IsPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Button">();
	}
	static class UButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButton>();
	}
};
static_assert(alignof(UButton) == 0x000004, "Wrong alignment on UButton");
static_assert(sizeof(UButton) == 0x000378, "Wrong size on UButton");
static_assert(offsetof(UButton, Style) == 0x0000E0, "Member 'UButton::Style' has a wrong offset!");
static_assert(offsetof(UButton, WidgetStyle) == 0x0000E4, "Member 'UButton::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UButton, ColorAndOpacity) == 0x000310, "Member 'UButton::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UButton, BackgroundColor) == 0x000320, "Member 'UButton::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UButton, ClickMethod) == 0x000330, "Member 'UButton::ClickMethod' has a wrong offset!");
static_assert(offsetof(UButton, TouchMethod) == 0x000331, "Member 'UButton::TouchMethod' has a wrong offset!");
static_assert(offsetof(UButton, IsFocusable) == 0x000332, "Member 'UButton::IsFocusable' has a wrong offset!");
static_assert(offsetof(UButton, OnClicked) == 0x000334, "Member 'UButton::OnClicked' has a wrong offset!");
static_assert(offsetof(UButton, OnPressed) == 0x000340, "Member 'UButton::OnPressed' has a wrong offset!");
static_assert(offsetof(UButton, OnReleased) == 0x00034C, "Member 'UButton::OnReleased' has a wrong offset!");
static_assert(offsetof(UButton, OnHovered) == 0x000358, "Member 'UButton::OnHovered' has a wrong offset!");
static_assert(offsetof(UButton, OnUnhovered) == 0x000364, "Member 'UButton::OnUnhovered' has a wrong offset!");

// Class UMG.CheckBox
// 0x0538 (0x0618 - 0x00E0)
class UCheckBox final : public UContentWidget
{
public:
	ECheckBoxState                                CheckedState;                                      // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             CheckedStateDelegate;                              // 0x00E4(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FCheckBoxStyle                         WidgetStyle;                                       // 0x00F4(0x04B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x05AC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UncheckedImage;                                    // 0x05B0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UncheckedHoveredImage;                             // 0x05B4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UncheckedPressedImage;                             // 0x05B8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       CheckedImage;                                      // 0x05BC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       CheckedHoveredImage;                               // 0x05C0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       CheckedPressedImage;                               // 0x05C4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UndeterminedImage;                                 // 0x05C8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UndeterminedHoveredImage;                          // 0x05CC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       UndeterminedPressedImage;                          // 0x05D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x05D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D5[0x3];                                      // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x05D8(0x0010)(Deprecated, NativeAccessSpecifierPublic)
	struct FSlateColor                            BorderBackgroundColor;                             // 0x05E8(0x001C)(Deprecated, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCheckStateChanged;                               // 0x0604(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCheckedState(ECheckBoxState InCheckedState);
	void SetIsChecked(bool InIsChecked);

	ECheckBoxState GetCheckedState() const;
	bool IsChecked() const;
	bool IsPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckBox">();
	}
	static class UCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckBox>();
	}
};
static_assert(alignof(UCheckBox) == 0x000004, "Wrong alignment on UCheckBox");
static_assert(sizeof(UCheckBox) == 0x000618, "Wrong size on UCheckBox");
static_assert(offsetof(UCheckBox, CheckedState) == 0x0000E0, "Member 'UCheckBox::CheckedState' has a wrong offset!");
static_assert(offsetof(UCheckBox, CheckedStateDelegate) == 0x0000E4, "Member 'UCheckBox::CheckedStateDelegate' has a wrong offset!");
static_assert(offsetof(UCheckBox, WidgetStyle) == 0x0000F4, "Member 'UCheckBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UCheckBox, Style) == 0x0005AC, "Member 'UCheckBox::Style' has a wrong offset!");
static_assert(offsetof(UCheckBox, UncheckedImage) == 0x0005B0, "Member 'UCheckBox::UncheckedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, UncheckedHoveredImage) == 0x0005B4, "Member 'UCheckBox::UncheckedHoveredImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, UncheckedPressedImage) == 0x0005B8, "Member 'UCheckBox::UncheckedPressedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, CheckedImage) == 0x0005BC, "Member 'UCheckBox::CheckedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, CheckedHoveredImage) == 0x0005C0, "Member 'UCheckBox::CheckedHoveredImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, CheckedPressedImage) == 0x0005C4, "Member 'UCheckBox::CheckedPressedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, UndeterminedImage) == 0x0005C8, "Member 'UCheckBox::UndeterminedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, UndeterminedHoveredImage) == 0x0005CC, "Member 'UCheckBox::UndeterminedHoveredImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, UndeterminedPressedImage) == 0x0005D0, "Member 'UCheckBox::UndeterminedPressedImage' has a wrong offset!");
static_assert(offsetof(UCheckBox, HorizontalAlignment) == 0x0005D4, "Member 'UCheckBox::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UCheckBox, Padding) == 0x0005D8, "Member 'UCheckBox::Padding' has a wrong offset!");
static_assert(offsetof(UCheckBox, BorderBackgroundColor) == 0x0005E8, "Member 'UCheckBox::BorderBackgroundColor' has a wrong offset!");
static_assert(offsetof(UCheckBox, OnCheckStateChanged) == 0x000604, "Member 'UCheckBox::OnCheckStateChanged' has a wrong offset!");

// Class UMG.InvalidationBox
// 0x000C (0x00EC - 0x00E0)
class UInvalidationBox final : public UContentWidget
{
public:
	bool                                          bCanCache;                                         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          CacheRelativeTransforms;                           // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E2[0xA];                                       // 0x00E2(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvalidateCache();
	void SetCanCache(bool CanCache);

	bool GetCanCache() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvalidationBox">();
	}
	static class UInvalidationBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvalidationBox>();
	}
};
static_assert(alignof(UInvalidationBox) == 0x000004, "Wrong alignment on UInvalidationBox");
static_assert(sizeof(UInvalidationBox) == 0x0000EC, "Wrong size on UInvalidationBox");
static_assert(offsetof(UInvalidationBox, bCanCache) == 0x0000E0, "Member 'UInvalidationBox::bCanCache' has a wrong offset!");
static_assert(offsetof(UInvalidationBox, CacheRelativeTransforms) == 0x0000E1, "Member 'UInvalidationBox::CacheRelativeTransforms' has a wrong offset!");

// Class UMG.MenuAnchor
// 0x002C (0x010C - 0x00E0)
class UMenuAnchor final : public UContentWidget
{
public:
	TSubclassOf<class UUserWidget>                MenuClass;                                         // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnGetMenuContentEvent;                             // 0x00E4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EMenuPlacement                                Placement;                                         // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldDeferPaintingAfterWindowContent;             // 0x00F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMenuOpenChanged;                                 // 0x00F8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x8];                                      // 0x0104(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	void Open(bool bFocusMenu);
	void ToggleOpen(bool bFocusOnOpen);

	struct FVector2D GetMenuPosition() const;
	bool HasOpenSubMenus() const;
	bool IsOpen() const;
	bool ShouldOpenDueToClick() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAnchor">();
	}
	static class UMenuAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAnchor>();
	}
};
static_assert(alignof(UMenuAnchor) == 0x000004, "Wrong alignment on UMenuAnchor");
static_assert(sizeof(UMenuAnchor) == 0x00010C, "Wrong size on UMenuAnchor");
static_assert(offsetof(UMenuAnchor, MenuClass) == 0x0000E0, "Member 'UMenuAnchor::MenuClass' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, OnGetMenuContentEvent) == 0x0000E4, "Member 'UMenuAnchor::OnGetMenuContentEvent' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, Placement) == 0x0000F4, "Member 'UMenuAnchor::Placement' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, ShouldDeferPaintingAfterWindowContent) == 0x0000F5, "Member 'UMenuAnchor::ShouldDeferPaintingAfterWindowContent' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, OnMenuOpenChanged) == 0x0000F8, "Member 'UMenuAnchor::OnMenuOpenChanged' has a wrong offset!");

// Class UMG.NamedSlot
// 0x0008 (0x00E8 - 0x00E0)
class UNamedSlot final : public UContentWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NamedSlot">();
	}
	static class UNamedSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNamedSlot>();
	}
};
static_assert(alignof(UNamedSlot) == 0x000004, "Wrong alignment on UNamedSlot");
static_assert(sizeof(UNamedSlot) == 0x0000E8, "Wrong size on UNamedSlot");

// Class UMG.RetainerBox
// 0x001C (0x00FC - 0x00E0)
class URetainerBox final : public UContentWidget
{
public:
	int32                                         Phase;                                             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseCount;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EffectMaterial;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextureParameter;                                  // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x8];                                       // 0x00F4(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEffectMaterial(class UMaterialInterface* EffectMaterial_0);
	void SetTextureParameter(class FName TextureParameter_0);

	class UMaterialInstanceDynamic* GetEffectMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetainerBox">();
	}
	static class URetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetainerBox>();
	}
};
static_assert(alignof(URetainerBox) == 0x000004, "Wrong alignment on URetainerBox");
static_assert(sizeof(URetainerBox) == 0x0000FC, "Wrong size on URetainerBox");
static_assert(offsetof(URetainerBox, Phase) == 0x0000E0, "Member 'URetainerBox::Phase' has a wrong offset!");
static_assert(offsetof(URetainerBox, PhaseCount) == 0x0000E4, "Member 'URetainerBox::PhaseCount' has a wrong offset!");
static_assert(offsetof(URetainerBox, EffectMaterial) == 0x0000E8, "Member 'URetainerBox::EffectMaterial' has a wrong offset!");
static_assert(offsetof(URetainerBox, TextureParameter) == 0x0000EC, "Member 'URetainerBox::TextureParameter' has a wrong offset!");

// Class UMG.SafeZone
// 0x0008 (0x00E8 - 0x00E0)
class USafeZone final : public UContentWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZone">();
	}
	static class USafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZone>();
	}
};
static_assert(alignof(USafeZone) == 0x000004, "Wrong alignment on USafeZone");
static_assert(sizeof(USafeZone) == 0x0000E8, "Wrong size on USafeZone");

// Class UMG.ScaleBox
// 0x0014 (0x00F4 - 0x00E0)
class UScaleBox final : public UContentWidget
{
public:
	EStretchDirection                             StretchDirection;                                  // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretch                                      Stretch;                                           // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserSpecifiedScale;                                // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreInheritedScale;                              // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0xB];                                       // 0x00E9(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleBox">();
	}
	static class UScaleBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScaleBox>();
	}
};
static_assert(alignof(UScaleBox) == 0x000004, "Wrong alignment on UScaleBox");
static_assert(sizeof(UScaleBox) == 0x0000F4, "Wrong size on UScaleBox");
static_assert(offsetof(UScaleBox, StretchDirection) == 0x0000E0, "Member 'UScaleBox::StretchDirection' has a wrong offset!");
static_assert(offsetof(UScaleBox, Stretch) == 0x0000E1, "Member 'UScaleBox::Stretch' has a wrong offset!");
static_assert(offsetof(UScaleBox, UserSpecifiedScale) == 0x0000E4, "Member 'UScaleBox::UserSpecifiedScale' has a wrong offset!");
static_assert(offsetof(UScaleBox, IgnoreInheritedScale) == 0x0000E8, "Member 'UScaleBox::IgnoreInheritedScale' has a wrong offset!");

// Class UMG.SizeBox
// 0x0024 (0x0104 - 0x00E0)
class USizeBox final : public UContentWidget
{
public:
	uint8                                         bOverride_WidthOverride : 1;                       // 0x00E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HeightOverride : 1;                      // 0x00E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinDesiredWidth : 1;                     // 0x00E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinDesiredHeight : 1;                    // 0x00E0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxDesiredWidth : 1;                     // 0x00E0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxDesiredHeight : 1;                    // 0x00E0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthOverride;                                     // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOverride;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredHeight;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredWidth;                                   // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredHeight;                                  // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x8];                                       // 0x00FC(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHeightOverride();
	void ClearMaxDesiredHeight();
	void ClearMaxDesiredWidth();
	void ClearMinDesiredHeight();
	void ClearMinDesiredWidth();
	void ClearWidthOverride();
	void SetHeightOverride(float InHeightOverride);
	void SetMaxDesiredHeight(float InMaxDesiredHeight);
	void SetMaxDesiredWidth(float InMaxDesiredWidth);
	void SetMinDesiredHeight(float InMinDesiredHeight);
	void SetMinDesiredWidth(float InMinDesiredWidth);
	void SetWidthOverride(float InWidthOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SizeBox">();
	}
	static class USizeBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<USizeBox>();
	}
};
static_assert(alignof(USizeBox) == 0x000004, "Wrong alignment on USizeBox");
static_assert(sizeof(USizeBox) == 0x000104, "Wrong size on USizeBox");
static_assert(offsetof(USizeBox, WidthOverride) == 0x0000E4, "Member 'USizeBox::WidthOverride' has a wrong offset!");
static_assert(offsetof(USizeBox, HeightOverride) == 0x0000E8, "Member 'USizeBox::HeightOverride' has a wrong offset!");
static_assert(offsetof(USizeBox, MinDesiredWidth) == 0x0000EC, "Member 'USizeBox::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(USizeBox, MinDesiredHeight) == 0x0000F0, "Member 'USizeBox::MinDesiredHeight' has a wrong offset!");
static_assert(offsetof(USizeBox, MaxDesiredWidth) == 0x0000F4, "Member 'USizeBox::MaxDesiredWidth' has a wrong offset!");
static_assert(offsetof(USizeBox, MaxDesiredHeight) == 0x0000F8, "Member 'USizeBox::MaxDesiredHeight' has a wrong offset!");

// Class UMG.Viewport
// 0x0020 (0x0100 - 0x00E0)
class UViewport final : public UContentWidget
{
public:
	struct FLinearColor                           BackgroundColor;                                   // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetViewLocation(const struct FVector& Location);
	void SetViewRotation(const struct FRotator& Rotation);
	class AActor* Spawn(TSubclassOf<class AActor> ActorClass);

	struct FVector GetViewLocation() const;
	class UWorld* GetViewportWorld() const;
	struct FRotator GetViewRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Viewport">();
	}
	static class UViewport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewport>();
	}
};
static_assert(alignof(UViewport) == 0x000004, "Wrong alignment on UViewport");
static_assert(sizeof(UViewport) == 0x000100, "Wrong size on UViewport");
static_assert(offsetof(UViewport, BackgroundColor) == 0x0000E0, "Member 'UViewport::BackgroundColor' has a wrong offset!");

// Class UMG.GridPanel
// 0x0020 (0x0100 - 0x00E0)
class UGridPanel final : public UPanelWidget
{
public:
	TArray<float>                                 ColumnFill;                                        // 0x00E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RowFill;                                           // 0x00EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGridSlot* AddChildToGrid(class UWidget* Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridPanel">();
	}
	static class UGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridPanel>();
	}
};
static_assert(alignof(UGridPanel) == 0x000004, "Wrong alignment on UGridPanel");
static_assert(sizeof(UGridPanel) == 0x000100, "Wrong size on UGridPanel");
static_assert(offsetof(UGridPanel, ColumnFill) == 0x0000E0, "Member 'UGridPanel::ColumnFill' has a wrong offset!");
static_assert(offsetof(UGridPanel, RowFill) == 0x0000EC, "Member 'UGridPanel::RowFill' has a wrong offset!");

// Class UMG.HorizontalBox
// 0x0008 (0x00E8 - 0x00E0)
class UHorizontalBox final : public UPanelWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UHorizontalBoxSlot* AddChildToHorizontalBox(class UWidget* Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorizontalBox">();
	}
	static class UHorizontalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorizontalBox>();
	}
};
static_assert(alignof(UHorizontalBox) == 0x000004, "Wrong alignment on UHorizontalBox");
static_assert(sizeof(UHorizontalBox) == 0x0000E8, "Wrong size on UHorizontalBox");

// Class UMG.Overlay
// 0x0008 (0x00E8 - 0x00E0)
class UOverlay final : public UPanelWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOverlaySlot* AddChildToOverlay(class UWidget* Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Overlay">();
	}
	static class UOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlay>();
	}
};
static_assert(alignof(UOverlay) == 0x000004, "Wrong alignment on UOverlay");
static_assert(sizeof(UOverlay) == 0x0000E8, "Wrong size on UOverlay");

// Class UMG.ScrollBox
// 0x0610 (0x06F0 - 0x00E0)
class UScrollBox final : public UPanelWidget
{
public:
	struct FScrollBoxStyle                        WidgetStyle;                                       // 0x00E0(0x01D4)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x02B4(0x0418)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x06CC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 BarStyle;                                          // 0x06D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x06D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x06D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x06D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D7[0x1];                                      // 0x06D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x06E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E1[0xF];                                      // 0x06E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ScrollToEnd();
	void ScrollToStart();
	void ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll);
	void SetScrollOffset(float NewScrollOffset);

	float GetScrollOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollBox">();
	}
	static class UScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollBox>();
	}
};
static_assert(alignof(UScrollBox) == 0x000004, "Wrong alignment on UScrollBox");
static_assert(sizeof(UScrollBox) == 0x0006F0, "Wrong size on UScrollBox");
static_assert(offsetof(UScrollBox, WidgetStyle) == 0x0000E0, "Member 'UScrollBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UScrollBox, WidgetBarStyle) == 0x0002B4, "Member 'UScrollBox::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UScrollBox, Style) == 0x0006CC, "Member 'UScrollBox::Style' has a wrong offset!");
static_assert(offsetof(UScrollBox, BarStyle) == 0x0006D0, "Member 'UScrollBox::BarStyle' has a wrong offset!");
static_assert(offsetof(UScrollBox, Orientation) == 0x0006D4, "Member 'UScrollBox::Orientation' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollBarVisibility) == 0x0006D5, "Member 'UScrollBox::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UScrollBox, ConsumeMouseWheel) == 0x0006D6, "Member 'UScrollBox::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollbarThickness) == 0x0006D8, "Member 'UScrollBox::ScrollbarThickness' has a wrong offset!");
static_assert(offsetof(UScrollBox, AlwaysShowScrollbar) == 0x0006E0, "Member 'UScrollBox::AlwaysShowScrollbar' has a wrong offset!");

// Class UMG.UniformGridPanel
// 0x0020 (0x0100 - 0x00E0)
class UUniformGridPanel final : public UPanelWidget
{
public:
	struct FMargin                                SlotPadding;                                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MinDesiredSlotWidth;                               // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredSlotHeight;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUniformGridSlot* AddChildToUniformGrid(class UWidget* Content);
	void SetMinDesiredSlotHeight(float InMinDesiredSlotHeight);
	void SetMinDesiredSlotWidth(float InMinDesiredSlotWidth);
	void SetSlotPadding(const struct FMargin& InSlotPadding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UniformGridPanel">();
	}
	static class UUniformGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUniformGridPanel>();
	}
};
static_assert(alignof(UUniformGridPanel) == 0x000004, "Wrong alignment on UUniformGridPanel");
static_assert(sizeof(UUniformGridPanel) == 0x000100, "Wrong size on UUniformGridPanel");
static_assert(offsetof(UUniformGridPanel, SlotPadding) == 0x0000E0, "Member 'UUniformGridPanel::SlotPadding' has a wrong offset!");
static_assert(offsetof(UUniformGridPanel, MinDesiredSlotWidth) == 0x0000F0, "Member 'UUniformGridPanel::MinDesiredSlotWidth' has a wrong offset!");
static_assert(offsetof(UUniformGridPanel, MinDesiredSlotHeight) == 0x0000F4, "Member 'UUniformGridPanel::MinDesiredSlotHeight' has a wrong offset!");

// Class UMG.VerticalBox
// 0x0008 (0x00E8 - 0x00E0)
class UVerticalBox final : public UPanelWidget
{
public:
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVerticalBoxSlot* AddChildToVerticalBox(class UWidget* Content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerticalBox">();
	}
	static class UVerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerticalBox>();
	}
};
static_assert(alignof(UVerticalBox) == 0x000004, "Wrong alignment on UVerticalBox");
static_assert(sizeof(UVerticalBox) == 0x0000E8, "Wrong size on UVerticalBox");

// Class UMG.WidgetSwitcher
// 0x000C (0x00EC - 0x00E0)
class UWidgetSwitcher final : public UPanelWidget
{
public:
	int32                                         ActiveWidgetIndex;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x8];                                       // 0x00E4(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActiveWidget(class UWidget* Widget);
	void SetActiveWidgetIndex(int32 INDEX);

	int32 GetActiveWidgetIndex() const;
	int32 GetNumWidgets() const;
	class UWidget* GetWidgetAtIndex(int32 INDEX) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetSwitcher">();
	}
	static class UWidgetSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetSwitcher>();
	}
};
static_assert(alignof(UWidgetSwitcher) == 0x000004, "Wrong alignment on UWidgetSwitcher");
static_assert(sizeof(UWidgetSwitcher) == 0x0000EC, "Wrong size on UWidgetSwitcher");
static_assert(offsetof(UWidgetSwitcher, ActiveWidgetIndex) == 0x0000E0, "Member 'UWidgetSwitcher::ActiveWidgetIndex' has a wrong offset!");

// Class UMG.WrapBox
// 0x0010 (0x00F0 - 0x00E0)
class UWrapBox final : public UPanelWidget
{
public:
	struct FVector2D                              InnerSlotPadding;                                  // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWrapBoxSlot* AddChildWrapBox(class UWidget* Content);
	void SetInnerSlotPadding(const struct FVector2D& InPadding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WrapBox">();
	}
	static class UWrapBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWrapBox>();
	}
};
static_assert(alignof(UWrapBox) == 0x000004, "Wrong alignment on UWrapBox");
static_assert(sizeof(UWrapBox) == 0x0000F0, "Wrong size on UWrapBox");
static_assert(offsetof(UWrapBox, InnerSlotPadding) == 0x0000E0, "Member 'UWrapBox::InnerSlotPadding' has a wrong offset!");

// Class UMG.ProgressBar
// 0x01B0 (0x0280 - 0x00D0)
class UProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x00D0(0x0160)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x0230(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImage;                                   // 0x0234(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImage;                                         // 0x0238(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       MarqueeImage;                                      // 0x023C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x0244(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x0245(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_246[0x2];                                      // 0x0246(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PercentDelegate;                                   // 0x0248(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0268(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetIsMarquee(bool InbIsMarquee);
	void SetPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressBar">();
	}
	static class UProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressBar>();
	}
};
static_assert(alignof(UProgressBar) == 0x000004, "Wrong alignment on UProgressBar");
static_assert(sizeof(UProgressBar) == 0x000280, "Wrong size on UProgressBar");
static_assert(offsetof(UProgressBar, WidgetStyle) == 0x0000D0, "Member 'UProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UProgressBar, Style) == 0x000230, "Member 'UProgressBar::Style' has a wrong offset!");
static_assert(offsetof(UProgressBar, BackgroundImage) == 0x000234, "Member 'UProgressBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UProgressBar, FillImage) == 0x000238, "Member 'UProgressBar::FillImage' has a wrong offset!");
static_assert(offsetof(UProgressBar, MarqueeImage) == 0x00023C, "Member 'UProgressBar::MarqueeImage' has a wrong offset!");
static_assert(offsetof(UProgressBar, Percent) == 0x000240, "Member 'UProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UProgressBar, BarFillType) == 0x000244, "Member 'UProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UProgressBar, bIsMarquee) == 0x000245, "Member 'UProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UProgressBar, PercentDelegate) == 0x000248, "Member 'UProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UProgressBar, FillColorAndOpacity) == 0x000258, "Member 'UProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UProgressBar, FillColorAndOpacityDelegate) == 0x000268, "Member 'UProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class UMG.ScrollBar
// 0x0430 (0x0500 - 0x00D0)
class UScrollBar final : public UWidget
{
public:
	struct FScrollBarStyle                        WidgetStyle;                                       // 0x00D0(0x0418)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x04E8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowScrollbar;                              // 0x04EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x04ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EE[0x2];                                      // 0x04EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Thickness;                                         // 0x04F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetState(float InOffsetFraction, float InThumbSizeFraction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollBar">();
	}
	static class UScrollBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollBar>();
	}
};
static_assert(alignof(UScrollBar) == 0x000004, "Wrong alignment on UScrollBar");
static_assert(sizeof(UScrollBar) == 0x000500, "Wrong size on UScrollBar");
static_assert(offsetof(UScrollBar, WidgetStyle) == 0x0000D0, "Member 'UScrollBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UScrollBar, Style) == 0x0004E8, "Member 'UScrollBar::Style' has a wrong offset!");
static_assert(offsetof(UScrollBar, bAlwaysShowScrollbar) == 0x0004EC, "Member 'UScrollBar::bAlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UScrollBar, Orientation) == 0x0004ED, "Member 'UScrollBar::Orientation' has a wrong offset!");
static_assert(offsetof(UScrollBar, Thickness) == 0x0004F0, "Member 'UScrollBar::Thickness' has a wrong offset!");

// Class UMG.Slider
// 0x0258 (0x0328 - 0x00D0)
class USlider final : public UWidget
{
public:
	float                                         Value;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x00D4(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSliderStyle                           WidgetStyle;                                       // 0x00E4(0x01D4)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SliderBarColor;                                    // 0x02BC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderHandleColor;                                 // 0x02CC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IndentHandle;                                      // 0x02DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          Locked;                                            // 0x02DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DE[0x2];                                      // 0x02DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepSize;                                          // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMouseCaptureBegin;                               // 0x02E4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMouseCaptureEnd;                                 // 0x02F0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnControllerCaptureBegin;                          // 0x02FC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnControllerCaptureEnd;                            // 0x0308(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueChanged;                                    // 0x0314(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIndentHandle(bool InValue);
	void SetLocked(bool InValue);
	void SetSliderBarColor(const struct FLinearColor& InValue);
	void SetSliderHandleColor(const struct FLinearColor& InValue);
	void SetStepSize(float InValue);
	void SetValue(float InValue);

	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Slider">();
	}
	static class USlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlider>();
	}
};
static_assert(alignof(USlider) == 0x000004, "Wrong alignment on USlider");
static_assert(sizeof(USlider) == 0x000328, "Wrong size on USlider");
static_assert(offsetof(USlider, Value) == 0x0000D0, "Member 'USlider::Value' has a wrong offset!");
static_assert(offsetof(USlider, ValueDelegate) == 0x0000D4, "Member 'USlider::ValueDelegate' has a wrong offset!");
static_assert(offsetof(USlider, WidgetStyle) == 0x0000E4, "Member 'USlider::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USlider, Orientation) == 0x0002B8, "Member 'USlider::Orientation' has a wrong offset!");
static_assert(offsetof(USlider, SliderBarColor) == 0x0002BC, "Member 'USlider::SliderBarColor' has a wrong offset!");
static_assert(offsetof(USlider, SliderHandleColor) == 0x0002CC, "Member 'USlider::SliderHandleColor' has a wrong offset!");
static_assert(offsetof(USlider, IndentHandle) == 0x0002DC, "Member 'USlider::IndentHandle' has a wrong offset!");
static_assert(offsetof(USlider, Locked) == 0x0002DD, "Member 'USlider::Locked' has a wrong offset!");
static_assert(offsetof(USlider, StepSize) == 0x0002E0, "Member 'USlider::StepSize' has a wrong offset!");
static_assert(offsetof(USlider, OnMouseCaptureBegin) == 0x0002E4, "Member 'USlider::OnMouseCaptureBegin' has a wrong offset!");
static_assert(offsetof(USlider, OnMouseCaptureEnd) == 0x0002F0, "Member 'USlider::OnMouseCaptureEnd' has a wrong offset!");
static_assert(offsetof(USlider, OnControllerCaptureBegin) == 0x0002FC, "Member 'USlider::OnControllerCaptureBegin' has a wrong offset!");
static_assert(offsetof(USlider, OnControllerCaptureEnd) == 0x000308, "Member 'USlider::OnControllerCaptureEnd' has a wrong offset!");
static_assert(offsetof(USlider, OnValueChanged) == 0x000314, "Member 'USlider::OnValueChanged' has a wrong offset!");

// Class UMG.Spacer
// 0x0010 (0x00E0 - 0x00D0)
class USpacer final : public UWidget
{
public:
	struct FVector2D                              Size;                                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSize(const struct FVector2D& InSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Spacer">();
	}
	static class USpacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpacer>();
	}
};
static_assert(alignof(USpacer) == 0x000004, "Wrong alignment on USpacer");
static_assert(sizeof(USpacer) == 0x0000E0, "Wrong size on USpacer");
static_assert(offsetof(USpacer, Size) == 0x0000D0, "Member 'USpacer::Size' has a wrong offset!");

// Class UMG.SpinBox
// 0x032C (0x03FC - 0x00D0)
class USpinBox final : public UWidget
{
public:
	float                                         Value;                                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x00D4(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpinBoxStyle                          WidgetStyle;                                       // 0x00E4(0x0274)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x0358(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderExponent;                                    // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x0364(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x0391(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x2];                                      // 0x0392(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            ForegroundColor;                                   // 0x0394(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueChanged;                                    // 0x03B0(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueCommitted;                                  // 0x03BC(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBeginSliderMovement;                             // 0x03C8(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndSliderMovement;                               // 0x03D4(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinValue : 1;                            // 0x03E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxValue : 1;                            // 0x03E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MinSliderValue : 1;                      // 0x03E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxSliderValue : 1;                      // 0x03E0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, Protected, NativeAccessSpecifierProtected))
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x03E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSliderValue;                                    // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSliderValue;                                    // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x8];                                      // 0x03F4(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMaxSliderValue();
	void ClearMaxValue();
	void ClearMinSliderValue();
	void ClearMinValue();
	void SetForegroundColor(const struct FSlateColor& InForegroundColor);
	void SetMaxSliderValue(float NewValue);
	void SetMaxValue(float NewValue);
	void SetMinSliderValue(float NewValue);
	void SetMinValue(float NewValue);
	void SetValue(float NewValue);

	float GetMaxSliderValue() const;
	float GetMaxValue() const;
	float GetMinSliderValue() const;
	float GetMinValue() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinBox">();
	}
	static class USpinBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinBox>();
	}
};
static_assert(alignof(USpinBox) == 0x000004, "Wrong alignment on USpinBox");
static_assert(sizeof(USpinBox) == 0x0003FC, "Wrong size on USpinBox");
static_assert(offsetof(USpinBox, Value) == 0x0000D0, "Member 'USpinBox::Value' has a wrong offset!");
static_assert(offsetof(USpinBox, ValueDelegate) == 0x0000D4, "Member 'USpinBox::ValueDelegate' has a wrong offset!");
static_assert(offsetof(USpinBox, WidgetStyle) == 0x0000E4, "Member 'USpinBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USpinBox, Style) == 0x000358, "Member 'USpinBox::Style' has a wrong offset!");
static_assert(offsetof(USpinBox, Delta) == 0x00035C, "Member 'USpinBox::Delta' has a wrong offset!");
static_assert(offsetof(USpinBox, SliderExponent) == 0x000360, "Member 'USpinBox::SliderExponent' has a wrong offset!");
static_assert(offsetof(USpinBox, Font) == 0x000364, "Member 'USpinBox::Font' has a wrong offset!");
static_assert(offsetof(USpinBox, MinDesiredWidth) == 0x00038C, "Member 'USpinBox::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(USpinBox, ClearKeyboardFocusOnCommit) == 0x000390, "Member 'USpinBox::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBox, SelectAllTextOnCommit) == 0x000391, "Member 'USpinBox::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBox, ForegroundColor) == 0x000394, "Member 'USpinBox::ForegroundColor' has a wrong offset!");
static_assert(offsetof(USpinBox, OnValueChanged) == 0x0003B0, "Member 'USpinBox::OnValueChanged' has a wrong offset!");
static_assert(offsetof(USpinBox, OnValueCommitted) == 0x0003BC, "Member 'USpinBox::OnValueCommitted' has a wrong offset!");
static_assert(offsetof(USpinBox, OnBeginSliderMovement) == 0x0003C8, "Member 'USpinBox::OnBeginSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBox, OnEndSliderMovement) == 0x0003D4, "Member 'USpinBox::OnEndSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBox, MinValue) == 0x0003E4, "Member 'USpinBox::MinValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MaxValue) == 0x0003E8, "Member 'USpinBox::MaxValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MinSliderValue) == 0x0003EC, "Member 'USpinBox::MinSliderValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MaxSliderValue) == 0x0003F0, "Member 'USpinBox::MaxSliderValue' has a wrong offset!");

// Class UMG.TableViewBase
// 0x0000 (0x00D0 - 0x00D0)
class UTableViewBase : public UWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableViewBase">();
	}
	static class UTableViewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableViewBase>();
	}
};
static_assert(alignof(UTableViewBase) == 0x000004, "Wrong alignment on UTableViewBase");
static_assert(sizeof(UTableViewBase) == 0x0000D0, "Wrong size on UTableViewBase");

// Class UMG.ListView
// 0x002C (0x00FC - 0x00D0)
class UListView final : public UTableViewBase
{
public:
	float                                         ItemHeight;                                        // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Items;                                             // 0x00D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ESelectionMode                                SelectionMode;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UObject* Item)>          OnGenerateRowEvent;                                // 0x00E4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x8];                                       // 0x00F4(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListView">();
	}
	static class UListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UListView>();
	}
};
static_assert(alignof(UListView) == 0x000004, "Wrong alignment on UListView");
static_assert(sizeof(UListView) == 0x0000FC, "Wrong size on UListView");
static_assert(offsetof(UListView, ItemHeight) == 0x0000D0, "Member 'UListView::ItemHeight' has a wrong offset!");
static_assert(offsetof(UListView, Items) == 0x0000D4, "Member 'UListView::Items' has a wrong offset!");
static_assert(offsetof(UListView, SelectionMode) == 0x0000E0, "Member 'UListView::SelectionMode' has a wrong offset!");
static_assert(offsetof(UListView, OnGenerateRowEvent) == 0x0000E4, "Member 'UListView::OnGenerateRowEvent' has a wrong offset!");

// Class UMG.TileView
// 0x0030 (0x0100 - 0x00D0)
class UTileView final : public UTableViewBase
{
public:
	float                                         ItemWidth;                                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemHeight;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Items;                                             // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ESelectionMode                                SelectionMode;                                     // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UObject* Item)>          OnGenerateTileEvent;                               // 0x00E8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestListRefresh();
	void SetItemHeight(float Height);
	void SetItemWidth(float Width);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileView">();
	}
	static class UTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileView>();
	}
};
static_assert(alignof(UTileView) == 0x000004, "Wrong alignment on UTileView");
static_assert(sizeof(UTileView) == 0x000100, "Wrong size on UTileView");
static_assert(offsetof(UTileView, ItemWidth) == 0x0000D0, "Member 'UTileView::ItemWidth' has a wrong offset!");
static_assert(offsetof(UTileView, ItemHeight) == 0x0000D4, "Member 'UTileView::ItemHeight' has a wrong offset!");
static_assert(offsetof(UTileView, Items) == 0x0000D8, "Member 'UTileView::Items' has a wrong offset!");
static_assert(offsetof(UTileView, SelectionMode) == 0x0000E4, "Member 'UTileView::SelectionMode' has a wrong offset!");
static_assert(offsetof(UTileView, OnGenerateTileEvent) == 0x0000E8, "Member 'UTileView::OnGenerateTileEvent' has a wrong offset!");

// Class UMG.TextLayoutWidget
// 0x0024 (0x00F4 - 0x00D0)
class UTextLayoutWidget : public UWidget
{
public:
	struct FShapedTextOptions                     ShapedTextOptions;                                 // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	ETextJustify                                  Justification;                                     // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AutoWrapText;                                      // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WrapTextAt;                                        // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                Margin;                                            // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         LineHeightPercentage;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextLayoutWidget">();
	}
	static class UTextLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextLayoutWidget>();
	}
};
static_assert(alignof(UTextLayoutWidget) == 0x000004, "Wrong alignment on UTextLayoutWidget");
static_assert(sizeof(UTextLayoutWidget) == 0x0000F4, "Wrong size on UTextLayoutWidget");
static_assert(offsetof(UTextLayoutWidget, ShapedTextOptions) == 0x0000D0, "Member 'UTextLayoutWidget::ShapedTextOptions' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, Justification) == 0x0000D8, "Member 'UTextLayoutWidget::Justification' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, AutoWrapText) == 0x0000D9, "Member 'UTextLayoutWidget::AutoWrapText' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, WrapTextAt) == 0x0000DC, "Member 'UTextLayoutWidget::WrapTextAt' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, Margin) == 0x0000E0, "Member 'UTextLayoutWidget::Margin' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, LineHeightPercentage) == 0x0000F0, "Member 'UTextLayoutWidget::LineHeightPercentage' has a wrong offset!");

// Class UMG.MultiLineEditableText
// 0x0174 (0x0268 - 0x00F4)
class UMultiLineEditableText final : public UTextLayoutWidget
{
public:
	class FText                                   TEXT;                                              // 0x00F4(0x000C)(Edit, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0100(0x000C)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x010C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        WidgetStyle;                                       // 0x011C(0x0100)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x021C(0x0028)(Deprecated, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnTextChanged;                                     // 0x0248(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTextCommitted;                                   // 0x0254(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FText& InText);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiLineEditableText">();
	}
	static class UMultiLineEditableText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiLineEditableText>();
	}
};
static_assert(alignof(UMultiLineEditableText) == 0x000004, "Wrong alignment on UMultiLineEditableText");
static_assert(sizeof(UMultiLineEditableText) == 0x000268, "Wrong size on UMultiLineEditableText");
static_assert(offsetof(UMultiLineEditableText, TEXT) == 0x0000F4, "Member 'UMultiLineEditableText::TEXT' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, HintText) == 0x000100, "Member 'UMultiLineEditableText::HintText' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, HintTextDelegate) == 0x00010C, "Member 'UMultiLineEditableText::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, WidgetStyle) == 0x00011C, "Member 'UMultiLineEditableText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, Font) == 0x00021C, "Member 'UMultiLineEditableText::Font' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, AllowContextMenu) == 0x000244, "Member 'UMultiLineEditableText::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, OnTextChanged) == 0x000248, "Member 'UMultiLineEditableText::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, OnTextCommitted) == 0x000254, "Member 'UMultiLineEditableText::OnTextCommitted' has a wrong offset!");

// Class UMG.MultiLineEditableTextBox
// 0x0840 (0x0934 - 0x00F4)
class UMultiLineEditableTextBox final : public UTextLayoutWidget
{
public:
	class FText                                   TEXT;                                              // 0x00F4(0x000C)(Edit, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0100(0x000C)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x010C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FEditableTextBoxStyle                  WidgetStyle;                                       // 0x011C(0x0698)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        TextStyle;                                         // 0x07B4(0x0100)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x08B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B5[0x3];                                      // 0x08B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateWidgetStyleAsset*                 Style;                                             // 0x08B8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x08BC(0x0028)(Deprecated, NativeAccessSpecifierPublic)
	struct FLinearColor                           ForegroundColor;                                   // 0x08E4(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x08F4(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReadOnlyForegroundColor;                           // 0x0904(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTextChanged;                                     // 0x0914(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTextCommitted;                                   // 0x0920(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_92C[0x8];                                      // 0x092C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetError(const class FText& InError);
	void SetText(const class FText& InText);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiLineEditableTextBox">();
	}
	static class UMultiLineEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiLineEditableTextBox>();
	}
};
static_assert(alignof(UMultiLineEditableTextBox) == 0x000004, "Wrong alignment on UMultiLineEditableTextBox");
static_assert(sizeof(UMultiLineEditableTextBox) == 0x000934, "Wrong size on UMultiLineEditableTextBox");
static_assert(offsetof(UMultiLineEditableTextBox, TEXT) == 0x0000F4, "Member 'UMultiLineEditableTextBox::TEXT' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, HintText) == 0x000100, "Member 'UMultiLineEditableTextBox::HintText' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, HintTextDelegate) == 0x00010C, "Member 'UMultiLineEditableTextBox::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, WidgetStyle) == 0x00011C, "Member 'UMultiLineEditableTextBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, TextStyle) == 0x0007B4, "Member 'UMultiLineEditableTextBox::TextStyle' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, AllowContextMenu) == 0x0008B4, "Member 'UMultiLineEditableTextBox::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, Style) == 0x0008B8, "Member 'UMultiLineEditableTextBox::Style' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, Font) == 0x0008BC, "Member 'UMultiLineEditableTextBox::Font' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, ForegroundColor) == 0x0008E4, "Member 'UMultiLineEditableTextBox::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, BackgroundColor) == 0x0008F4, "Member 'UMultiLineEditableTextBox::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, ReadOnlyForegroundColor) == 0x000904, "Member 'UMultiLineEditableTextBox::ReadOnlyForegroundColor' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, OnTextChanged) == 0x000914, "Member 'UMultiLineEditableTextBox::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, OnTextCommitted) == 0x000920, "Member 'UMultiLineEditableTextBox::OnTextCommitted' has a wrong offset!");

// Class UMG.RichTextBlock
// 0x0168 (0x025C - 0x00F4)
class URichTextBlock final : public UTextLayoutWidget
{
public:
	class FText                                   TEXT;                                              // 0x00F4(0x000C)(Edit, Protected, NativeAccessSpecifierProtected)
	TDelegate<void()>                             TextDelegate;                                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         Font;                                              // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color;                                             // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class URichTextBlockDecorator*>        Decorators;                                        // 0x0148(0x000C)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x108];                                    // 0x0154(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlock">();
	}
	static class URichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlock>();
	}
};
static_assert(alignof(URichTextBlock) == 0x000004, "Wrong alignment on URichTextBlock");
static_assert(sizeof(URichTextBlock) == 0x00025C, "Wrong size on URichTextBlock");
static_assert(offsetof(URichTextBlock, TEXT) == 0x0000F4, "Member 'URichTextBlock::TEXT' has a wrong offset!");
static_assert(offsetof(URichTextBlock, TextDelegate) == 0x000100, "Member 'URichTextBlock::TextDelegate' has a wrong offset!");
static_assert(offsetof(URichTextBlock, Font) == 0x000110, "Member 'URichTextBlock::Font' has a wrong offset!");
static_assert(offsetof(URichTextBlock, Color) == 0x000138, "Member 'URichTextBlock::Color' has a wrong offset!");
static_assert(offsetof(URichTextBlock, Decorators) == 0x000148, "Member 'URichTextBlock::Decorators' has a wrong offset!");

// Class UMG.TextBlock
// 0x00A8 (0x019C - 0x00F4)
class UTextBlock final : public UTextLayoutWidget
{
public:
	class FText                                   TEXT;                                              // 0x00F4(0x000C)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x0110(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x012C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x013C(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x0164(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x016C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ShadowColorAndOpacityDelegate;                     // 0x017C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWrapWithInvalidationPanel;                        // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0xB];                                      // 0x0191(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetFont(const struct FSlateFontInfo& InFontInfo);
	void SetJustification(ETextJustify InJustification);
	void SetOpacity(float InOpacity);
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity);
	void SetShadowOffset(const struct FVector2D& InShadowOffset);
	void SetText(const class FText& InText);

	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextBlock">();
	}
	static class UTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextBlock>();
	}
};
static_assert(alignof(UTextBlock) == 0x000004, "Wrong alignment on UTextBlock");
static_assert(sizeof(UTextBlock) == 0x00019C, "Wrong size on UTextBlock");
static_assert(offsetof(UTextBlock, TEXT) == 0x0000F4, "Member 'UTextBlock::TEXT' has a wrong offset!");
static_assert(offsetof(UTextBlock, TextDelegate) == 0x000100, "Member 'UTextBlock::TextDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, ColorAndOpacity) == 0x000110, "Member 'UTextBlock::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTextBlock, ColorAndOpacityDelegate) == 0x00012C, "Member 'UTextBlock::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, Font) == 0x00013C, "Member 'UTextBlock::Font' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowOffset) == 0x000164, "Member 'UTextBlock::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowColorAndOpacity) == 0x00016C, "Member 'UTextBlock::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowColorAndOpacityDelegate) == 0x00017C, "Member 'UTextBlock::ShadowColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, MinDesiredWidth) == 0x00018C, "Member 'UTextBlock::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UTextBlock, bWrapWithInvalidationPanel) == 0x000190, "Member 'UTextBlock::bWrapWithInvalidationPanel' has a wrong offset!");

// Class UMG.Throbber
// 0x0088 (0x0158 - 0x00D0)
class UThrobber final : public UWidget
{
public:
	int32                                         NumberOfPieces;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateHorizontally;                              // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAnimateVertically;                                // 0x00D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAnimateOpacity;                                   // 0x00D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateBrushAsset*                       PieceImage;                                        // 0x00D8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            Image;                                             // 0x00DC(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAnimateHorizontally(bool bInAnimateHorizontally);
	void SetAnimateOpacity(bool bInAnimateOpacity);
	void SetAnimateVertically(bool bInAnimateVertically);
	void SetNumberOfPieces(int32 InNumberOfPieces);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Throbber">();
	}
	static class UThrobber* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrobber>();
	}
};
static_assert(alignof(UThrobber) == 0x000004, "Wrong alignment on UThrobber");
static_assert(sizeof(UThrobber) == 0x000158, "Wrong size on UThrobber");
static_assert(offsetof(UThrobber, NumberOfPieces) == 0x0000D0, "Member 'UThrobber::NumberOfPieces' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateHorizontally) == 0x0000D4, "Member 'UThrobber::bAnimateHorizontally' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateVertically) == 0x0000D5, "Member 'UThrobber::bAnimateVertically' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateOpacity) == 0x0000D6, "Member 'UThrobber::bAnimateOpacity' has a wrong offset!");
static_assert(offsetof(UThrobber, PieceImage) == 0x0000D8, "Member 'UThrobber::PieceImage' has a wrong offset!");
static_assert(offsetof(UThrobber, Image) == 0x0000DC, "Member 'UThrobber::Image' has a wrong offset!");

// Class UMG.UserWidget
// 0x00E8 (0x01B8 - 0x00D0)
class UUserWidget : public UWidget
{
public:
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorAndOpacity;                                   // 0x00D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x00E4(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x00F4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ForegroundColorDelegate;                           // 0x0110(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bSupportsKeyboardFocus;                            // 0x0130(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetTree*                            WidgetTree;                                        // 0x0134(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUMGSequencePlayer*>             ActiveSequencePlayers;                             // 0x0138(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UUMGSequencePlayer*>             StoppedSequencePlayers;                            // 0x0144(0x000C)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FNamedSlotBinding>              NamedSlotBindings;                                 // 0x0150(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bStopAction;                                       // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x0168(0x0004)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4C];                                     // 0x016C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddToPlayerScreen(int32 ZOrder);
	void AddToViewport(int32 ZOrder);
	void Construct();
	void Destruct();
	void ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback);
	struct FEventReply OnAnalogValueChanged(const struct FGeometry& MyGeometry, const struct FAnalogInputEvent& InAnalogInputEvent);
	void OnAnimationFinished(const class UWidgetAnimation* Animation);
	void OnAnimationStarted(const class UWidgetAnimation* Animation);
	struct FEventReply OnControllerAnalogValueChanged(const struct FGeometry& MyGeometry, const struct FControllerEvent& ControllerEvent);
	struct FEventReply OnControllerButtonPressed(const struct FGeometry& MyGeometry, const struct FControllerEvent& ControllerEvent);
	struct FEventReply OnControllerButtonReleased(const struct FGeometry& MyGeometry, const struct FControllerEvent& ControllerEvent);
	void OnDragCancelled(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnDragDetected(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation** Operation);
	void OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	bool OnDragOver(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	bool OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnFocusLost(const struct FFocusEvent& InFocusEvent);
	struct FEventReply OnFocusReceived(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent);
	struct FEventReply OnKeyChar(const struct FGeometry& MyGeometry, const struct FCharacterEvent& InCharacterEvent);
	struct FEventReply OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnKeyUp(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnMotionDetected(const struct FGeometry& MyGeometry, const struct FMotionEvent& InMotionEvent);
	struct FEventReply OnMouseButtonDoubleClick(const struct FGeometry& InMyGeometry, const struct FPointerEvent& InMouseEvent);
	struct FEventReply OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnMouseButtonUp(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnMouseEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnMouseLeave(const struct FPointerEvent& MouseEvent);
	struct FEventReply OnMouseMove(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnMouseWheel(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnPreviewKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnPreviewMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnTouchEnded(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent);
	struct FEventReply OnTouchGesture(const struct FGeometry& MyGeometry, const struct FPointerEvent& GestureEvent);
	struct FEventReply OnTouchMoved(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent);
	struct FEventReply OnTouchStarted(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent);
	float PauseAnimation(const class UWidgetAnimation* InAnimation);
	void PlayAnimation(const class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode);
	void PlaySound(class USoundBase* SoundToPlay);
	void RemoveFromViewport();
	void SetAlignmentInViewport(const struct FVector2D& Alignment);
	void SetAnchorsInViewport(const struct FAnchors& Anchors);
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity);
	void SetDesiredSizeInViewport(const struct FVector2D& Size);
	void SetForegroundColor(const struct FSlateColor& InForegroundColor);
	void SetInputActionBlocking(bool bShouldBlock);
	void SetInputActionPriority(int32 NewPriority);
	void SetNumLoopsToPlay(const class UWidgetAnimation* InAnimation, int32 NumLoopsToPlay);
	void SetOwningLocalPlayer(class ULocalPlayer* LocalPlayer);
	void SetPadding(const struct FMargin& InPadding);
	void SetPositionInViewport(const struct FVector2D& Position, bool bRemoveDPIScale);
	void StopAnimation(const class UWidgetAnimation* InAnimation);
	void StopListeningForAllInputActions();
	void StopListeningForInputAction(class FName ActionName, EInputEvent EventType);
	void Tick(const struct FGeometry& MyGeometry, float InDeltaTime);

	bool GetIsVisible() const;
	class ULocalPlayer* GetOwningLocalPlayer() const;
	class APlayerController* GetOwningPlayer() const;
	class APawn* GetOwningPlayerPawn() const;
	bool IsAnimationPlaying(const class UWidgetAnimation* InAnimation) const;
	bool IsInteractable() const;
	bool IsInViewport() const;
	bool IsListeningForInputAction(class FName ActionName) const;
	bool IsPlayingAnimation() const;
	void OnPaint(struct FPaintContext& Context) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserWidget">();
	}
	static class UUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserWidget>();
	}
};
static_assert(alignof(UUserWidget) == 0x000004, "Wrong alignment on UUserWidget");
static_assert(sizeof(UUserWidget) == 0x0001B8, "Wrong size on UUserWidget");
static_assert(offsetof(UUserWidget, ColorAndOpacity) == 0x0000D4, "Member 'UUserWidget::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UUserWidget, ColorAndOpacityDelegate) == 0x0000E4, "Member 'UUserWidget::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidget, ForegroundColor) == 0x0000F4, "Member 'UUserWidget::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UUserWidget, ForegroundColorDelegate) == 0x000110, "Member 'UUserWidget::ForegroundColorDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidget, Padding) == 0x000120, "Member 'UUserWidget::Padding' has a wrong offset!");
static_assert(offsetof(UUserWidget, bSupportsKeyboardFocus) == 0x000130, "Member 'UUserWidget::bSupportsKeyboardFocus' has a wrong offset!");
static_assert(offsetof(UUserWidget, bIsFocusable) == 0x000131, "Member 'UUserWidget::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UUserWidget, WidgetTree) == 0x000134, "Member 'UUserWidget::WidgetTree' has a wrong offset!");
static_assert(offsetof(UUserWidget, ActiveSequencePlayers) == 0x000138, "Member 'UUserWidget::ActiveSequencePlayers' has a wrong offset!");
static_assert(offsetof(UUserWidget, StoppedSequencePlayers) == 0x000144, "Member 'UUserWidget::StoppedSequencePlayers' has a wrong offset!");
static_assert(offsetof(UUserWidget, NamedSlotBindings) == 0x000150, "Member 'UUserWidget::NamedSlotBindings' has a wrong offset!");
static_assert(offsetof(UUserWidget, bStopAction) == 0x00015C, "Member 'UUserWidget::bStopAction' has a wrong offset!");
static_assert(offsetof(UUserWidget, Priority) == 0x000160, "Member 'UUserWidget::Priority' has a wrong offset!");
static_assert(offsetof(UUserWidget, InputComponent) == 0x000168, "Member 'UUserWidget::InputComponent' has a wrong offset!");

// Class UMG.WidgetTree
// 0x0010 (0x002C - 0x001C)
class UWidgetTree final : public UObject
{
public:
	class UWidget*                                RootWidget;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        AllWidgets;                                        // 0x0020(0x000C)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetTree">();
	}
	static class UWidgetTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetTree>();
	}
};
static_assert(alignof(UWidgetTree) == 0x000004, "Wrong alignment on UWidgetTree");
static_assert(sizeof(UWidgetTree) == 0x00002C, "Wrong size on UWidgetTree");
static_assert(offsetof(UWidgetTree, RootWidget) == 0x00001C, "Member 'UWidgetTree::RootWidget' has a wrong offset!");
static_assert(offsetof(UWidgetTree, AllWidgets) == 0x000020, "Member 'UWidgetTree::AllWidgets' has a wrong offset!");

// Class UMG.WidgetAnimation
// 0x0120 (0x013C - 0x001C)
class UWidgetAnimation final : public UMovieSceneSequence
{
public:
	UMulticastDelegateProperty_                   OnAnimationStarted;                                // 0x001C(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAnimationFinished;                               // 0x0028(0x000C)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMovieScene*                            MovieScene;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWidgetAnimationBinding>        AnimationBindings;                                 // 0x0038(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xF8];                                      // 0x0044(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEndTime() const;
	float GetStartTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetAnimation">();
	}
	static class UWidgetAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetAnimation>();
	}
};
static_assert(alignof(UWidgetAnimation) == 0x000004, "Wrong alignment on UWidgetAnimation");
static_assert(sizeof(UWidgetAnimation) == 0x00013C, "Wrong size on UWidgetAnimation");
static_assert(offsetof(UWidgetAnimation, OnAnimationStarted) == 0x00001C, "Member 'UWidgetAnimation::OnAnimationStarted' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, OnAnimationFinished) == 0x000028, "Member 'UWidgetAnimation::OnAnimationFinished' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, MovieScene) == 0x000034, "Member 'UWidgetAnimation::MovieScene' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, AnimationBindings) == 0x000038, "Member 'UWidgetAnimation::AnimationBindings' has a wrong offset!");

// Class UMG.WidgetBlueprintGeneratedClass
// 0x002C (0x01F8 - 0x01CC)
class UWidgetBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	class UWidgetTree*                            WidgetTree;                                        // 0x01CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDelegateRuntimeBinding>        Bindings;                                          // 0x01D0(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UWidgetAnimation*>               Animations;                                        // 0x01DC(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           NamedSlots;                                        // 0x01E8(0x000C)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bCanEverTick : 1;                                  // 0x01F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         bCanEverPaint : 1;                                 // 0x01F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetBlueprintGeneratedClass">();
	}
	static class UWidgetBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UWidgetBlueprintGeneratedClass) == 0x000004, "Wrong alignment on UWidgetBlueprintGeneratedClass");
static_assert(sizeof(UWidgetBlueprintGeneratedClass) == 0x0001F8, "Wrong size on UWidgetBlueprintGeneratedClass");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, WidgetTree) == 0x0001CC, "Member 'UWidgetBlueprintGeneratedClass::WidgetTree' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, Bindings) == 0x0001D0, "Member 'UWidgetBlueprintGeneratedClass::Bindings' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, Animations) == 0x0001DC, "Member 'UWidgetBlueprintGeneratedClass::Animations' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, NamedSlots) == 0x0001E8, "Member 'UWidgetBlueprintGeneratedClass::NamedSlots' has a wrong offset!");

// Class UMG.WidgetBlueprintLibrary
// 0x0000 (0x001C - 0x001C)
class UWidgetBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelDragDrop();
	static struct FEventReply CaptureJoystick(struct FEventReply& Reply, class UWidget* CapturingWidget, bool bInAllJoysticks);
	static struct FEventReply CaptureMouse(struct FEventReply& Reply, class UWidget* CapturingWidget);
	static struct FEventReply ClearUserFocus(struct FEventReply& Reply, bool bInAllUsers);
	static class UUserWidget* Create(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetType, class APlayerController* OwningPlayer);
	static class UDragDropOperation* CreateDragDropOperation(TSubclassOf<class UDragDropOperation> OperationClass);
	static struct FEventReply DetectDrag(struct FEventReply& Reply, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey);
	static struct FEventReply DetectDragIfPressed(const struct FPointerEvent& PointerEvent, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey);
	static void DismissAllMenus();
	static void DrawBox(struct FPaintContext& Context, const struct FVector2D& Position, const struct FVector2D& Size, class USlateBrushAsset* Brush, const struct FLinearColor& Tint);
	static void DrawLine(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias);
	static void DrawLines(struct FPaintContext& Context, const TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias);
	static void DrawText(struct FPaintContext& Context, const class FString& InString, const struct FVector2D& Position, const struct FLinearColor& Tint);
	static void DrawTextFormatted(struct FPaintContext& Context, const class FText& TEXT, const struct FVector2D& Position, class UFont* Font, int32 FontSize, class FName FontTypeFace, const struct FLinearColor& Tint);
	static struct FEventReply EndDragDrop(struct FEventReply& Reply);
	static void GetAllWidgetsOfClass(class UObject* WorldContextObject, TArray<class UUserWidget*>* FoundWidgets, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly);
	static void GetAllWidgetsWithInterface(class UObject* WorldContextObject, TSubclassOf<class IInterface> Interface, TArray<class UUserWidget*>* FoundWidgets, bool TopLevelOnly);
	static class UObject* GetBrushResource(struct FSlateBrush& Brush);
	static class UMaterialInterface* GetBrushResourceAsMaterial(struct FSlateBrush& Brush);
	static class UTexture2D* GetBrushResourceAsTexture2D(struct FSlateBrush& Brush);
	static class UDragDropOperation* GetDragDroppingContent();
	static class UMaterialInstanceDynamic* GetDynamicMaterial(struct FSlateBrush& Brush);
	static struct FInputEvent GetInputEventFromCharacterEvent(const struct FCharacterEvent& Event);
	static struct FInputEvent GetInputEventFromControllerEvent(const struct FControllerEvent& Event);
	static struct FInputEvent GetInputEventFromKeyEvent(const struct FKeyEvent& Event);
	static struct FInputEvent GetInputEventFromNavigationEvent(const struct FNavigationEvent& Event);
	static struct FInputEvent GetInputEventFromPointerEvent(const struct FPointerEvent& Event);
	static struct FKeyEvent GetKeyEventFromAnalogInputEvent(const struct FAnalogInputEvent& Event);
	static struct FEventReply Handled();
	static bool IsDragDropping();
	static struct FEventReply LockMouse(struct FEventReply& Reply, class UWidget* CapturingWidget);
	static struct FSlateBrush MakeBrushFromAsset(class USlateBrushAsset* BrushAsset);
	static struct FSlateBrush MakeBrushFromMaterial(class UMaterialInterface* Material, int32 Width, int32 Height);
	static struct FSlateBrush MakeBrushFromTexture(class UTexture2D* Texture, int32 Width, int32 Height);
	static struct FSlateBrush NoResourceBrush();
	static struct FEventReply ReleaseJoystickCapture(struct FEventReply& Reply, bool bInAllJoysticks);
	static struct FEventReply ReleaseMouseCapture(struct FEventReply& Reply);
	static void SetBrushResourceToMaterial(struct FSlateBrush& Brush, class UMaterialInterface* Material);
	static void SetBrushResourceToTexture(struct FSlateBrush& Brush, class UTexture2D* Texture);
	static void SetFocusToGameViewport();
	static void SetInputMode_GameAndUI(class APlayerController* Target, class UWidget* InWidgetToFocus, bool bLockMouseToViewport, bool bHideCursorDuringCapture);
	static void SetInputMode_GameOnly(class APlayerController* Target);
	static void SetInputMode_UIOnly(class APlayerController* Target, class UWidget* InWidgetToFocus, bool bLockMouseToViewport);
	static struct FEventReply SetMousePosition(struct FEventReply& Reply, const struct FVector2D& NewMousePosition);
	static struct FEventReply SetUserFocus(struct FEventReply& Reply, class UWidget* FocusWidget, bool bInAllUsers);
	static struct FEventReply Unhandled();
	static struct FEventReply UnlockMouse(struct FEventReply& Reply);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetBlueprintLibrary">();
	}
	static class UWidgetBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetBlueprintLibrary>();
	}
};
static_assert(alignof(UWidgetBlueprintLibrary) == 0x000004, "Wrong alignment on UWidgetBlueprintLibrary");
static_assert(sizeof(UWidgetBlueprintLibrary) == 0x00001C, "Wrong size on UWidgetBlueprintLibrary");

// Class UMG.WidgetComponent
// 0x0094 (0x04C0 - 0x042C)
class UWidgetComponent final : public UPrimitiveComponent
{
public:
	EWidgetSpace                                  Space;                                             // 0x042C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              DrawSize;                                          // 0x0434(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Pivot;                                             // 0x043C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxInteractionDistance;                            // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalPlayer*                           OwnerPlayer;                                       // 0x0448(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundColor;                                   // 0x044C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EWidgetBlendMode                              BlendMode;                                         // 0x045C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOpaque;                                         // 0x045D(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsTwoSided;                                       // 0x045E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_45F[0x1];                                      // 0x045F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParabolaDistortion;                                // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TickWhenOffscreen;                                 // 0x0464(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0468(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBodySetup*                             BodySetup;                                         // 0x046C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TranslucentMaterial;                               // 0x0470(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TranslucentMaterial_OneSided;                      // 0x0474(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpaqueMaterial;                                    // 0x0478(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpaqueMaterial_OneSided;                           // 0x047C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaskedMaterial;                                    // 0x0480(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaskedMaterial_OneSided;                           // 0x0484(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0488(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x048C(0x0004)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLegacyRotation;                                // 0x0490(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAddedToScreen;                                    // 0x0491(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_492[0x2E];                                     // 0x0492(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDrawSize(const struct FVector2D& Size);
	void SetMaxInteractionDistance(float Distance);
	void SetOwnerPlayer(class ULocalPlayer* LocalPlayer);
	void SetWidget(class UUserWidget* Widget_0);

	struct FVector2D GetDrawSize() const;
	float GetMaxInteractionDistance() const;
	class ULocalPlayer* GetOwnerPlayer() const;
	class UUserWidget* GetUserWidgetObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetComponent">();
	}
	static class UWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetComponent>();
	}
};
static_assert(alignof(UWidgetComponent) == 0x000004, "Wrong alignment on UWidgetComponent");
static_assert(sizeof(UWidgetComponent) == 0x0004C0, "Wrong size on UWidgetComponent");
static_assert(offsetof(UWidgetComponent, Space) == 0x00042C, "Member 'UWidgetComponent::Space' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, WidgetClass) == 0x000430, "Member 'UWidgetComponent::WidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, DrawSize) == 0x000434, "Member 'UWidgetComponent::DrawSize' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, Pivot) == 0x00043C, "Member 'UWidgetComponent::Pivot' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaxInteractionDistance) == 0x000444, "Member 'UWidgetComponent::MaxInteractionDistance' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OwnerPlayer) == 0x000448, "Member 'UWidgetComponent::OwnerPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BackgroundColor) == 0x00044C, "Member 'UWidgetComponent::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BlendMode) == 0x00045C, "Member 'UWidgetComponent::BlendMode' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bIsOpaque) == 0x00045D, "Member 'UWidgetComponent::bIsOpaque' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bIsTwoSided) == 0x00045E, "Member 'UWidgetComponent::bIsTwoSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, ParabolaDistortion) == 0x000460, "Member 'UWidgetComponent::ParabolaDistortion' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TickWhenOffscreen) == 0x000464, "Member 'UWidgetComponent::TickWhenOffscreen' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, Widget) == 0x000468, "Member 'UWidgetComponent::Widget' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BodySetup) == 0x00046C, "Member 'UWidgetComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TranslucentMaterial) == 0x000470, "Member 'UWidgetComponent::TranslucentMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TranslucentMaterial_OneSided) == 0x000474, "Member 'UWidgetComponent::TranslucentMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OpaqueMaterial) == 0x000478, "Member 'UWidgetComponent::OpaqueMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OpaqueMaterial_OneSided) == 0x00047C, "Member 'UWidgetComponent::OpaqueMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaskedMaterial) == 0x000480, "Member 'UWidgetComponent::MaskedMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaskedMaterial_OneSided) == 0x000484, "Member 'UWidgetComponent::MaskedMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, RenderTarget) == 0x000488, "Member 'UWidgetComponent::RenderTarget' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaterialInstance) == 0x00048C, "Member 'UWidgetComponent::MaterialInstance' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bUseLegacyRotation) == 0x000490, "Member 'UWidgetComponent::bUseLegacyRotation' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bAddedToScreen) == 0x000491, "Member 'UWidgetComponent::bAddedToScreen' has a wrong offset!");

// Class UMG.WidgetLayoutLibrary
// 0x0000 (0x001C - 0x001C)
class UWidgetLayoutLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetMousePositionScaledByDPI(class APlayerController* Player, float* LocationX, float* LocationY);
	static float GetViewportScale(class UObject* WorldContextObject);
	static struct FVector2D GetViewportSize(class UObject* WorldContextObject);
	static bool ProjectWorldLocationToWidgetPosition(class APlayerController* PlayerController, const struct FVector& WorldLocation, struct FVector2D* ScreenPosition);
	static void RemoveAllWidgets(class UObject* WorldContextObject);
	static class UBorderSlot* SlotAsBorderSlot(class UWidget* Widget);
	static class UCanvasPanelSlot* SlotAsCanvasSlot(class UWidget* Widget);
	static class UGridSlot* SlotAsGridSlot(class UWidget* Widget);
	static class UHorizontalBoxSlot* SlotAsHorizontalBoxSlot(class UWidget* Widget);
	static class UOverlaySlot* SlotAsOverlaySlot(class UWidget* Widget);
	static class UUniformGridSlot* SlotAsUniformGridSlot(class UWidget* Widget);
	static class UVerticalBoxSlot* SlotAsVerticalBoxSlot(class UWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetLayoutLibrary">();
	}
	static class UWidgetLayoutLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetLayoutLibrary>();
	}
};
static_assert(alignof(UWidgetLayoutLibrary) == 0x000004, "Wrong alignment on UWidgetLayoutLibrary");
static_assert(sizeof(UWidgetLayoutLibrary) == 0x00001C, "Wrong size on UWidgetLayoutLibrary");

// Class UMG.WidgetNavigation
// 0x0078 (0x0094 - 0x001C)
class UWidgetNavigation final : public UObject
{
public:
	struct FWidgetNavigationData                  Up;                                                // 0x001C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Down;                                              // 0x0030(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Left;                                              // 0x0044(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Right;                                             // 0x0058(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Next;                                              // 0x006C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Previous;                                          // 0x0080(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetNavigation">();
	}
	static class UWidgetNavigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetNavigation>();
	}
};
static_assert(alignof(UWidgetNavigation) == 0x000004, "Wrong alignment on UWidgetNavigation");
static_assert(sizeof(UWidgetNavigation) == 0x000094, "Wrong size on UWidgetNavigation");
static_assert(offsetof(UWidgetNavigation, Up) == 0x00001C, "Member 'UWidgetNavigation::Up' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Down) == 0x000030, "Member 'UWidgetNavigation::Down' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Left) == 0x000044, "Member 'UWidgetNavigation::Left' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Right) == 0x000058, "Member 'UWidgetNavigation::Right' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Next) == 0x00006C, "Member 'UWidgetNavigation::Next' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Previous) == 0x000080, "Member 'UWidgetNavigation::Previous' has a wrong offset!");

}

#pragma pack(pop)
